CVE ID,CVE Page,CWE ID,Known Exploits,Vulnerability Classification,Publish Date,Update Date,Score,Access Gained,Attack Origin,Complexity,Authentication Required,Confidentiality,Integrity,Availability,Summmary,Lang,Project,codeLink,commitID,parentID,Diff,parentURL,commitURL,codeParent,codeCommit
CVE-2011-4862,https://www.cvedetails.com/cve/CVE-2011-4862/,CWE-119,,Exec Code Overflow,2011-12-24,2017-08-28,10.0,Admin,Remote,Low,Not required,Complete,Complete,Complete,"Buffer overflow in libtelnet/encrypt.c in telnetd in FreeBSD 7.3 through 9.0, MIT Kerberos Version 5 Applications (aka krb5-appl) 1.0.2 and earlier, Heimdal 1.5.1 and earlier, GNU inetutils, and possibly other products allows remote attackers to execute arbitrary code via a long encryption key, as exploited in the wild in December 2011.",C,savannah,https://git.savannah.gnu.org/cgit/inetutils.git/commit/?id=665f1e73cdd9b38e2d2e11b8db9958a315935592,665f1e73cdd9b38e2d2e11b8db9958a315935592,b48e61c52c10955ca2cc848834c2de306cf0d157,"@@ -796,6 +796,9 @@ encrypt_keyid (kp, keyid, len)   int dir = kp->dir;   register int ret = 0; +  if (len > MAXKEYLEN)+    len = MAXKEYLEN;+   if (!(ep = (*kp->getcrypt) (*kp->modep)))     {       if (len == 0)",https://git.savannah.gnu.org/cgit/inetutils.git/tree/libtelnet/encrypt.c?id=b48e61c52c10955ca2cc848834c2de306cf0d157,https://git.savannah.gnu.org/cgit/inetutils.git/tree/libtelnet/encrypt.c?id=665f1e73cdd9b38e2d2e11b8db9958a315935592,"<!DOCTYPE html>
<html lang='en'>
<head>
<title>encrypt.c\libtelnet - inetutils.git - GNU Inetutils </title>
<meta name='generator' content='cgit v1.2.1'/>
<meta name='robots' content='index, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit/cgit.css'/>
<link rel='shortcut icon' href='/gitweb/git-favicon.png'/>
<link rel='alternate' title='Atom feed' href='https://git.savannah.gnu.org/cgit/inetutils.git/atom/libtelnet/encrypt.c?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.savannah.gnu.org/inetutils.git' title='inetutils.git Git repository'/>
<link rel='vcs-git' href='https://git.savannah.gnu.org/git/inetutils.git' title='inetutils.git Git repository'/>
<link rel='vcs-git' href='ssh://git.savannah.gnu.org/srv/git/inetutils.git' title='inetutils.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/cgit/'><img src='/cgit/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/cgit/'>index</a> : <a title='inetutils.git' href='/cgit/inetutils.git/'>inetutils.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='b48e61c52c10955ca2cc848834c2de306cf0d157'/><select name='h' onchange='this.form.submit();'>
<option value='bsd'>bsd</option>
<option value='master' selected='selected'>master</option>
<option value='master-UNNAMED-BRANCH'>master-UNNAMED-BRANCH</option>
<option value='release1_4_0'>release1_4_0</option>
<option value='ucbinetd'>ucbinetd</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>GNU Inetutils </td><td class='sub right'></td></tr></table>
<table class='tabs'><tr><td>
<a href='/cgit/inetutils.git/'>summary</a><a href='/cgit/inetutils.git/refs/?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>refs</a><a href='/cgit/inetutils.git/log/libtelnet/encrypt.c'>log</a><a class='active' href='/cgit/inetutils.git/tree/libtelnet/encrypt.c?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>tree</a><a href='/cgit/inetutils.git/commit/libtelnet/encrypt.c?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>commit</a><a href='/cgit/inetutils.git/diff/libtelnet/encrypt.c?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>diff</a></td><td class='form'><form class='right' method='get' action='/cgit/inetutils.git/log/libtelnet/encrypt.c'>
<input type='hidden' name='id' value='b48e61c52c10955ca2cc848834c2de306cf0d157'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='path'>path: <a href='/cgit/inetutils.git/tree/?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>root</a>/<a href='/cgit/inetutils.git/tree/libtelnet?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>libtelnet</a>/<a href='/cgit/inetutils.git/tree/libtelnet/encrypt.c?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>encrypt.c</a></div><div class='content'>blob: 06827d9b6c64bc58a8c75c2229914007e7318737 (<a href='/cgit/inetutils.git/plain/libtelnet/encrypt.c?id=b48e61c52c10955ca2cc848834c2de306cf0d157'>plain</a>)
<table summary='blob content' class='blob'>
<tr><td class='linenumbers'><pre><a id='n1' href='#n1'>1</a>
<a id='n2' href='#n2'>2</a>
<a id='n3' href='#n3'>3</a>
<a id='n4' href='#n4'>4</a>
<a id='n5' href='#n5'>5</a>
<a id='n6' href='#n6'>6</a>
<a id='n7' href='#n7'>7</a>
<a id='n8' href='#n8'>8</a>
<a id='n9' href='#n9'>9</a>
<a id='n10' href='#n10'>10</a>
<a id='n11' href='#n11'>11</a>
<a id='n12' href='#n12'>12</a>
<a id='n13' href='#n13'>13</a>
<a id='n14' href='#n14'>14</a>
<a id='n15' href='#n15'>15</a>
<a id='n16' href='#n16'>16</a>
<a id='n17' href='#n17'>17</a>
<a id='n18' href='#n18'>18</a>
<a id='n19' href='#n19'>19</a>
<a id='n20' href='#n20'>20</a>
<a id='n21' href='#n21'>21</a>
<a id='n22' href='#n22'>22</a>
<a id='n23' href='#n23'>23</a>
<a id='n24' href='#n24'>24</a>
<a id='n25' href='#n25'>25</a>
<a id='n26' href='#n26'>26</a>
<a id='n27' href='#n27'>27</a>
<a id='n28' href='#n28'>28</a>
<a id='n29' href='#n29'>29</a>
<a id='n30' href='#n30'>30</a>
<a id='n31' href='#n31'>31</a>
<a id='n32' href='#n32'>32</a>
<a id='n33' href='#n33'>33</a>
<a id='n34' href='#n34'>34</a>
<a id='n35' href='#n35'>35</a>
<a id='n36' href='#n36'>36</a>
<a id='n37' href='#n37'>37</a>
<a id='n38' href='#n38'>38</a>
<a id='n39' href='#n39'>39</a>
<a id='n40' href='#n40'>40</a>
<a id='n41' href='#n41'>41</a>
<a id='n42' href='#n42'>42</a>
<a id='n43' href='#n43'>43</a>
<a id='n44' href='#n44'>44</a>
<a id='n45' href='#n45'>45</a>
<a id='n46' href='#n46'>46</a>
<a id='n47' href='#n47'>47</a>
<a id='n48' href='#n48'>48</a>
<a id='n49' href='#n49'>49</a>
<a id='n50' href='#n50'>50</a>
<a id='n51' href='#n51'>51</a>
<a id='n52' href='#n52'>52</a>
<a id='n53' href='#n53'>53</a>
<a id='n54' href='#n54'>54</a>
<a id='n55' href='#n55'>55</a>
<a id='n56' href='#n56'>56</a>
<a id='n57' href='#n57'>57</a>
<a id='n58' href='#n58'>58</a>
<a id='n59' href='#n59'>59</a>
<a id='n60' href='#n60'>60</a>
<a id='n61' href='#n61'>61</a>
<a id='n62' href='#n62'>62</a>
<a id='n63' href='#n63'>63</a>
<a id='n64' href='#n64'>64</a>
<a id='n65' href='#n65'>65</a>
<a id='n66' href='#n66'>66</a>
<a id='n67' href='#n67'>67</a>
<a id='n68' href='#n68'>68</a>
<a id='n69' href='#n69'>69</a>
<a id='n70' href='#n70'>70</a>
<a id='n71' href='#n71'>71</a>
<a id='n72' href='#n72'>72</a>
<a id='n73' href='#n73'>73</a>
<a id='n74' href='#n74'>74</a>
<a id='n75' href='#n75'>75</a>
<a id='n76' href='#n76'>76</a>
<a id='n77' href='#n77'>77</a>
<a id='n78' href='#n78'>78</a>
<a id='n79' href='#n79'>79</a>
<a id='n80' href='#n80'>80</a>
<a id='n81' href='#n81'>81</a>
<a id='n82' href='#n82'>82</a>
<a id='n83' href='#n83'>83</a>
<a id='n84' href='#n84'>84</a>
<a id='n85' href='#n85'>85</a>
<a id='n86' href='#n86'>86</a>
<a id='n87' href='#n87'>87</a>
<a id='n88' href='#n88'>88</a>
<a id='n89' href='#n89'>89</a>
<a id='n90' href='#n90'>90</a>
<a id='n91' href='#n91'>91</a>
<a id='n92' href='#n92'>92</a>
<a id='n93' href='#n93'>93</a>
<a id='n94' href='#n94'>94</a>
<a id='n95' href='#n95'>95</a>
<a id='n96' href='#n96'>96</a>
<a id='n97' href='#n97'>97</a>
<a id='n98' href='#n98'>98</a>
<a id='n99' href='#n99'>99</a>
<a id='n100' href='#n100'>100</a>
<a id='n101' href='#n101'>101</a>
<a id='n102' href='#n102'>102</a>
<a id='n103' href='#n103'>103</a>
<a id='n104' href='#n104'>104</a>
<a id='n105' href='#n105'>105</a>
<a id='n106' href='#n106'>106</a>
<a id='n107' href='#n107'>107</a>
<a id='n108' href='#n108'>108</a>
<a id='n109' href='#n109'>109</a>
<a id='n110' href='#n110'>110</a>
<a id='n111' href='#n111'>111</a>
<a id='n112' href='#n112'>112</a>
<a id='n113' href='#n113'>113</a>
<a id='n114' href='#n114'>114</a>
<a id='n115' href='#n115'>115</a>
<a id='n116' href='#n116'>116</a>
<a id='n117' href='#n117'>117</a>
<a id='n118' href='#n118'>118</a>
<a id='n119' href='#n119'>119</a>
<a id='n120' href='#n120'>120</a>
<a id='n121' href='#n121'>121</a>
<a id='n122' href='#n122'>122</a>
<a id='n123' href='#n123'>123</a>
<a id='n124' href='#n124'>124</a>
<a id='n125' href='#n125'>125</a>
<a id='n126' href='#n126'>126</a>
<a id='n127' href='#n127'>127</a>
<a id='n128' href='#n128'>128</a>
<a id='n129' href='#n129'>129</a>
<a id='n130' href='#n130'>130</a>
<a id='n131' href='#n131'>131</a>
<a id='n132' href='#n132'>132</a>
<a id='n133' href='#n133'>133</a>
<a id='n134' href='#n134'>134</a>
<a id='n135' href='#n135'>135</a>
<a id='n136' href='#n136'>136</a>
<a id='n137' href='#n137'>137</a>
<a id='n138' href='#n138'>138</a>
<a id='n139' href='#n139'>139</a>
<a id='n140' href='#n140'>140</a>
<a id='n141' href='#n141'>141</a>
<a id='n142' href='#n142'>142</a>
<a id='n143' href='#n143'>143</a>
<a id='n144' href='#n144'>144</a>
<a id='n145' href='#n145'>145</a>
<a id='n146' href='#n146'>146</a>
<a id='n147' href='#n147'>147</a>
<a id='n148' href='#n148'>148</a>
<a id='n149' href='#n149'>149</a>
<a id='n150' href='#n150'>150</a>
<a id='n151' href='#n151'>151</a>
<a id='n152' href='#n152'>152</a>
<a id='n153' href='#n153'>153</a>
<a id='n154' href='#n154'>154</a>
<a id='n155' href='#n155'>155</a>
<a id='n156' href='#n156'>156</a>
<a id='n157' href='#n157'>157</a>
<a id='n158' href='#n158'>158</a>
<a id='n159' href='#n159'>159</a>
<a id='n160' href='#n160'>160</a>
<a id='n161' href='#n161'>161</a>
<a id='n162' href='#n162'>162</a>
<a id='n163' href='#n163'>163</a>
<a id='n164' href='#n164'>164</a>
<a id='n165' href='#n165'>165</a>
<a id='n166' href='#n166'>166</a>
<a id='n167' href='#n167'>167</a>
<a id='n168' href='#n168'>168</a>
<a id='n169' href='#n169'>169</a>
<a id='n170' href='#n170'>170</a>
<a id='n171' href='#n171'>171</a>
<a id='n172' href='#n172'>172</a>
<a id='n173' href='#n173'>173</a>
<a id='n174' href='#n174'>174</a>
<a id='n175' href='#n175'>175</a>
<a id='n176' href='#n176'>176</a>
<a id='n177' href='#n177'>177</a>
<a id='n178' href='#n178'>178</a>
<a id='n179' href='#n179'>179</a>
<a id='n180' href='#n180'>180</a>
<a id='n181' href='#n181'>181</a>
<a id='n182' href='#n182'>182</a>
<a id='n183' href='#n183'>183</a>
<a id='n184' href='#n184'>184</a>
<a id='n185' href='#n185'>185</a>
<a id='n186' href='#n186'>186</a>
<a id='n187' href='#n187'>187</a>
<a id='n188' href='#n188'>188</a>
<a id='n189' href='#n189'>189</a>
<a id='n190' href='#n190'>190</a>
<a id='n191' href='#n191'>191</a>
<a id='n192' href='#n192'>192</a>
<a id='n193' href='#n193'>193</a>
<a id='n194' href='#n194'>194</a>
<a id='n195' href='#n195'>195</a>
<a id='n196' href='#n196'>196</a>
<a id='n197' href='#n197'>197</a>
<a id='n198' href='#n198'>198</a>
<a id='n199' href='#n199'>199</a>
<a id='n200' href='#n200'>200</a>
<a id='n201' href='#n201'>201</a>
<a id='n202' href='#n202'>202</a>
<a id='n203' href='#n203'>203</a>
<a id='n204' href='#n204'>204</a>
<a id='n205' href='#n205'>205</a>
<a id='n206' href='#n206'>206</a>
<a id='n207' href='#n207'>207</a>
<a id='n208' href='#n208'>208</a>
<a id='n209' href='#n209'>209</a>
<a id='n210' href='#n210'>210</a>
<a id='n211' href='#n211'>211</a>
<a id='n212' href='#n212'>212</a>
<a id='n213' href='#n213'>213</a>
<a id='n214' href='#n214'>214</a>
<a id='n215' href='#n215'>215</a>
<a id='n216' href='#n216'>216</a>
<a id='n217' href='#n217'>217</a>
<a id='n218' href='#n218'>218</a>
<a id='n219' href='#n219'>219</a>
<a id='n220' href='#n220'>220</a>
<a id='n221' href='#n221'>221</a>
<a id='n222' href='#n222'>222</a>
<a id='n223' href='#n223'>223</a>
<a id='n224' href='#n224'>224</a>
<a id='n225' href='#n225'>225</a>
<a id='n226' href='#n226'>226</a>
<a id='n227' href='#n227'>227</a>
<a id='n228' href='#n228'>228</a>
<a id='n229' href='#n229'>229</a>
<a id='n230' href='#n230'>230</a>
<a id='n231' href='#n231'>231</a>
<a id='n232' href='#n232'>232</a>
<a id='n233' href='#n233'>233</a>
<a id='n234' href='#n234'>234</a>
<a id='n235' href='#n235'>235</a>
<a id='n236' href='#n236'>236</a>
<a id='n237' href='#n237'>237</a>
<a id='n238' href='#n238'>238</a>
<a id='n239' href='#n239'>239</a>
<a id='n240' href='#n240'>240</a>
<a id='n241' href='#n241'>241</a>
<a id='n242' href='#n242'>242</a>
<a id='n243' href='#n243'>243</a>
<a id='n244' href='#n244'>244</a>
<a id='n245' href='#n245'>245</a>
<a id='n246' href='#n246'>246</a>
<a id='n247' href='#n247'>247</a>
<a id='n248' href='#n248'>248</a>
<a id='n249' href='#n249'>249</a>
<a id='n250' href='#n250'>250</a>
<a id='n251' href='#n251'>251</a>
<a id='n252' href='#n252'>252</a>
<a id='n253' href='#n253'>253</a>
<a id='n254' href='#n254'>254</a>
<a id='n255' href='#n255'>255</a>
<a id='n256' href='#n256'>256</a>
<a id='n257' href='#n257'>257</a>
<a id='n258' href='#n258'>258</a>
<a id='n259' href='#n259'>259</a>
<a id='n260' href='#n260'>260</a>
<a id='n261' href='#n261'>261</a>
<a id='n262' href='#n262'>262</a>
<a id='n263' href='#n263'>263</a>
<a id='n264' href='#n264'>264</a>
<a id='n265' href='#n265'>265</a>
<a id='n266' href='#n266'>266</a>
<a id='n267' href='#n267'>267</a>
<a id='n268' href='#n268'>268</a>
<a id='n269' href='#n269'>269</a>
<a id='n270' href='#n270'>270</a>
<a id='n271' href='#n271'>271</a>
<a id='n272' href='#n272'>272</a>
<a id='n273' href='#n273'>273</a>
<a id='n274' href='#n274'>274</a>
<a id='n275' href='#n275'>275</a>
<a id='n276' href='#n276'>276</a>
<a id='n277' href='#n277'>277</a>
<a id='n278' href='#n278'>278</a>
<a id='n279' href='#n279'>279</a>
<a id='n280' href='#n280'>280</a>
<a id='n281' href='#n281'>281</a>
<a id='n282' href='#n282'>282</a>
<a id='n283' href='#n283'>283</a>
<a id='n284' href='#n284'>284</a>
<a id='n285' href='#n285'>285</a>
<a id='n286' href='#n286'>286</a>
<a id='n287' href='#n287'>287</a>
<a id='n288' href='#n288'>288</a>
<a id='n289' href='#n289'>289</a>
<a id='n290' href='#n290'>290</a>
<a id='n291' href='#n291'>291</a>
<a id='n292' href='#n292'>292</a>
<a id='n293' href='#n293'>293</a>
<a id='n294' href='#n294'>294</a>
<a id='n295' href='#n295'>295</a>
<a id='n296' href='#n296'>296</a>
<a id='n297' href='#n297'>297</a>
<a id='n298' href='#n298'>298</a>
<a id='n299' href='#n299'>299</a>
<a id='n300' href='#n300'>300</a>
<a id='n301' href='#n301'>301</a>
<a id='n302' href='#n302'>302</a>
<a id='n303' href='#n303'>303</a>
<a id='n304' href='#n304'>304</a>
<a id='n305' href='#n305'>305</a>
<a id='n306' href='#n306'>306</a>
<a id='n307' href='#n307'>307</a>
<a id='n308' href='#n308'>308</a>
<a id='n309' href='#n309'>309</a>
<a id='n310' href='#n310'>310</a>
<a id='n311' href='#n311'>311</a>
<a id='n312' href='#n312'>312</a>
<a id='n313' href='#n313'>313</a>
<a id='n314' href='#n314'>314</a>
<a id='n315' href='#n315'>315</a>
<a id='n316' href='#n316'>316</a>
<a id='n317' href='#n317'>317</a>
<a id='n318' href='#n318'>318</a>
<a id='n319' href='#n319'>319</a>
<a id='n320' href='#n320'>320</a>
<a id='n321' href='#n321'>321</a>
<a id='n322' href='#n322'>322</a>
<a id='n323' href='#n323'>323</a>
<a id='n324' href='#n324'>324</a>
<a id='n325' href='#n325'>325</a>
<a id='n326' href='#n326'>326</a>
<a id='n327' href='#n327'>327</a>
<a id='n328' href='#n328'>328</a>
<a id='n329' href='#n329'>329</a>
<a id='n330' href='#n330'>330</a>
<a id='n331' href='#n331'>331</a>
<a id='n332' href='#n332'>332</a>
<a id='n333' href='#n333'>333</a>
<a id='n334' href='#n334'>334</a>
<a id='n335' href='#n335'>335</a>
<a id='n336' href='#n336'>336</a>
<a id='n337' href='#n337'>337</a>
<a id='n338' href='#n338'>338</a>
<a id='n339' href='#n339'>339</a>
<a id='n340' href='#n340'>340</a>
<a id='n341' href='#n341'>341</a>
<a id='n342' href='#n342'>342</a>
<a id='n343' href='#n343'>343</a>
<a id='n344' href='#n344'>344</a>
<a id='n345' href='#n345'>345</a>
<a id='n346' href='#n346'>346</a>
<a id='n347' href='#n347'>347</a>
<a id='n348' href='#n348'>348</a>
<a id='n349' href='#n349'>349</a>
<a id='n350' href='#n350'>350</a>
<a id='n351' href='#n351'>351</a>
<a id='n352' href='#n352'>352</a>
<a id='n353' href='#n353'>353</a>
<a id='n354' href='#n354'>354</a>
<a id='n355' href='#n355'>355</a>
<a id='n356' href='#n356'>356</a>
<a id='n357' href='#n357'>357</a>
<a id='n358' href='#n358'>358</a>
<a id='n359' href='#n359'>359</a>
<a id='n360' href='#n360'>360</a>
<a id='n361' href='#n361'>361</a>
<a id='n362' href='#n362'>362</a>
<a id='n363' href='#n363'>363</a>
<a id='n364' href='#n364'>364</a>
<a id='n365' href='#n365'>365</a>
<a id='n366' href='#n366'>366</a>
<a id='n367' href='#n367'>367</a>
<a id='n368' href='#n368'>368</a>
<a id='n369' href='#n369'>369</a>
<a id='n370' href='#n370'>370</a>
<a id='n371' href='#n371'>371</a>
<a id='n372' href='#n372'>372</a>
<a id='n373' href='#n373'>373</a>
<a id='n374' href='#n374'>374</a>
<a id='n375' href='#n375'>375</a>
<a id='n376' href='#n376'>376</a>
<a id='n377' href='#n377'>377</a>
<a id='n378' href='#n378'>378</a>
<a id='n379' href='#n379'>379</a>
<a id='n380' href='#n380'>380</a>
<a id='n381' href='#n381'>381</a>
<a id='n382' href='#n382'>382</a>
<a id='n383' href='#n383'>383</a>
<a id='n384' href='#n384'>384</a>
<a id='n385' href='#n385'>385</a>
<a id='n386' href='#n386'>386</a>
<a id='n387' href='#n387'>387</a>
<a id='n388' href='#n388'>388</a>
<a id='n389' href='#n389'>389</a>
<a id='n390' href='#n390'>390</a>
<a id='n391' href='#n391'>391</a>
<a id='n392' href='#n392'>392</a>
<a id='n393' href='#n393'>393</a>
<a id='n394' href='#n394'>394</a>
<a id='n395' href='#n395'>395</a>
<a id='n396' href='#n396'>396</a>
<a id='n397' href='#n397'>397</a>
<a id='n398' href='#n398'>398</a>
<a id='n399' href='#n399'>399</a>
<a id='n400' href='#n400'>400</a>
<a id='n401' href='#n401'>401</a>
<a id='n402' href='#n402'>402</a>
<a id='n403' href='#n403'>403</a>
<a id='n404' href='#n404'>404</a>
<a id='n405' href='#n405'>405</a>
<a id='n406' href='#n406'>406</a>
<a id='n407' href='#n407'>407</a>
<a id='n408' href='#n408'>408</a>
<a id='n409' href='#n409'>409</a>
<a id='n410' href='#n410'>410</a>
<a id='n411' href='#n411'>411</a>
<a id='n412' href='#n412'>412</a>
<a id='n413' href='#n413'>413</a>
<a id='n414' href='#n414'>414</a>
<a id='n415' href='#n415'>415</a>
<a id='n416' href='#n416'>416</a>
<a id='n417' href='#n417'>417</a>
<a id='n418' href='#n418'>418</a>
<a id='n419' href='#n419'>419</a>
<a id='n420' href='#n420'>420</a>
<a id='n421' href='#n421'>421</a>
<a id='n422' href='#n422'>422</a>
<a id='n423' href='#n423'>423</a>
<a id='n424' href='#n424'>424</a>
<a id='n425' href='#n425'>425</a>
<a id='n426' href='#n426'>426</a>
<a id='n427' href='#n427'>427</a>
<a id='n428' href='#n428'>428</a>
<a id='n429' href='#n429'>429</a>
<a id='n430' href='#n430'>430</a>
<a id='n431' href='#n431'>431</a>
<a id='n432' href='#n432'>432</a>
<a id='n433' href='#n433'>433</a>
<a id='n434' href='#n434'>434</a>
<a id='n435' href='#n435'>435</a>
<a id='n436' href='#n436'>436</a>
<a id='n437' href='#n437'>437</a>
<a id='n438' href='#n438'>438</a>
<a id='n439' href='#n439'>439</a>
<a id='n440' href='#n440'>440</a>
<a id='n441' href='#n441'>441</a>
<a id='n442' href='#n442'>442</a>
<a id='n443' href='#n443'>443</a>
<a id='n444' href='#n444'>444</a>
<a id='n445' href='#n445'>445</a>
<a id='n446' href='#n446'>446</a>
<a id='n447' href='#n447'>447</a>
<a id='n448' href='#n448'>448</a>
<a id='n449' href='#n449'>449</a>
<a id='n450' href='#n450'>450</a>
<a id='n451' href='#n451'>451</a>
<a id='n452' href='#n452'>452</a>
<a id='n453' href='#n453'>453</a>
<a id='n454' href='#n454'>454</a>
<a id='n455' href='#n455'>455</a>
<a id='n456' href='#n456'>456</a>
<a id='n457' href='#n457'>457</a>
<a id='n458' href='#n458'>458</a>
<a id='n459' href='#n459'>459</a>
<a id='n460' href='#n460'>460</a>
<a id='n461' href='#n461'>461</a>
<a id='n462' href='#n462'>462</a>
<a id='n463' href='#n463'>463</a>
<a id='n464' href='#n464'>464</a>
<a id='n465' href='#n465'>465</a>
<a id='n466' href='#n466'>466</a>
<a id='n467' href='#n467'>467</a>
<a id='n468' href='#n468'>468</a>
<a id='n469' href='#n469'>469</a>
<a id='n470' href='#n470'>470</a>
<a id='n471' href='#n471'>471</a>
<a id='n472' href='#n472'>472</a>
<a id='n473' href='#n473'>473</a>
<a id='n474' href='#n474'>474</a>
<a id='n475' href='#n475'>475</a>
<a id='n476' href='#n476'>476</a>
<a id='n477' href='#n477'>477</a>
<a id='n478' href='#n478'>478</a>
<a id='n479' href='#n479'>479</a>
<a id='n480' href='#n480'>480</a>
<a id='n481' href='#n481'>481</a>
<a id='n482' href='#n482'>482</a>
<a id='n483' href='#n483'>483</a>
<a id='n484' href='#n484'>484</a>
<a id='n485' href='#n485'>485</a>
<a id='n486' href='#n486'>486</a>
<a id='n487' href='#n487'>487</a>
<a id='n488' href='#n488'>488</a>
<a id='n489' href='#n489'>489</a>
<a id='n490' href='#n490'>490</a>
<a id='n491' href='#n491'>491</a>
<a id='n492' href='#n492'>492</a>
<a id='n493' href='#n493'>493</a>
<a id='n494' href='#n494'>494</a>
<a id='n495' href='#n495'>495</a>
<a id='n496' href='#n496'>496</a>
<a id='n497' href='#n497'>497</a>
<a id='n498' href='#n498'>498</a>
<a id='n499' href='#n499'>499</a>
<a id='n500' href='#n500'>500</a>
<a id='n501' href='#n501'>501</a>
<a id='n502' href='#n502'>502</a>
<a id='n503' href='#n503'>503</a>
<a id='n504' href='#n504'>504</a>
<a id='n505' href='#n505'>505</a>
<a id='n506' href='#n506'>506</a>
<a id='n507' href='#n507'>507</a>
<a id='n508' href='#n508'>508</a>
<a id='n509' href='#n509'>509</a>
<a id='n510' href='#n510'>510</a>
<a id='n511' href='#n511'>511</a>
<a id='n512' href='#n512'>512</a>
<a id='n513' href='#n513'>513</a>
<a id='n514' href='#n514'>514</a>
<a id='n515' href='#n515'>515</a>
<a id='n516' href='#n516'>516</a>
<a id='n517' href='#n517'>517</a>
<a id='n518' href='#n518'>518</a>
<a id='n519' href='#n519'>519</a>
<a id='n520' href='#n520'>520</a>
<a id='n521' href='#n521'>521</a>
<a id='n522' href='#n522'>522</a>
<a id='n523' href='#n523'>523</a>
<a id='n524' href='#n524'>524</a>
<a id='n525' href='#n525'>525</a>
<a id='n526' href='#n526'>526</a>
<a id='n527' href='#n527'>527</a>
<a id='n528' href='#n528'>528</a>
<a id='n529' href='#n529'>529</a>
<a id='n530' href='#n530'>530</a>
<a id='n531' href='#n531'>531</a>
<a id='n532' href='#n532'>532</a>
<a id='n533' href='#n533'>533</a>
<a id='n534' href='#n534'>534</a>
<a id='n535' href='#n535'>535</a>
<a id='n536' href='#n536'>536</a>
<a id='n537' href='#n537'>537</a>
<a id='n538' href='#n538'>538</a>
<a id='n539' href='#n539'>539</a>
<a id='n540' href='#n540'>540</a>
<a id='n541' href='#n541'>541</a>
<a id='n542' href='#n542'>542</a>
<a id='n543' href='#n543'>543</a>
<a id='n544' href='#n544'>544</a>
<a id='n545' href='#n545'>545</a>
<a id='n546' href='#n546'>546</a>
<a id='n547' href='#n547'>547</a>
<a id='n548' href='#n548'>548</a>
<a id='n549' href='#n549'>549</a>
<a id='n550' href='#n550'>550</a>
<a id='n551' href='#n551'>551</a>
<a id='n552' href='#n552'>552</a>
<a id='n553' href='#n553'>553</a>
<a id='n554' href='#n554'>554</a>
<a id='n555' href='#n555'>555</a>
<a id='n556' href='#n556'>556</a>
<a id='n557' href='#n557'>557</a>
<a id='n558' href='#n558'>558</a>
<a id='n559' href='#n559'>559</a>
<a id='n560' href='#n560'>560</a>
<a id='n561' href='#n561'>561</a>
<a id='n562' href='#n562'>562</a>
<a id='n563' href='#n563'>563</a>
<a id='n564' href='#n564'>564</a>
<a id='n565' href='#n565'>565</a>
<a id='n566' href='#n566'>566</a>
<a id='n567' href='#n567'>567</a>
<a id='n568' href='#n568'>568</a>
<a id='n569' href='#n569'>569</a>
<a id='n570' href='#n570'>570</a>
<a id='n571' href='#n571'>571</a>
<a id='n572' href='#n572'>572</a>
<a id='n573' href='#n573'>573</a>
<a id='n574' href='#n574'>574</a>
<a id='n575' href='#n575'>575</a>
<a id='n576' href='#n576'>576</a>
<a id='n577' href='#n577'>577</a>
<a id='n578' href='#n578'>578</a>
<a id='n579' href='#n579'>579</a>
<a id='n580' href='#n580'>580</a>
<a id='n581' href='#n581'>581</a>
<a id='n582' href='#n582'>582</a>
<a id='n583' href='#n583'>583</a>
<a id='n584' href='#n584'>584</a>
<a id='n585' href='#n585'>585</a>
<a id='n586' href='#n586'>586</a>
<a id='n587' href='#n587'>587</a>
<a id='n588' href='#n588'>588</a>
<a id='n589' href='#n589'>589</a>
<a id='n590' href='#n590'>590</a>
<a id='n591' href='#n591'>591</a>
<a id='n592' href='#n592'>592</a>
<a id='n593' href='#n593'>593</a>
<a id='n594' href='#n594'>594</a>
<a id='n595' href='#n595'>595</a>
<a id='n596' href='#n596'>596</a>
<a id='n597' href='#n597'>597</a>
<a id='n598' href='#n598'>598</a>
<a id='n599' href='#n599'>599</a>
<a id='n600' href='#n600'>600</a>
<a id='n601' href='#n601'>601</a>
<a id='n602' href='#n602'>602</a>
<a id='n603' href='#n603'>603</a>
<a id='n604' href='#n604'>604</a>
<a id='n605' href='#n605'>605</a>
<a id='n606' href='#n606'>606</a>
<a id='n607' href='#n607'>607</a>
<a id='n608' href='#n608'>608</a>
<a id='n609' href='#n609'>609</a>
<a id='n610' href='#n610'>610</a>
<a id='n611' href='#n611'>611</a>
<a id='n612' href='#n612'>612</a>
<a id='n613' href='#n613'>613</a>
<a id='n614' href='#n614'>614</a>
<a id='n615' href='#n615'>615</a>
<a id='n616' href='#n616'>616</a>
<a id='n617' href='#n617'>617</a>
<a id='n618' href='#n618'>618</a>
<a id='n619' href='#n619'>619</a>
<a id='n620' href='#n620'>620</a>
<a id='n621' href='#n621'>621</a>
<a id='n622' href='#n622'>622</a>
<a id='n623' href='#n623'>623</a>
<a id='n624' href='#n624'>624</a>
<a id='n625' href='#n625'>625</a>
<a id='n626' href='#n626'>626</a>
<a id='n627' href='#n627'>627</a>
<a id='n628' href='#n628'>628</a>
<a id='n629' href='#n629'>629</a>
<a id='n630' href='#n630'>630</a>
<a id='n631' href='#n631'>631</a>
<a id='n632' href='#n632'>632</a>
<a id='n633' href='#n633'>633</a>
<a id='n634' href='#n634'>634</a>
<a id='n635' href='#n635'>635</a>
<a id='n636' href='#n636'>636</a>
<a id='n637' href='#n637'>637</a>
<a id='n638' href='#n638'>638</a>
<a id='n639' href='#n639'>639</a>
<a id='n640' href='#n640'>640</a>
<a id='n641' href='#n641'>641</a>
<a id='n642' href='#n642'>642</a>
<a id='n643' href='#n643'>643</a>
<a id='n644' href='#n644'>644</a>
<a id='n645' href='#n645'>645</a>
<a id='n646' href='#n646'>646</a>
<a id='n647' href='#n647'>647</a>
<a id='n648' href='#n648'>648</a>
<a id='n649' href='#n649'>649</a>
<a id='n650' href='#n650'>650</a>
<a id='n651' href='#n651'>651</a>
<a id='n652' href='#n652'>652</a>
<a id='n653' href='#n653'>653</a>
<a id='n654' href='#n654'>654</a>
<a id='n655' href='#n655'>655</a>
<a id='n656' href='#n656'>656</a>
<a id='n657' href='#n657'>657</a>
<a id='n658' href='#n658'>658</a>
<a id='n659' href='#n659'>659</a>
<a id='n660' href='#n660'>660</a>
<a id='n661' href='#n661'>661</a>
<a id='n662' href='#n662'>662</a>
<a id='n663' href='#n663'>663</a>
<a id='n664' href='#n664'>664</a>
<a id='n665' href='#n665'>665</a>
<a id='n666' href='#n666'>666</a>
<a id='n667' href='#n667'>667</a>
<a id='n668' href='#n668'>668</a>
<a id='n669' href='#n669'>669</a>
<a id='n670' href='#n670'>670</a>
<a id='n671' href='#n671'>671</a>
<a id='n672' href='#n672'>672</a>
<a id='n673' href='#n673'>673</a>
<a id='n674' href='#n674'>674</a>
<a id='n675' href='#n675'>675</a>
<a id='n676' href='#n676'>676</a>
<a id='n677' href='#n677'>677</a>
<a id='n678' href='#n678'>678</a>
<a id='n679' href='#n679'>679</a>
<a id='n680' href='#n680'>680</a>
<a id='n681' href='#n681'>681</a>
<a id='n682' href='#n682'>682</a>
<a id='n683' href='#n683'>683</a>
<a id='n684' href='#n684'>684</a>
<a id='n685' href='#n685'>685</a>
<a id='n686' href='#n686'>686</a>
<a id='n687' href='#n687'>687</a>
<a id='n688' href='#n688'>688</a>
<a id='n689' href='#n689'>689</a>
<a id='n690' href='#n690'>690</a>
<a id='n691' href='#n691'>691</a>
<a id='n692' href='#n692'>692</a>
<a id='n693' href='#n693'>693</a>
<a id='n694' href='#n694'>694</a>
<a id='n695' href='#n695'>695</a>
<a id='n696' href='#n696'>696</a>
<a id='n697' href='#n697'>697</a>
<a id='n698' href='#n698'>698</a>
<a id='n699' href='#n699'>699</a>
<a id='n700' href='#n700'>700</a>
<a id='n701' href='#n701'>701</a>
<a id='n702' href='#n702'>702</a>
<a id='n703' href='#n703'>703</a>
<a id='n704' href='#n704'>704</a>
<a id='n705' href='#n705'>705</a>
<a id='n706' href='#n706'>706</a>
<a id='n707' href='#n707'>707</a>
<a id='n708' href='#n708'>708</a>
<a id='n709' href='#n709'>709</a>
<a id='n710' href='#n710'>710</a>
<a id='n711' href='#n711'>711</a>
<a id='n712' href='#n712'>712</a>
<a id='n713' href='#n713'>713</a>
<a id='n714' href='#n714'>714</a>
<a id='n715' href='#n715'>715</a>
<a id='n716' href='#n716'>716</a>
<a id='n717' href='#n717'>717</a>
<a id='n718' href='#n718'>718</a>
<a id='n719' href='#n719'>719</a>
<a id='n720' href='#n720'>720</a>
<a id='n721' href='#n721'>721</a>
<a id='n722' href='#n722'>722</a>
<a id='n723' href='#n723'>723</a>
<a id='n724' href='#n724'>724</a>
<a id='n725' href='#n725'>725</a>
<a id='n726' href='#n726'>726</a>
<a id='n727' href='#n727'>727</a>
<a id='n728' href='#n728'>728</a>
<a id='n729' href='#n729'>729</a>
<a id='n730' href='#n730'>730</a>
<a id='n731' href='#n731'>731</a>
<a id='n732' href='#n732'>732</a>
<a id='n733' href='#n733'>733</a>
<a id='n734' href='#n734'>734</a>
<a id='n735' href='#n735'>735</a>
<a id='n736' href='#n736'>736</a>
<a id='n737' href='#n737'>737</a>
<a id='n738' href='#n738'>738</a>
<a id='n739' href='#n739'>739</a>
<a id='n740' href='#n740'>740</a>
<a id='n741' href='#n741'>741</a>
<a id='n742' href='#n742'>742</a>
<a id='n743' href='#n743'>743</a>
<a id='n744' href='#n744'>744</a>
<a id='n745' href='#n745'>745</a>
<a id='n746' href='#n746'>746</a>
<a id='n747' href='#n747'>747</a>
<a id='n748' href='#n748'>748</a>
<a id='n749' href='#n749'>749</a>
<a id='n750' href='#n750'>750</a>
<a id='n751' href='#n751'>751</a>
<a id='n752' href='#n752'>752</a>
<a id='n753' href='#n753'>753</a>
<a id='n754' href='#n754'>754</a>
<a id='n755' href='#n755'>755</a>
<a id='n756' href='#n756'>756</a>
<a id='n757' href='#n757'>757</a>
<a id='n758' href='#n758'>758</a>
<a id='n759' href='#n759'>759</a>
<a id='n760' href='#n760'>760</a>
<a id='n761' href='#n761'>761</a>
<a id='n762' href='#n762'>762</a>
<a id='n763' href='#n763'>763</a>
<a id='n764' href='#n764'>764</a>
<a id='n765' href='#n765'>765</a>
<a id='n766' href='#n766'>766</a>
<a id='n767' href='#n767'>767</a>
<a id='n768' href='#n768'>768</a>
<a id='n769' href='#n769'>769</a>
<a id='n770' href='#n770'>770</a>
<a id='n771' href='#n771'>771</a>
<a id='n772' href='#n772'>772</a>
<a id='n773' href='#n773'>773</a>
<a id='n774' href='#n774'>774</a>
<a id='n775' href='#n775'>775</a>
<a id='n776' href='#n776'>776</a>
<a id='n777' href='#n777'>777</a>
<a id='n778' href='#n778'>778</a>
<a id='n779' href='#n779'>779</a>
<a id='n780' href='#n780'>780</a>
<a id='n781' href='#n781'>781</a>
<a id='n782' href='#n782'>782</a>
<a id='n783' href='#n783'>783</a>
<a id='n784' href='#n784'>784</a>
<a id='n785' href='#n785'>785</a>
<a id='n786' href='#n786'>786</a>
<a id='n787' href='#n787'>787</a>
<a id='n788' href='#n788'>788</a>
<a id='n789' href='#n789'>789</a>
<a id='n790' href='#n790'>790</a>
<a id='n791' href='#n791'>791</a>
<a id='n792' href='#n792'>792</a>
<a id='n793' href='#n793'>793</a>
<a id='n794' href='#n794'>794</a>
<a id='n795' href='#n795'>795</a>
<a id='n796' href='#n796'>796</a>
<a id='n797' href='#n797'>797</a>
<a id='n798' href='#n798'>798</a>
<a id='n799' href='#n799'>799</a>
<a id='n800' href='#n800'>800</a>
<a id='n801' href='#n801'>801</a>
<a id='n802' href='#n802'>802</a>
<a id='n803' href='#n803'>803</a>
<a id='n804' href='#n804'>804</a>
<a id='n805' href='#n805'>805</a>
<a id='n806' href='#n806'>806</a>
<a id='n807' href='#n807'>807</a>
<a id='n808' href='#n808'>808</a>
<a id='n809' href='#n809'>809</a>
<a id='n810' href='#n810'>810</a>
<a id='n811' href='#n811'>811</a>
<a id='n812' href='#n812'>812</a>
<a id='n813' href='#n813'>813</a>
<a id='n814' href='#n814'>814</a>
<a id='n815' href='#n815'>815</a>
<a id='n816' href='#n816'>816</a>
<a id='n817' href='#n817'>817</a>
<a id='n818' href='#n818'>818</a>
<a id='n819' href='#n819'>819</a>
<a id='n820' href='#n820'>820</a>
<a id='n821' href='#n821'>821</a>
<a id='n822' href='#n822'>822</a>
<a id='n823' href='#n823'>823</a>
<a id='n824' href='#n824'>824</a>
<a id='n825' href='#n825'>825</a>
<a id='n826' href='#n826'>826</a>
<a id='n827' href='#n827'>827</a>
<a id='n828' href='#n828'>828</a>
<a id='n829' href='#n829'>829</a>
<a id='n830' href='#n830'>830</a>
<a id='n831' href='#n831'>831</a>
<a id='n832' href='#n832'>832</a>
<a id='n833' href='#n833'>833</a>
<a id='n834' href='#n834'>834</a>
<a id='n835' href='#n835'>835</a>
<a id='n836' href='#n836'>836</a>
<a id='n837' href='#n837'>837</a>
<a id='n838' href='#n838'>838</a>
<a id='n839' href='#n839'>839</a>
<a id='n840' href='#n840'>840</a>
<a id='n841' href='#n841'>841</a>
<a id='n842' href='#n842'>842</a>
<a id='n843' href='#n843'>843</a>
<a id='n844' href='#n844'>844</a>
<a id='n845' href='#n845'>845</a>
<a id='n846' href='#n846'>846</a>
<a id='n847' href='#n847'>847</a>
<a id='n848' href='#n848'>848</a>
<a id='n849' href='#n849'>849</a>
<a id='n850' href='#n850'>850</a>
<a id='n851' href='#n851'>851</a>
<a id='n852' href='#n852'>852</a>
<a id='n853' href='#n853'>853</a>
<a id='n854' href='#n854'>854</a>
<a id='n855' href='#n855'>855</a>
<a id='n856' href='#n856'>856</a>
<a id='n857' href='#n857'>857</a>
<a id='n858' href='#n858'>858</a>
<a id='n859' href='#n859'>859</a>
<a id='n860' href='#n860'>860</a>
<a id='n861' href='#n861'>861</a>
<a id='n862' href='#n862'>862</a>
<a id='n863' href='#n863'>863</a>
<a id='n864' href='#n864'>864</a>
<a id='n865' href='#n865'>865</a>
<a id='n866' href='#n866'>866</a>
<a id='n867' href='#n867'>867</a>
<a id='n868' href='#n868'>868</a>
<a id='n869' href='#n869'>869</a>
<a id='n870' href='#n870'>870</a>
<a id='n871' href='#n871'>871</a>
<a id='n872' href='#n872'>872</a>
<a id='n873' href='#n873'>873</a>
<a id='n874' href='#n874'>874</a>
<a id='n875' href='#n875'>875</a>
<a id='n876' href='#n876'>876</a>
<a id='n877' href='#n877'>877</a>
<a id='n878' href='#n878'>878</a>
<a id='n879' href='#n879'>879</a>
<a id='n880' href='#n880'>880</a>
<a id='n881' href='#n881'>881</a>
<a id='n882' href='#n882'>882</a>
<a id='n883' href='#n883'>883</a>
<a id='n884' href='#n884'>884</a>
<a id='n885' href='#n885'>885</a>
<a id='n886' href='#n886'>886</a>
<a id='n887' href='#n887'>887</a>
<a id='n888' href='#n888'>888</a>
<a id='n889' href='#n889'>889</a>
<a id='n890' href='#n890'>890</a>
<a id='n891' href='#n891'>891</a>
<a id='n892' href='#n892'>892</a>
<a id='n893' href='#n893'>893</a>
<a id='n894' href='#n894'>894</a>
<a id='n895' href='#n895'>895</a>
<a id='n896' href='#n896'>896</a>
<a id='n897' href='#n897'>897</a>
<a id='n898' href='#n898'>898</a>
<a id='n899' href='#n899'>899</a>
<a id='n900' href='#n900'>900</a>
<a id='n901' href='#n901'>901</a>
<a id='n902' href='#n902'>902</a>
<a id='n903' href='#n903'>903</a>
<a id='n904' href='#n904'>904</a>
<a id='n905' href='#n905'>905</a>
<a id='n906' href='#n906'>906</a>
<a id='n907' href='#n907'>907</a>
<a id='n908' href='#n908'>908</a>
<a id='n909' href='#n909'>909</a>
<a id='n910' href='#n910'>910</a>
<a id='n911' href='#n911'>911</a>
<a id='n912' href='#n912'>912</a>
<a id='n913' href='#n913'>913</a>
<a id='n914' href='#n914'>914</a>
<a id='n915' href='#n915'>915</a>
<a id='n916' href='#n916'>916</a>
<a id='n917' href='#n917'>917</a>
<a id='n918' href='#n918'>918</a>
<a id='n919' href='#n919'>919</a>
<a id='n920' href='#n920'>920</a>
<a id='n921' href='#n921'>921</a>
<a id='n922' href='#n922'>922</a>
<a id='n923' href='#n923'>923</a>
<a id='n924' href='#n924'>924</a>
<a id='n925' href='#n925'>925</a>
<a id='n926' href='#n926'>926</a>
<a id='n927' href='#n927'>927</a>
<a id='n928' href='#n928'>928</a>
<a id='n929' href='#n929'>929</a>
<a id='n930' href='#n930'>930</a>
<a id='n931' href='#n931'>931</a>
<a id='n932' href='#n932'>932</a>
<a id='n933' href='#n933'>933</a>
<a id='n934' href='#n934'>934</a>
<a id='n935' href='#n935'>935</a>
<a id='n936' href='#n936'>936</a>
<a id='n937' href='#n937'>937</a>
<a id='n938' href='#n938'>938</a>
<a id='n939' href='#n939'>939</a>
<a id='n940' href='#n940'>940</a>
<a id='n941' href='#n941'>941</a>
<a id='n942' href='#n942'>942</a>
<a id='n943' href='#n943'>943</a>
<a id='n944' href='#n944'>944</a>
<a id='n945' href='#n945'>945</a>
<a id='n946' href='#n946'>946</a>
<a id='n947' href='#n947'>947</a>
<a id='n948' href='#n948'>948</a>
<a id='n949' href='#n949'>949</a>
<a id='n950' href='#n950'>950</a>
<a id='n951' href='#n951'>951</a>
<a id='n952' href='#n952'>952</a>
<a id='n953' href='#n953'>953</a>
<a id='n954' href='#n954'>954</a>
<a id='n955' href='#n955'>955</a>
<a id='n956' href='#n956'>956</a>
<a id='n957' href='#n957'>957</a>
<a id='n958' href='#n958'>958</a>
<a id='n959' href='#n959'>959</a>
<a id='n960' href='#n960'>960</a>
<a id='n961' href='#n961'>961</a>
<a id='n962' href='#n962'>962</a>
<a id='n963' href='#n963'>963</a>
<a id='n964' href='#n964'>964</a>
<a id='n965' href='#n965'>965</a>
<a id='n966' href='#n966'>966</a>
<a id='n967' href='#n967'>967</a>
<a id='n968' href='#n968'>968</a>
<a id='n969' href='#n969'>969</a>
<a id='n970' href='#n970'>970</a>
<a id='n971' href='#n971'>971</a>
<a id='n972' href='#n972'>972</a>
<a id='n973' href='#n973'>973</a>
<a id='n974' href='#n974'>974</a>
<a id='n975' href='#n975'>975</a>
<a id='n976' href='#n976'>976</a>
<a id='n977' href='#n977'>977</a>
<a id='n978' href='#n978'>978</a>
<a id='n979' href='#n979'>979</a>
<a id='n980' href='#n980'>980</a>
<a id='n981' href='#n981'>981</a>
<a id='n982' href='#n982'>982</a>
<a id='n983' href='#n983'>983</a>
<a id='n984' href='#n984'>984</a>
<a id='n985' href='#n985'>985</a>
<a id='n986' href='#n986'>986</a>
<a id='n987' href='#n987'>987</a>
<a id='n988' href='#n988'>988</a>
<a id='n989' href='#n989'>989</a>
<a id='n990' href='#n990'>990</a>
<a id='n991' href='#n991'>991</a>
<a id='n992' href='#n992'>992</a>
<a id='n993' href='#n993'>993</a>
<a id='n994' href='#n994'>994</a>
<a id='n995' href='#n995'>995</a>
<a id='n996' href='#n996'>996</a>
<a id='n997' href='#n997'>997</a>
<a id='n998' href='#n998'>998</a>
<a id='n999' href='#n999'>999</a>
<a id='n1000' href='#n1000'>1000</a>
<a id='n1001' href='#n1001'>1001</a>
<a id='n1002' href='#n1002'>1002</a>
<a id='n1003' href='#n1003'>1003</a>
<a id='n1004' href='#n1004'>1004</a>
<a id='n1005' href='#n1005'>1005</a>
<a id='n1006' href='#n1006'>1006</a>
<a id='n1007' href='#n1007'>1007</a>
<a id='n1008' href='#n1008'>1008</a>
<a id='n1009' href='#n1009'>1009</a>
<a id='n1010' href='#n1010'>1010</a>
<a id='n1011' href='#n1011'>1011</a>
<a id='n1012' href='#n1012'>1012</a>
<a id='n1013' href='#n1013'>1013</a>
<a id='n1014' href='#n1014'>1014</a>
<a id='n1015' href='#n1015'>1015</a>
<a id='n1016' href='#n1016'>1016</a>
<a id='n1017' href='#n1017'>1017</a>
<a id='n1018' href='#n1018'>1018</a>
<a id='n1019' href='#n1019'>1019</a>
<a id='n1020' href='#n1020'>1020</a>
<a id='n1021' href='#n1021'>1021</a>
<a id='n1022' href='#n1022'>1022</a>
<a id='n1023' href='#n1023'>1023</a>
<a id='n1024' href='#n1024'>1024</a>
<a id='n1025' href='#n1025'>1025</a>
<a id='n1026' href='#n1026'>1026</a>
<a id='n1027' href='#n1027'>1027</a>
<a id='n1028' href='#n1028'>1028</a>
<a id='n1029' href='#n1029'>1029</a>
<a id='n1030' href='#n1030'>1030</a>
<a id='n1031' href='#n1031'>1031</a>
<a id='n1032' href='#n1032'>1032</a>
<a id='n1033' href='#n1033'>1033</a>
<a id='n1034' href='#n1034'>1034</a>
<a id='n1035' href='#n1035'>1035</a>
<a id='n1036' href='#n1036'>1036</a>
<a id='n1037' href='#n1037'>1037</a>
<a id='n1038' href='#n1038'>1038</a>
<a id='n1039' href='#n1039'>1039</a>
<a id='n1040' href='#n1040'>1040</a>
<a id='n1041' href='#n1041'>1041</a>
<a id='n1042' href='#n1042'>1042</a>
<a id='n1043' href='#n1043'>1043</a>
<a id='n1044' href='#n1044'>1044</a>
<a id='n1045' href='#n1045'>1045</a>
<a id='n1046' href='#n1046'>1046</a>
<a id='n1047' href='#n1047'>1047</a>
<a id='n1048' href='#n1048'>1048</a>
<a id='n1049' href='#n1049'>1049</a>
<a id='n1050' href='#n1050'>1050</a>
<a id='n1051' href='#n1051'>1051</a>
<a id='n1052' href='#n1052'>1052</a>
<a id='n1053' href='#n1053'>1053</a>
<a id='n1054' href='#n1054'>1054</a>
<a id='n1055' href='#n1055'>1055</a>
<a id='n1056' href='#n1056'>1056</a>
<a id='n1057' href='#n1057'>1057</a>
<a id='n1058' href='#n1058'>1058</a>
<a id='n1059' href='#n1059'>1059</a>
<a id='n1060' href='#n1060'>1060</a>
<a id='n1061' href='#n1061'>1061</a>
<a id='n1062' href='#n1062'>1062</a>
<a id='n1063' href='#n1063'>1063</a>
<a id='n1064' href='#n1064'>1064</a>
<a id='n1065' href='#n1065'>1065</a>
<a id='n1066' href='#n1066'>1066</a>
<a id='n1067' href='#n1067'>1067</a>
<a id='n1068' href='#n1068'>1068</a>
<a id='n1069' href='#n1069'>1069</a>
<a id='n1070' href='#n1070'>1070</a>
<a id='n1071' href='#n1071'>1071</a>
<a id='n1072' href='#n1072'>1072</a>
<a id='n1073' href='#n1073'>1073</a>
<a id='n1074' href='#n1074'>1074</a>
<a id='n1075' href='#n1075'>1075</a>
</pre></td>
<td class='lines'><pre><code>/*
  Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
  2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
  Software Foundation, Inc.

  This file is part of GNU Inetutils.

  GNU Inetutils is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or (at
  your option) any later version.

  GNU Inetutils is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see `http://www.gnu.org/licenses/'. */

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (C) 1990 by the Massachusetts Institute of Technology
 *
 * Export of this software from the United States of America is assumed
 * to require a specific license from the United States Government.
 * It is the responsibility of any person or organization contemplating
 * export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided ""as is"" without express
 * or implied warranty.
 */

#include &lt;config.h&gt;

#ifdef	ENCRYPTION

# define ENCRYPT_NAMES
# include &lt;arpa/telnet.h&gt;

# include ""encrypt.h""
# include ""misc.h""

# include &lt;stdlib.h&gt;
# include &lt;string.h&gt;

# include &lt;stdio.h&gt;
# include ""genget.h""

/*
 * These functions pointers point to the current routines
 * for encrypting and decrypting data.
 */
void (*encrypt_output) (unsigned char *, int);
int (*decrypt_input) (int);

int encrypt_debug_mode = 0;
static int decrypt_mode = 0;
static int encrypt_mode = 0;
static int encrypt_verbose = 0;
static int autoencrypt = 0;
static int autodecrypt = 0;
static int havesessionkey = 0;
static int Server = 0;
static char *Name = ""Noname"";

# define typemask(x)	((x) &gt; 0 ? 1 &lt;&lt; ((x)-1) : 0)

static long i_support_encrypt = typemask (ENCTYPE_DES_CFB64)
  | typemask (ENCTYPE_DES_OFB64);
     static long
       i_support_decrypt = typemask (ENCTYPE_DES_CFB64)
  | typemask (ENCTYPE_DES_OFB64);
     static long
       i_wont_support_encrypt = 0;
     static long
       i_wont_support_decrypt = 0;
# define I_SUPPORT_ENCRYPT	(i_support_encrypt &amp; ~i_wont_support_encrypt)
# define I_SUPPORT_DECRYPT	(i_support_decrypt &amp; ~i_wont_support_decrypt)

     static long
       remote_supports_encrypt = 0;
     static long
       remote_supports_decrypt = 0;

     static
       Encryptions
       encryptions[] = {
# if defined DES_ENCRYPTION || defined SHISHI
       {""DES_CFB64"", ENCTYPE_DES_CFB64,
	cfb64_encrypt,
	cfb64_decrypt,
	cfb64_init,
	cfb64_start,
	cfb64_is,
	cfb64_reply,
	cfb64_session,
	cfb64_keyid,
	cfb64_printsub},
       {""DES_OFB64"", ENCTYPE_DES_OFB64,
	ofb64_encrypt,
	ofb64_decrypt,
	ofb64_init,
	ofb64_start,
	ofb64_is,
	ofb64_reply,
	ofb64_session,
	ofb64_keyid,
	ofb64_printsub},
# endif	/* DES_ENCRYPTION */
       {0,},
     };

static unsigned char str_send[64] = { IAC, SB, TELOPT_ENCRYPT,
  ENCRYPT_SUPPORT
};
static unsigned char str_suplen = 0;
static unsigned char str_start[72] = { IAC, SB, TELOPT_ENCRYPT };
static unsigned char str_end[] = { IAC, SB, TELOPT_ENCRYPT, 0, IAC, SE };

Encryptions *
findencryption (type)
     int type;
{
  Encryptions *ep = encryptions;

  if (!(I_SUPPORT_ENCRYPT &amp; remote_supports_decrypt &amp; typemask (type)))
    return (0);
  while (ep-&gt;type &amp;&amp; ep-&gt;type != type)
    ++ep;
  return (ep-&gt;type ? ep : 0);
}

Encryptions *
finddecryption (type)
     int type;
{
  Encryptions *ep = encryptions;

  if (!(I_SUPPORT_DECRYPT &amp; remote_supports_encrypt &amp; typemask (type)))
    return (0);
  while (ep-&gt;type &amp;&amp; ep-&gt;type != type)
    ++ep;
  return (ep-&gt;type ? ep : 0);
}

# define MAXKEYLEN 64

static struct key_info
{
  unsigned char keyid[MAXKEYLEN];
  int keylen;
  int dir;
  int *modep;
  Encryptions *(*getcrypt) ();
} ki[2] =
{
  {
    {
  0}, 0, DIR_ENCRYPT, &amp;encrypt_mode, findencryption},
  {
    {
0}, 0, DIR_DECRYPT, &amp;decrypt_mode, finddecryption},};

void
encrypt_init (name, server)
     char *name;
     int server;
{
  Encryptions *ep = encryptions;

  Name = name;
  Server = server;
  i_support_encrypt = i_support_decrypt = 0;
  remote_supports_encrypt = remote_supports_decrypt = 0;
  encrypt_mode = 0;
  decrypt_mode = 0;
  encrypt_output = 0;
  decrypt_input = 0;
  str_suplen = 4;

  while (ep-&gt;type)
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: I will support %s\r\n"",
		Name, ENCTYPE_NAME (ep-&gt;type));
      i_support_encrypt |= typemask (ep-&gt;type);
      i_support_decrypt |= typemask (ep-&gt;type);
      if ((i_wont_support_decrypt &amp; typemask (ep-&gt;type)) == 0)
	if ((str_send[str_suplen++] = ep-&gt;type) == IAC)
	  str_send[str_suplen++] = IAC;
      if (ep-&gt;init)
	(*ep-&gt;init) (Server);
      ++ep;
    }
  str_send[str_suplen++] = IAC;
  str_send[str_suplen++] = SE;
}

void
encrypt_list_types ()
{
  Encryptions *ep = encryptions;

  printf (""Valid encryption types:\n"");
  while (ep-&gt;type)
    {
      printf (""\t%s (%d)\r\n"", ENCTYPE_NAME (ep-&gt;type), ep-&gt;type);
      ++ep;
    }
}

int
EncryptEnable (type, mode)
     char *type, *mode;
{
  if (isprefix (type, ""help"") || isprefix (type, ""?""))
    {
      printf (""Usage: encrypt enable &lt;type&gt; [input|output]\n"");
      encrypt_list_types ();
      return (0);
    }
  if (EncryptType (type, mode))
    return (EncryptStart (mode));
  return (0);
}

int
EncryptDisable (type, mode)
     char *type, *mode;
{
  register Encryptions *ep;
  int ret = 0;

  if (isprefix (type, ""help"") || isprefix (type, ""?""))
    {
      printf (""Usage: encrypt disable &lt;type&gt; [input|output]\n"");
      encrypt_list_types ();
    }
  else if ((ep = (Encryptions *) genget (type, encryptions,
					 sizeof (Encryptions))) == 0)
    {
      printf (""%s: invalid encryption type\n"", type);
    }
  else if (Ambiguous (ep))
    {
      printf (""Ambiguous type '%s'\n"", type);
    }
  else
    {
      if ((mode == 0) || (isprefix (mode, ""input"") ? 1 : 0))
	{
	  if (decrypt_mode == ep-&gt;type)
	    EncryptStopInput ();
	  i_wont_support_decrypt |= typemask (ep-&gt;type);
	  ret = 1;
	}
      if ((mode == 0) || (isprefix (mode, ""output"")))
	{
	  if (encrypt_mode == ep-&gt;type)
	    EncryptStopOutput ();
	  i_wont_support_encrypt |= typemask (ep-&gt;type);
	  ret = 1;
	}
      if (ret == 0)
	printf (""%s: invalid encryption mode\n"", mode);
    }
  return (ret);
}

int
EncryptType (type, mode)
     char *type;
     char *mode;
{
  register Encryptions *ep;
  int ret = 0;

  if (isprefix (type, ""help"") || isprefix (type, ""?""))
    {
      printf (""Usage: encrypt type &lt;type&gt; [input|output]\n"");
      encrypt_list_types ();
    }
  else if ((ep = (Encryptions *) genget (type, encryptions,
					 sizeof (Encryptions))) == 0)
    {
      printf (""%s: invalid encryption type\n"", type);
    }
  else if (Ambiguous (ep))
    {
      printf (""Ambiguous type '%s'\n"", type);
    }
  else
    {
      if ((mode == 0) || isprefix (mode, ""input""))
	{
	  decrypt_mode = ep-&gt;type;
	  i_wont_support_decrypt &amp;= ~typemask (ep-&gt;type);
	  ret = 1;
	}
      if ((mode == 0) || isprefix (mode, ""output""))
	{
	  encrypt_mode = ep-&gt;type;
	  i_wont_support_encrypt &amp;= ~typemask (ep-&gt;type);
	  ret = 1;
	}
      if (ret == 0)
	printf (""%s: invalid encryption mode\n"", mode);
    }
  return (ret);
}

int
EncryptStart (mode)
     char *mode;
{
  register int ret = 0;
  if (mode)
    {
      if (isprefix (mode, ""input""))
	return (EncryptStartInput ());
      if (isprefix (mode, ""output""))
	return (EncryptStartOutput ());
      if (isprefix (mode, ""help"") || isprefix (mode, ""?""))
	{
	  printf (""Usage: encrypt start [input|output]\n"");
	  return (0);
	}
      printf (""%s: invalid encryption mode 'encrypt start ?' for help\n"",
	      mode);
      return (0);
    }
  ret += EncryptStartInput ();
  ret += EncryptStartOutput ();
  return (ret);
}

int
EncryptStartInput ()
{
  if (decrypt_mode)
    {
      encrypt_send_request_start ();
      return (1);
    }
  printf (""No previous decryption mode, decryption not enabled\r\n"");
  return (0);
}

int
EncryptStartOutput ()
{
  if (encrypt_mode)
    {
      encrypt_start_output (encrypt_mode);
      return (1);
    }
  printf (""No previous encryption mode, encryption not enabled\r\n"");
  return (0);
}

int
EncryptStop (mode)
     char *mode;
{
  int ret = 0;
  if (mode)
    {
      if (isprefix (mode, ""input""))
	return (EncryptStopInput ());
      if (isprefix (mode, ""output""))
	return (EncryptStopOutput ());
      if (isprefix (mode, ""help"") || isprefix (mode, ""?""))
	{
	  printf (""Usage: encrypt stop [input|output]\n"");
	  return (0);
	}
      printf (""%s: invalid encryption mode 'encrypt stop ?' for help\n"",
	      mode);
      return (0);
    }
  ret += EncryptStopInput ();
  ret += EncryptStopOutput ();
  return (ret);
}

int
EncryptStopInput ()
{
  encrypt_send_request_end ();
  return (1);
}

int
EncryptStopOutput ()
{
  encrypt_send_end ();
  return (1);
}

void
encrypt_display ()
{
  if (encrypt_output)
    printf (""Currently encrypting output with %s\r\n"",
	    ENCTYPE_NAME (encrypt_mode));
  if (decrypt_input)
    printf (""Currently decrypting input with %s\r\n"",
	    ENCTYPE_NAME (decrypt_mode));
}

int
EncryptStatus ()
{
  if (encrypt_output)
    printf (""Currently encrypting output with %s\r\n"",
	    ENCTYPE_NAME (encrypt_mode));
  else if (encrypt_mode)
    {
      printf (""Currently output is clear text.\r\n"");
      printf (""Last encryption mode was %s\r\n"", ENCTYPE_NAME (encrypt_mode));
    }
  if (decrypt_input)
    {
      printf (""Currently decrypting input with %s\r\n"",
	      ENCTYPE_NAME (decrypt_mode));
    }
  else if (decrypt_mode)
    {
      printf (""Currently input is clear text.\r\n"");
      printf (""Last decryption mode was %s\r\n"", ENCTYPE_NAME (decrypt_mode));
    }
  return 1;
}

void
encrypt_send_support ()
{
  if (str_suplen)
    {
      /*
       * If the user has requested that decryption start
       * immediatly, then send a ""REQUEST START"" before
       * we negotiate the type.
       */
      if (!Server &amp;&amp; autodecrypt)
	encrypt_send_request_start ();
      net_write (str_send, str_suplen);
      printsub ('&gt;', &amp;str_send[2], str_suplen - 2);
      str_suplen = 0;
    }
}

int
EncryptDebug (on)
     int on;
{
  if (on &lt; 0)
    encrypt_debug_mode ^= 1;
  else
    encrypt_debug_mode = on;
  printf (""Encryption debugging %s\r\n"",
	  encrypt_debug_mode ? ""enabled"" : ""disabled"");
  return (1);
}

int
EncryptVerbose (on)
     int on;
{
  if (on &lt; 0)
    encrypt_verbose ^= 1;
  else
    encrypt_verbose = on;
  printf (""Encryption %s verbose\r\n"", encrypt_verbose ? ""is"" : ""is not"");
  return (1);
}

int
EncryptAutoEnc (on)
     int on;
{
  encrypt_auto (on);
  printf (""Automatic encryption of output is %s\r\n"",
	  autoencrypt ? ""enabled"" : ""disabled"");
  return (1);
}

int
EncryptAutoDec (on)
     int on;
{
  decrypt_auto (on);
  printf (""Automatic decryption of input is %s\r\n"",
	  autodecrypt ? ""enabled"" : ""disabled"");
  return (1);
}

/*
 * Called when ENCRYPT SUPPORT is received.
 */
void
encrypt_support (typelist, cnt)
     unsigned char *typelist;
     int cnt;
{
  register int type, use_type = 0;
  Encryptions *ep;

  /*
   * Forget anything the other side has previously told us.
   */
  remote_supports_decrypt = 0;

  while (cnt-- &gt; 0)
    {
      type = *typelist++;
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: He is supporting %s (%d)\r\n"",
		Name, ENCTYPE_NAME (type), type);
      if ((type &lt; ENCTYPE_CNT) &amp;&amp; (I_SUPPORT_ENCRYPT &amp; typemask (type)))
	{
	  remote_supports_decrypt |= typemask (type);
	  if (use_type == 0)
	    use_type = type;
	}
    }
  if (use_type)
    {
      ep = findencryption (use_type);
      if (!ep)
	return;
      type = ep-&gt;start ? (*ep-&gt;start) (DIR_ENCRYPT, Server) : 0;
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: (*ep-&gt;start)() returned %d\r\n"", Name, type);
      if (type &lt; 0)
	return;
      encrypt_mode = use_type;
      if (type == 0)
	encrypt_start_output (use_type);
    }
}

void
encrypt_is (data, cnt)
     unsigned char *data;
     int cnt;
{
  Encryptions *ep;
  register int type, ret;

  if (--cnt &lt; 0)
    return;
  type = *data++;
  if (type &lt; ENCTYPE_CNT)
    remote_supports_encrypt |= typemask (type);
  if (!(ep = finddecryption (type)))
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: Can't find type %s (%d) for initial negotiation\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      return;
    }
  if (!ep-&gt;is)
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: No initial negotiation needed for type %s (%d)\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      ret = 0;
    }
  else
    {
      ret = (*ep-&gt;is) (data, cnt);
      if (encrypt_debug_mode)
	printf (""(*ep-&gt;is)(%x, %d) returned %s(%d)\n"", data, cnt,
		(ret &lt; 0) ? ""FAIL "" :
		(ret == 0) ? ""SUCCESS "" : ""MORE_TO_DO "", ret);
    }
  if (ret &lt; 0)
    {
      autodecrypt = 0;
    }
  else
    {
      decrypt_mode = type;
      if (ret == 0 &amp;&amp; autodecrypt)
	encrypt_send_request_start ();
    }
}

void
encrypt_reply (data, cnt)
     unsigned char *data;
     int cnt;
{
  Encryptions *ep;
  register int ret, type;

  if (--cnt &lt; 0)
    return;
  type = *data++;
  if (!(ep = findencryption (type)))
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: Can't find type %s (%d) for initial negotiation\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      return;
    }
  if (!ep-&gt;reply)
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: No initial negotiation needed for type %s (%d)\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      ret = 0;
    }
  else
    {
      ret = (*ep-&gt;reply) (data, cnt);
      if (encrypt_debug_mode)
	printf (""(*ep-&gt;reply)(%x, %d) returned %s(%d)\n"",
		data, cnt,
		(ret &lt; 0) ? ""FAIL "" :
		(ret == 0) ? ""SUCCESS "" : ""MORE_TO_DO "", ret);
    }
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: encrypt_reply returned %d\n"", Name, ret);
  if (ret &lt; 0)
    {
      autoencrypt = 0;
    }
  else
    {
      encrypt_mode = type;
      if (ret == 0 &amp;&amp; autoencrypt)
	encrypt_start_output (type);
    }
}

/*
 * Called when a ENCRYPT START command is received.
 */
void
encrypt_start (data, cnt)
     unsigned char *data;
     int cnt;
{
  Encryptions *ep;

  if (!decrypt_mode)
    {
      /*
       * Something is wrong.  We should not get a START
       * command without having already picked our
       * decryption scheme.  Send a REQUEST-END to
       * attempt to clear the channel...
       */
      printf (""%s: Warning, Cannot decrypt input stream!!!\r\n"", Name);
      encrypt_send_request_end ();
      return;
    }

  if (ep = finddecryption (decrypt_mode))
    {
      decrypt_input = ep-&gt;input;
      if (encrypt_verbose)
	printf (""[ Input is now decrypted with type %s ]\r\n"",
		ENCTYPE_NAME (decrypt_mode));
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: Start to decrypt input with type %s\r\n"",
		Name, ENCTYPE_NAME (decrypt_mode));
    }
  else
    {
      printf (""%s: Warning, Cannot decrypt type %s (%d)!!!\r\n"",
	      Name,
	      ENCTYPE_NAME_OK (decrypt_mode)
	      ? ENCTYPE_NAME (decrypt_mode) : ""(unknown)"", decrypt_mode);
      encrypt_send_request_end ();
    }
}

void
encrypt_session_key (key, server)
     Session_Key *key;
     int server;
{
  Encryptions *ep = encryptions;

  havesessionkey = 1;

  while (ep-&gt;type)
    {
      if (ep-&gt;session)
	(*ep-&gt;session) (key, server);
      ++ep;
    }
}

/*
 * Called when ENCRYPT END is received.
 */
void
encrypt_end ()
{
  decrypt_input = 0;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Input is back to clear text\r\n"", Name);
  if (encrypt_verbose)
    printf (""[ Input is now clear text ]\r\n"");
}

/*
 * Called when ENCRYPT REQUEST-END is received.
 */
void
encrypt_request_end ()
{
  encrypt_send_end ();
}

/*
 * Called when ENCRYPT REQUEST-START is received.  If we receive
 * this before a type is picked, then that indicates that the
 * other side wants us to start encrypting data as soon as we
 * can.
 */
void
encrypt_request_start (data, cnt)
     unsigned char *data;
     int cnt;
{
  if (encrypt_mode == 0)
    {
      if (Server)
	autoencrypt = 1;
      return;
    }
  encrypt_start_output (encrypt_mode);
}

static unsigned char str_keyid[(MAXKEYLEN * 2) + 5] =
  { IAC, SB, TELOPT_ENCRYPT };

static void
encrypt_keyid (kp, keyid, len)
     struct key_info *kp;
     unsigned char *keyid;
     int len;
{
  Encryptions *ep;
  unsigned char *strp, *cp;
  int dir = kp-&gt;dir;
  register int ret = 0;

  if (!(ep = (*kp-&gt;getcrypt) (*kp-&gt;modep)))
    {
      if (len == 0)
	return;
      kp-&gt;keylen = 0;
    }
  else if (len == 0)
    {
      /*
       * Empty option, indicates a failure.
       */
      if (kp-&gt;keylen == 0)
	return;
      kp-&gt;keylen = 0;
      if (ep-&gt;keyid)
	(*ep-&gt;keyid) (dir, kp-&gt;keyid, &amp;kp-&gt;keylen);

    }
  else if ((len != kp-&gt;keylen) || (memcmp (keyid, kp-&gt;keyid, len) != 0))
    {
      /*
       * Length or contents are different
       */
      kp-&gt;keylen = len;
      memmove (kp-&gt;keyid, keyid, len);
      if (ep-&gt;keyid)
	(*ep-&gt;keyid) (dir, kp-&gt;keyid, &amp;kp-&gt;keylen);
    }
  else
    {
      if (ep-&gt;keyid)
	ret = (*ep-&gt;keyid) (dir, kp-&gt;keyid, &amp;kp-&gt;keylen);
      if ((ret == 0) &amp;&amp; (dir == DIR_ENCRYPT) &amp;&amp; autoencrypt)
	encrypt_start_output (*kp-&gt;modep);
      return;
    }

  encrypt_send_keyid (dir, kp-&gt;keyid, kp-&gt;keylen, 0);
}

void
encrypt_enc_keyid (keyid, len)
     unsigned char *keyid;
     int len;
{
  encrypt_keyid (&amp;ki[1], keyid, len);
}

void
encrypt_dec_keyid (keyid, len)
     unsigned char *keyid;
     int len;
{
  encrypt_keyid (&amp;ki[0], keyid, len);
}

void
encrypt_send_keyid (dir, keyid, keylen, saveit)
     int dir;
     unsigned char *keyid;
     int keylen;
     int saveit;
{
  unsigned char *strp;

  str_keyid[3] = (dir == DIR_ENCRYPT) ? ENCRYPT_ENC_KEYID : ENCRYPT_DEC_KEYID;
  if (saveit)
    {
      struct key_info *kp = &amp;ki[(dir == DIR_ENCRYPT) ? 0 : 1];
      memmove (kp-&gt;keyid, keyid, keylen);
      kp-&gt;keylen = keylen;
    }

  for (strp = &amp;str_keyid[4]; keylen &gt; 0; --keylen)
    {
      if ((*strp++ = *keyid++) == IAC)
	*strp++ = IAC;
    }
  *strp++ = IAC;
  *strp++ = SE;
  net_write (str_keyid, strp - str_keyid);
  printsub ('&gt;', &amp;str_keyid[2], strp - str_keyid - 2);
}

void
encrypt_auto (on)
     int on;
{
  if (on &lt; 0)
    autoencrypt ^= 1;
  else
    autoencrypt = on ? 1 : 0;
}

void
decrypt_auto (on)
     int on;
{
  if (on &lt; 0)
    autodecrypt ^= 1;
  else
    autodecrypt = on ? 1 : 0;
}

void
encrypt_start_output (type)
     int type;
{
  Encryptions *ep;
  register unsigned char *p;
  register int i;

  if (!(ep = findencryption (type)))
    {
      if (encrypt_debug_mode)
	{
	  printf (""&gt;&gt;&gt;%s: Can't encrypt with type %s (%d)\r\n"",
		  Name,
		  ENCTYPE_NAME_OK (type)
		  ? ENCTYPE_NAME (type) : ""(unknown)"", type);
	}
      return;
    }
  if (ep-&gt;start)
    {
      i = (*ep-&gt;start) (DIR_ENCRYPT, Server);
      if (encrypt_debug_mode)
	{
	  printf (""&gt;&gt;&gt;%s: Encrypt start: %s (%d) %s\r\n"",
		  Name,
		  (i &lt; 0) ? ""failed"" :
		  ""initial negotiation in progress"", i, ENCTYPE_NAME (type));
	}
      if (i)
	return;
    }
  p = str_start + 3;
  *p++ = ENCRYPT_START;
  for (i = 0; i &lt; ki[0].keylen; ++i)
    {
      if ((*p++ = ki[0].keyid[i]) == IAC)
	*p++ = IAC;
    }
  *p++ = IAC;
  *p++ = SE;
  net_write (str_start, p - str_start);
  net_encrypt ();
  printsub ('&gt;', &amp;str_start[2], p - &amp;str_start[2]);
  /*
   * If we are already encrypting in some mode, then
   * encrypt the ring (which includes our request) in
   * the old mode, mark it all as ""clear text"" and then
   * switch to the new mode.
   */
  encrypt_output = ep-&gt;output;
  encrypt_mode = type;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Started to encrypt output with type %s\r\n"",
	    Name, ENCTYPE_NAME (type));
  if (encrypt_verbose)
    printf (""[ Output is now encrypted with type %s ]\r\n"",
	    ENCTYPE_NAME (type));
}

void
encrypt_send_end ()
{
  if (!encrypt_output)
    return;

  str_end[3] = ENCRYPT_END;
  net_write (str_end, sizeof (str_end));
  net_encrypt ();
  printsub ('&gt;', &amp;str_end[2], sizeof (str_end) - 2);
  /*
   * Encrypt the output buffer now because it will not be done by
   * netflush...
   */
  encrypt_output = 0;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Output is back to clear text\r\n"", Name);
  if (encrypt_verbose)
    printf (""[ Output is now clear text ]\r\n"");
}

void
encrypt_send_request_start ()
{
  register unsigned char *p;
  register int i;

  p = &amp;str_start[3];
  *p++ = ENCRYPT_REQSTART;
  for (i = 0; i &lt; ki[1].keylen; ++i)
    {
      if ((*p++ = ki[1].keyid[i]) == IAC)
	*p++ = IAC;
    }
  *p++ = IAC;
  *p++ = SE;
  net_write (str_start, p - str_start);
  printsub ('&gt;', &amp;str_start[2], p - &amp;str_start[2]);
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Request input to be encrypted\r\n"", Name);
}

void
encrypt_send_request_end ()
{
  str_end[3] = ENCRYPT_REQEND;
  net_write (str_end, sizeof (str_end));
  printsub ('&gt;', &amp;str_end[2], sizeof (str_end) - 2);

  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Request input to be clear text\r\n"", Name);
}

void
encrypt_wait ()
{
  register int encrypt, decrypt;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: in encrypt_wait\r\n"", Name);
  if (!havesessionkey || !(I_SUPPORT_ENCRYPT &amp; remote_supports_decrypt))
    return;
  while (autoencrypt &amp;&amp; !encrypt_output)
    if (telnet_spin ())
      return;
}

void
encrypt_debug (mode)
     int mode;
{
  encrypt_debug_mode = mode;
}

void
encrypt_gen_printsub (data, cnt, buf, buflen)
     unsigned char *data, *buf;
     int cnt, buflen;
{
  char tbuf[16], *cp;

  cnt -= 2;
  data += 2;
  buf[buflen - 1] = '\0';
  buf[buflen - 2] = '*';
  buflen -= 2;;
  for (; cnt &gt; 0; cnt--, data++)
    {
      sprintf (tbuf, "" %d"", *data);
      for (cp = tbuf; *cp &amp;&amp; buflen &gt; 0; --buflen)
	*buf++ = *cp++;
      if (buflen &lt;= 0)
	return;
    }
  *buf = '\0';
}

void
encrypt_printsub (data, cnt, buf, buflen)
     unsigned char *data, *buf;
     int cnt, buflen;
{
  Encryptions *ep;
  register int type = data[1];

  for (ep = encryptions; ep-&gt;type &amp;&amp; ep-&gt;type != type; ep++)
    ;

  if (ep-&gt;printsub)
    (*ep-&gt;printsub) (data, cnt, buf, buflen);
  else
    encrypt_gen_printsub (data, cnt, buf, buflen);
}
#endif /* ENCRYPTION */
</code></pre></td></tr></table>
</div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit v1.2.1</a> (<a href='https://git-scm.com/'>git 2.18.0</a>) at 2020-05-09 06:46:00 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
","<!DOCTYPE html>
<html lang='en'>
<head>
<title>encrypt.c\libtelnet - inetutils.git - GNU Inetutils </title>
<meta name='generator' content='cgit v1.2.1'/>
<meta name='robots' content='index, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit/cgit.css'/>
<link rel='shortcut icon' href='/gitweb/git-favicon.png'/>
<link rel='alternate' title='Atom feed' href='https://git.savannah.gnu.org/cgit/inetutils.git/atom/libtelnet/encrypt.c?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.savannah.gnu.org/inetutils.git' title='inetutils.git Git repository'/>
<link rel='vcs-git' href='https://git.savannah.gnu.org/git/inetutils.git' title='inetutils.git Git repository'/>
<link rel='vcs-git' href='ssh://git.savannah.gnu.org/srv/git/inetutils.git' title='inetutils.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/cgit/'><img src='/cgit/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/cgit/'>index</a> : <a title='inetutils.git' href='/cgit/inetutils.git/'>inetutils.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='665f1e73cdd9b38e2d2e11b8db9958a315935592'/><select name='h' onchange='this.form.submit();'>
<option value='bsd'>bsd</option>
<option value='master' selected='selected'>master</option>
<option value='master-UNNAMED-BRANCH'>master-UNNAMED-BRANCH</option>
<option value='release1_4_0'>release1_4_0</option>
<option value='ucbinetd'>ucbinetd</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>GNU Inetutils </td><td class='sub right'></td></tr></table>
<table class='tabs'><tr><td>
<a href='/cgit/inetutils.git/'>summary</a><a href='/cgit/inetutils.git/refs/?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>refs</a><a href='/cgit/inetutils.git/log/libtelnet/encrypt.c'>log</a><a class='active' href='/cgit/inetutils.git/tree/libtelnet/encrypt.c?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>tree</a><a href='/cgit/inetutils.git/commit/libtelnet/encrypt.c?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>commit</a><a href='/cgit/inetutils.git/diff/libtelnet/encrypt.c?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>diff</a></td><td class='form'><form class='right' method='get' action='/cgit/inetutils.git/log/libtelnet/encrypt.c'>
<input type='hidden' name='id' value='665f1e73cdd9b38e2d2e11b8db9958a315935592'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='path'>path: <a href='/cgit/inetutils.git/tree/?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>root</a>/<a href='/cgit/inetutils.git/tree/libtelnet?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>libtelnet</a>/<a href='/cgit/inetutils.git/tree/libtelnet/encrypt.c?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>encrypt.c</a></div><div class='content'>blob: abfa6d48e06c08add28bd092882de51bf5141bea (<a href='/cgit/inetutils.git/plain/libtelnet/encrypt.c?id=665f1e73cdd9b38e2d2e11b8db9958a315935592'>plain</a>)
<table summary='blob content' class='blob'>
<tr><td class='linenumbers'><pre><a id='n1' href='#n1'>1</a>
<a id='n2' href='#n2'>2</a>
<a id='n3' href='#n3'>3</a>
<a id='n4' href='#n4'>4</a>
<a id='n5' href='#n5'>5</a>
<a id='n6' href='#n6'>6</a>
<a id='n7' href='#n7'>7</a>
<a id='n8' href='#n8'>8</a>
<a id='n9' href='#n9'>9</a>
<a id='n10' href='#n10'>10</a>
<a id='n11' href='#n11'>11</a>
<a id='n12' href='#n12'>12</a>
<a id='n13' href='#n13'>13</a>
<a id='n14' href='#n14'>14</a>
<a id='n15' href='#n15'>15</a>
<a id='n16' href='#n16'>16</a>
<a id='n17' href='#n17'>17</a>
<a id='n18' href='#n18'>18</a>
<a id='n19' href='#n19'>19</a>
<a id='n20' href='#n20'>20</a>
<a id='n21' href='#n21'>21</a>
<a id='n22' href='#n22'>22</a>
<a id='n23' href='#n23'>23</a>
<a id='n24' href='#n24'>24</a>
<a id='n25' href='#n25'>25</a>
<a id='n26' href='#n26'>26</a>
<a id='n27' href='#n27'>27</a>
<a id='n28' href='#n28'>28</a>
<a id='n29' href='#n29'>29</a>
<a id='n30' href='#n30'>30</a>
<a id='n31' href='#n31'>31</a>
<a id='n32' href='#n32'>32</a>
<a id='n33' href='#n33'>33</a>
<a id='n34' href='#n34'>34</a>
<a id='n35' href='#n35'>35</a>
<a id='n36' href='#n36'>36</a>
<a id='n37' href='#n37'>37</a>
<a id='n38' href='#n38'>38</a>
<a id='n39' href='#n39'>39</a>
<a id='n40' href='#n40'>40</a>
<a id='n41' href='#n41'>41</a>
<a id='n42' href='#n42'>42</a>
<a id='n43' href='#n43'>43</a>
<a id='n44' href='#n44'>44</a>
<a id='n45' href='#n45'>45</a>
<a id='n46' href='#n46'>46</a>
<a id='n47' href='#n47'>47</a>
<a id='n48' href='#n48'>48</a>
<a id='n49' href='#n49'>49</a>
<a id='n50' href='#n50'>50</a>
<a id='n51' href='#n51'>51</a>
<a id='n52' href='#n52'>52</a>
<a id='n53' href='#n53'>53</a>
<a id='n54' href='#n54'>54</a>
<a id='n55' href='#n55'>55</a>
<a id='n56' href='#n56'>56</a>
<a id='n57' href='#n57'>57</a>
<a id='n58' href='#n58'>58</a>
<a id='n59' href='#n59'>59</a>
<a id='n60' href='#n60'>60</a>
<a id='n61' href='#n61'>61</a>
<a id='n62' href='#n62'>62</a>
<a id='n63' href='#n63'>63</a>
<a id='n64' href='#n64'>64</a>
<a id='n65' href='#n65'>65</a>
<a id='n66' href='#n66'>66</a>
<a id='n67' href='#n67'>67</a>
<a id='n68' href='#n68'>68</a>
<a id='n69' href='#n69'>69</a>
<a id='n70' href='#n70'>70</a>
<a id='n71' href='#n71'>71</a>
<a id='n72' href='#n72'>72</a>
<a id='n73' href='#n73'>73</a>
<a id='n74' href='#n74'>74</a>
<a id='n75' href='#n75'>75</a>
<a id='n76' href='#n76'>76</a>
<a id='n77' href='#n77'>77</a>
<a id='n78' href='#n78'>78</a>
<a id='n79' href='#n79'>79</a>
<a id='n80' href='#n80'>80</a>
<a id='n81' href='#n81'>81</a>
<a id='n82' href='#n82'>82</a>
<a id='n83' href='#n83'>83</a>
<a id='n84' href='#n84'>84</a>
<a id='n85' href='#n85'>85</a>
<a id='n86' href='#n86'>86</a>
<a id='n87' href='#n87'>87</a>
<a id='n88' href='#n88'>88</a>
<a id='n89' href='#n89'>89</a>
<a id='n90' href='#n90'>90</a>
<a id='n91' href='#n91'>91</a>
<a id='n92' href='#n92'>92</a>
<a id='n93' href='#n93'>93</a>
<a id='n94' href='#n94'>94</a>
<a id='n95' href='#n95'>95</a>
<a id='n96' href='#n96'>96</a>
<a id='n97' href='#n97'>97</a>
<a id='n98' href='#n98'>98</a>
<a id='n99' href='#n99'>99</a>
<a id='n100' href='#n100'>100</a>
<a id='n101' href='#n101'>101</a>
<a id='n102' href='#n102'>102</a>
<a id='n103' href='#n103'>103</a>
<a id='n104' href='#n104'>104</a>
<a id='n105' href='#n105'>105</a>
<a id='n106' href='#n106'>106</a>
<a id='n107' href='#n107'>107</a>
<a id='n108' href='#n108'>108</a>
<a id='n109' href='#n109'>109</a>
<a id='n110' href='#n110'>110</a>
<a id='n111' href='#n111'>111</a>
<a id='n112' href='#n112'>112</a>
<a id='n113' href='#n113'>113</a>
<a id='n114' href='#n114'>114</a>
<a id='n115' href='#n115'>115</a>
<a id='n116' href='#n116'>116</a>
<a id='n117' href='#n117'>117</a>
<a id='n118' href='#n118'>118</a>
<a id='n119' href='#n119'>119</a>
<a id='n120' href='#n120'>120</a>
<a id='n121' href='#n121'>121</a>
<a id='n122' href='#n122'>122</a>
<a id='n123' href='#n123'>123</a>
<a id='n124' href='#n124'>124</a>
<a id='n125' href='#n125'>125</a>
<a id='n126' href='#n126'>126</a>
<a id='n127' href='#n127'>127</a>
<a id='n128' href='#n128'>128</a>
<a id='n129' href='#n129'>129</a>
<a id='n130' href='#n130'>130</a>
<a id='n131' href='#n131'>131</a>
<a id='n132' href='#n132'>132</a>
<a id='n133' href='#n133'>133</a>
<a id='n134' href='#n134'>134</a>
<a id='n135' href='#n135'>135</a>
<a id='n136' href='#n136'>136</a>
<a id='n137' href='#n137'>137</a>
<a id='n138' href='#n138'>138</a>
<a id='n139' href='#n139'>139</a>
<a id='n140' href='#n140'>140</a>
<a id='n141' href='#n141'>141</a>
<a id='n142' href='#n142'>142</a>
<a id='n143' href='#n143'>143</a>
<a id='n144' href='#n144'>144</a>
<a id='n145' href='#n145'>145</a>
<a id='n146' href='#n146'>146</a>
<a id='n147' href='#n147'>147</a>
<a id='n148' href='#n148'>148</a>
<a id='n149' href='#n149'>149</a>
<a id='n150' href='#n150'>150</a>
<a id='n151' href='#n151'>151</a>
<a id='n152' href='#n152'>152</a>
<a id='n153' href='#n153'>153</a>
<a id='n154' href='#n154'>154</a>
<a id='n155' href='#n155'>155</a>
<a id='n156' href='#n156'>156</a>
<a id='n157' href='#n157'>157</a>
<a id='n158' href='#n158'>158</a>
<a id='n159' href='#n159'>159</a>
<a id='n160' href='#n160'>160</a>
<a id='n161' href='#n161'>161</a>
<a id='n162' href='#n162'>162</a>
<a id='n163' href='#n163'>163</a>
<a id='n164' href='#n164'>164</a>
<a id='n165' href='#n165'>165</a>
<a id='n166' href='#n166'>166</a>
<a id='n167' href='#n167'>167</a>
<a id='n168' href='#n168'>168</a>
<a id='n169' href='#n169'>169</a>
<a id='n170' href='#n170'>170</a>
<a id='n171' href='#n171'>171</a>
<a id='n172' href='#n172'>172</a>
<a id='n173' href='#n173'>173</a>
<a id='n174' href='#n174'>174</a>
<a id='n175' href='#n175'>175</a>
<a id='n176' href='#n176'>176</a>
<a id='n177' href='#n177'>177</a>
<a id='n178' href='#n178'>178</a>
<a id='n179' href='#n179'>179</a>
<a id='n180' href='#n180'>180</a>
<a id='n181' href='#n181'>181</a>
<a id='n182' href='#n182'>182</a>
<a id='n183' href='#n183'>183</a>
<a id='n184' href='#n184'>184</a>
<a id='n185' href='#n185'>185</a>
<a id='n186' href='#n186'>186</a>
<a id='n187' href='#n187'>187</a>
<a id='n188' href='#n188'>188</a>
<a id='n189' href='#n189'>189</a>
<a id='n190' href='#n190'>190</a>
<a id='n191' href='#n191'>191</a>
<a id='n192' href='#n192'>192</a>
<a id='n193' href='#n193'>193</a>
<a id='n194' href='#n194'>194</a>
<a id='n195' href='#n195'>195</a>
<a id='n196' href='#n196'>196</a>
<a id='n197' href='#n197'>197</a>
<a id='n198' href='#n198'>198</a>
<a id='n199' href='#n199'>199</a>
<a id='n200' href='#n200'>200</a>
<a id='n201' href='#n201'>201</a>
<a id='n202' href='#n202'>202</a>
<a id='n203' href='#n203'>203</a>
<a id='n204' href='#n204'>204</a>
<a id='n205' href='#n205'>205</a>
<a id='n206' href='#n206'>206</a>
<a id='n207' href='#n207'>207</a>
<a id='n208' href='#n208'>208</a>
<a id='n209' href='#n209'>209</a>
<a id='n210' href='#n210'>210</a>
<a id='n211' href='#n211'>211</a>
<a id='n212' href='#n212'>212</a>
<a id='n213' href='#n213'>213</a>
<a id='n214' href='#n214'>214</a>
<a id='n215' href='#n215'>215</a>
<a id='n216' href='#n216'>216</a>
<a id='n217' href='#n217'>217</a>
<a id='n218' href='#n218'>218</a>
<a id='n219' href='#n219'>219</a>
<a id='n220' href='#n220'>220</a>
<a id='n221' href='#n221'>221</a>
<a id='n222' href='#n222'>222</a>
<a id='n223' href='#n223'>223</a>
<a id='n224' href='#n224'>224</a>
<a id='n225' href='#n225'>225</a>
<a id='n226' href='#n226'>226</a>
<a id='n227' href='#n227'>227</a>
<a id='n228' href='#n228'>228</a>
<a id='n229' href='#n229'>229</a>
<a id='n230' href='#n230'>230</a>
<a id='n231' href='#n231'>231</a>
<a id='n232' href='#n232'>232</a>
<a id='n233' href='#n233'>233</a>
<a id='n234' href='#n234'>234</a>
<a id='n235' href='#n235'>235</a>
<a id='n236' href='#n236'>236</a>
<a id='n237' href='#n237'>237</a>
<a id='n238' href='#n238'>238</a>
<a id='n239' href='#n239'>239</a>
<a id='n240' href='#n240'>240</a>
<a id='n241' href='#n241'>241</a>
<a id='n242' href='#n242'>242</a>
<a id='n243' href='#n243'>243</a>
<a id='n244' href='#n244'>244</a>
<a id='n245' href='#n245'>245</a>
<a id='n246' href='#n246'>246</a>
<a id='n247' href='#n247'>247</a>
<a id='n248' href='#n248'>248</a>
<a id='n249' href='#n249'>249</a>
<a id='n250' href='#n250'>250</a>
<a id='n251' href='#n251'>251</a>
<a id='n252' href='#n252'>252</a>
<a id='n253' href='#n253'>253</a>
<a id='n254' href='#n254'>254</a>
<a id='n255' href='#n255'>255</a>
<a id='n256' href='#n256'>256</a>
<a id='n257' href='#n257'>257</a>
<a id='n258' href='#n258'>258</a>
<a id='n259' href='#n259'>259</a>
<a id='n260' href='#n260'>260</a>
<a id='n261' href='#n261'>261</a>
<a id='n262' href='#n262'>262</a>
<a id='n263' href='#n263'>263</a>
<a id='n264' href='#n264'>264</a>
<a id='n265' href='#n265'>265</a>
<a id='n266' href='#n266'>266</a>
<a id='n267' href='#n267'>267</a>
<a id='n268' href='#n268'>268</a>
<a id='n269' href='#n269'>269</a>
<a id='n270' href='#n270'>270</a>
<a id='n271' href='#n271'>271</a>
<a id='n272' href='#n272'>272</a>
<a id='n273' href='#n273'>273</a>
<a id='n274' href='#n274'>274</a>
<a id='n275' href='#n275'>275</a>
<a id='n276' href='#n276'>276</a>
<a id='n277' href='#n277'>277</a>
<a id='n278' href='#n278'>278</a>
<a id='n279' href='#n279'>279</a>
<a id='n280' href='#n280'>280</a>
<a id='n281' href='#n281'>281</a>
<a id='n282' href='#n282'>282</a>
<a id='n283' href='#n283'>283</a>
<a id='n284' href='#n284'>284</a>
<a id='n285' href='#n285'>285</a>
<a id='n286' href='#n286'>286</a>
<a id='n287' href='#n287'>287</a>
<a id='n288' href='#n288'>288</a>
<a id='n289' href='#n289'>289</a>
<a id='n290' href='#n290'>290</a>
<a id='n291' href='#n291'>291</a>
<a id='n292' href='#n292'>292</a>
<a id='n293' href='#n293'>293</a>
<a id='n294' href='#n294'>294</a>
<a id='n295' href='#n295'>295</a>
<a id='n296' href='#n296'>296</a>
<a id='n297' href='#n297'>297</a>
<a id='n298' href='#n298'>298</a>
<a id='n299' href='#n299'>299</a>
<a id='n300' href='#n300'>300</a>
<a id='n301' href='#n301'>301</a>
<a id='n302' href='#n302'>302</a>
<a id='n303' href='#n303'>303</a>
<a id='n304' href='#n304'>304</a>
<a id='n305' href='#n305'>305</a>
<a id='n306' href='#n306'>306</a>
<a id='n307' href='#n307'>307</a>
<a id='n308' href='#n308'>308</a>
<a id='n309' href='#n309'>309</a>
<a id='n310' href='#n310'>310</a>
<a id='n311' href='#n311'>311</a>
<a id='n312' href='#n312'>312</a>
<a id='n313' href='#n313'>313</a>
<a id='n314' href='#n314'>314</a>
<a id='n315' href='#n315'>315</a>
<a id='n316' href='#n316'>316</a>
<a id='n317' href='#n317'>317</a>
<a id='n318' href='#n318'>318</a>
<a id='n319' href='#n319'>319</a>
<a id='n320' href='#n320'>320</a>
<a id='n321' href='#n321'>321</a>
<a id='n322' href='#n322'>322</a>
<a id='n323' href='#n323'>323</a>
<a id='n324' href='#n324'>324</a>
<a id='n325' href='#n325'>325</a>
<a id='n326' href='#n326'>326</a>
<a id='n327' href='#n327'>327</a>
<a id='n328' href='#n328'>328</a>
<a id='n329' href='#n329'>329</a>
<a id='n330' href='#n330'>330</a>
<a id='n331' href='#n331'>331</a>
<a id='n332' href='#n332'>332</a>
<a id='n333' href='#n333'>333</a>
<a id='n334' href='#n334'>334</a>
<a id='n335' href='#n335'>335</a>
<a id='n336' href='#n336'>336</a>
<a id='n337' href='#n337'>337</a>
<a id='n338' href='#n338'>338</a>
<a id='n339' href='#n339'>339</a>
<a id='n340' href='#n340'>340</a>
<a id='n341' href='#n341'>341</a>
<a id='n342' href='#n342'>342</a>
<a id='n343' href='#n343'>343</a>
<a id='n344' href='#n344'>344</a>
<a id='n345' href='#n345'>345</a>
<a id='n346' href='#n346'>346</a>
<a id='n347' href='#n347'>347</a>
<a id='n348' href='#n348'>348</a>
<a id='n349' href='#n349'>349</a>
<a id='n350' href='#n350'>350</a>
<a id='n351' href='#n351'>351</a>
<a id='n352' href='#n352'>352</a>
<a id='n353' href='#n353'>353</a>
<a id='n354' href='#n354'>354</a>
<a id='n355' href='#n355'>355</a>
<a id='n356' href='#n356'>356</a>
<a id='n357' href='#n357'>357</a>
<a id='n358' href='#n358'>358</a>
<a id='n359' href='#n359'>359</a>
<a id='n360' href='#n360'>360</a>
<a id='n361' href='#n361'>361</a>
<a id='n362' href='#n362'>362</a>
<a id='n363' href='#n363'>363</a>
<a id='n364' href='#n364'>364</a>
<a id='n365' href='#n365'>365</a>
<a id='n366' href='#n366'>366</a>
<a id='n367' href='#n367'>367</a>
<a id='n368' href='#n368'>368</a>
<a id='n369' href='#n369'>369</a>
<a id='n370' href='#n370'>370</a>
<a id='n371' href='#n371'>371</a>
<a id='n372' href='#n372'>372</a>
<a id='n373' href='#n373'>373</a>
<a id='n374' href='#n374'>374</a>
<a id='n375' href='#n375'>375</a>
<a id='n376' href='#n376'>376</a>
<a id='n377' href='#n377'>377</a>
<a id='n378' href='#n378'>378</a>
<a id='n379' href='#n379'>379</a>
<a id='n380' href='#n380'>380</a>
<a id='n381' href='#n381'>381</a>
<a id='n382' href='#n382'>382</a>
<a id='n383' href='#n383'>383</a>
<a id='n384' href='#n384'>384</a>
<a id='n385' href='#n385'>385</a>
<a id='n386' href='#n386'>386</a>
<a id='n387' href='#n387'>387</a>
<a id='n388' href='#n388'>388</a>
<a id='n389' href='#n389'>389</a>
<a id='n390' href='#n390'>390</a>
<a id='n391' href='#n391'>391</a>
<a id='n392' href='#n392'>392</a>
<a id='n393' href='#n393'>393</a>
<a id='n394' href='#n394'>394</a>
<a id='n395' href='#n395'>395</a>
<a id='n396' href='#n396'>396</a>
<a id='n397' href='#n397'>397</a>
<a id='n398' href='#n398'>398</a>
<a id='n399' href='#n399'>399</a>
<a id='n400' href='#n400'>400</a>
<a id='n401' href='#n401'>401</a>
<a id='n402' href='#n402'>402</a>
<a id='n403' href='#n403'>403</a>
<a id='n404' href='#n404'>404</a>
<a id='n405' href='#n405'>405</a>
<a id='n406' href='#n406'>406</a>
<a id='n407' href='#n407'>407</a>
<a id='n408' href='#n408'>408</a>
<a id='n409' href='#n409'>409</a>
<a id='n410' href='#n410'>410</a>
<a id='n411' href='#n411'>411</a>
<a id='n412' href='#n412'>412</a>
<a id='n413' href='#n413'>413</a>
<a id='n414' href='#n414'>414</a>
<a id='n415' href='#n415'>415</a>
<a id='n416' href='#n416'>416</a>
<a id='n417' href='#n417'>417</a>
<a id='n418' href='#n418'>418</a>
<a id='n419' href='#n419'>419</a>
<a id='n420' href='#n420'>420</a>
<a id='n421' href='#n421'>421</a>
<a id='n422' href='#n422'>422</a>
<a id='n423' href='#n423'>423</a>
<a id='n424' href='#n424'>424</a>
<a id='n425' href='#n425'>425</a>
<a id='n426' href='#n426'>426</a>
<a id='n427' href='#n427'>427</a>
<a id='n428' href='#n428'>428</a>
<a id='n429' href='#n429'>429</a>
<a id='n430' href='#n430'>430</a>
<a id='n431' href='#n431'>431</a>
<a id='n432' href='#n432'>432</a>
<a id='n433' href='#n433'>433</a>
<a id='n434' href='#n434'>434</a>
<a id='n435' href='#n435'>435</a>
<a id='n436' href='#n436'>436</a>
<a id='n437' href='#n437'>437</a>
<a id='n438' href='#n438'>438</a>
<a id='n439' href='#n439'>439</a>
<a id='n440' href='#n440'>440</a>
<a id='n441' href='#n441'>441</a>
<a id='n442' href='#n442'>442</a>
<a id='n443' href='#n443'>443</a>
<a id='n444' href='#n444'>444</a>
<a id='n445' href='#n445'>445</a>
<a id='n446' href='#n446'>446</a>
<a id='n447' href='#n447'>447</a>
<a id='n448' href='#n448'>448</a>
<a id='n449' href='#n449'>449</a>
<a id='n450' href='#n450'>450</a>
<a id='n451' href='#n451'>451</a>
<a id='n452' href='#n452'>452</a>
<a id='n453' href='#n453'>453</a>
<a id='n454' href='#n454'>454</a>
<a id='n455' href='#n455'>455</a>
<a id='n456' href='#n456'>456</a>
<a id='n457' href='#n457'>457</a>
<a id='n458' href='#n458'>458</a>
<a id='n459' href='#n459'>459</a>
<a id='n460' href='#n460'>460</a>
<a id='n461' href='#n461'>461</a>
<a id='n462' href='#n462'>462</a>
<a id='n463' href='#n463'>463</a>
<a id='n464' href='#n464'>464</a>
<a id='n465' href='#n465'>465</a>
<a id='n466' href='#n466'>466</a>
<a id='n467' href='#n467'>467</a>
<a id='n468' href='#n468'>468</a>
<a id='n469' href='#n469'>469</a>
<a id='n470' href='#n470'>470</a>
<a id='n471' href='#n471'>471</a>
<a id='n472' href='#n472'>472</a>
<a id='n473' href='#n473'>473</a>
<a id='n474' href='#n474'>474</a>
<a id='n475' href='#n475'>475</a>
<a id='n476' href='#n476'>476</a>
<a id='n477' href='#n477'>477</a>
<a id='n478' href='#n478'>478</a>
<a id='n479' href='#n479'>479</a>
<a id='n480' href='#n480'>480</a>
<a id='n481' href='#n481'>481</a>
<a id='n482' href='#n482'>482</a>
<a id='n483' href='#n483'>483</a>
<a id='n484' href='#n484'>484</a>
<a id='n485' href='#n485'>485</a>
<a id='n486' href='#n486'>486</a>
<a id='n487' href='#n487'>487</a>
<a id='n488' href='#n488'>488</a>
<a id='n489' href='#n489'>489</a>
<a id='n490' href='#n490'>490</a>
<a id='n491' href='#n491'>491</a>
<a id='n492' href='#n492'>492</a>
<a id='n493' href='#n493'>493</a>
<a id='n494' href='#n494'>494</a>
<a id='n495' href='#n495'>495</a>
<a id='n496' href='#n496'>496</a>
<a id='n497' href='#n497'>497</a>
<a id='n498' href='#n498'>498</a>
<a id='n499' href='#n499'>499</a>
<a id='n500' href='#n500'>500</a>
<a id='n501' href='#n501'>501</a>
<a id='n502' href='#n502'>502</a>
<a id='n503' href='#n503'>503</a>
<a id='n504' href='#n504'>504</a>
<a id='n505' href='#n505'>505</a>
<a id='n506' href='#n506'>506</a>
<a id='n507' href='#n507'>507</a>
<a id='n508' href='#n508'>508</a>
<a id='n509' href='#n509'>509</a>
<a id='n510' href='#n510'>510</a>
<a id='n511' href='#n511'>511</a>
<a id='n512' href='#n512'>512</a>
<a id='n513' href='#n513'>513</a>
<a id='n514' href='#n514'>514</a>
<a id='n515' href='#n515'>515</a>
<a id='n516' href='#n516'>516</a>
<a id='n517' href='#n517'>517</a>
<a id='n518' href='#n518'>518</a>
<a id='n519' href='#n519'>519</a>
<a id='n520' href='#n520'>520</a>
<a id='n521' href='#n521'>521</a>
<a id='n522' href='#n522'>522</a>
<a id='n523' href='#n523'>523</a>
<a id='n524' href='#n524'>524</a>
<a id='n525' href='#n525'>525</a>
<a id='n526' href='#n526'>526</a>
<a id='n527' href='#n527'>527</a>
<a id='n528' href='#n528'>528</a>
<a id='n529' href='#n529'>529</a>
<a id='n530' href='#n530'>530</a>
<a id='n531' href='#n531'>531</a>
<a id='n532' href='#n532'>532</a>
<a id='n533' href='#n533'>533</a>
<a id='n534' href='#n534'>534</a>
<a id='n535' href='#n535'>535</a>
<a id='n536' href='#n536'>536</a>
<a id='n537' href='#n537'>537</a>
<a id='n538' href='#n538'>538</a>
<a id='n539' href='#n539'>539</a>
<a id='n540' href='#n540'>540</a>
<a id='n541' href='#n541'>541</a>
<a id='n542' href='#n542'>542</a>
<a id='n543' href='#n543'>543</a>
<a id='n544' href='#n544'>544</a>
<a id='n545' href='#n545'>545</a>
<a id='n546' href='#n546'>546</a>
<a id='n547' href='#n547'>547</a>
<a id='n548' href='#n548'>548</a>
<a id='n549' href='#n549'>549</a>
<a id='n550' href='#n550'>550</a>
<a id='n551' href='#n551'>551</a>
<a id='n552' href='#n552'>552</a>
<a id='n553' href='#n553'>553</a>
<a id='n554' href='#n554'>554</a>
<a id='n555' href='#n555'>555</a>
<a id='n556' href='#n556'>556</a>
<a id='n557' href='#n557'>557</a>
<a id='n558' href='#n558'>558</a>
<a id='n559' href='#n559'>559</a>
<a id='n560' href='#n560'>560</a>
<a id='n561' href='#n561'>561</a>
<a id='n562' href='#n562'>562</a>
<a id='n563' href='#n563'>563</a>
<a id='n564' href='#n564'>564</a>
<a id='n565' href='#n565'>565</a>
<a id='n566' href='#n566'>566</a>
<a id='n567' href='#n567'>567</a>
<a id='n568' href='#n568'>568</a>
<a id='n569' href='#n569'>569</a>
<a id='n570' href='#n570'>570</a>
<a id='n571' href='#n571'>571</a>
<a id='n572' href='#n572'>572</a>
<a id='n573' href='#n573'>573</a>
<a id='n574' href='#n574'>574</a>
<a id='n575' href='#n575'>575</a>
<a id='n576' href='#n576'>576</a>
<a id='n577' href='#n577'>577</a>
<a id='n578' href='#n578'>578</a>
<a id='n579' href='#n579'>579</a>
<a id='n580' href='#n580'>580</a>
<a id='n581' href='#n581'>581</a>
<a id='n582' href='#n582'>582</a>
<a id='n583' href='#n583'>583</a>
<a id='n584' href='#n584'>584</a>
<a id='n585' href='#n585'>585</a>
<a id='n586' href='#n586'>586</a>
<a id='n587' href='#n587'>587</a>
<a id='n588' href='#n588'>588</a>
<a id='n589' href='#n589'>589</a>
<a id='n590' href='#n590'>590</a>
<a id='n591' href='#n591'>591</a>
<a id='n592' href='#n592'>592</a>
<a id='n593' href='#n593'>593</a>
<a id='n594' href='#n594'>594</a>
<a id='n595' href='#n595'>595</a>
<a id='n596' href='#n596'>596</a>
<a id='n597' href='#n597'>597</a>
<a id='n598' href='#n598'>598</a>
<a id='n599' href='#n599'>599</a>
<a id='n600' href='#n600'>600</a>
<a id='n601' href='#n601'>601</a>
<a id='n602' href='#n602'>602</a>
<a id='n603' href='#n603'>603</a>
<a id='n604' href='#n604'>604</a>
<a id='n605' href='#n605'>605</a>
<a id='n606' href='#n606'>606</a>
<a id='n607' href='#n607'>607</a>
<a id='n608' href='#n608'>608</a>
<a id='n609' href='#n609'>609</a>
<a id='n610' href='#n610'>610</a>
<a id='n611' href='#n611'>611</a>
<a id='n612' href='#n612'>612</a>
<a id='n613' href='#n613'>613</a>
<a id='n614' href='#n614'>614</a>
<a id='n615' href='#n615'>615</a>
<a id='n616' href='#n616'>616</a>
<a id='n617' href='#n617'>617</a>
<a id='n618' href='#n618'>618</a>
<a id='n619' href='#n619'>619</a>
<a id='n620' href='#n620'>620</a>
<a id='n621' href='#n621'>621</a>
<a id='n622' href='#n622'>622</a>
<a id='n623' href='#n623'>623</a>
<a id='n624' href='#n624'>624</a>
<a id='n625' href='#n625'>625</a>
<a id='n626' href='#n626'>626</a>
<a id='n627' href='#n627'>627</a>
<a id='n628' href='#n628'>628</a>
<a id='n629' href='#n629'>629</a>
<a id='n630' href='#n630'>630</a>
<a id='n631' href='#n631'>631</a>
<a id='n632' href='#n632'>632</a>
<a id='n633' href='#n633'>633</a>
<a id='n634' href='#n634'>634</a>
<a id='n635' href='#n635'>635</a>
<a id='n636' href='#n636'>636</a>
<a id='n637' href='#n637'>637</a>
<a id='n638' href='#n638'>638</a>
<a id='n639' href='#n639'>639</a>
<a id='n640' href='#n640'>640</a>
<a id='n641' href='#n641'>641</a>
<a id='n642' href='#n642'>642</a>
<a id='n643' href='#n643'>643</a>
<a id='n644' href='#n644'>644</a>
<a id='n645' href='#n645'>645</a>
<a id='n646' href='#n646'>646</a>
<a id='n647' href='#n647'>647</a>
<a id='n648' href='#n648'>648</a>
<a id='n649' href='#n649'>649</a>
<a id='n650' href='#n650'>650</a>
<a id='n651' href='#n651'>651</a>
<a id='n652' href='#n652'>652</a>
<a id='n653' href='#n653'>653</a>
<a id='n654' href='#n654'>654</a>
<a id='n655' href='#n655'>655</a>
<a id='n656' href='#n656'>656</a>
<a id='n657' href='#n657'>657</a>
<a id='n658' href='#n658'>658</a>
<a id='n659' href='#n659'>659</a>
<a id='n660' href='#n660'>660</a>
<a id='n661' href='#n661'>661</a>
<a id='n662' href='#n662'>662</a>
<a id='n663' href='#n663'>663</a>
<a id='n664' href='#n664'>664</a>
<a id='n665' href='#n665'>665</a>
<a id='n666' href='#n666'>666</a>
<a id='n667' href='#n667'>667</a>
<a id='n668' href='#n668'>668</a>
<a id='n669' href='#n669'>669</a>
<a id='n670' href='#n670'>670</a>
<a id='n671' href='#n671'>671</a>
<a id='n672' href='#n672'>672</a>
<a id='n673' href='#n673'>673</a>
<a id='n674' href='#n674'>674</a>
<a id='n675' href='#n675'>675</a>
<a id='n676' href='#n676'>676</a>
<a id='n677' href='#n677'>677</a>
<a id='n678' href='#n678'>678</a>
<a id='n679' href='#n679'>679</a>
<a id='n680' href='#n680'>680</a>
<a id='n681' href='#n681'>681</a>
<a id='n682' href='#n682'>682</a>
<a id='n683' href='#n683'>683</a>
<a id='n684' href='#n684'>684</a>
<a id='n685' href='#n685'>685</a>
<a id='n686' href='#n686'>686</a>
<a id='n687' href='#n687'>687</a>
<a id='n688' href='#n688'>688</a>
<a id='n689' href='#n689'>689</a>
<a id='n690' href='#n690'>690</a>
<a id='n691' href='#n691'>691</a>
<a id='n692' href='#n692'>692</a>
<a id='n693' href='#n693'>693</a>
<a id='n694' href='#n694'>694</a>
<a id='n695' href='#n695'>695</a>
<a id='n696' href='#n696'>696</a>
<a id='n697' href='#n697'>697</a>
<a id='n698' href='#n698'>698</a>
<a id='n699' href='#n699'>699</a>
<a id='n700' href='#n700'>700</a>
<a id='n701' href='#n701'>701</a>
<a id='n702' href='#n702'>702</a>
<a id='n703' href='#n703'>703</a>
<a id='n704' href='#n704'>704</a>
<a id='n705' href='#n705'>705</a>
<a id='n706' href='#n706'>706</a>
<a id='n707' href='#n707'>707</a>
<a id='n708' href='#n708'>708</a>
<a id='n709' href='#n709'>709</a>
<a id='n710' href='#n710'>710</a>
<a id='n711' href='#n711'>711</a>
<a id='n712' href='#n712'>712</a>
<a id='n713' href='#n713'>713</a>
<a id='n714' href='#n714'>714</a>
<a id='n715' href='#n715'>715</a>
<a id='n716' href='#n716'>716</a>
<a id='n717' href='#n717'>717</a>
<a id='n718' href='#n718'>718</a>
<a id='n719' href='#n719'>719</a>
<a id='n720' href='#n720'>720</a>
<a id='n721' href='#n721'>721</a>
<a id='n722' href='#n722'>722</a>
<a id='n723' href='#n723'>723</a>
<a id='n724' href='#n724'>724</a>
<a id='n725' href='#n725'>725</a>
<a id='n726' href='#n726'>726</a>
<a id='n727' href='#n727'>727</a>
<a id='n728' href='#n728'>728</a>
<a id='n729' href='#n729'>729</a>
<a id='n730' href='#n730'>730</a>
<a id='n731' href='#n731'>731</a>
<a id='n732' href='#n732'>732</a>
<a id='n733' href='#n733'>733</a>
<a id='n734' href='#n734'>734</a>
<a id='n735' href='#n735'>735</a>
<a id='n736' href='#n736'>736</a>
<a id='n737' href='#n737'>737</a>
<a id='n738' href='#n738'>738</a>
<a id='n739' href='#n739'>739</a>
<a id='n740' href='#n740'>740</a>
<a id='n741' href='#n741'>741</a>
<a id='n742' href='#n742'>742</a>
<a id='n743' href='#n743'>743</a>
<a id='n744' href='#n744'>744</a>
<a id='n745' href='#n745'>745</a>
<a id='n746' href='#n746'>746</a>
<a id='n747' href='#n747'>747</a>
<a id='n748' href='#n748'>748</a>
<a id='n749' href='#n749'>749</a>
<a id='n750' href='#n750'>750</a>
<a id='n751' href='#n751'>751</a>
<a id='n752' href='#n752'>752</a>
<a id='n753' href='#n753'>753</a>
<a id='n754' href='#n754'>754</a>
<a id='n755' href='#n755'>755</a>
<a id='n756' href='#n756'>756</a>
<a id='n757' href='#n757'>757</a>
<a id='n758' href='#n758'>758</a>
<a id='n759' href='#n759'>759</a>
<a id='n760' href='#n760'>760</a>
<a id='n761' href='#n761'>761</a>
<a id='n762' href='#n762'>762</a>
<a id='n763' href='#n763'>763</a>
<a id='n764' href='#n764'>764</a>
<a id='n765' href='#n765'>765</a>
<a id='n766' href='#n766'>766</a>
<a id='n767' href='#n767'>767</a>
<a id='n768' href='#n768'>768</a>
<a id='n769' href='#n769'>769</a>
<a id='n770' href='#n770'>770</a>
<a id='n771' href='#n771'>771</a>
<a id='n772' href='#n772'>772</a>
<a id='n773' href='#n773'>773</a>
<a id='n774' href='#n774'>774</a>
<a id='n775' href='#n775'>775</a>
<a id='n776' href='#n776'>776</a>
<a id='n777' href='#n777'>777</a>
<a id='n778' href='#n778'>778</a>
<a id='n779' href='#n779'>779</a>
<a id='n780' href='#n780'>780</a>
<a id='n781' href='#n781'>781</a>
<a id='n782' href='#n782'>782</a>
<a id='n783' href='#n783'>783</a>
<a id='n784' href='#n784'>784</a>
<a id='n785' href='#n785'>785</a>
<a id='n786' href='#n786'>786</a>
<a id='n787' href='#n787'>787</a>
<a id='n788' href='#n788'>788</a>
<a id='n789' href='#n789'>789</a>
<a id='n790' href='#n790'>790</a>
<a id='n791' href='#n791'>791</a>
<a id='n792' href='#n792'>792</a>
<a id='n793' href='#n793'>793</a>
<a id='n794' href='#n794'>794</a>
<a id='n795' href='#n795'>795</a>
<a id='n796' href='#n796'>796</a>
<a id='n797' href='#n797'>797</a>
<a id='n798' href='#n798'>798</a>
<a id='n799' href='#n799'>799</a>
<a id='n800' href='#n800'>800</a>
<a id='n801' href='#n801'>801</a>
<a id='n802' href='#n802'>802</a>
<a id='n803' href='#n803'>803</a>
<a id='n804' href='#n804'>804</a>
<a id='n805' href='#n805'>805</a>
<a id='n806' href='#n806'>806</a>
<a id='n807' href='#n807'>807</a>
<a id='n808' href='#n808'>808</a>
<a id='n809' href='#n809'>809</a>
<a id='n810' href='#n810'>810</a>
<a id='n811' href='#n811'>811</a>
<a id='n812' href='#n812'>812</a>
<a id='n813' href='#n813'>813</a>
<a id='n814' href='#n814'>814</a>
<a id='n815' href='#n815'>815</a>
<a id='n816' href='#n816'>816</a>
<a id='n817' href='#n817'>817</a>
<a id='n818' href='#n818'>818</a>
<a id='n819' href='#n819'>819</a>
<a id='n820' href='#n820'>820</a>
<a id='n821' href='#n821'>821</a>
<a id='n822' href='#n822'>822</a>
<a id='n823' href='#n823'>823</a>
<a id='n824' href='#n824'>824</a>
<a id='n825' href='#n825'>825</a>
<a id='n826' href='#n826'>826</a>
<a id='n827' href='#n827'>827</a>
<a id='n828' href='#n828'>828</a>
<a id='n829' href='#n829'>829</a>
<a id='n830' href='#n830'>830</a>
<a id='n831' href='#n831'>831</a>
<a id='n832' href='#n832'>832</a>
<a id='n833' href='#n833'>833</a>
<a id='n834' href='#n834'>834</a>
<a id='n835' href='#n835'>835</a>
<a id='n836' href='#n836'>836</a>
<a id='n837' href='#n837'>837</a>
<a id='n838' href='#n838'>838</a>
<a id='n839' href='#n839'>839</a>
<a id='n840' href='#n840'>840</a>
<a id='n841' href='#n841'>841</a>
<a id='n842' href='#n842'>842</a>
<a id='n843' href='#n843'>843</a>
<a id='n844' href='#n844'>844</a>
<a id='n845' href='#n845'>845</a>
<a id='n846' href='#n846'>846</a>
<a id='n847' href='#n847'>847</a>
<a id='n848' href='#n848'>848</a>
<a id='n849' href='#n849'>849</a>
<a id='n850' href='#n850'>850</a>
<a id='n851' href='#n851'>851</a>
<a id='n852' href='#n852'>852</a>
<a id='n853' href='#n853'>853</a>
<a id='n854' href='#n854'>854</a>
<a id='n855' href='#n855'>855</a>
<a id='n856' href='#n856'>856</a>
<a id='n857' href='#n857'>857</a>
<a id='n858' href='#n858'>858</a>
<a id='n859' href='#n859'>859</a>
<a id='n860' href='#n860'>860</a>
<a id='n861' href='#n861'>861</a>
<a id='n862' href='#n862'>862</a>
<a id='n863' href='#n863'>863</a>
<a id='n864' href='#n864'>864</a>
<a id='n865' href='#n865'>865</a>
<a id='n866' href='#n866'>866</a>
<a id='n867' href='#n867'>867</a>
<a id='n868' href='#n868'>868</a>
<a id='n869' href='#n869'>869</a>
<a id='n870' href='#n870'>870</a>
<a id='n871' href='#n871'>871</a>
<a id='n872' href='#n872'>872</a>
<a id='n873' href='#n873'>873</a>
<a id='n874' href='#n874'>874</a>
<a id='n875' href='#n875'>875</a>
<a id='n876' href='#n876'>876</a>
<a id='n877' href='#n877'>877</a>
<a id='n878' href='#n878'>878</a>
<a id='n879' href='#n879'>879</a>
<a id='n880' href='#n880'>880</a>
<a id='n881' href='#n881'>881</a>
<a id='n882' href='#n882'>882</a>
<a id='n883' href='#n883'>883</a>
<a id='n884' href='#n884'>884</a>
<a id='n885' href='#n885'>885</a>
<a id='n886' href='#n886'>886</a>
<a id='n887' href='#n887'>887</a>
<a id='n888' href='#n888'>888</a>
<a id='n889' href='#n889'>889</a>
<a id='n890' href='#n890'>890</a>
<a id='n891' href='#n891'>891</a>
<a id='n892' href='#n892'>892</a>
<a id='n893' href='#n893'>893</a>
<a id='n894' href='#n894'>894</a>
<a id='n895' href='#n895'>895</a>
<a id='n896' href='#n896'>896</a>
<a id='n897' href='#n897'>897</a>
<a id='n898' href='#n898'>898</a>
<a id='n899' href='#n899'>899</a>
<a id='n900' href='#n900'>900</a>
<a id='n901' href='#n901'>901</a>
<a id='n902' href='#n902'>902</a>
<a id='n903' href='#n903'>903</a>
<a id='n904' href='#n904'>904</a>
<a id='n905' href='#n905'>905</a>
<a id='n906' href='#n906'>906</a>
<a id='n907' href='#n907'>907</a>
<a id='n908' href='#n908'>908</a>
<a id='n909' href='#n909'>909</a>
<a id='n910' href='#n910'>910</a>
<a id='n911' href='#n911'>911</a>
<a id='n912' href='#n912'>912</a>
<a id='n913' href='#n913'>913</a>
<a id='n914' href='#n914'>914</a>
<a id='n915' href='#n915'>915</a>
<a id='n916' href='#n916'>916</a>
<a id='n917' href='#n917'>917</a>
<a id='n918' href='#n918'>918</a>
<a id='n919' href='#n919'>919</a>
<a id='n920' href='#n920'>920</a>
<a id='n921' href='#n921'>921</a>
<a id='n922' href='#n922'>922</a>
<a id='n923' href='#n923'>923</a>
<a id='n924' href='#n924'>924</a>
<a id='n925' href='#n925'>925</a>
<a id='n926' href='#n926'>926</a>
<a id='n927' href='#n927'>927</a>
<a id='n928' href='#n928'>928</a>
<a id='n929' href='#n929'>929</a>
<a id='n930' href='#n930'>930</a>
<a id='n931' href='#n931'>931</a>
<a id='n932' href='#n932'>932</a>
<a id='n933' href='#n933'>933</a>
<a id='n934' href='#n934'>934</a>
<a id='n935' href='#n935'>935</a>
<a id='n936' href='#n936'>936</a>
<a id='n937' href='#n937'>937</a>
<a id='n938' href='#n938'>938</a>
<a id='n939' href='#n939'>939</a>
<a id='n940' href='#n940'>940</a>
<a id='n941' href='#n941'>941</a>
<a id='n942' href='#n942'>942</a>
<a id='n943' href='#n943'>943</a>
<a id='n944' href='#n944'>944</a>
<a id='n945' href='#n945'>945</a>
<a id='n946' href='#n946'>946</a>
<a id='n947' href='#n947'>947</a>
<a id='n948' href='#n948'>948</a>
<a id='n949' href='#n949'>949</a>
<a id='n950' href='#n950'>950</a>
<a id='n951' href='#n951'>951</a>
<a id='n952' href='#n952'>952</a>
<a id='n953' href='#n953'>953</a>
<a id='n954' href='#n954'>954</a>
<a id='n955' href='#n955'>955</a>
<a id='n956' href='#n956'>956</a>
<a id='n957' href='#n957'>957</a>
<a id='n958' href='#n958'>958</a>
<a id='n959' href='#n959'>959</a>
<a id='n960' href='#n960'>960</a>
<a id='n961' href='#n961'>961</a>
<a id='n962' href='#n962'>962</a>
<a id='n963' href='#n963'>963</a>
<a id='n964' href='#n964'>964</a>
<a id='n965' href='#n965'>965</a>
<a id='n966' href='#n966'>966</a>
<a id='n967' href='#n967'>967</a>
<a id='n968' href='#n968'>968</a>
<a id='n969' href='#n969'>969</a>
<a id='n970' href='#n970'>970</a>
<a id='n971' href='#n971'>971</a>
<a id='n972' href='#n972'>972</a>
<a id='n973' href='#n973'>973</a>
<a id='n974' href='#n974'>974</a>
<a id='n975' href='#n975'>975</a>
<a id='n976' href='#n976'>976</a>
<a id='n977' href='#n977'>977</a>
<a id='n978' href='#n978'>978</a>
<a id='n979' href='#n979'>979</a>
<a id='n980' href='#n980'>980</a>
<a id='n981' href='#n981'>981</a>
<a id='n982' href='#n982'>982</a>
<a id='n983' href='#n983'>983</a>
<a id='n984' href='#n984'>984</a>
<a id='n985' href='#n985'>985</a>
<a id='n986' href='#n986'>986</a>
<a id='n987' href='#n987'>987</a>
<a id='n988' href='#n988'>988</a>
<a id='n989' href='#n989'>989</a>
<a id='n990' href='#n990'>990</a>
<a id='n991' href='#n991'>991</a>
<a id='n992' href='#n992'>992</a>
<a id='n993' href='#n993'>993</a>
<a id='n994' href='#n994'>994</a>
<a id='n995' href='#n995'>995</a>
<a id='n996' href='#n996'>996</a>
<a id='n997' href='#n997'>997</a>
<a id='n998' href='#n998'>998</a>
<a id='n999' href='#n999'>999</a>
<a id='n1000' href='#n1000'>1000</a>
<a id='n1001' href='#n1001'>1001</a>
<a id='n1002' href='#n1002'>1002</a>
<a id='n1003' href='#n1003'>1003</a>
<a id='n1004' href='#n1004'>1004</a>
<a id='n1005' href='#n1005'>1005</a>
<a id='n1006' href='#n1006'>1006</a>
<a id='n1007' href='#n1007'>1007</a>
<a id='n1008' href='#n1008'>1008</a>
<a id='n1009' href='#n1009'>1009</a>
<a id='n1010' href='#n1010'>1010</a>
<a id='n1011' href='#n1011'>1011</a>
<a id='n1012' href='#n1012'>1012</a>
<a id='n1013' href='#n1013'>1013</a>
<a id='n1014' href='#n1014'>1014</a>
<a id='n1015' href='#n1015'>1015</a>
<a id='n1016' href='#n1016'>1016</a>
<a id='n1017' href='#n1017'>1017</a>
<a id='n1018' href='#n1018'>1018</a>
<a id='n1019' href='#n1019'>1019</a>
<a id='n1020' href='#n1020'>1020</a>
<a id='n1021' href='#n1021'>1021</a>
<a id='n1022' href='#n1022'>1022</a>
<a id='n1023' href='#n1023'>1023</a>
<a id='n1024' href='#n1024'>1024</a>
<a id='n1025' href='#n1025'>1025</a>
<a id='n1026' href='#n1026'>1026</a>
<a id='n1027' href='#n1027'>1027</a>
<a id='n1028' href='#n1028'>1028</a>
<a id='n1029' href='#n1029'>1029</a>
<a id='n1030' href='#n1030'>1030</a>
<a id='n1031' href='#n1031'>1031</a>
<a id='n1032' href='#n1032'>1032</a>
<a id='n1033' href='#n1033'>1033</a>
<a id='n1034' href='#n1034'>1034</a>
<a id='n1035' href='#n1035'>1035</a>
<a id='n1036' href='#n1036'>1036</a>
<a id='n1037' href='#n1037'>1037</a>
<a id='n1038' href='#n1038'>1038</a>
<a id='n1039' href='#n1039'>1039</a>
<a id='n1040' href='#n1040'>1040</a>
<a id='n1041' href='#n1041'>1041</a>
<a id='n1042' href='#n1042'>1042</a>
<a id='n1043' href='#n1043'>1043</a>
<a id='n1044' href='#n1044'>1044</a>
<a id='n1045' href='#n1045'>1045</a>
<a id='n1046' href='#n1046'>1046</a>
<a id='n1047' href='#n1047'>1047</a>
<a id='n1048' href='#n1048'>1048</a>
<a id='n1049' href='#n1049'>1049</a>
<a id='n1050' href='#n1050'>1050</a>
<a id='n1051' href='#n1051'>1051</a>
<a id='n1052' href='#n1052'>1052</a>
<a id='n1053' href='#n1053'>1053</a>
<a id='n1054' href='#n1054'>1054</a>
<a id='n1055' href='#n1055'>1055</a>
<a id='n1056' href='#n1056'>1056</a>
<a id='n1057' href='#n1057'>1057</a>
<a id='n1058' href='#n1058'>1058</a>
<a id='n1059' href='#n1059'>1059</a>
<a id='n1060' href='#n1060'>1060</a>
<a id='n1061' href='#n1061'>1061</a>
<a id='n1062' href='#n1062'>1062</a>
<a id='n1063' href='#n1063'>1063</a>
<a id='n1064' href='#n1064'>1064</a>
<a id='n1065' href='#n1065'>1065</a>
<a id='n1066' href='#n1066'>1066</a>
<a id='n1067' href='#n1067'>1067</a>
<a id='n1068' href='#n1068'>1068</a>
<a id='n1069' href='#n1069'>1069</a>
<a id='n1070' href='#n1070'>1070</a>
<a id='n1071' href='#n1071'>1071</a>
<a id='n1072' href='#n1072'>1072</a>
<a id='n1073' href='#n1073'>1073</a>
<a id='n1074' href='#n1074'>1074</a>
<a id='n1075' href='#n1075'>1075</a>
<a id='n1076' href='#n1076'>1076</a>
<a id='n1077' href='#n1077'>1077</a>
<a id='n1078' href='#n1078'>1078</a>
</pre></td>
<td class='lines'><pre><code>/*
  Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
  2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
  Software Foundation, Inc.

  This file is part of GNU Inetutils.

  GNU Inetutils is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or (at
  your option) any later version.

  GNU Inetutils is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see `http://www.gnu.org/licenses/'. */

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (C) 1990 by the Massachusetts Institute of Technology
 *
 * Export of this software from the United States of America is assumed
 * to require a specific license from the United States Government.
 * It is the responsibility of any person or organization contemplating
 * export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided ""as is"" without express
 * or implied warranty.
 */

#include &lt;config.h&gt;

#ifdef	ENCRYPTION

# define ENCRYPT_NAMES
# include &lt;arpa/telnet.h&gt;

# include ""encrypt.h""
# include ""misc.h""

# include &lt;stdlib.h&gt;
# include &lt;string.h&gt;

# include &lt;stdio.h&gt;
# include ""genget.h""

/*
 * These functions pointers point to the current routines
 * for encrypting and decrypting data.
 */
void (*encrypt_output) (unsigned char *, int);
int (*decrypt_input) (int);

int encrypt_debug_mode = 0;
static int decrypt_mode = 0;
static int encrypt_mode = 0;
static int encrypt_verbose = 0;
static int autoencrypt = 0;
static int autodecrypt = 0;
static int havesessionkey = 0;
static int Server = 0;
static char *Name = ""Noname"";

# define typemask(x)	((x) &gt; 0 ? 1 &lt;&lt; ((x)-1) : 0)

static long i_support_encrypt = typemask (ENCTYPE_DES_CFB64)
  | typemask (ENCTYPE_DES_OFB64);
     static long
       i_support_decrypt = typemask (ENCTYPE_DES_CFB64)
  | typemask (ENCTYPE_DES_OFB64);
     static long
       i_wont_support_encrypt = 0;
     static long
       i_wont_support_decrypt = 0;
# define I_SUPPORT_ENCRYPT	(i_support_encrypt &amp; ~i_wont_support_encrypt)
# define I_SUPPORT_DECRYPT	(i_support_decrypt &amp; ~i_wont_support_decrypt)

     static long
       remote_supports_encrypt = 0;
     static long
       remote_supports_decrypt = 0;

     static
       Encryptions
       encryptions[] = {
# if defined DES_ENCRYPTION || defined SHISHI
       {""DES_CFB64"", ENCTYPE_DES_CFB64,
	cfb64_encrypt,
	cfb64_decrypt,
	cfb64_init,
	cfb64_start,
	cfb64_is,
	cfb64_reply,
	cfb64_session,
	cfb64_keyid,
	cfb64_printsub},
       {""DES_OFB64"", ENCTYPE_DES_OFB64,
	ofb64_encrypt,
	ofb64_decrypt,
	ofb64_init,
	ofb64_start,
	ofb64_is,
	ofb64_reply,
	ofb64_session,
	ofb64_keyid,
	ofb64_printsub},
# endif	/* DES_ENCRYPTION */
       {0,},
     };

static unsigned char str_send[64] = { IAC, SB, TELOPT_ENCRYPT,
  ENCRYPT_SUPPORT
};
static unsigned char str_suplen = 0;
static unsigned char str_start[72] = { IAC, SB, TELOPT_ENCRYPT };
static unsigned char str_end[] = { IAC, SB, TELOPT_ENCRYPT, 0, IAC, SE };

Encryptions *
findencryption (type)
     int type;
{
  Encryptions *ep = encryptions;

  if (!(I_SUPPORT_ENCRYPT &amp; remote_supports_decrypt &amp; typemask (type)))
    return (0);
  while (ep-&gt;type &amp;&amp; ep-&gt;type != type)
    ++ep;
  return (ep-&gt;type ? ep : 0);
}

Encryptions *
finddecryption (type)
     int type;
{
  Encryptions *ep = encryptions;

  if (!(I_SUPPORT_DECRYPT &amp; remote_supports_encrypt &amp; typemask (type)))
    return (0);
  while (ep-&gt;type &amp;&amp; ep-&gt;type != type)
    ++ep;
  return (ep-&gt;type ? ep : 0);
}

# define MAXKEYLEN 64

static struct key_info
{
  unsigned char keyid[MAXKEYLEN];
  int keylen;
  int dir;
  int *modep;
  Encryptions *(*getcrypt) ();
} ki[2] =
{
  {
    {
  0}, 0, DIR_ENCRYPT, &amp;encrypt_mode, findencryption},
  {
    {
0}, 0, DIR_DECRYPT, &amp;decrypt_mode, finddecryption},};

void
encrypt_init (name, server)
     char *name;
     int server;
{
  Encryptions *ep = encryptions;

  Name = name;
  Server = server;
  i_support_encrypt = i_support_decrypt = 0;
  remote_supports_encrypt = remote_supports_decrypt = 0;
  encrypt_mode = 0;
  decrypt_mode = 0;
  encrypt_output = 0;
  decrypt_input = 0;
  str_suplen = 4;

  while (ep-&gt;type)
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: I will support %s\r\n"",
		Name, ENCTYPE_NAME (ep-&gt;type));
      i_support_encrypt |= typemask (ep-&gt;type);
      i_support_decrypt |= typemask (ep-&gt;type);
      if ((i_wont_support_decrypt &amp; typemask (ep-&gt;type)) == 0)
	if ((str_send[str_suplen++] = ep-&gt;type) == IAC)
	  str_send[str_suplen++] = IAC;
      if (ep-&gt;init)
	(*ep-&gt;init) (Server);
      ++ep;
    }
  str_send[str_suplen++] = IAC;
  str_send[str_suplen++] = SE;
}

void
encrypt_list_types ()
{
  Encryptions *ep = encryptions;

  printf (""Valid encryption types:\n"");
  while (ep-&gt;type)
    {
      printf (""\t%s (%d)\r\n"", ENCTYPE_NAME (ep-&gt;type), ep-&gt;type);
      ++ep;
    }
}

int
EncryptEnable (type, mode)
     char *type, *mode;
{
  if (isprefix (type, ""help"") || isprefix (type, ""?""))
    {
      printf (""Usage: encrypt enable &lt;type&gt; [input|output]\n"");
      encrypt_list_types ();
      return (0);
    }
  if (EncryptType (type, mode))
    return (EncryptStart (mode));
  return (0);
}

int
EncryptDisable (type, mode)
     char *type, *mode;
{
  register Encryptions *ep;
  int ret = 0;

  if (isprefix (type, ""help"") || isprefix (type, ""?""))
    {
      printf (""Usage: encrypt disable &lt;type&gt; [input|output]\n"");
      encrypt_list_types ();
    }
  else if ((ep = (Encryptions *) genget (type, encryptions,
					 sizeof (Encryptions))) == 0)
    {
      printf (""%s: invalid encryption type\n"", type);
    }
  else if (Ambiguous (ep))
    {
      printf (""Ambiguous type '%s'\n"", type);
    }
  else
    {
      if ((mode == 0) || (isprefix (mode, ""input"") ? 1 : 0))
	{
	  if (decrypt_mode == ep-&gt;type)
	    EncryptStopInput ();
	  i_wont_support_decrypt |= typemask (ep-&gt;type);
	  ret = 1;
	}
      if ((mode == 0) || (isprefix (mode, ""output"")))
	{
	  if (encrypt_mode == ep-&gt;type)
	    EncryptStopOutput ();
	  i_wont_support_encrypt |= typemask (ep-&gt;type);
	  ret = 1;
	}
      if (ret == 0)
	printf (""%s: invalid encryption mode\n"", mode);
    }
  return (ret);
}

int
EncryptType (type, mode)
     char *type;
     char *mode;
{
  register Encryptions *ep;
  int ret = 0;

  if (isprefix (type, ""help"") || isprefix (type, ""?""))
    {
      printf (""Usage: encrypt type &lt;type&gt; [input|output]\n"");
      encrypt_list_types ();
    }
  else if ((ep = (Encryptions *) genget (type, encryptions,
					 sizeof (Encryptions))) == 0)
    {
      printf (""%s: invalid encryption type\n"", type);
    }
  else if (Ambiguous (ep))
    {
      printf (""Ambiguous type '%s'\n"", type);
    }
  else
    {
      if ((mode == 0) || isprefix (mode, ""input""))
	{
	  decrypt_mode = ep-&gt;type;
	  i_wont_support_decrypt &amp;= ~typemask (ep-&gt;type);
	  ret = 1;
	}
      if ((mode == 0) || isprefix (mode, ""output""))
	{
	  encrypt_mode = ep-&gt;type;
	  i_wont_support_encrypt &amp;= ~typemask (ep-&gt;type);
	  ret = 1;
	}
      if (ret == 0)
	printf (""%s: invalid encryption mode\n"", mode);
    }
  return (ret);
}

int
EncryptStart (mode)
     char *mode;
{
  register int ret = 0;
  if (mode)
    {
      if (isprefix (mode, ""input""))
	return (EncryptStartInput ());
      if (isprefix (mode, ""output""))
	return (EncryptStartOutput ());
      if (isprefix (mode, ""help"") || isprefix (mode, ""?""))
	{
	  printf (""Usage: encrypt start [input|output]\n"");
	  return (0);
	}
      printf (""%s: invalid encryption mode 'encrypt start ?' for help\n"",
	      mode);
      return (0);
    }
  ret += EncryptStartInput ();
  ret += EncryptStartOutput ();
  return (ret);
}

int
EncryptStartInput ()
{
  if (decrypt_mode)
    {
      encrypt_send_request_start ();
      return (1);
    }
  printf (""No previous decryption mode, decryption not enabled\r\n"");
  return (0);
}

int
EncryptStartOutput ()
{
  if (encrypt_mode)
    {
      encrypt_start_output (encrypt_mode);
      return (1);
    }
  printf (""No previous encryption mode, encryption not enabled\r\n"");
  return (0);
}

int
EncryptStop (mode)
     char *mode;
{
  int ret = 0;
  if (mode)
    {
      if (isprefix (mode, ""input""))
	return (EncryptStopInput ());
      if (isprefix (mode, ""output""))
	return (EncryptStopOutput ());
      if (isprefix (mode, ""help"") || isprefix (mode, ""?""))
	{
	  printf (""Usage: encrypt stop [input|output]\n"");
	  return (0);
	}
      printf (""%s: invalid encryption mode 'encrypt stop ?' for help\n"",
	      mode);
      return (0);
    }
  ret += EncryptStopInput ();
  ret += EncryptStopOutput ();
  return (ret);
}

int
EncryptStopInput ()
{
  encrypt_send_request_end ();
  return (1);
}

int
EncryptStopOutput ()
{
  encrypt_send_end ();
  return (1);
}

void
encrypt_display ()
{
  if (encrypt_output)
    printf (""Currently encrypting output with %s\r\n"",
	    ENCTYPE_NAME (encrypt_mode));
  if (decrypt_input)
    printf (""Currently decrypting input with %s\r\n"",
	    ENCTYPE_NAME (decrypt_mode));
}

int
EncryptStatus ()
{
  if (encrypt_output)
    printf (""Currently encrypting output with %s\r\n"",
	    ENCTYPE_NAME (encrypt_mode));
  else if (encrypt_mode)
    {
      printf (""Currently output is clear text.\r\n"");
      printf (""Last encryption mode was %s\r\n"", ENCTYPE_NAME (encrypt_mode));
    }
  if (decrypt_input)
    {
      printf (""Currently decrypting input with %s\r\n"",
	      ENCTYPE_NAME (decrypt_mode));
    }
  else if (decrypt_mode)
    {
      printf (""Currently input is clear text.\r\n"");
      printf (""Last decryption mode was %s\r\n"", ENCTYPE_NAME (decrypt_mode));
    }
  return 1;
}

void
encrypt_send_support ()
{
  if (str_suplen)
    {
      /*
       * If the user has requested that decryption start
       * immediatly, then send a ""REQUEST START"" before
       * we negotiate the type.
       */
      if (!Server &amp;&amp; autodecrypt)
	encrypt_send_request_start ();
      net_write (str_send, str_suplen);
      printsub ('&gt;', &amp;str_send[2], str_suplen - 2);
      str_suplen = 0;
    }
}

int
EncryptDebug (on)
     int on;
{
  if (on &lt; 0)
    encrypt_debug_mode ^= 1;
  else
    encrypt_debug_mode = on;
  printf (""Encryption debugging %s\r\n"",
	  encrypt_debug_mode ? ""enabled"" : ""disabled"");
  return (1);
}

int
EncryptVerbose (on)
     int on;
{
  if (on &lt; 0)
    encrypt_verbose ^= 1;
  else
    encrypt_verbose = on;
  printf (""Encryption %s verbose\r\n"", encrypt_verbose ? ""is"" : ""is not"");
  return (1);
}

int
EncryptAutoEnc (on)
     int on;
{
  encrypt_auto (on);
  printf (""Automatic encryption of output is %s\r\n"",
	  autoencrypt ? ""enabled"" : ""disabled"");
  return (1);
}

int
EncryptAutoDec (on)
     int on;
{
  decrypt_auto (on);
  printf (""Automatic decryption of input is %s\r\n"",
	  autodecrypt ? ""enabled"" : ""disabled"");
  return (1);
}

/*
 * Called when ENCRYPT SUPPORT is received.
 */
void
encrypt_support (typelist, cnt)
     unsigned char *typelist;
     int cnt;
{
  register int type, use_type = 0;
  Encryptions *ep;

  /*
   * Forget anything the other side has previously told us.
   */
  remote_supports_decrypt = 0;

  while (cnt-- &gt; 0)
    {
      type = *typelist++;
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: He is supporting %s (%d)\r\n"",
		Name, ENCTYPE_NAME (type), type);
      if ((type &lt; ENCTYPE_CNT) &amp;&amp; (I_SUPPORT_ENCRYPT &amp; typemask (type)))
	{
	  remote_supports_decrypt |= typemask (type);
	  if (use_type == 0)
	    use_type = type;
	}
    }
  if (use_type)
    {
      ep = findencryption (use_type);
      if (!ep)
	return;
      type = ep-&gt;start ? (*ep-&gt;start) (DIR_ENCRYPT, Server) : 0;
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: (*ep-&gt;start)() returned %d\r\n"", Name, type);
      if (type &lt; 0)
	return;
      encrypt_mode = use_type;
      if (type == 0)
	encrypt_start_output (use_type);
    }
}

void
encrypt_is (data, cnt)
     unsigned char *data;
     int cnt;
{
  Encryptions *ep;
  register int type, ret;

  if (--cnt &lt; 0)
    return;
  type = *data++;
  if (type &lt; ENCTYPE_CNT)
    remote_supports_encrypt |= typemask (type);
  if (!(ep = finddecryption (type)))
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: Can't find type %s (%d) for initial negotiation\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      return;
    }
  if (!ep-&gt;is)
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: No initial negotiation needed for type %s (%d)\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      ret = 0;
    }
  else
    {
      ret = (*ep-&gt;is) (data, cnt);
      if (encrypt_debug_mode)
	printf (""(*ep-&gt;is)(%x, %d) returned %s(%d)\n"", data, cnt,
		(ret &lt; 0) ? ""FAIL "" :
		(ret == 0) ? ""SUCCESS "" : ""MORE_TO_DO "", ret);
    }
  if (ret &lt; 0)
    {
      autodecrypt = 0;
    }
  else
    {
      decrypt_mode = type;
      if (ret == 0 &amp;&amp; autodecrypt)
	encrypt_send_request_start ();
    }
}

void
encrypt_reply (data, cnt)
     unsigned char *data;
     int cnt;
{
  Encryptions *ep;
  register int ret, type;

  if (--cnt &lt; 0)
    return;
  type = *data++;
  if (!(ep = findencryption (type)))
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: Can't find type %s (%d) for initial negotiation\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      return;
    }
  if (!ep-&gt;reply)
    {
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: No initial negotiation needed for type %s (%d)\r\n"",
		Name,
		ENCTYPE_NAME_OK (type)
		? ENCTYPE_NAME (type) : ""(unknown)"", type);
      ret = 0;
    }
  else
    {
      ret = (*ep-&gt;reply) (data, cnt);
      if (encrypt_debug_mode)
	printf (""(*ep-&gt;reply)(%x, %d) returned %s(%d)\n"",
		data, cnt,
		(ret &lt; 0) ? ""FAIL "" :
		(ret == 0) ? ""SUCCESS "" : ""MORE_TO_DO "", ret);
    }
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: encrypt_reply returned %d\n"", Name, ret);
  if (ret &lt; 0)
    {
      autoencrypt = 0;
    }
  else
    {
      encrypt_mode = type;
      if (ret == 0 &amp;&amp; autoencrypt)
	encrypt_start_output (type);
    }
}

/*
 * Called when a ENCRYPT START command is received.
 */
void
encrypt_start (data, cnt)
     unsigned char *data;
     int cnt;
{
  Encryptions *ep;

  if (!decrypt_mode)
    {
      /*
       * Something is wrong.  We should not get a START
       * command without having already picked our
       * decryption scheme.  Send a REQUEST-END to
       * attempt to clear the channel...
       */
      printf (""%s: Warning, Cannot decrypt input stream!!!\r\n"", Name);
      encrypt_send_request_end ();
      return;
    }

  if (ep = finddecryption (decrypt_mode))
    {
      decrypt_input = ep-&gt;input;
      if (encrypt_verbose)
	printf (""[ Input is now decrypted with type %s ]\r\n"",
		ENCTYPE_NAME (decrypt_mode));
      if (encrypt_debug_mode)
	printf (""&gt;&gt;&gt;%s: Start to decrypt input with type %s\r\n"",
		Name, ENCTYPE_NAME (decrypt_mode));
    }
  else
    {
      printf (""%s: Warning, Cannot decrypt type %s (%d)!!!\r\n"",
	      Name,
	      ENCTYPE_NAME_OK (decrypt_mode)
	      ? ENCTYPE_NAME (decrypt_mode) : ""(unknown)"", decrypt_mode);
      encrypt_send_request_end ();
    }
}

void
encrypt_session_key (key, server)
     Session_Key *key;
     int server;
{
  Encryptions *ep = encryptions;

  havesessionkey = 1;

  while (ep-&gt;type)
    {
      if (ep-&gt;session)
	(*ep-&gt;session) (key, server);
      ++ep;
    }
}

/*
 * Called when ENCRYPT END is received.
 */
void
encrypt_end ()
{
  decrypt_input = 0;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Input is back to clear text\r\n"", Name);
  if (encrypt_verbose)
    printf (""[ Input is now clear text ]\r\n"");
}

/*
 * Called when ENCRYPT REQUEST-END is received.
 */
void
encrypt_request_end ()
{
  encrypt_send_end ();
}

/*
 * Called when ENCRYPT REQUEST-START is received.  If we receive
 * this before a type is picked, then that indicates that the
 * other side wants us to start encrypting data as soon as we
 * can.
 */
void
encrypt_request_start (data, cnt)
     unsigned char *data;
     int cnt;
{
  if (encrypt_mode == 0)
    {
      if (Server)
	autoencrypt = 1;
      return;
    }
  encrypt_start_output (encrypt_mode);
}

static unsigned char str_keyid[(MAXKEYLEN * 2) + 5] =
  { IAC, SB, TELOPT_ENCRYPT };

static void
encrypt_keyid (kp, keyid, len)
     struct key_info *kp;
     unsigned char *keyid;
     int len;
{
  Encryptions *ep;
  unsigned char *strp, *cp;
  int dir = kp-&gt;dir;
  register int ret = 0;

  if (len &gt; MAXKEYLEN)
    len = MAXKEYLEN;

  if (!(ep = (*kp-&gt;getcrypt) (*kp-&gt;modep)))
    {
      if (len == 0)
	return;
      kp-&gt;keylen = 0;
    }
  else if (len == 0)
    {
      /*
       * Empty option, indicates a failure.
       */
      if (kp-&gt;keylen == 0)
	return;
      kp-&gt;keylen = 0;
      if (ep-&gt;keyid)
	(*ep-&gt;keyid) (dir, kp-&gt;keyid, &amp;kp-&gt;keylen);

    }
  else if ((len != kp-&gt;keylen) || (memcmp (keyid, kp-&gt;keyid, len) != 0))
    {
      /*
       * Length or contents are different
       */
      kp-&gt;keylen = len;
      memmove (kp-&gt;keyid, keyid, len);
      if (ep-&gt;keyid)
	(*ep-&gt;keyid) (dir, kp-&gt;keyid, &amp;kp-&gt;keylen);
    }
  else
    {
      if (ep-&gt;keyid)
	ret = (*ep-&gt;keyid) (dir, kp-&gt;keyid, &amp;kp-&gt;keylen);
      if ((ret == 0) &amp;&amp; (dir == DIR_ENCRYPT) &amp;&amp; autoencrypt)
	encrypt_start_output (*kp-&gt;modep);
      return;
    }

  encrypt_send_keyid (dir, kp-&gt;keyid, kp-&gt;keylen, 0);
}

void
encrypt_enc_keyid (keyid, len)
     unsigned char *keyid;
     int len;
{
  encrypt_keyid (&amp;ki[1], keyid, len);
}

void
encrypt_dec_keyid (keyid, len)
     unsigned char *keyid;
     int len;
{
  encrypt_keyid (&amp;ki[0], keyid, len);
}

void
encrypt_send_keyid (dir, keyid, keylen, saveit)
     int dir;
     unsigned char *keyid;
     int keylen;
     int saveit;
{
  unsigned char *strp;

  str_keyid[3] = (dir == DIR_ENCRYPT) ? ENCRYPT_ENC_KEYID : ENCRYPT_DEC_KEYID;
  if (saveit)
    {
      struct key_info *kp = &amp;ki[(dir == DIR_ENCRYPT) ? 0 : 1];
      memmove (kp-&gt;keyid, keyid, keylen);
      kp-&gt;keylen = keylen;
    }

  for (strp = &amp;str_keyid[4]; keylen &gt; 0; --keylen)
    {
      if ((*strp++ = *keyid++) == IAC)
	*strp++ = IAC;
    }
  *strp++ = IAC;
  *strp++ = SE;
  net_write (str_keyid, strp - str_keyid);
  printsub ('&gt;', &amp;str_keyid[2], strp - str_keyid - 2);
}

void
encrypt_auto (on)
     int on;
{
  if (on &lt; 0)
    autoencrypt ^= 1;
  else
    autoencrypt = on ? 1 : 0;
}

void
decrypt_auto (on)
     int on;
{
  if (on &lt; 0)
    autodecrypt ^= 1;
  else
    autodecrypt = on ? 1 : 0;
}

void
encrypt_start_output (type)
     int type;
{
  Encryptions *ep;
  register unsigned char *p;
  register int i;

  if (!(ep = findencryption (type)))
    {
      if (encrypt_debug_mode)
	{
	  printf (""&gt;&gt;&gt;%s: Can't encrypt with type %s (%d)\r\n"",
		  Name,
		  ENCTYPE_NAME_OK (type)
		  ? ENCTYPE_NAME (type) : ""(unknown)"", type);
	}
      return;
    }
  if (ep-&gt;start)
    {
      i = (*ep-&gt;start) (DIR_ENCRYPT, Server);
      if (encrypt_debug_mode)
	{
	  printf (""&gt;&gt;&gt;%s: Encrypt start: %s (%d) %s\r\n"",
		  Name,
		  (i &lt; 0) ? ""failed"" :
		  ""initial negotiation in progress"", i, ENCTYPE_NAME (type));
	}
      if (i)
	return;
    }
  p = str_start + 3;
  *p++ = ENCRYPT_START;
  for (i = 0; i &lt; ki[0].keylen; ++i)
    {
      if ((*p++ = ki[0].keyid[i]) == IAC)
	*p++ = IAC;
    }
  *p++ = IAC;
  *p++ = SE;
  net_write (str_start, p - str_start);
  net_encrypt ();
  printsub ('&gt;', &amp;str_start[2], p - &amp;str_start[2]);
  /*
   * If we are already encrypting in some mode, then
   * encrypt the ring (which includes our request) in
   * the old mode, mark it all as ""clear text"" and then
   * switch to the new mode.
   */
  encrypt_output = ep-&gt;output;
  encrypt_mode = type;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Started to encrypt output with type %s\r\n"",
	    Name, ENCTYPE_NAME (type));
  if (encrypt_verbose)
    printf (""[ Output is now encrypted with type %s ]\r\n"",
	    ENCTYPE_NAME (type));
}

void
encrypt_send_end ()
{
  if (!encrypt_output)
    return;

  str_end[3] = ENCRYPT_END;
  net_write (str_end, sizeof (str_end));
  net_encrypt ();
  printsub ('&gt;', &amp;str_end[2], sizeof (str_end) - 2);
  /*
   * Encrypt the output buffer now because it will not be done by
   * netflush...
   */
  encrypt_output = 0;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Output is back to clear text\r\n"", Name);
  if (encrypt_verbose)
    printf (""[ Output is now clear text ]\r\n"");
}

void
encrypt_send_request_start ()
{
  register unsigned char *p;
  register int i;

  p = &amp;str_start[3];
  *p++ = ENCRYPT_REQSTART;
  for (i = 0; i &lt; ki[1].keylen; ++i)
    {
      if ((*p++ = ki[1].keyid[i]) == IAC)
	*p++ = IAC;
    }
  *p++ = IAC;
  *p++ = SE;
  net_write (str_start, p - str_start);
  printsub ('&gt;', &amp;str_start[2], p - &amp;str_start[2]);
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Request input to be encrypted\r\n"", Name);
}

void
encrypt_send_request_end ()
{
  str_end[3] = ENCRYPT_REQEND;
  net_write (str_end, sizeof (str_end));
  printsub ('&gt;', &amp;str_end[2], sizeof (str_end) - 2);

  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: Request input to be clear text\r\n"", Name);
}

void
encrypt_wait ()
{
  register int encrypt, decrypt;
  if (encrypt_debug_mode)
    printf (""&gt;&gt;&gt;%s: in encrypt_wait\r\n"", Name);
  if (!havesessionkey || !(I_SUPPORT_ENCRYPT &amp; remote_supports_decrypt))
    return;
  while (autoencrypt &amp;&amp; !encrypt_output)
    if (telnet_spin ())
      return;
}

void
encrypt_debug (mode)
     int mode;
{
  encrypt_debug_mode = mode;
}

void
encrypt_gen_printsub (data, cnt, buf, buflen)
     unsigned char *data, *buf;
     int cnt, buflen;
{
  char tbuf[16], *cp;

  cnt -= 2;
  data += 2;
  buf[buflen - 1] = '\0';
  buf[buflen - 2] = '*';
  buflen -= 2;;
  for (; cnt &gt; 0; cnt--, data++)
    {
      sprintf (tbuf, "" %d"", *data);
      for (cp = tbuf; *cp &amp;&amp; buflen &gt; 0; --buflen)
	*buf++ = *cp++;
      if (buflen &lt;= 0)
	return;
    }
  *buf = '\0';
}

void
encrypt_printsub (data, cnt, buf, buflen)
     unsigned char *data, *buf;
     int cnt, buflen;
{
  Encryptions *ep;
  register int type = data[1];

  for (ep = encryptions; ep-&gt;type &amp;&amp; ep-&gt;type != type; ep++)
    ;

  if (ep-&gt;printsub)
    (*ep-&gt;printsub) (data, cnt, buf, buflen);
  else
    encrypt_gen_printsub (data, cnt, buf, buflen);
}
#endif /* ENCRYPTION */
</code></pre></td></tr></table>
</div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit v1.2.1</a> (<a href='https://git-scm.com/'>git 2.18.0</a>) at 2020-05-09 06:46:01 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
"
CVE-2015-8467,https://www.cvedetails.com/cve/CVE-2015-8467/,CWE-264,,Bypass,2015-12-29,2016-12-30,6.0,None,Remote,Medium,Single system,Partial,Partial,Partial,"The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",C,samba,https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,a819d2b440aafa3138d95ff6e8b824da885a70e9,"@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
+               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
+               bool admin_required;
                const char *error_string;
        } map[] = {
                {
@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
+               {
+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
+                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
+               },
+               {
+                       .uac = UF_NORMAL_ACCOUNT,
+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
+               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                return ldb_module_operr(ac->module);
        }
 
-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
+       ret = dsdb_get_sd_from_ldb_message(ldb,
                                           ac, res->msgs[0], &domain_sd);
 
        if (ret != LDB_SUCCESS) {
@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                                if (have_priv == false) {
                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                }
-                       } else {
+                       } else if (map[i].priv_to_change_from & user_account_control_old) {
+                               bool is_admin = security_token_has_builtin_administrators(user_token);
+                               if (is_admin == false) {
+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
+                               }
+                       } else if (map[i].guid) {
                                ret = acl_check_extended_right(ac, domain_sd,
                                                               user_token,
                                                               map[i].guid,
                                                               SEC_ADS_CONTROL_ACCESS,
                                                               sid);
+                       } else {
+                               ret = LDB_SUCCESS;
                        }
                        if (ret != LDB_SUCCESS) {
                                break;",https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd," /*
    SAM ldb module
 
    Copyright (C) Andrew Bartlett <abartlet@samba.org> 2005-2014
    Copyright (C) Simo Sorce  2004-2008
    Copyright (C) Matthias Dieter Wallnöfer 2009-2011
    Copyright (C) Matthieu Patou 2012
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 /*
  *  Name: ldb
  *
  *  Component: ldb samldb module
  *
  *  Description: various internal DSDB triggers - most for SAM specific objects
  *
  *  Author: Simo Sorce
  */
 
 #include ""includes.h""
 #include ""libcli/ldap/ldap_ndr.h""
 #include ""ldb_module.h""
 #include ""auth/auth.h""
 #include ""dsdb/samdb/samdb.h""
 #include ""dsdb/samdb/ldb_modules/util.h""
 #include ""dsdb/samdb/ldb_modules/ridalloc.h""
 #include ""libcli/security/security.h""
 #include ""librpc/gen_ndr/ndr_security.h""
 #include ""ldb_wrap.h""
 #include ""param/param.h""
 #include ""libds/common/flag_mapping.h""
 
 struct samldb_ctx;
 enum samldb_add_type {
         SAMLDB_TYPE_USER,
         SAMLDB_TYPE_GROUP,
         SAMLDB_TYPE_CLASS,
         SAMLDB_TYPE_ATTRIBUTE
 };
 
 typedef int (*samldb_step_fn_t)(struct samldb_ctx *);
 
 struct samldb_step {
         struct samldb_step *next;
         samldb_step_fn_t fn;
 };
 
 struct samldb_ctx {
         struct ldb_module *module;
         struct ldb_request *req;
 
         /* used for add operations */
         enum samldb_add_type type;
 
         /* the resulting message */
         struct ldb_message *msg;
 
         /* used in ""samldb_find_for_defaultObjectCategory"" */
         struct ldb_dn *dn, *res_dn;
 
         /* all the async steps necessary to complete the operation */
         struct samldb_step *steps;
         struct samldb_step *curstep;
 
         /* If someone set an ares to forward controls and response back to the caller */
         struct ldb_reply *ares;
 };
 
 static struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,
                                           struct ldb_request *req)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
 
         ldb = ldb_module_get_ctx(module);
 
         ac = talloc_zero(req, struct samldb_ctx);
         if (ac == NULL) {
                 ldb_oom(ldb);
                 return NULL;
         }
 
         ac->module = module;
         ac->req = req;
 
         return ac;
 }
 
 static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)
 {
         struct samldb_step *step, *stepper;
 
         step = talloc_zero(ac, struct samldb_step);
         if (step == NULL) {
                 return ldb_oom(ldb_module_get_ctx(ac->module));
         }
 
         step->fn = fn;
 
         if (ac->steps == NULL) {
                 ac->steps = step;
                 ac->curstep = step;
         } else {
                 if (ac->curstep == NULL)
                         return ldb_operr(ldb_module_get_ctx(ac->module));
                 for (stepper = ac->curstep; stepper->next != NULL;
                         stepper = stepper->next);
                 stepper->next = step;
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_first_step(struct samldb_ctx *ac)
 {
         if (ac->steps == NULL) {
                 return ldb_operr(ldb_module_get_ctx(ac->module));
         }
 
         ac->curstep = ac->steps;
         return ac->curstep->fn(ac);
 }
 
 static int samldb_next_step(struct samldb_ctx *ac)
 {
         if (ac->curstep->next) {
                 ac->curstep = ac->curstep->next;
                 return ac->curstep->fn(ac);
         }
 
         /* We exit the samldb module here. If someone set an ""ares"" to forward
          * controls and response back to the caller, use them. */
         if (ac->ares) {
                 return ldb_module_done(ac->req, ac->ares->controls,
                                        ac->ares->response, LDB_SUCCESS);
         } else {
                 return ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);
         }
 }
 
 
 /* sAMAccountName handling */
 
 static int samldb_generate_sAMAccountName(struct ldb_context *ldb,
                                           struct ldb_message *msg)
 {
         char *name;
 
         /* Format: $000000-000000000000 */
 
         name = talloc_asprintf(msg, ""$%.6X-%.6X%.6X"",
                                 (unsigned int)generate_random(),
                                 (unsigned int)generate_random(),
                                 (unsigned int)generate_random());
         if (name == NULL) {
                 return ldb_oom(ldb);
         }
         return ldb_msg_add_steal_string(msg, ""sAMAccountName"", name);
 }
 
 static int samldb_check_sAMAccountName(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char *name;
         int ret;
         struct ldb_result *res;
         const char * const noattrs[] = { NULL };
 
         if (ldb_msg_find_element(ac->msg, ""sAMAccountName"") == NULL) {
                 ret = samldb_generate_sAMAccountName(ldb, ac->msg);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         name = ldb_msg_find_attr_as_string(ac->msg, ""sAMAccountName"", NULL);
         if (name == NULL) {
                 /* The ""sAMAccountName"" cannot be nothing */
                 ldb_set_errstring(ldb,
                                   ""samldb: Empty account names aren't allowed!"");
                 return LDB_ERR_CONSTRAINT_VIOLATION;
         }
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs,
                                  DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(sAMAccountName=%s)"",
                                  ldb_binary_encode_string(ac, name));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 0) {
                 ldb_asprintf_errstring(ldb,
                                        ""samldb: Account name (sAMAccountName) '%s' already in use!"",
                                        name);
                 talloc_free(res);
                 return LDB_ERR_ENTRY_ALREADY_EXISTS;
         }
         talloc_free(res);
 
         return samldb_next_step(ac);
 }
 
 
 static bool samldb_msg_add_sid(struct ldb_message *msg,
                                 const char *name,
                                 const struct dom_sid *sid)
 {
         struct ldb_val v;
         enum ndr_err_code ndr_err;
 
         ndr_err = ndr_push_struct_blob(&v, msg, sid,
                                        (ndr_push_flags_fn_t)ndr_push_dom_sid);
         if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
                 return false;
         }
         return (ldb_msg_add_value(msg, name, &v, NULL) == 0);
 }
 
 
 /* allocate a SID using our RID Set */
 static int samldb_allocate_sid(struct samldb_ctx *ac)
 {
         uint32_t rid;
         struct dom_sid *sid;
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         int ret;
 
         ret = ridalloc_allocate_rid(ac->module, &rid, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);
         if (sid == NULL) {
                 return ldb_module_oom(ac->module);
         }
 
         if ( ! samldb_msg_add_sid(ac->msg, ""objectSid"", sid)) {
                 return ldb_operr(ldb);
         }
 
         return samldb_next_step(ac);
 }
 
 /*
   see if a krbtgt_number is available
  */
 static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,
                                           uint32_t krbtgt_number)
 {
         TALLOC_CTX *tmp_ctx = talloc_new(ac);
         struct ldb_result *res;
         const char * const no_attrs[] = { NULL };
         int ret;
 
         ret = dsdb_module_search(ac->module, tmp_ctx, &res,
                                  ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),
                                  LDB_SCOPE_SUBTREE, no_attrs,
                                  DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(msDC-SecondaryKrbTgtNumber=%u)"",
                                  krbtgt_number);
         if (ret == LDB_SUCCESS && res->count == 0) {
                 talloc_free(tmp_ctx);
                 return true;
         }
         talloc_free(tmp_ctx);
         return false;
 }
 
 /* special handling for add in RODC join */
 static int samldb_rodc_add(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t krbtgt_number, i_start, i;
         int ret;
         char *newpass;
         struct ldb_val newpass_utf16;
 
         /* find a unused msDC-SecondaryKrbTgtNumber */
         i_start = generate_random() & 0xFFFF;
         if (i_start == 0) {
                 i_start = 1;
         }
 
         for (i=i_start; i<=0xFFFF; i++) {
                 if (samldb_krbtgtnumber_available(ac, i)) {
                         krbtgt_number = i;
                         goto found;
                 }
         }
         for (i=1; i<i_start; i++) {
                 if (samldb_krbtgtnumber_available(ac, i)) {
                         krbtgt_number = i;
                         goto found;
                 }
         }
 
         ldb_asprintf_errstring(ldb,
                                ""%08X: Unable to find available msDS-SecondaryKrbTgtNumber"",
                                W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));
         return LDB_ERR_OTHER;
 
 found:
         ret = ldb_msg_add_empty(ac->msg, ""msDS-SecondaryKrbTgtNumber"",
                                 LDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                  ""msDS-SecondaryKrbTgtNumber"", krbtgt_number);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         ret = ldb_msg_add_fmt(ac->msg, ""sAMAccountName"", ""krbtgt_%u"",
                               krbtgt_number);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         newpass = generate_random_password(ac->msg, 128, 255);
         if (newpass == NULL) {
                 return ldb_operr(ldb);
         }
 
         if (!convert_string_talloc(ac,
                                    CH_UNIX, CH_UTF16,
                                    newpass, strlen(newpass),
                                    (void *)&newpass_utf16.data,
                                    &newpass_utf16.length)) {
                 ldb_asprintf_errstring(ldb,
                                        ""samldb_rodc_add: ""
                                        ""failed to generate UTF16 password from random password"");
                 return LDB_ERR_OPERATIONS_ERROR;
         }
         ret = ldb_msg_add_steal_value(ac->msg, ""clearTextPassword"", &newpass_utf16);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         return samldb_next_step(ac);
 }
 
 static int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_result *res;
         const char * const no_attrs[] = { NULL };
         int ret;
 
         ac->res_dn = NULL;
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ac->dn, LDB_SCOPE_BASE, no_attrs,
                                  DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT
                                  | DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectClass=classSchema)"");
         if (ret == LDB_ERR_NO_SUCH_OBJECT) {
                 /* Don't be pricky when the DN doesn't exist if we have the */
                 /* RELAX control specified */
                 if (ldb_request_get_control(ac->req,
                                             LDB_CONTROL_RELAX_OID) == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb_find_defaultObjectCategory: ""
                                           ""Invalid DN for 'defaultObjectCategory'!"");
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 }
         }
         if ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {
                 return ret;
         }
 
         if (ret == LDB_SUCCESS) {
                 /* ensure the defaultObjectCategory has a full GUID */
                 struct ldb_message *m;
                 m = ldb_msg_new(ac->msg);
                 if (m == NULL) {
                         return ldb_oom(ldb);
                 }
                 m->dn = ac->msg->dn;
                 if (ldb_msg_add_string(m, ""defaultObjectCategory"",
                                        ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=
                     LDB_SUCCESS) {
                         return ldb_oom(ldb);
                 }
                 m->elements[0].flags = LDB_FLAG_MOD_REPLACE;
 
                 ret = dsdb_module_modify(ac->module, m,
                                          DSDB_FLAG_NEXT_MODULE,
                                          ac->req);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
 
         ac->res_dn = ac->dn;
 
         return samldb_next_step(ac);
 }
 
 /**
  * msDS-IntId attributeSchema attribute handling
  * during LDB_ADD request processing
  */
 static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)
 {
         int ret;
         bool id_exists;
         uint32_t msds_intid;
         int32_t system_flags;
         struct ldb_context *ldb;
         struct ldb_result *ldb_res;
         struct ldb_dn *schema_dn;
         struct samldb_msds_intid_persistant *msds_intid_struct;
         struct dsdb_schema *schema;
 
         ldb = ldb_module_get_ctx(ac->module);
         schema_dn = ldb_get_schema_basedn(ldb);
 
         /* replicated update should always go through */
         if (ldb_request_get_control(ac->req,
                                     DSDB_CONTROL_REPLICATED_UPDATE_OID)) {
                 return LDB_SUCCESS;
         }
 
         /* msDS-IntId is handled by system and should never be
          * passed by clients */
         if (ldb_msg_find_element(ac->msg, ""msDS-IntId"")) {
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* do not generate msDS-IntId if Relax control is passed */
         if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {
                 return LDB_SUCCESS;
         }
 
         /* check Functional Level */
         if (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {
                 return LDB_SUCCESS;
         }
 
         /* check systemFlags for SCHEMA_BASE_OBJECT flag */
         system_flags = ldb_msg_find_attr_as_int(ac->msg, ""systemFlags"", 0);
         if (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {
                 return LDB_SUCCESS;
         }
         schema = dsdb_get_schema(ldb, NULL);
         if (!schema) {
                 ldb_debug_set(ldb, LDB_DEBUG_FATAL,
                               ""samldb_schema_info_update: no dsdb_schema loaded"");
                 DEBUG(0,(__location__ "": %s\n"", ldb_errstring(ldb)));
                 return ldb_operr(ldb);
         }
 
         msds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);
         if (!msds_intid_struct) {
                 msds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);
                 /* Generate new value for msDs-IntId
                 * Value should be in 0x80000000..0xBFFFFFFF range */
                 msds_intid = generate_random() % 0X3FFFFFFF;
                 msds_intid += 0x80000000;
                 msds_intid_struct->msds_intid = msds_intid;
                 msds_intid_struct->usn = schema->loaded_usn;
                 DEBUG(2, (""No samldb_msds_intid_persistant struct, allocating a new one\n""));
         } else {
                 msds_intid = msds_intid_struct->msds_intid;
         }
 
         /* probe id values until unique one is found */
         do {
                 uint64_t current_usn;
                 msds_intid++;
                 if (msds_intid > 0xBFFFFFFF) {
                         msds_intid = 0x80000001;
                 }
                 /*
                  * Alternative strategy to a costly (even indexed search) to the
                  * database.
                  * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because
                  * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).
                  * If so generate another random value.
                  * If not check if the highest USN in the database for the schema partition is the
                  * one that we know.
                  * If so it means that's only this ldb context that is touching the schema in the database.
                  * If not it means that's someone else has modified the database while we are doing our changes too
                  * (this case should be very bery rare) in order to be sure do the search in the database.
                  */
                 if (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {
                         msds_intid = generate_random() % 0X3FFFFFFF;
                         msds_intid += 0x80000000;
                         continue;
                 }
 
                 ret = dsdb_module_load_partition_usn(ac->module, schema_dn,
                                                      &current_usn, NULL, NULL);
                 if (ret != LDB_SUCCESS) {
                         ldb_debug_set(ldb, LDB_DEBUG_ERROR,
                                       __location__"": Searching for schema USN failed: %s\n"",
                                       ldb_errstring(ldb));
                         return ldb_operr(ldb);
                 }
 
                 /* current_usn can be lesser than msds_intid_struct-> if there is
                  * uncommited changes.
                  */
                 if (current_usn > msds_intid_struct->usn) {
                         /* oups something has changed, someone/something
                          * else is modifying or has modified the schema
                          * we'd better check this intid is the database directly
                          */
 
                         DEBUG(2, (""Schema has changed, searching the database for the unicity of %d\n"",
                                         msds_intid));
 
                         ret = dsdb_module_search(ac->module, ac,
                                                 &ldb_res,
                                                 schema_dn, LDB_SCOPE_ONELEVEL, NULL,
                                                 DSDB_FLAG_NEXT_MODULE,
                                                 ac->req,
                                                 ""(msDS-IntId=%d)"", msds_intid);
                         if (ret != LDB_SUCCESS) {
                                 ldb_debug_set(ldb, LDB_DEBUG_ERROR,
                                         __location__"": Searching for msDS-IntId=%d failed - %s\n"",
                                         msds_intid,
                                         ldb_errstring(ldb));
                                 return ldb_operr(ldb);
                         }
                         id_exists = (ldb_res->count > 0);
                         talloc_free(ldb_res);
                 } else {
                         id_exists = 0;
                 }
 
         } while(id_exists);
         msds_intid_struct->msds_intid = msds_intid;
         ldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);
 
         return samdb_msg_add_int(ldb, ac->msg, ac->msg, ""msDS-IntId"",
                                  msds_intid);
 }
 
 
 /*
  * samldb_add_entry (async)
  */
 
 static int samldb_add_entry_callback(struct ldb_request *req,
                                         struct ldb_reply *ares)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
         int ret;
 
         ac = talloc_get_type(req->context, struct samldb_ctx);
         ldb = ldb_module_get_ctx(ac->module);
 
         if (!ares) {
                 return ldb_module_done(ac->req, NULL, NULL,
                                         LDB_ERR_OPERATIONS_ERROR);
         }
 
         if (ares->type == LDB_REPLY_REFERRAL) {
                 return ldb_module_send_referral(ac->req, ares->referral);
         }
 
         if (ares->error != LDB_SUCCESS) {
                 return ldb_module_done(ac->req, ares->controls,
                                         ares->response, ares->error);
         }
         if (ares->type != LDB_REPLY_DONE) {
                 ldb_asprintf_errstring(ldb, ""Invalid LDB reply type %d"", ares->type);
                 return ldb_module_done(ac->req, NULL, NULL,
                                         LDB_ERR_OPERATIONS_ERROR);
         }
 
         /* The caller may wish to get controls back from the add */
         ac->ares = talloc_steal(ac, ares);
 
         ret = samldb_next_step(ac);
         if (ret != LDB_SUCCESS) {
                 return ldb_module_done(ac->req, NULL, NULL, ret);
         }
         return ret;
 }
 
 static int samldb_add_entry(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb;
         struct ldb_request *req;
         int ret;
 
         ldb = ldb_module_get_ctx(ac->module);
 
         ret = ldb_build_add_req(&req, ldb, ac,
                                 ac->msg,
                                 ac->req->controls,
                                 ac, samldb_add_entry_callback,
                                 ac->req);
         LDB_REQ_SET_LOCATION(req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         return ldb_next_request(ac->module, req);
 }
 
 /*
  * return true if msg carries an attributeSchema that is intended to be RODC
  * filtered but is also a system-critical attribute.
  */
 static bool check_rodc_critical_attribute(struct ldb_message *msg)
 {
         uint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;
 
         schemaFlagsEx = ldb_msg_find_attr_as_uint(msg, ""schemaFlagsEx"", 0);
         searchFlags = ldb_msg_find_attr_as_uint(msg, ""searchFlags"", 0);
         rodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE
                               | SEARCH_FLAG_CONFIDENTIAL);
 
         if ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&
                 ((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {
                 return true;
         } else {
                 return false;
         }
 }
 
 
 static int samldb_fill_object(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         int ret;
 
         /* Add information for the different account types */
         switch(ac->type) {
         case SAMLDB_TYPE_USER: {
                 struct ldb_control *rodc_control = ldb_request_get_control(ac->req,
                                                                            LDB_CONTROL_RODC_DCPROMO_OID);
                 if (rodc_control != NULL) {
                         /* see [MS-ADTS] 3.1.1.3.4.1.23 LDAP_SERVER_RODC_DCPROMO_OID */
                         rodc_control->critical = false;
                         ret = samldb_add_step(ac, samldb_rodc_add);
                         if (ret != LDB_SUCCESS) return ret;
                 }
 
                 /* check if we have a valid sAMAccountName */
                 ret = samldb_add_step(ac, samldb_check_sAMAccountName);
                 if (ret != LDB_SUCCESS) return ret;
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
                 break;
         }
 
         case SAMLDB_TYPE_GROUP: {
                 /* check if we have a valid sAMAccountName */
                 ret = samldb_add_step(ac, samldb_check_sAMAccountName);
                 if (ret != LDB_SUCCESS) return ret;
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
                 break;
         }
 
         case SAMLDB_TYPE_CLASS: {
                 const struct ldb_val *rdn_value, *def_obj_cat_val;
                 unsigned int v = ldb_msg_find_attr_as_uint(ac->msg, ""objectClassCategory"", -2);
 
                 /* As discussed with Microsoft through dochelp in April 2012 this is the behavior of windows*/
                 if (!ldb_msg_find_element(ac->msg, ""subClassOf"")) {
                         ret = ldb_msg_add_string(ac->msg, ""subClassOf"", ""top"");
                         if (ret != LDB_SUCCESS) return ret;
                 }
 
                 ret = samdb_find_or_add_attribute(ldb, ac->msg,
                                                   ""rdnAttId"", ""cn"");
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* do not allow to mark an attributeSchema as RODC filtered if it
                  * is system-critical */
                 if (check_rodc_critical_attribute(ac->msg)) {
                         ldb_asprintf_errstring(ldb, ""Refusing schema add of %s - cannot combine critical class with RODC filtering"",
                                                ldb_dn_get_linearized(ac->msg->dn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
 
                 rdn_value = ldb_dn_get_rdn_val(ac->msg->dn);
                 if (rdn_value == NULL) {
                         return ldb_operr(ldb);
                 }
                 if (!ldb_msg_find_element(ac->msg, ""lDAPDisplayName"")) {
                         /* the RDN has prefix ""CN"" */
                         ret = ldb_msg_add_string(ac->msg, ""lDAPDisplayName"",
                                 samdb_cn_to_lDAPDisplayName(ac->msg,
                                                             (const char *) rdn_value->data));
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 if (!ldb_msg_find_element(ac->msg, ""schemaIDGUID"")) {
                         struct GUID guid;
                         /* a new GUID */
                         guid = GUID_random();
                         ret = dsdb_msg_add_guid(ac->msg, &guid, ""schemaIDGUID"");
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 def_obj_cat_val = ldb_msg_find_ldb_val(ac->msg,
                                                        ""defaultObjectCategory"");
                 if (def_obj_cat_val != NULL) {
                         /* ""defaultObjectCategory"" has been set by the caller.
                          * Do some checks for consistency.
                          * NOTE: The real constraint check (that
                          * 'defaultObjectCategory' is the DN of the new
                          * objectclass or any parent of it) is still incomplete.
                          * For now we say that 'defaultObjectCategory' is valid
                          * if it exists and it is of objectclass ""classSchema"".
                          */
                         ac->dn = ldb_dn_from_ldb_val(ac, ldb, def_obj_cat_val);
                         if (ac->dn == NULL) {
                                 ldb_set_errstring(ldb,
                                                   ""Invalid DN for 'defaultObjectCategory'!"");
                                 return LDB_ERR_CONSTRAINT_VIOLATION;
                         }
                 } else {
                         /* ""defaultObjectCategory"" has not been set by the
                          * caller. Use the entry DN for it. */
                         ac->dn = ac->msg->dn;
 
                         ret = ldb_msg_add_string(ac->msg, ""defaultObjectCategory"",
                                                  ldb_dn_alloc_linearized(ac->msg, ac->dn));
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* Now perform the checks for the 'defaultObjectCategory'. The
                  * lookup DN was already saved in ""ac->dn"" */
                 ret = samldb_add_step(ac, samldb_find_for_defaultObjectCategory);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* -2 is not a valid objectClassCategory so it means the attribute wasn't present */
                 if (v == -2) {
                         /* Windows 2003 does this*/
                         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""objectClassCategory"", 0);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                 }
                 break;
         }
 
         case SAMLDB_TYPE_ATTRIBUTE: {
                 const struct ldb_val *rdn_value;
                 struct ldb_message_element *el;
                 rdn_value = ldb_dn_get_rdn_val(ac->msg->dn);
                 if (rdn_value == NULL) {
                         return ldb_operr(ldb);
                 }
                 if (!ldb_msg_find_element(ac->msg, ""lDAPDisplayName"")) {
                         /* the RDN has prefix ""CN"" */
                         ret = ldb_msg_add_string(ac->msg, ""lDAPDisplayName"",
                                 samdb_cn_to_lDAPDisplayName(ac->msg,
                                                             (const char *) rdn_value->data));
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 /* do not allow to mark an attributeSchema as RODC filtered if it
                  * is system-critical */
                 if (check_rodc_critical_attribute(ac->msg)) {
                         ldb_asprintf_errstring(ldb,
                                                ""samldb: refusing schema add of %s - cannot combine critical attribute with RODC filtering"",
                                                ldb_dn_get_linearized(ac->msg->dn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
 
                 ret = samdb_find_or_add_attribute(ldb, ac->msg,
                                                   ""isSingleValued"", ""FALSE"");
                 if (ret != LDB_SUCCESS) return ret;
 
                 if (!ldb_msg_find_element(ac->msg, ""schemaIDGUID"")) {
                         struct GUID guid;
                         /* a new GUID */
                         guid = GUID_random();
                         ret = dsdb_msg_add_guid(ac->msg, &guid, ""schemaIDGUID"");
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 el = ldb_msg_find_element(ac->msg, ""attributeSyntax"");
                 if (el) {
                         /*
                          * No need to scream if there isn't as we have code later on
                          * that will take care of it.
                          */
                         const struct dsdb_syntax *syntax = find_syntax_map_by_ad_oid((const char *)el->values[0].data);
                         if (!syntax) {
                                 DEBUG(9, (""Can't find dsdb_syntax object for attributeSyntax %s\n"",
                                                 (const char *)el->values[0].data));
                         } else {
                                 unsigned int v = ldb_msg_find_attr_as_uint(ac->msg, ""oMSyntax"", 0);
                                 const struct ldb_val *val = ldb_msg_find_ldb_val(ac->msg, ""oMObjectClass"");
 
                                 if (v == 0) {
                                         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""oMSyntax"", syntax->oMSyntax);
                                         if (ret != LDB_SUCCESS) {
                                                 return ret;
                                         }
                                 }
                                 if (!val) {
                                         struct ldb_val val2 = ldb_val_dup(ldb, &syntax->oMObjectClass);
                                         if (val2.length > 0) {
                                                 ret = ldb_msg_add_value(ac->msg, ""oMObjectClass"", &val2, NULL);
                                                 if (ret != LDB_SUCCESS) {
                                                         return ret;
                                                 }
                                         }
                                 }
                         }
                 }
 
                 /* handle msDS-IntID attribute */
                 ret = samldb_add_handle_msDS_IntId(ac);
                 if (ret != LDB_SUCCESS) return ret;
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
                 break;
         }
 
         default:
                 ldb_asprintf_errstring(ldb, ""Invalid entry type!"");
                 return LDB_ERR_OPERATIONS_ERROR;
                 break;
         }
 
         return samldb_first_step(ac);
 }
 
 static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb;
         const struct ldb_val *rdn_value;
         struct dom_sid *sid;
         int ret;
 
         ldb = ldb_module_get_ctx(ac->module);
 
         sid = samdb_result_dom_sid(ac->msg, ac->msg, ""objectSid"");
         if (sid == NULL) {
                 rdn_value = ldb_dn_get_rdn_val(ac->msg->dn);
                 if (rdn_value == NULL) {
                         return ldb_operr(ldb);
                 }
                 sid = dom_sid_parse_talloc(ac->msg,
                                            (const char *)rdn_value->data);
                 if (sid == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: No valid SID found in ForeignSecurityPrincipal CN!"");
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 }
                 if (! samldb_msg_add_sid(ac->msg, ""objectSid"", sid)) {
                         return ldb_operr(ldb);
                 }
         }
 
         /* finally proceed with adding the entry */
         ret = samldb_add_step(ac, samldb_add_entry);
         if (ret != LDB_SUCCESS) return ret;
 
         return samldb_first_step(ac);
 }
 
 static int samldb_schema_info_update(struct samldb_ctx *ac)
 {
         int ret;
         struct ldb_context *ldb;
         struct dsdb_schema *schema;
 
         /* replicated update should always go through */
         if (ldb_request_get_control(ac->req,
                                     DSDB_CONTROL_REPLICATED_UPDATE_OID)) {
                 return LDB_SUCCESS;
         }
 
         /* do not update schemaInfo during provisioning */
         if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {
                 return LDB_SUCCESS;
         }
 
         ldb = ldb_module_get_ctx(ac->module);
         schema = dsdb_get_schema(ldb, NULL);
         if (!schema) {
                 ldb_debug_set(ldb, LDB_DEBUG_FATAL,
                               ""samldb_schema_info_update: no dsdb_schema loaded"");
                 DEBUG(0,(__location__ "": %s\n"", ldb_errstring(ldb)));
                 return ldb_operr(ldb);
         }
 
         ret = dsdb_module_schema_info_update(ac->module, schema,
                                              DSDB_FLAG_NEXT_MODULE|
                                              DSDB_FLAG_AS_SYSTEM,
                                              ac->req);
         if (ret != LDB_SUCCESS) {
                 ldb_asprintf_errstring(ldb,
                                        ""samldb_schema_info_update: dsdb_module_schema_info_update failed with %s"",
                                        ldb_errstring(ldb));
                 return ret;
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid);
 static int samldb_check_user_account_control_rules(struct samldb_ctx *ac,
                                                    struct dom_sid *sid,
                                                    uint32_t user_account_control,
                                                    uint32_t user_account_control_old);
 
 /*
  * ""Objectclass"" trigger (MS-SAMR 3.1.1.8.1)
  *
  * Has to be invoked on ""add"" and ""modify"" operations on ""user"", ""computer"" and
  * ""group"" objects.
  * ac->msg contains the ""add""/""modify"" message
  * ac->type contains the object type (main objectclass)
  */
 static int samldb_objectclass_trigger(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         void *skip_allocate_sids = ldb_get_opaque(ldb,
                                                   ""skip_allocate_sids"");
         struct ldb_message_element *el, *el2;
         struct dom_sid *sid;
         int ret;
 
         /* make sure that ""sAMAccountType"" is not specified */
         el = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
         if (el != NULL) {
                 ldb_set_errstring(ldb,
                                   ""samldb: sAMAccountType must not be specified!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Step 1: objectSid assignment */
 
         /* Don't allow the objectSid to be changed. But beside the RELAX
          * control we have also to guarantee that it can always be set with
          * SYSTEM permissions. This is needed for the ""samba3sam"" backend. */
         sid = samdb_result_dom_sid(ac, ac->msg, ""objectSid"");
         if ((sid != NULL) && (!dsdb_module_am_system(ac->module)) &&
             (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {
                 ldb_set_errstring(ldb,
                                   ""samldb: objectSid must not be specified!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* but generate a new SID when we do have an add operations */
         if ((sid == NULL) && (ac->req->operation == LDB_ADD) && !skip_allocate_sids) {
                 ret = samldb_add_step(ac, samldb_allocate_sid);
                 if (ret != LDB_SUCCESS) return ret;
         }
 
         switch(ac->type) {
         case SAMLDB_TYPE_USER: {
                 bool uac_generated = false, uac_add_flags = false;
 
                 /* Step 1.2: Default values */
                 ret = dsdb_user_obj_set_defaults(ldb, ac->msg);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* On add operations we might need to generate a
                  * ""userAccountControl"" (if it isn't specified). */
                 el = ldb_msg_find_element(ac->msg, ""userAccountControl"");
                 if ((el == NULL) && (ac->req->operation == LDB_ADD)) {
                         ret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,
                                                  ""userAccountControl"",
                                                  UF_NORMAL_ACCOUNT);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                         uac_generated = true;
                         uac_add_flags = true;
                 }
 
                 el = ldb_msg_find_element(ac->msg, ""userAccountControl"");
                 if (el != NULL) {
                         uint32_t user_account_control;
                         /* Step 1.3: ""userAccountControl"" -> ""sAMAccountType"" mapping */
                         user_account_control = ldb_msg_find_attr_as_uint(ac->msg,
                                                                          ""userAccountControl"",
                                                                          0);
                         /*
                          * ""userAccountControl"" = 0 or missing one of
                          * the types means ""UF_NORMAL_ACCOUNT"".  See
                          * MS-SAMR 3.1.1.8.10 point 8
                          */
                         if ((user_account_control & UF_ACCOUNT_TYPE_MASK) == 0) {
                                 user_account_control = UF_NORMAL_ACCOUNT | user_account_control;
                                 uac_generated = true;
                         }
 
                         /*
                          * As per MS-SAMR 3.1.1.8.10 these flags have not to be set
                          */
                         if ((user_account_control & UF_LOCKOUT) != 0) {
                                 user_account_control &= ~UF_LOCKOUT;
                                 uac_generated = true;
                         }
                         if ((user_account_control & UF_PASSWORD_EXPIRED) != 0) {
                                 user_account_control &= ~UF_PASSWORD_EXPIRED;
                                 uac_generated = true;
                         }
 
                         ret = samldb_check_user_account_control_rules(ac, NULL,
                                                                       user_account_control, 0);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
 
                         /* Workstation and (read-only) DC objects do need objectclass ""computer"" */
                         if ((samdb_find_attribute(ldb, ac->msg,
                                                   ""objectclass"", ""computer"") == NULL) &&
                             (user_account_control &
                              (UF_SERVER_TRUST_ACCOUNT | UF_WORKSTATION_TRUST_ACCOUNT))) {
                                 ldb_set_errstring(ldb,
                                                   ""samldb: Requested account type does need objectclass 'computer'!"");
                                 return LDB_ERR_OBJECT_CLASS_VIOLATION;
                         }
 
                         /* add ""sAMAccountType"" attribute */
                         ret = dsdb_user_obj_set_account_type(ldb, ac->msg, user_account_control, NULL);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
 
                         /* ""isCriticalSystemObject"" might be set */
                         if (user_account_control &
                             (UF_SERVER_TRUST_ACCOUNT | UF_PARTIAL_SECRETS_ACCOUNT)) {
                                 ret = ldb_msg_add_string(ac->msg, ""isCriticalSystemObject"",
                                                          ""TRUE"");
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                                 el2 = ldb_msg_find_element(ac->msg,
                                                            ""isCriticalSystemObject"");
                                 el2->flags = LDB_FLAG_MOD_REPLACE;
                         } else if (user_account_control & UF_WORKSTATION_TRUST_ACCOUNT) {
                                 ret = ldb_msg_add_string(ac->msg, ""isCriticalSystemObject"",
                                                          ""FALSE"");
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                                 el2 = ldb_msg_find_element(ac->msg,
                                                            ""isCriticalSystemObject"");
                                 el2->flags = LDB_FLAG_MOD_REPLACE;
                         }
 
                         /* Step 1.4: ""userAccountControl"" -> ""primaryGroupID"" mapping */
                         if (!ldb_msg_find_element(ac->msg, ""primaryGroupID"")) {
                                 uint32_t rid;
 
                                 ret = dsdb_user_obj_set_primary_group_id(ldb, ac->msg, user_account_control, &rid);
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                                 /*
                                  * Older AD deployments don't know about the
                                  * RODC group
                                  */
                                 if (rid == DOMAIN_RID_READONLY_DCS) {
                                         ret = samldb_prim_group_tester(ac, rid);
                                         if (ret != LDB_SUCCESS) {
                                                 return ret;
                                         }
                                 }
                         }
 
                         /* Step 1.5: Add additional flags when needed */
                         /* Obviously this is done when the ""userAccountControl""
                          * has been generated here (tested against Windows
                          * Server) */
                         if (uac_generated) {
                                 if (uac_add_flags) {
                                         user_account_control |= UF_ACCOUNTDISABLE;
                                         user_account_control |= UF_PASSWD_NOTREQD;
                                 }
 
                                 ret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,
                                                          ""userAccountControl"",
                                                          user_account_control);
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                         }
 
                 }
                 break;
         }
 
         case SAMLDB_TYPE_GROUP: {
                 const char *tempstr;
 
                 /* Step 2.2: Default values */
                 tempstr = talloc_asprintf(ac->msg, ""%d"",
                                           GTYPE_SECURITY_GLOBAL_GROUP);
                 if (tempstr == NULL) return ldb_operr(ldb);
                 ret = samdb_find_or_add_attribute(ldb, ac->msg,
                         ""groupType"", tempstr);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* Step 2.3: ""groupType"" -> ""sAMAccountType"" */
                 el = ldb_msg_find_element(ac->msg, ""groupType"");
                 if (el != NULL) {
                         uint32_t group_type, account_type;
 
                         group_type = ldb_msg_find_attr_as_uint(ac->msg,
                                                                ""groupType"", 0);
 
                         /* The creation of builtin groups requires the
                          * RELAX control */
                         if (group_type == GTYPE_SECURITY_BUILTIN_LOCAL_GROUP) {
                                 if (ldb_request_get_control(ac->req,
                                                             LDB_CONTROL_RELAX_OID) == NULL) {
                                         return LDB_ERR_UNWILLING_TO_PERFORM;
                                 }
                         }
 
                         account_type = ds_gtype2atype(group_type);
                         if (account_type == 0) {
                                 ldb_set_errstring(ldb, ""samldb: Unrecognized account type!"");
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                                  ""sAMAccountType"",
                                                  account_type);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                         el2 = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
                         el2->flags = LDB_FLAG_MOD_REPLACE;
                 }
                 break;
         }
 
         default:
                 ldb_asprintf_errstring(ldb,
                                 ""Invalid entry type!"");
                 return LDB_ERR_OPERATIONS_ERROR;
                 break;
         }
 
         return LDB_SUCCESS;
 }
 
 /*
  * ""Primary group ID"" trigger (MS-SAMR 3.1.1.8.2)
  *
  * Has to be invoked on ""add"" and ""modify"" operations on ""user"" and ""computer""
  * objects.
  * ac->msg contains the ""add""/""modify"" message
  */
 
 static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct dom_sid *sid;
         struct ldb_result *res;
         int ret;
         const char * const noattrs[] = { NULL };
 
         sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);
         if (sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE,
                                  noattrs, DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectSid=%s)"",
                                  ldap_encode_ndr_dom_sid(ac, sid));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 talloc_free(res);
                 ldb_asprintf_errstring(ldb,
                                        ""Failed to find primary group with RID %u!"",
                                        rid);
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 static int samldb_prim_group_set(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t rid;
 
         rid = ldb_msg_find_attr_as_uint(ac->msg, ""primaryGroupID"", (uint32_t) -1);
         if (rid == (uint32_t) -1) {
                 /* we aren't affected of any primary group set */
                 return LDB_SUCCESS;
 
         } else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {
                 ldb_set_errstring(ldb,
                                   ""The primary group isn't settable on add operations!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         return samldb_prim_group_tester(ac, rid);
 }
 
 static int samldb_prim_group_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const attrs[] = {
                 ""primaryGroupID"",
                 ""memberOf"",
                 ""userAccountControl"",
                 NULL };
         struct ldb_result *res, *group_res;
         struct ldb_message_element *el;
         struct ldb_message *msg;
         uint32_t prev_rid, new_rid, uac;
         struct dom_sid *prev_sid, *new_sid;
         struct ldb_dn *prev_prim_group_dn, *new_prim_group_dn;
         int ret;
         const char * const noattrs[] = { NULL };
 
         el = dsdb_get_single_valued_attr(ac->msg, ""primaryGroupID"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Fetch information from the existing object */
 
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
                                     DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         uac = ldb_msg_find_attr_as_uint(res->msgs[0], ""userAccountControl"", 0);
 
         /* Finds out the DN of the old primary group */
 
         prev_rid = ldb_msg_find_attr_as_uint(res->msgs[0], ""primaryGroupID"",
                                              (uint32_t) -1);
         if (prev_rid == (uint32_t) -1) {
                 /* User objects do always have a mandatory ""primaryGroupID""
                  * attribute. If this doesn't exist then the object is of the
                  * wrong type. This is the exact Windows error code */
                 return LDB_ERR_OBJECT_CLASS_VIOLATION;
         }
 
         prev_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), prev_rid);
         if (prev_sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* Finds out the DN of the new primary group
          * Notice: in order to parse the primary group ID correctly we create
          * a temporary message here. */
 
         msg = ldb_msg_new(ac->msg);
         if (msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         new_rid = ldb_msg_find_attr_as_uint(msg, ""primaryGroupID"", (uint32_t) -1);
         talloc_free(msg);
         if (new_rid == (uint32_t) -1) {
                 /* we aren't affected of any primary group change */
                 return LDB_SUCCESS;
         }
 
         if (prev_rid == new_rid) {
                 return LDB_SUCCESS;
         }
 
         if ((uac & UF_SERVER_TRUST_ACCOUNT) && new_rid != DOMAIN_RID_DCS) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: UF_SERVER_TRUST_ACCOUNT requires ""
                         ""primaryGroupID=%u!"",
                         W_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),
                         DOMAIN_RID_DCS);
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         if ((uac & UF_PARTIAL_SECRETS_ACCOUNT) && new_rid != DOMAIN_RID_READONLY_DCS) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT requires ""
                         ""primaryGroupID=%u!"",
                         W_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),
                         DOMAIN_RID_READONLY_DCS);
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         ret = dsdb_module_search(ac->module, ac, &group_res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE,
                                  noattrs, DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectSid=%s)"",
                                  ldap_encode_ndr_dom_sid(ac, prev_sid));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (group_res->count != 1) {
                 return ldb_operr(ldb);
         }
         prev_prim_group_dn = group_res->msgs[0]->dn;
 
         new_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), new_rid);
         if (new_sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         ret = dsdb_module_search(ac->module, ac, &group_res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE,
                                  noattrs, DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectSid=%s)"",
                                  ldap_encode_ndr_dom_sid(ac, new_sid));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (group_res->count != 1) {
                 /* Here we know if the specified new primary group candidate is
                  * valid or not. */
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
         new_prim_group_dn = group_res->msgs[0]->dn;
 
         /* We need to be already a normal member of the new primary
          * group in order to be successful. */
         el = samdb_find_attribute(ldb, res->msgs[0], ""memberOf"",
                                   ldb_dn_get_linearized(new_prim_group_dn));
         if (el == NULL) {
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Remove the ""member"" attribute on the new primary group */
         msg = ldb_msg_new(ac->msg);
         if (msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         msg->dn = new_prim_group_dn;
 
         ret = samdb_msg_add_delval(ldb, msg, msg, ""member"",
                                    ldb_dn_get_linearized(ac->msg->dn));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         ret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         talloc_free(msg);
 
         /* Add a ""member"" attribute for the previous primary group */
         msg = ldb_msg_new(ac->msg);
         if (msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         msg->dn = prev_prim_group_dn;
 
         ret = samdb_msg_add_addval(ldb, msg, msg, ""member"",
                                    ldb_dn_get_linearized(ac->msg->dn));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         ret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         talloc_free(msg);
 
         return LDB_SUCCESS;
 }
 
 static int samldb_prim_group_trigger(struct samldb_ctx *ac)
 {
         int ret;
 
         if (ac->req->operation == LDB_ADD) {
                 ret = samldb_prim_group_set(ac);
         } else {
                 ret = samldb_prim_group_change(ac);
         }
 
         return ret;
 }
 
 static int samldb_check_user_account_control_invariants(struct samldb_ctx *ac,
                                                     uint32_t user_account_control)
 {
         int i, ret = 0;
         bool need_check = false;
         const struct uac_to_guid {
                 uint32_t uac;
                 bool never;
                 uint32_t needs;
                 uint32_t not_with;
                 const char *error_string;
         } map[] = {
                 {
                         .uac = UF_TEMP_DUPLICATE_ACCOUNT,
                         .never = true,
                         .error_string = ""Updating the UF_TEMP_DUPLICATE_ACCOUNT flag is never allowed""
                 },
                 {
                         .uac = UF_PARTIAL_SECRETS_ACCOUNT,
                         .needs = UF_WORKSTATION_TRUST_ACCOUNT,
                         .error_string = ""Setting UF_PARTIAL_SECRETS_ACCOUNT only permitted with UF_WORKSTATION_TRUST_ACCOUNT""
                 },
                 {
                         .uac = UF_TRUSTED_FOR_DELEGATION,
                         .not_with = UF_PARTIAL_SECRETS_ACCOUNT,
                         .error_string = ""Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT""
                 },
                 {
                         .uac = UF_NORMAL_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_NORMAL_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_WORKSTATION_TRUST_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_INTERDOMAIN_TRUST_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_SERVER_TRUST_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_SERVER_TRUST_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_TRUSTED_FOR_DELEGATION,
                         .not_with = UF_PARTIAL_SECRETS_ACCOUNT,
                         .error_string = ""Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT""
                 }
         };
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 if (user_account_control & map[i].uac) {
                         need_check = true;
                         break;
                 }
         }
         if (need_check == false) {
                 return LDB_SUCCESS;
         }
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 uint32_t this_uac = user_account_control & map[i].uac;
                 if (this_uac != 0) {
                         if (map[i].never) {
                                 ret = LDB_ERR_OTHER;
                                 break;
                         } else if (map[i].needs != 0) {
                                 if ((map[i].needs & user_account_control) == 0) {
                                         ret = LDB_ERR_OTHER;
                                         break;
                                 }
                         } else if (map[i].not_with != 0) {
                                 if ((map[i].not_with & user_account_control) != 0) {
                                         ret = LDB_ERR_OTHER;
                                         break;
                                 }
                         }
                 }
         }
         if (ret != LDB_SUCCESS) {
                 switch (ac->req->operation) {
                 case LDB_ADD:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to add %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 case LDB_MODIFY:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to modify %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 default:
                         return ldb_module_operr(ac->module);
                 }
         }
         return ret;
 }
 
 /**
  * Validate that the restriction in point 5 of MS-SAMR 3.1.1.8.10 userAccountControl is honoured
  *
  */
 static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                                                  struct dom_sid *sid,
                                                  uint32_t user_account_control,
                                                  uint32_t user_account_control_old)
 {
         int i, ret = 0;
         bool need_acl_check = false;
         struct ldb_result *res;
         const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
         struct security_token *user_token;
         struct security_descriptor *domain_sd;
         struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
         const struct uac_to_guid {
                 uint32_t uac;
                 const char *oid;
                 const char *guid;
                 enum sec_privilege privilege;
                 bool delete_is_privileged;
                 const char *error_string;
         } map[] = {
                 {
                         .uac = UF_PASSWD_NOTREQD,
                         .guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,
                         .error_string = ""Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_DONT_EXPIRE_PASSWD,
                         .guid = GUID_DRS_UNEXPIRE_PASSWORD,
                         .error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                         .guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
                         .error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_SERVER_TRUST_ACCOUNT,
                         .guid = GUID_DRS_DS_INSTALL_REPLICA,
                         .error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_PARTIAL_SECRETS_ACCOUNT,
                         .guid = GUID_DRS_DS_INSTALL_REPLICA,
                         .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                         .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
                         .error_string = ""Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface"",
                         .delete_is_privileged = true
                 },
                 {
                         .uac = UF_TRUSTED_FOR_DELEGATION,
                         .privilege = SEC_PRIV_ENABLE_DELEGATION,
                         .delete_is_privileged = true,
                         .error_string = ""Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
                 },
                 {
                         .uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
                         .privilege = SEC_PRIV_ENABLE_DELEGATION,
                         .delete_is_privileged = true,
                         .error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
                 }
 
         };
 
         if (dsdb_module_am_system(ac->module)) {
                 return LDB_SUCCESS;
         }
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 if (user_account_control & map[i].uac) {
                         need_acl_check = true;
                         break;
                 }
         }
         if (need_acl_check == false) {
                 return LDB_SUCCESS;
         }
 
         user_token = acl_user_token(ac->module);
         if (user_token == NULL) {
                 return LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
         }
 
         ret = dsdb_module_search_dn(ac->module, ac, &res,
                                     domain_dn,
                                     sd_attrs,
                                     DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
                                     ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 return ldb_module_operr(ac->module);
         }
 
         ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
                                            ac, res->msgs[0], &domain_sd);
 
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 uint32_t this_uac_new = user_account_control & map[i].uac;
                 uint32_t this_uac_old = user_account_control_old & map[i].uac;
                 if (this_uac_new != this_uac_old) {
                         if (this_uac_old != 0) {
                                 if (map[i].delete_is_privileged == false) {
                                         continue;
                                 }
                         }
                         if (map[i].oid) {
                                 struct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);
                                 if (control == NULL) {
                                         ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                 }
                         } else if (map[i].privilege != SEC_PRIV_INVALID) {
                                 bool have_priv = security_token_has_privilege(user_token,
                                                                               map[i].privilege);
                                 if (have_priv == false) {
                                         ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                 }
                         } else {
                                 ret = acl_check_extended_right(ac, domain_sd,
                                                                user_token,
                                                                map[i].guid,
                                                                SEC_ADS_CONTROL_ACCESS,
                                                                sid);
                         }
                         if (ret != LDB_SUCCESS) {
                                 break;
                         }
                 }
         }
         if (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {
                 switch (ac->req->operation) {
                 case LDB_ADD:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to add %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 case LDB_MODIFY:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to modify %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 default:
                         return ldb_module_operr(ac->module);
                 }
                 if (map[i].guid) {
                         dsdb_acl_debug(domain_sd, acl_user_token(ac->module),
                                        domain_dn,
                                        true,
                                        10);
                 }
         }
         return ret;
 }
 
 static int samldb_check_user_account_control_rules(struct samldb_ctx *ac,
                                                    struct dom_sid *sid,
                                                    uint32_t user_account_control,
                                                    uint32_t user_account_control_old)
 {
         int ret;
         ret = samldb_check_user_account_control_invariants(ac, user_account_control);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         ret = samldb_check_user_account_control_acl(ac, sid, user_account_control, user_account_control_old);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         return ret;
 }
 
 
 /**
  * This function is called on LDB modify operations. It performs some additions/
  * replaces on the current LDB message when ""userAccountControl"" changes.
  */
 static int samldb_user_account_control_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t old_uac;
         uint32_t new_uac;
         uint32_t raw_uac;
         uint32_t old_ufa;
         uint32_t new_ufa;
         uint32_t old_uac_computed;
         uint32_t clear_uac;
         uint32_t old_atype;
         uint32_t new_atype;
         uint32_t old_pgrid;
         uint32_t new_pgrid;
         NTTIME old_lockoutTime;
         struct ldb_message_element *el;
         struct ldb_val *val;
         struct ldb_val computer_val;
         struct ldb_message *tmp_msg;
         struct dom_sid *sid;
         int ret;
         struct ldb_result *res;
         const char * const attrs[] = {
                 ""objectClass"",
                 ""isCriticalSystemObject"",
                 ""userAccountControl"",
                 ""msDS-User-Account-Control-Computed"",
                 ""lockoutTime"",
                 ""objectSid"",
                 NULL
         };
         bool is_computer = false;
         bool old_is_critical = false;
         bool new_is_critical = false;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""userAccountControl"",
                                          ac->req->operation);
         if (el == NULL || el->num_values == 0) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: 'userAccountControl' can't be deleted!"",
                         W_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Create a temporary message for fetching the ""userAccountControl"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         raw_uac = ldb_msg_find_attr_as_uint(tmp_msg,
                                             ""userAccountControl"",
                                             0);
         talloc_free(tmp_msg);
         /*
          * UF_LOCKOUT, UF_PASSWD_CANT_CHANGE and UF_PASSWORD_EXPIRED
          * are only generated and not stored. We ignore them almost
          * completely, along with unknown bits and UF_SCRIPT.
          *
          * The only exception is ACB_AUTOLOCK, which features in
          * clear_acb when the bit is cleared in this modify operation.
          *
          * MS-SAMR 2.2.1.13 UF_FLAG Codes states that some bits are
          * ignored by clients and servers
          */
         new_uac = raw_uac & UF_SETTABLE_BITS;
 
         /* Fetch the old ""userAccountControl"" and ""objectClass"" */
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
                                     DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         old_uac = ldb_msg_find_attr_as_uint(res->msgs[0], ""userAccountControl"", 0);
         if (old_uac == 0) {
                 return ldb_operr(ldb);
         }
         old_uac_computed = ldb_msg_find_attr_as_uint(res->msgs[0],
                                                      ""msDS-User-Account-Control-Computed"", 0);
         old_lockoutTime = ldb_msg_find_attr_as_int64(res->msgs[0],
                                                      ""lockoutTime"", 0);
         old_is_critical = ldb_msg_find_attr_as_bool(res->msgs[0],
                                                     ""isCriticalSystemObject"", 0);
         /* When we do not have objectclass ""computer"" we cannot switch to a (read-only) DC */
         el = ldb_msg_find_element(res->msgs[0], ""objectClass"");
         if (el == NULL) {
                 return ldb_operr(ldb);
         }
         computer_val = data_blob_string_const(""computer"");
         val = ldb_msg_find_val(el, &computer_val);
         if (val != NULL) {
                 is_computer = true;
         }
 
         old_ufa = old_uac & UF_ACCOUNT_TYPE_MASK;
         old_atype = ds_uf2atype(old_ufa);
         old_pgrid = ds_uf2prim_group_rid(old_uac);
 
         new_ufa = new_uac & UF_ACCOUNT_TYPE_MASK;
         if (new_ufa == 0) {
                 /*
                  * ""userAccountControl"" = 0 or missing one of the
                  * types means ""UF_NORMAL_ACCOUNT"".  See MS-SAMR
                  * 3.1.1.8.10 point 8
                  */
                 new_ufa = UF_NORMAL_ACCOUNT;
                 new_uac |= new_ufa;
         }
         sid = samdb_result_dom_sid(res, res->msgs[0], ""objectSid"");
         if (sid == NULL) {
                 return ldb_module_operr(ac->module);
         }
 
         ret = samldb_check_user_account_control_rules(ac, sid, new_uac, old_uac);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         new_atype = ds_uf2atype(new_ufa);
         new_pgrid = ds_uf2prim_group_rid(new_uac);
 
         clear_uac = (old_uac | old_uac_computed) & ~raw_uac;
 
         switch (new_ufa) {
         case UF_NORMAL_ACCOUNT:
                 new_is_critical = old_is_critical;
                 break;
 
         case UF_INTERDOMAIN_TRUST_ACCOUNT:
                 new_is_critical = true;
                 break;
 
         case UF_WORKSTATION_TRUST_ACCOUNT:
                 new_is_critical = false;
                 if (new_uac & UF_PARTIAL_SECRETS_ACCOUNT) {
                         if (!is_computer) {
                                 ldb_asprintf_errstring(ldb,
                                                        ""%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT ""
                                                        ""requires objectclass 'computer'!"",
                                                        W_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                         new_is_critical = true;
                 }
                 break;
 
         case UF_SERVER_TRUST_ACCOUNT:
                 if (!is_computer) {
                         ldb_asprintf_errstring(ldb,
                                 ""%08X: samldb: UF_SERVER_TRUST_ACCOUNT ""
                                 ""requires objectclass 'computer'!"",
                                 W_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
                 new_is_critical = true;
                 break;
 
         default:
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: invalid userAccountControl[0x%08X]"",
                         W_ERROR_V(WERR_INVALID_PARAMETER), raw_uac);
                 return LDB_ERR_OTHER;
         }
 
         if (old_atype != new_atype) {
                 ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                          ""sAMAccountType"", new_atype);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         /* As per MS-SAMR 3.1.1.8.10 these flags have not to be set */
         if ((clear_uac & UF_LOCKOUT) && (old_lockoutTime != 0)) {
                 /* ""pwdLastSet"" reset as password expiration has been forced  */
                 ldb_msg_remove_attr(ac->msg, ""lockoutTime"");
                 ret = samdb_msg_add_uint64(ldb, ac->msg, ac->msg, ""lockoutTime"",
                                            (NTTIME)0);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg, ""lockoutTime"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         /* ""isCriticalSystemObject"" might be set/changed */
         if (old_is_critical != new_is_critical) {
                 ret = ldb_msg_add_string(ac->msg, ""isCriticalSystemObject"",
                                          new_is_critical ? ""TRUE"": ""FALSE"");
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg,
                                            ""isCriticalSystemObject"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         if (!ldb_msg_find_element(ac->msg, ""primaryGroupID"") &&
             (old_pgrid != new_pgrid)) {
                 /* Older AD deployments don't know about the RODC group */
                 if (new_pgrid == DOMAIN_RID_READONLY_DCS) {
                         ret = samldb_prim_group_tester(ac, new_pgrid);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                 }
 
                 ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                          ""primaryGroupID"", new_pgrid);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg,
                                            ""primaryGroupID"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         /* Propagate eventual ""userAccountControl"" attribute changes */
         if (old_uac != new_uac) {
                 char *tempstr = talloc_asprintf(ac->msg, ""%d"",
                                                 new_uac);
                 if (tempstr == NULL) {
                         return ldb_module_oom(ac->module);
                 }
 
                 /* Overwrite ""userAccountControl"" correctly */
                 el = dsdb_get_single_valued_attr(ac->msg, ""userAccountControl"",
                                                  ac->req->operation);
                 el->values[0].data = (uint8_t *) tempstr;
                 el->values[0].length = strlen(tempstr);
         } else {
                 ldb_msg_remove_attr(ac->msg, ""userAccountControl"");
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_lockout_time(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         NTTIME lockoutTime;
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""lockoutTime"",
                                          ac->req->operation);
         if (el == NULL || el->num_values == 0) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: 'lockoutTime' can't be deleted!"",
                         W_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Create a temporary message for fetching the ""lockoutTime"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         lockoutTime = ldb_msg_find_attr_as_int64(tmp_msg,
                                                  ""lockoutTime"",
                                                  0);
         talloc_free(tmp_msg);
 
         if (lockoutTime != 0) {
                 return LDB_SUCCESS;
         }
 
         /* lockoutTime == 0 resets badPwdCount */
         ldb_msg_remove_attr(ac->msg, ""badPwdCount"");
         ret = samdb_msg_add_int(ldb, ac->msg, ac->msg,
                                 ""badPwdCount"", 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         el = ldb_msg_find_element(ac->msg, ""badPwdCount"");
         el->flags = LDB_FLAG_MOD_REPLACE;
 
         return LDB_SUCCESS;
 }
 
 static int samldb_group_type_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t group_type, old_group_type, account_type;
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         int ret;
         struct ldb_result *res;
         const char * const attrs[] = { ""groupType"", NULL };
 
         el = dsdb_get_single_valued_attr(ac->msg, ""groupType"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""groupType"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         group_type = ldb_msg_find_attr_as_uint(tmp_msg, ""groupType"", 0);
         talloc_free(tmp_msg);
 
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
                                     DSDB_FLAG_NEXT_MODULE |
                                     DSDB_SEARCH_SHOW_DELETED, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         old_group_type = ldb_msg_find_attr_as_uint(res->msgs[0], ""groupType"", 0);
         if (old_group_type == 0) {
                 return ldb_operr(ldb);
         }
 
         /* Group type switching isn't so easy as it seems: We can only
          * change in this directions: global <-> universal <-> local
          * On each step also the group type itself
          * (security/distribution) is variable. */
 
         if (ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID) == NULL) {
                 switch (group_type) {
                 case GTYPE_SECURITY_GLOBAL_GROUP:
                 case GTYPE_DISTRIBUTION_GLOBAL_GROUP:
                         /* change to ""universal"" allowed */
                         if ((old_group_type == GTYPE_SECURITY_DOMAIN_LOCAL_GROUP) ||
                         (old_group_type == GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP)) {
                                 ldb_set_errstring(ldb,
                                         ""samldb: Change from security/distribution local group forbidden!"");
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                 break;
 
                 case GTYPE_SECURITY_UNIVERSAL_GROUP:
                 case GTYPE_DISTRIBUTION_UNIVERSAL_GROUP:
                         /* each change allowed */
                 break;
                 case GTYPE_SECURITY_DOMAIN_LOCAL_GROUP:
                 case GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP:
                         /* change to ""universal"" allowed */
                         if ((old_group_type == GTYPE_SECURITY_GLOBAL_GROUP) ||
                         (old_group_type == GTYPE_DISTRIBUTION_GLOBAL_GROUP)) {
                                 ldb_set_errstring(ldb,
                                         ""samldb: Change from security/distribution global group forbidden!"");
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                 break;
 
                 case GTYPE_SECURITY_BUILTIN_LOCAL_GROUP:
                 default:
                         /* we don't allow this ""groupType"" values */
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 break;
                 }
         }
 
         account_type =  ds_gtype2atype(group_type);
         if (account_type == 0) {
                 ldb_set_errstring(ldb, ""samldb: Unrecognized account type!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""sAMAccountType"",
                                  account_type);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         el = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
         el->flags = LDB_FLAG_MOD_REPLACE;
 
         return LDB_SUCCESS;
 }
 
 static int samldb_sam_accountname_check(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const no_attrs[] = { NULL };
         struct ldb_result *res;
         const char *sam_accountname, *enc_str;
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""sAMAccountName"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""sAMAccountName"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         /* We must not steal the original string, it belongs to the caller! */
         sam_accountname = talloc_strdup(ac, 
                                         ldb_msg_find_attr_as_string(tmp_msg, ""sAMAccountName"", NULL));
         talloc_free(tmp_msg);
 
         if (sam_accountname == NULL) {
                 /* The ""sAMAccountName"" cannot be nothing */
                 ldb_set_errstring(ldb,
                                   ""samldb: Empty account names aren't allowed!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         enc_str = ldb_binary_encode_string(ac, sam_accountname);
         if (enc_str == NULL) {
                 return ldb_module_oom(ac->module);
         }
 
         /* Make sure that a ""sAMAccountName"" is only used once */
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE, no_attrs,
                                  DSDB_FLAG_NEXT_MODULE, ac->req,
                                  ""(sAMAccountName=%s)"", enc_str);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count > 1) {
                 return ldb_operr(ldb);
         } else if (res->count == 1) {
                 if (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""samldb: Account name (sAMAccountName) '%s' already in use!"",
                                                sam_accountname);
                         return LDB_ERR_ENTRY_ALREADY_EXISTS;
                 }
         }
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 static int samldb_member_check(struct samldb_ctx *ac)
 {
         const char * const attrs[] = { ""objectSid"", NULL };
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_message_element *el;
         struct ldb_dn *member_dn;
         struct dom_sid *sid;
         struct ldb_result *res;
         struct dom_sid *group_sid;
         unsigned int i, j;
         int ret;
 
         /* Fetch information from the existing object */
 
         ret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,
                                  DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req, NULL);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 return ldb_operr(ldb);
         }
 
         group_sid = samdb_result_dom_sid(res, res->msgs[0], ""objectSid"");
         if (group_sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* We've to walk over all modification entries and consider the ""member""
          * ones. */
         for (i = 0; i < ac->msg->num_elements; i++) {
                 if (ldb_attr_cmp(ac->msg->elements[i].name, ""member"") != 0) {
                         continue;
                 }
 
                 el = &ac->msg->elements[i];
                 for (j = 0; j < el->num_values; j++) {
                         struct ldb_result *group_res;
                         const char *group_attrs[] = { ""primaryGroupID"" , NULL };
                         uint32_t prim_group_rid;
 
                         if (LDB_FLAG_MOD_TYPE(el->flags) == LDB_FLAG_MOD_DELETE) {
                                 /* Deletes will be handled in
                                  * repl_meta_data, and deletes not
                                  * matching a member will return
                                  * LDB_ERR_UNWILLING_TO_PERFORM
                                  * there */
                                 continue;
                         }
 
                         member_dn = ldb_dn_from_ldb_val(ac, ldb,
                                                         &el->values[j]);
                         if (!ldb_dn_validate(member_dn)) {
                                 return ldb_operr(ldb);
                         }
 
                         /* Denies to add ""member""s to groups which are primary
                          * ones for them - in this case return
                          * ERR_ENTRY_ALREADY_EXISTS. */
 
                         ret = dsdb_module_search_dn(ac->module, ac, &group_res,
                                                     member_dn, group_attrs,
                                                     DSDB_FLAG_NEXT_MODULE, ac->req);
                         if (ret == LDB_ERR_NO_SUCH_OBJECT) {
                                 /* member DN doesn't exist yet */
                                 continue;
                         }
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                         prim_group_rid = ldb_msg_find_attr_as_uint(group_res->msgs[0], ""primaryGroupID"", (uint32_t)-1);
                         if (prim_group_rid == (uint32_t) -1) {
                                 /* the member hasn't to be a user account ->
                                  * therefore no check needed in this case. */
                                 continue;
                         }
 
                         sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb),
                                               prim_group_rid);
                         if (sid == NULL) {
                                 return ldb_operr(ldb);
                         }
 
                         if (dom_sid_equal(group_sid, sid)) {
                                 ldb_asprintf_errstring(ldb,
                                                        ""samldb: member %s already set via primaryGroupID %u"",
                                                        ldb_dn_get_linearized(member_dn), prim_group_rid);
                                 return LDB_ERR_ENTRY_ALREADY_EXISTS;
                         }
                 }
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 /* SAM objects have special rules regarding the ""description"" attribute on
  * modify operations. */
 static int samldb_description_check(struct samldb_ctx *ac, bool *modified)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const attrs[] = { ""objectClass"", ""description"", NULL };
         struct ldb_result *res;
         unsigned int i;
         int ret;
 
         /* Fetch information from the existing object */
         ret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,
                                  DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req,
                                  ""(|(objectclass=user)(objectclass=group)(objectclass=samDomain)(objectclass=samServer))"");
         if (ret != LDB_SUCCESS) {
                 /* don't treat it specially ... let normal error codes
                    happen from other places */
                 ldb_reset_err_string(ldb);
                 return LDB_SUCCESS;
         }
         if (res->count == 0) {
                 /* we didn't match the filter */
                 talloc_free(res);
                 return LDB_SUCCESS;
         }
 
         /* We've to walk over all modification entries and consider the
          * ""description"" ones. */
         for (i = 0; i < ac->msg->num_elements; i++) {
                 if (ldb_attr_cmp(ac->msg->elements[i].name, ""description"") == 0) {
                         ac->msg->elements[i].flags |= LDB_FLAG_INTERNAL_FORCE_SINGLE_VALUE_CHECK;
                         *modified = true;
                 }
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 /* This trigger adapts the ""servicePrincipalName"" attributes if the
  * ""dNSHostName"" and/or ""sAMAccountName"" attribute change(s) */
 static int samldb_service_principal_names_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_message_element *el = NULL, *el2 = NULL;
         struct ldb_message *msg;
         const char * const attrs[] = { ""servicePrincipalName"", NULL };
         struct ldb_result *res;
         const char *dns_hostname = NULL, *old_dns_hostname = NULL,
                    *sam_accountname = NULL, *old_sam_accountname = NULL;
         unsigned int i, j;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""dNSHostName"",
                                          ac->req->operation);
         el2 = dsdb_get_single_valued_attr(ac->msg, ""sAMAccountName"",
                                           ac->req->operation);
         if ((el == NULL) && (el2 == NULL)) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""dNSHostName"" */
         if (el != NULL) {
                 const char *dns_attrs[] = { ""dNSHostName"", NULL };
                 msg = ldb_msg_new(ac->msg);
                 if (msg == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                 ret = ldb_msg_add(msg, el, 0);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 dns_hostname = talloc_strdup(ac, 
                                              ldb_msg_find_attr_as_string(msg, ""dNSHostName"", NULL));
                 if (dns_hostname == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                         
                 talloc_free(msg);
 
                 ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn,
                                             dns_attrs, DSDB_FLAG_NEXT_MODULE, ac->req);
                 if (ret == LDB_SUCCESS) {
                         old_dns_hostname = ldb_msg_find_attr_as_string(res->msgs[0], ""dNSHostName"", NULL);
                 }
         }
 
         /* Create a temporary message for fetching the ""sAMAccountName"" */
         if (el2 != NULL) {
                 char *tempstr, *tempstr2 = NULL;
                 const char *acct_attrs[] = { ""sAMAccountName"", NULL };
 
                 msg = ldb_msg_new(ac->msg);
                 if (msg == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                 ret = ldb_msg_add(msg, el2, 0);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 tempstr = talloc_strdup(ac,
                                         ldb_msg_find_attr_as_string(msg, ""sAMAccountName"", NULL));
                 talloc_free(msg);
 
                 ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, acct_attrs,
                                             DSDB_FLAG_NEXT_MODULE, ac->req);
                 if (ret == LDB_SUCCESS) {
                         tempstr2 = talloc_strdup(ac,
                                                  ldb_msg_find_attr_as_string(res->msgs[0],
                                                                              ""sAMAccountName"", NULL));
                 }
 
 
                 /* The ""sAMAccountName"" needs some additional trimming: we need
                  * to remove the trailing ""$""s if they exist. */
                 if ((tempstr != NULL) && (tempstr[0] != '\0') &&
                     (tempstr[strlen(tempstr) - 1] == '$')) {
                         tempstr[strlen(tempstr) - 1] = '\0';
                 }
                 if ((tempstr2 != NULL) && (tempstr2[0] != '\0') &&
                     (tempstr2[strlen(tempstr2) - 1] == '$')) {
                         tempstr2[strlen(tempstr2) - 1] = '\0';
                 }
                 sam_accountname = tempstr;
                 old_sam_accountname = tempstr2;
         }
 
         if (old_dns_hostname == NULL) {
                 /* we cannot change when the old name is unknown */
                 dns_hostname = NULL;
         }
         if ((old_dns_hostname != NULL) && (dns_hostname != NULL) &&
             (strcasecmp_m(old_dns_hostname, dns_hostname) == 0)) {
                 /* The ""dNSHostName"" didn't change */
                 dns_hostname = NULL;
         }
 
         if (old_sam_accountname == NULL) {
                 /* we cannot change when the old name is unknown */
                 sam_accountname = NULL;
         }
         if ((old_sam_accountname != NULL) && (sam_accountname != NULL) &&
             (strcasecmp_m(old_sam_accountname, sam_accountname) == 0)) {
                 /* The ""sAMAccountName"" didn't change */
                 sam_accountname = NULL;
         }
 
         if ((dns_hostname == NULL) && (sam_accountname == NULL)) {
                 /* Well, there are information missing (old name(s)) or the
                  * names didn't change. We've nothing to do and can exit here */
                 return LDB_SUCCESS;
         }
 
         /* Potential ""servicePrincipalName"" changes in the same request have to
          * be handled before the update (Windows behaviour). */
         el = ldb_msg_find_element(ac->msg, ""servicePrincipalName"");
         if (el != NULL) {
                 msg = ldb_msg_new(ac->msg);
                 if (msg == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                 msg->dn = ac->msg->dn;
 
                 do {
                         ret = ldb_msg_add(msg, el, el->flags);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
 
                         ldb_msg_remove_element(ac->msg, el);
 
                         el = ldb_msg_find_element(ac->msg,
                                                   ""servicePrincipalName"");
                 } while (el != NULL);
 
                 ret = dsdb_module_modify(ac->module, msg,
                                          DSDB_FLAG_NEXT_MODULE, ac->req);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 talloc_free(msg);
         }
 
         /* Fetch the ""servicePrincipalName""s if any */
         ret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,
                                  DSDB_FLAG_NEXT_MODULE, ac->req, NULL);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if ((res->count != 1) || (res->msgs[0]->num_elements > 1)) {
                 return ldb_operr(ldb);
         }
 
         if (res->msgs[0]->num_elements == 1) {
                 /*
                  * Yes, we do have ""servicePrincipalName""s. First we update them
                  * locally, that means we do always substitute the current
                  * ""dNSHostName"" with the new one and/or ""sAMAccountName""
                  * without ""$"" with the new one and then we append the
                  * modified ""servicePrincipalName""s as a message element
                  * replace to the modification request (Windows behaviour). We
                  * need also to make sure that the values remain case-
                  * insensitively unique.
                  */
 
                 ret = ldb_msg_add_empty(ac->msg, ""servicePrincipalName"",
                                         LDB_FLAG_MOD_REPLACE, &el);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 for (i = 0; i < res->msgs[0]->elements[0].num_values; i++) {
                         char *old_str, *new_str;
                         char *pos = NULL;
                         const char *tok;
                         struct ldb_val *vals;
                         bool found = false;
 
                         old_str = (char *)
                                 res->msgs[0]->elements[0].values[i].data;
 
                         new_str = talloc_strdup(ac->msg,
                                                 strtok_r(old_str, ""/"", &pos));
                         if (new_str == NULL) {
                                 return ldb_module_oom(ac->module);
                         }
 
                         while ((tok = strtok_r(NULL, ""/"", &pos)) != NULL) {
                                 if ((dns_hostname != NULL) &&
                                     (strcasecmp_m(tok, old_dns_hostname) == 0)) {
                                         tok = dns_hostname;
                                 }
                                 if ((sam_accountname != NULL) &&
                                     (strcasecmp_m(tok, old_sam_accountname) == 0)) {
                                         tok = sam_accountname;
                                 }
 
                                 new_str = talloc_asprintf(ac->msg, ""%s/%s"",
                                                           new_str, tok);
                                 if (new_str == NULL) {
                                         return ldb_module_oom(ac->module);
                                 }
                         }
 
                         /* Uniqueness check */
                         for (j = 0; (!found) && (j < el->num_values); j++) {
                                 if (strcasecmp_m((char *)el->values[j].data,
                                                new_str) == 0) {
                                         found = true;
                                 }
                         }
                         if (found) {
                                 continue;
                         }
 
                         /*
                          * append the new ""servicePrincipalName"" -
                          * code derived from ldb_msg_add_value().
                          *
                          * Open coded to make it clear that we must
                          * append to the MOD_REPLACE el created above.
                          */
                         vals = talloc_realloc(ac->msg, el->values,
                                               struct ldb_val,
                                               el->num_values + 1);
                         if (vals == NULL) {
                                 return ldb_module_oom(ac->module);
                         }
                         el->values = vals;
                         el->values[el->num_values] = data_blob_string_const(new_str);
                         ++(el->num_values);
                 }
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 /* This checks the ""fSMORoleOwner"" attributes */
 static int samldb_fsmo_role_owner_check(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const no_attrs[] = { NULL };
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         struct ldb_dn *res_dn;
         struct ldb_result *res;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""fSMORoleOwner"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""fSMORoleOwner"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         res_dn = ldb_msg_find_attr_as_dn(ldb, ac, tmp_msg, ""fSMORoleOwner"");
         talloc_free(tmp_msg);
 
         if (res_dn == NULL) {
                 ldb_set_errstring(ldb,
                                   ""samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!"");
                 if (ac->req->operation == LDB_ADD) {
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 } else {
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
 
         /* Fetched DN has to reference a ""nTDSDSA"" entry */
         ret = dsdb_module_search(ac->module, ac, &res, res_dn, LDB_SCOPE_BASE,
                                  no_attrs,
                                  DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
                                  ac->req, ""(objectClass=nTDSDSA)"");
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 ldb_set_errstring(ldb,
                                   ""samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 
 /* add */
 static int samldb_add(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
         struct ldb_message_element *el;
         int ret;
 
         ldb = ldb_module_get_ctx(module);
         ldb_debug(ldb, LDB_DEBUG_TRACE, ""samldb_add\n"");
 
         /* do not manipulate our control entries */
         if (ldb_dn_is_special(req->op.add.message->dn)) {
                 return ldb_next_request(module, req);
         }
 
         el = ldb_msg_find_element(req->op.add.message, ""userParameters"");
         if (el != NULL && ldb_req_is_untrusted(req)) {
                 const char *reason = ""samldb_add: ""
                         ""setting userParameters is not supported over LDAP, ""
                         ""see https://bugzilla.samba.org/show_bug.cgi?id=8077"";
                 ldb_debug(ldb, LDB_DEBUG_WARNING, ""%s"", reason);
                 return ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);
         }
 
         ac = samldb_ctx_init(module, req);
         if (ac == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* build the new msg */
         ac->msg = ldb_msg_copy_shallow(ac, req->op.add.message);
         if (ac->msg == NULL) {
                 talloc_free(ac);
                 ldb_debug(ldb, LDB_DEBUG_FATAL,
                           ""samldb_add: ldb_msg_copy_shallow failed!\n"");
                 return ldb_operr(ldb);
         }
 
         el = ldb_msg_find_element(ac->msg, ""fSMORoleOwner"");
         if (el != NULL) {
                 ret = samldb_fsmo_role_owner_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""user"") != NULL) {
                 ac->type = SAMLDB_TYPE_USER;
 
                 ret = samldb_prim_group_trigger(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 ret = samldb_objectclass_trigger(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 return samldb_fill_object(ac);
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""group"") != NULL) {
                 ac->type = SAMLDB_TYPE_GROUP;
 
                 ret = samldb_objectclass_trigger(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 return samldb_fill_object(ac);
         }
 
         /* perhaps a foreignSecurityPrincipal? */
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"",
                                  ""foreignSecurityPrincipal"") != NULL) {
                 return samldb_fill_foreignSecurityPrincipal_object(ac);
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""classSchema"") != NULL) {
                 ret = samldb_schema_info_update(ac);
                 if (ret != LDB_SUCCESS) {
                         talloc_free(ac);
                         return ret;
                 }
 
                 ac->type = SAMLDB_TYPE_CLASS;
                 return samldb_fill_object(ac);
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""attributeSchema"") != NULL) {
                 ret = samldb_schema_info_update(ac);
                 if (ret != LDB_SUCCESS) {
                         talloc_free(ac);
                         return ret;
                 }
 
                 ac->type = SAMLDB_TYPE_ATTRIBUTE;
                 return samldb_fill_object(ac);
         }
 
         talloc_free(ac);
 
         /* nothing matched, go on */
         return ldb_next_request(module, req);
 }
 
 /* modify */
 static int samldb_modify(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
         struct ldb_message_element *el, *el2;
         struct ldb_control *is_undelete;
         bool modified = false;
         int ret;
 
         if (ldb_dn_is_special(req->op.mod.message->dn)) {
                 /* do not manipulate our control entries */
                 return ldb_next_request(module, req);
         }
 
         ldb = ldb_module_get_ctx(module);
 
         /*
          * we are going to need some special handling if in Undelete call.
          * Since tombstone_reanimate module will restore certain attributes,
          * we need to relax checks for: sAMAccountType, primaryGroupID
          */
         is_undelete = ldb_request_get_control(req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID);
 
         /* make sure that ""objectSid"" is not specified */
         el = ldb_msg_find_element(req->op.mod.message, ""objectSid"");
         if (el != NULL) {
                 if (ldb_request_get_control(req, LDB_CONTROL_PROVISION_OID) == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: objectSid must not be specified!"");
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
         if (is_undelete == NULL) {
                 /* make sure that ""sAMAccountType"" is not specified */
                 el = ldb_msg_find_element(req->op.mod.message, ""sAMAccountType"");
                 if (el != NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: sAMAccountType must not be specified!"");
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
         /* make sure that ""isCriticalSystemObject"" is not specified */
         el = ldb_msg_find_element(req->op.mod.message, ""isCriticalSystemObject"");
         if (el != NULL) {
                 if (ldb_request_get_control(req, LDB_CONTROL_RELAX_OID) == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: isCriticalSystemObject must not be specified!"");
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
 
         /* msDS-IntId is not allowed to be modified
          * except when modification comes from replication */
         if (ldb_msg_find_element(req->op.mod.message, ""msDS-IntId"")) {
                 if (!ldb_request_get_control(req,
                                              DSDB_CONTROL_REPLICATED_UPDATE_OID)) {
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 }
         }
 
         el = ldb_msg_find_element(req->op.mod.message, ""userParameters"");
         if (el != NULL && ldb_req_is_untrusted(req)) {
                 const char *reason = ""samldb: ""
                         ""setting userParameters is not supported over LDAP, ""
                         ""see https://bugzilla.samba.org/show_bug.cgi?id=8077"";
                 ldb_debug(ldb, LDB_DEBUG_WARNING, ""%s"", reason);
                 return ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);
         }
 
         ac = samldb_ctx_init(module, req);
         if (ac == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* build the new msg */
         ac->msg = ldb_msg_copy_shallow(ac, req->op.mod.message);
         if (ac->msg == NULL) {
                 talloc_free(ac);
                 ldb_debug(ldb, LDB_DEBUG_FATAL,
                           ""samldb_modify: ldb_msg_copy_shallow failed!\n"");
                 return ldb_operr(ldb);
         }
 
         if (is_undelete == NULL) {
                 el = ldb_msg_find_element(ac->msg, ""primaryGroupID"");
                 if (el != NULL) {
                         ret = samldb_prim_group_trigger(ac);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""userAccountControl"");
         if (el != NULL) {
                 modified = true;
                 ret = samldb_user_account_control_change(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""lockoutTime"");
         if (el != NULL) {
                 modified = true;
                 ret = samldb_lockout_time(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""groupType"");
         if (el != NULL) {
                 modified = true;
                 ret = samldb_group_type_change(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""sAMAccountName"");
         if (el != NULL) {
                 ret = samldb_sam_accountname_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""member"");
         if (el != NULL) {
                 ret = samldb_member_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""description"");
         if (el != NULL) {
                 ret = samldb_description_check(ac, &modified);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""dNSHostName"");
         el2 = ldb_msg_find_element(ac->msg, ""sAMAccountName"");
         if ((el != NULL) || (el2 != NULL)) {
                 modified = true;
                 ret = samldb_service_principal_names_change(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""fSMORoleOwner"");
         if (el != NULL) {
                 ret = samldb_fsmo_role_owner_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         if (modified) {
                 struct ldb_request *child_req;
 
                 /* Now perform the real modifications as a child request */
                 ret = ldb_build_mod_req(&child_req, ldb, ac,
                                         ac->msg,
                                         req->controls,
                                         req, dsdb_next_callback,
                                         req);
                 LDB_REQ_SET_LOCATION(child_req);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 return ldb_next_request(module, child_req);
         }
 
         talloc_free(ac);
 
         /* no change which interests us, go on */
         return ldb_next_request(module, req);
 }
 
 /* delete */
 
 static int samldb_prim_group_users_check(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb;
         struct dom_sid *sid;
         uint32_t rid;
         NTSTATUS status;
         int ret;
         struct ldb_result *res;
         const char * const attrs[] = { ""objectSid"", ""isDeleted"", NULL };
         const char * const noattrs[] = { NULL };
 
         ldb = ldb_module_get_ctx(ac->module);
 
         /* Finds out the SID/RID of the SAM object */
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->req->op.del.dn,
                                         attrs,
                                         DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
                                         ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         if (ldb_msg_check_string_attribute(res->msgs[0], ""isDeleted"", ""TRUE"")) {
                 return LDB_SUCCESS;
         }
 
         sid = samdb_result_dom_sid(ac, res->msgs[0], ""objectSid"");
         if (sid == NULL) {
                 /* No SID - it might not be a SAM object - therefore ok */
                 return LDB_SUCCESS;
         }
         status = dom_sid_split_rid(ac, sid, NULL, &rid);
         if (!NT_STATUS_IS_OK(status)) {
                 return ldb_operr(ldb);
         }
         if (rid == 0) {
                 /* Special object (security principal?) */
                 return LDB_SUCCESS;
         }
         /* do not allow deletion of well-known sids */
         if (rid < DSDB_SAMDB_MINIMUM_ALLOWED_RID &&
             (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {
                 return LDB_ERR_OTHER;
         }
 
         /* Deny delete requests from groups which are primary ones */
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE, noattrs,
                                  DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(&(primaryGroupID=%u)(objectClass=user))"", rid);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count > 0) {
                 return LDB_ERR_ENTRY_ALREADY_EXISTS;
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_delete(struct ldb_module *module, struct ldb_request *req)
 {
         struct samldb_ctx *ac;
         int ret;
 
         if (ldb_dn_is_special(req->op.del.dn)) {
                 /* do not manipulate our control entries */
                 return ldb_next_request(module, req);
         }
 
         ac = samldb_ctx_init(module, req);
         if (ac == NULL) {
                 return ldb_operr(ldb_module_get_ctx(module));
         }
 
         ret = samldb_prim_group_users_check(ac);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         talloc_free(ac);
 
         return ldb_next_request(module, req);
 }
 
 /* rename */
 
 static int check_rename_constraints(struct ldb_message *msg,
                                     struct samldb_ctx *ac,
                                     struct ldb_dn *olddn, struct ldb_dn *newdn)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_dn *dn1, *dn2, *nc_root;
         int32_t systemFlags;
         bool move_op = false;
         bool rename_op = false;
         int ret;
 
         /* Skip the checks if old and new DN are the same, or if we have the
          * relax control specified or if the returned objects is already
          * deleted and needs only to be moved for consistency. */
 
         if (ldb_dn_compare(olddn, newdn) == 0) {
                 return LDB_SUCCESS;
         }
         if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) != NULL) {
                 return LDB_SUCCESS;
         }
 
         if (ldb_msg_find_attr_as_bool(msg, ""isDeleted"", false)) {
                 /*
                  * check originating request if we are supposed
                  * to ""see"" this record in first place.
                  */
                 if (ldb_request_get_control(ac->req, LDB_CONTROL_SHOW_DELETED_OID) == NULL) {
                         return LDB_ERR_NO_SUCH_OBJECT;
                 }
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Objects under CN=System */
 
         dn1 = ldb_dn_copy(ac, ldb_get_default_basedn(ldb));
         if (dn1 == NULL) return ldb_oom(ldb);
 
         if ( ! ldb_dn_add_child_fmt(dn1, ""CN=System"")) {
                 talloc_free(dn1);
                 return LDB_ERR_OPERATIONS_ERROR;
         }
 
         if ((ldb_dn_compare_base(dn1, olddn) == 0) &&
             (ldb_dn_compare_base(dn1, newdn) != 0)) {
                 talloc_free(dn1);
                 ldb_asprintf_errstring(ldb,
                                        ""subtree_rename: Cannot move/rename %s. Objects under CN=System have to stay under it!"",
                                        ldb_dn_get_linearized(olddn));
                 return LDB_ERR_OTHER;
         }
 
         talloc_free(dn1);
 
         /* LSA objects */
 
         if ((samdb_find_attribute(ldb, msg, ""objectClass"", ""secret"") != NULL) ||
             (samdb_find_attribute(ldb, msg, ""objectClass"", ""trustedDomain"") != NULL)) {
                 ldb_asprintf_errstring(ldb,
                                        ""subtree_rename: Cannot move/rename %s. It's an LSA-specific object!"",
                                        ldb_dn_get_linearized(olddn));
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* systemFlags */
 
         dn1 = ldb_dn_get_parent(ac, olddn);
         if (dn1 == NULL) return ldb_oom(ldb);
         dn2 = ldb_dn_get_parent(ac, newdn);
         if (dn2 == NULL) return ldb_oom(ldb);
 
         if (ldb_dn_compare(dn1, dn2) == 0) {
                 rename_op = true;
         } else {
                 move_op = true;
         }
 
         talloc_free(dn1);
         talloc_free(dn2);
 
         systemFlags = ldb_msg_find_attr_as_int(msg, ""systemFlags"", 0);
 
         /* Fetch name context */
 
         ret = dsdb_find_nc_root(ldb, ac, olddn, &nc_root);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         if (ldb_dn_compare(nc_root, ldb_get_schema_basedn(ldb)) == 0) {
                 if (move_op) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot move %s within schema partition"",
                                                ldb_dn_get_linearized(olddn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
                 if (rename_op &&
                     (systemFlags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot rename %s within schema partition"",
                                                ldb_dn_get_linearized(olddn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         } else if (ldb_dn_compare(nc_root, ldb_get_config_basedn(ldb)) == 0) {
                 if (move_op &&
                     (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_MOVE) == 0) {
                         /* Here we have to do more: control the
                          * ""ALLOW_LIMITED_MOVE"" flag. This means that the
                          * grand-grand-parents of two objects have to be equal
                          * in order to perform the move (this is used for
                          * moving ""server"" objects in the ""sites"" container). */
                         bool limited_move =
                                 systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_LIMITED_MOVE;
 
                         if (limited_move) {
                                 dn1 = ldb_dn_copy(ac, olddn);
                                 if (dn1 == NULL) return ldb_oom(ldb);
                                 dn2 = ldb_dn_copy(ac, newdn);
                                 if (dn2 == NULL) return ldb_oom(ldb);
 
                                 limited_move &= ldb_dn_remove_child_components(dn1, 3);
                                 limited_move &= ldb_dn_remove_child_components(dn2, 3);
                                 limited_move &= ldb_dn_compare(dn1, dn2) == 0;
 
                                 talloc_free(dn1);
                                 talloc_free(dn2);
                         }
 
                         if (!limited_move
                             && ldb_request_get_control(ac->req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID) == NULL) {
                                 ldb_asprintf_errstring(ldb,
                                                        ""subtree_rename: Cannot move %s to %s in config partition"",
                                                        ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                 }
                 if (rename_op &&
                     (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_RENAME) == 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot rename %s to %s within config partition"",
                                                ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         } else if (ldb_dn_compare(nc_root, ldb_get_default_basedn(ldb)) == 0) {
                 if (move_op &&
                     (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_MOVE) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot move %s to %s - DISALLOW_MOVE set"",
                                                ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
                 if (rename_op &&
                     (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_RENAME) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                        ""subtree_rename: Cannot rename %s to %s - DISALLOW_RENAME set"",
                                                ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
 
         talloc_free(nc_root);
 
         return LDB_SUCCESS;
 }
 
 
 static int samldb_rename_search_base_callback(struct ldb_request *req,
                                                struct ldb_reply *ares)
 {
         struct samldb_ctx *ac;
         int ret;
 
         ac = talloc_get_type(req->context, struct samldb_ctx);
 
         if (!ares) {
                 return ldb_module_done(ac->req, NULL, NULL,
                                         LDB_ERR_OPERATIONS_ERROR);
         }
         if (ares->error != LDB_SUCCESS) {
                 return ldb_module_done(ac->req, ares->controls,
                                         ares->response, ares->error);
         }
 
         switch (ares->type) {
         case LDB_REPLY_ENTRY:
                 /*
                  * This is the root entry of the originating move
                  * respectively rename request. It has been already
                  * stored in the list using ""subtree_rename_search()"".
                  * Only this one is subject to constraint checking.
                  */
                 ret = check_rename_constraints(ares->message, ac,
                                                ac->req->op.rename.olddn,
                                                ac->req->op.rename.newdn);
                 if (ret != LDB_SUCCESS) {
                         return ldb_module_done(ac->req, NULL, NULL,
                                                ret);
                 }
                 break;
 
         case LDB_REPLY_REFERRAL:
                 /* ignore */
                 break;
 
         case LDB_REPLY_DONE:
 
                 /*
                  * Great, no problem with the rename, so go ahead as
                  * if we never were here
                  */
                 ret = ldb_next_request(ac->module, ac->req);
                 talloc_free(ares);
                 return ret;
         }
 
         talloc_free(ares);
         return LDB_SUCCESS;
 }
 
 
 /* rename */
 static int samldb_rename(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb;
         static const char * const attrs[] = { ""objectClass"", ""systemFlags"",
                                               ""isDeleted"", NULL };
         struct ldb_request *search_req;
         struct samldb_ctx *ac;
         int ret;
 
         if (ldb_dn_is_special(req->op.rename.olddn)) { /* do not manipulate our control entries */
                 return ldb_next_request(module, req);
         }
 
         ldb = ldb_module_get_ctx(module);
 
         ac = samldb_ctx_init(module, req);
         if (!ac) {
                 return ldb_oom(ldb);
         }
 
         ret = ldb_build_search_req(&search_req, ldb, ac,
                                    req->op.rename.olddn,
                                    LDB_SCOPE_BASE,
                                    ""(objectClass=*)"",
                                    attrs,
                                    NULL,
                                    ac,
                                    samldb_rename_search_base_callback,
                                    req);
         LDB_REQ_SET_LOCATION(search_req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         ret = ldb_request_add_control(search_req, LDB_CONTROL_SHOW_RECYCLED_OID,
                                       true, NULL);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         return ldb_next_request(ac->module, search_req);
 }
 
 /* extended */
 
 static int samldb_extended_allocate_rid_pool(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(module);
         struct dsdb_fsmo_extended_op *exop;
         int ret;
 
         exop = talloc_get_type(req->op.extended.data,
                                struct dsdb_fsmo_extended_op);
         if (!exop) {
                 ldb_set_errstring(ldb,
                                   ""samldb_extended_allocate_rid_pool: invalid extended data"");
                 return LDB_ERR_PROTOCOL_ERROR;
         }
 
         ret = ridalloc_allocate_rid_pool_fsmo(module, exop, req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         return ldb_module_done(req, NULL, NULL, LDB_SUCCESS);
 }
 
 static int samldb_extended(struct ldb_module *module, struct ldb_request *req)
 {
         if (strcmp(req->op.extended.oid, DSDB_EXTENDED_ALLOCATE_RID_POOL) == 0) {
                 return samldb_extended_allocate_rid_pool(module, req);
         }
 
         return ldb_next_request(module, req);
 }
 
 
 static const struct ldb_module_ops ldb_samldb_module_ops = {
         .name          = ""samldb"",
         .add           = samldb_add,
         .modify        = samldb_modify,
         .del           = samldb_delete,
         .rename        = samldb_rename,
         .extended      = samldb_extended
 };
 
 
 int ldb_samldb_module_init(const char *version)
 {
         LDB_MODULE_CHECK_VERSION(version);
         return ldb_register_module(&ldb_samldb_module_ops);
 }
"," /*
    SAM ldb module
 
    Copyright (C) Andrew Bartlett <abartlet@samba.org> 2005-2014
    Copyright (C) Simo Sorce  2004-2008
    Copyright (C) Matthias Dieter Wallnöfer 2009-2011
    Copyright (C) Matthieu Patou 2012
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 /*
  *  Name: ldb
  *
  *  Component: ldb samldb module
  *
  *  Description: various internal DSDB triggers - most for SAM specific objects
  *
  *  Author: Simo Sorce
  */
 
 #include ""includes.h""
 #include ""libcli/ldap/ldap_ndr.h""
 #include ""ldb_module.h""
 #include ""auth/auth.h""
 #include ""dsdb/samdb/samdb.h""
 #include ""dsdb/samdb/ldb_modules/util.h""
 #include ""dsdb/samdb/ldb_modules/ridalloc.h""
 #include ""libcli/security/security.h""
 #include ""librpc/gen_ndr/ndr_security.h""
 #include ""ldb_wrap.h""
 #include ""param/param.h""
 #include ""libds/common/flag_mapping.h""
 
 struct samldb_ctx;
 enum samldb_add_type {
         SAMLDB_TYPE_USER,
         SAMLDB_TYPE_GROUP,
         SAMLDB_TYPE_CLASS,
         SAMLDB_TYPE_ATTRIBUTE
 };
 
 typedef int (*samldb_step_fn_t)(struct samldb_ctx *);
 
 struct samldb_step {
         struct samldb_step *next;
         samldb_step_fn_t fn;
 };
 
 struct samldb_ctx {
         struct ldb_module *module;
         struct ldb_request *req;
 
         /* used for add operations */
         enum samldb_add_type type;
 
         /* the resulting message */
         struct ldb_message *msg;
 
         /* used in ""samldb_find_for_defaultObjectCategory"" */
         struct ldb_dn *dn, *res_dn;
 
         /* all the async steps necessary to complete the operation */
         struct samldb_step *steps;
         struct samldb_step *curstep;
 
         /* If someone set an ares to forward controls and response back to the caller */
         struct ldb_reply *ares;
 };
 
 static struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,
                                           struct ldb_request *req)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
 
         ldb = ldb_module_get_ctx(module);
 
         ac = talloc_zero(req, struct samldb_ctx);
         if (ac == NULL) {
                 ldb_oom(ldb);
                 return NULL;
         }
 
         ac->module = module;
         ac->req = req;
 
         return ac;
 }
 
 static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)
 {
         struct samldb_step *step, *stepper;
 
         step = talloc_zero(ac, struct samldb_step);
         if (step == NULL) {
                 return ldb_oom(ldb_module_get_ctx(ac->module));
         }
 
         step->fn = fn;
 
         if (ac->steps == NULL) {
                 ac->steps = step;
                 ac->curstep = step;
         } else {
                 if (ac->curstep == NULL)
                         return ldb_operr(ldb_module_get_ctx(ac->module));
                 for (stepper = ac->curstep; stepper->next != NULL;
                         stepper = stepper->next);
                 stepper->next = step;
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_first_step(struct samldb_ctx *ac)
 {
         if (ac->steps == NULL) {
                 return ldb_operr(ldb_module_get_ctx(ac->module));
         }
 
         ac->curstep = ac->steps;
         return ac->curstep->fn(ac);
 }
 
 static int samldb_next_step(struct samldb_ctx *ac)
 {
         if (ac->curstep->next) {
                 ac->curstep = ac->curstep->next;
                 return ac->curstep->fn(ac);
         }
 
         /* We exit the samldb module here. If someone set an ""ares"" to forward
          * controls and response back to the caller, use them. */
         if (ac->ares) {
                 return ldb_module_done(ac->req, ac->ares->controls,
                                        ac->ares->response, LDB_SUCCESS);
         } else {
                 return ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);
         }
 }
 
 
 /* sAMAccountName handling */
 
 static int samldb_generate_sAMAccountName(struct ldb_context *ldb,
                                           struct ldb_message *msg)
 {
         char *name;
 
         /* Format: $000000-000000000000 */
 
         name = talloc_asprintf(msg, ""$%.6X-%.6X%.6X"",
                                 (unsigned int)generate_random(),
                                 (unsigned int)generate_random(),
                                 (unsigned int)generate_random());
         if (name == NULL) {
                 return ldb_oom(ldb);
         }
         return ldb_msg_add_steal_string(msg, ""sAMAccountName"", name);
 }
 
 static int samldb_check_sAMAccountName(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char *name;
         int ret;
         struct ldb_result *res;
         const char * const noattrs[] = { NULL };
 
         if (ldb_msg_find_element(ac->msg, ""sAMAccountName"") == NULL) {
                 ret = samldb_generate_sAMAccountName(ldb, ac->msg);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         name = ldb_msg_find_attr_as_string(ac->msg, ""sAMAccountName"", NULL);
         if (name == NULL) {
                 /* The ""sAMAccountName"" cannot be nothing */
                 ldb_set_errstring(ldb,
                                   ""samldb: Empty account names aren't allowed!"");
                 return LDB_ERR_CONSTRAINT_VIOLATION;
         }
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs,
                                  DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(sAMAccountName=%s)"",
                                  ldb_binary_encode_string(ac, name));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 0) {
                 ldb_asprintf_errstring(ldb,
                                        ""samldb: Account name (sAMAccountName) '%s' already in use!"",
                                        name);
                 talloc_free(res);
                 return LDB_ERR_ENTRY_ALREADY_EXISTS;
         }
         talloc_free(res);
 
         return samldb_next_step(ac);
 }
 
 
 static bool samldb_msg_add_sid(struct ldb_message *msg,
                                 const char *name,
                                 const struct dom_sid *sid)
 {
         struct ldb_val v;
         enum ndr_err_code ndr_err;
 
         ndr_err = ndr_push_struct_blob(&v, msg, sid,
                                        (ndr_push_flags_fn_t)ndr_push_dom_sid);
         if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
                 return false;
         }
         return (ldb_msg_add_value(msg, name, &v, NULL) == 0);
 }
 
 
 /* allocate a SID using our RID Set */
 static int samldb_allocate_sid(struct samldb_ctx *ac)
 {
         uint32_t rid;
         struct dom_sid *sid;
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         int ret;
 
         ret = ridalloc_allocate_rid(ac->module, &rid, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);
         if (sid == NULL) {
                 return ldb_module_oom(ac->module);
         }
 
         if ( ! samldb_msg_add_sid(ac->msg, ""objectSid"", sid)) {
                 return ldb_operr(ldb);
         }
 
         return samldb_next_step(ac);
 }
 
 /*
   see if a krbtgt_number is available
  */
 static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,
                                           uint32_t krbtgt_number)
 {
         TALLOC_CTX *tmp_ctx = talloc_new(ac);
         struct ldb_result *res;
         const char * const no_attrs[] = { NULL };
         int ret;
 
         ret = dsdb_module_search(ac->module, tmp_ctx, &res,
                                  ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),
                                  LDB_SCOPE_SUBTREE, no_attrs,
                                  DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(msDC-SecondaryKrbTgtNumber=%u)"",
                                  krbtgt_number);
         if (ret == LDB_SUCCESS && res->count == 0) {
                 talloc_free(tmp_ctx);
                 return true;
         }
         talloc_free(tmp_ctx);
         return false;
 }
 
 /* special handling for add in RODC join */
 static int samldb_rodc_add(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t krbtgt_number, i_start, i;
         int ret;
         char *newpass;
         struct ldb_val newpass_utf16;
 
         /* find a unused msDC-SecondaryKrbTgtNumber */
         i_start = generate_random() & 0xFFFF;
         if (i_start == 0) {
                 i_start = 1;
         }
 
         for (i=i_start; i<=0xFFFF; i++) {
                 if (samldb_krbtgtnumber_available(ac, i)) {
                         krbtgt_number = i;
                         goto found;
                 }
         }
         for (i=1; i<i_start; i++) {
                 if (samldb_krbtgtnumber_available(ac, i)) {
                         krbtgt_number = i;
                         goto found;
                 }
         }
 
         ldb_asprintf_errstring(ldb,
                                ""%08X: Unable to find available msDS-SecondaryKrbTgtNumber"",
                                W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));
         return LDB_ERR_OTHER;
 
 found:
         ret = ldb_msg_add_empty(ac->msg, ""msDS-SecondaryKrbTgtNumber"",
                                 LDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                  ""msDS-SecondaryKrbTgtNumber"", krbtgt_number);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         ret = ldb_msg_add_fmt(ac->msg, ""sAMAccountName"", ""krbtgt_%u"",
                               krbtgt_number);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         newpass = generate_random_password(ac->msg, 128, 255);
         if (newpass == NULL) {
                 return ldb_operr(ldb);
         }
 
         if (!convert_string_talloc(ac,
                                    CH_UNIX, CH_UTF16,
                                    newpass, strlen(newpass),
                                    (void *)&newpass_utf16.data,
                                    &newpass_utf16.length)) {
                 ldb_asprintf_errstring(ldb,
                                        ""samldb_rodc_add: ""
                                        ""failed to generate UTF16 password from random password"");
                 return LDB_ERR_OPERATIONS_ERROR;
         }
         ret = ldb_msg_add_steal_value(ac->msg, ""clearTextPassword"", &newpass_utf16);
         if (ret != LDB_SUCCESS) {
                 return ldb_operr(ldb);
         }
 
         return samldb_next_step(ac);
 }
 
 static int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_result *res;
         const char * const no_attrs[] = { NULL };
         int ret;
 
         ac->res_dn = NULL;
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ac->dn, LDB_SCOPE_BASE, no_attrs,
                                  DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT
                                  | DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectClass=classSchema)"");
         if (ret == LDB_ERR_NO_SUCH_OBJECT) {
                 /* Don't be pricky when the DN doesn't exist if we have the */
                 /* RELAX control specified */
                 if (ldb_request_get_control(ac->req,
                                             LDB_CONTROL_RELAX_OID) == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb_find_defaultObjectCategory: ""
                                           ""Invalid DN for 'defaultObjectCategory'!"");
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 }
         }
         if ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {
                 return ret;
         }
 
         if (ret == LDB_SUCCESS) {
                 /* ensure the defaultObjectCategory has a full GUID */
                 struct ldb_message *m;
                 m = ldb_msg_new(ac->msg);
                 if (m == NULL) {
                         return ldb_oom(ldb);
                 }
                 m->dn = ac->msg->dn;
                 if (ldb_msg_add_string(m, ""defaultObjectCategory"",
                                        ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=
                     LDB_SUCCESS) {
                         return ldb_oom(ldb);
                 }
                 m->elements[0].flags = LDB_FLAG_MOD_REPLACE;
 
                 ret = dsdb_module_modify(ac->module, m,
                                          DSDB_FLAG_NEXT_MODULE,
                                          ac->req);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
 
         ac->res_dn = ac->dn;
 
         return samldb_next_step(ac);
 }
 
 /**
  * msDS-IntId attributeSchema attribute handling
  * during LDB_ADD request processing
  */
 static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)
 {
         int ret;
         bool id_exists;
         uint32_t msds_intid;
         int32_t system_flags;
         struct ldb_context *ldb;
         struct ldb_result *ldb_res;
         struct ldb_dn *schema_dn;
         struct samldb_msds_intid_persistant *msds_intid_struct;
         struct dsdb_schema *schema;
 
         ldb = ldb_module_get_ctx(ac->module);
         schema_dn = ldb_get_schema_basedn(ldb);
 
         /* replicated update should always go through */
         if (ldb_request_get_control(ac->req,
                                     DSDB_CONTROL_REPLICATED_UPDATE_OID)) {
                 return LDB_SUCCESS;
         }
 
         /* msDS-IntId is handled by system and should never be
          * passed by clients */
         if (ldb_msg_find_element(ac->msg, ""msDS-IntId"")) {
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* do not generate msDS-IntId if Relax control is passed */
         if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {
                 return LDB_SUCCESS;
         }
 
         /* check Functional Level */
         if (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {
                 return LDB_SUCCESS;
         }
 
         /* check systemFlags for SCHEMA_BASE_OBJECT flag */
         system_flags = ldb_msg_find_attr_as_int(ac->msg, ""systemFlags"", 0);
         if (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {
                 return LDB_SUCCESS;
         }
         schema = dsdb_get_schema(ldb, NULL);
         if (!schema) {
                 ldb_debug_set(ldb, LDB_DEBUG_FATAL,
                               ""samldb_schema_info_update: no dsdb_schema loaded"");
                 DEBUG(0,(__location__ "": %s\n"", ldb_errstring(ldb)));
                 return ldb_operr(ldb);
         }
 
         msds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);
         if (!msds_intid_struct) {
                 msds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);
                 /* Generate new value for msDs-IntId
                 * Value should be in 0x80000000..0xBFFFFFFF range */
                 msds_intid = generate_random() % 0X3FFFFFFF;
                 msds_intid += 0x80000000;
                 msds_intid_struct->msds_intid = msds_intid;
                 msds_intid_struct->usn = schema->loaded_usn;
                 DEBUG(2, (""No samldb_msds_intid_persistant struct, allocating a new one\n""));
         } else {
                 msds_intid = msds_intid_struct->msds_intid;
         }
 
         /* probe id values until unique one is found */
         do {
                 uint64_t current_usn;
                 msds_intid++;
                 if (msds_intid > 0xBFFFFFFF) {
                         msds_intid = 0x80000001;
                 }
                 /*
                  * Alternative strategy to a costly (even indexed search) to the
                  * database.
                  * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because
                  * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).
                  * If so generate another random value.
                  * If not check if the highest USN in the database for the schema partition is the
                  * one that we know.
                  * If so it means that's only this ldb context that is touching the schema in the database.
                  * If not it means that's someone else has modified the database while we are doing our changes too
                  * (this case should be very bery rare) in order to be sure do the search in the database.
                  */
                 if (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {
                         msds_intid = generate_random() % 0X3FFFFFFF;
                         msds_intid += 0x80000000;
                         continue;
                 }
 
                 ret = dsdb_module_load_partition_usn(ac->module, schema_dn,
                                                      &current_usn, NULL, NULL);
                 if (ret != LDB_SUCCESS) {
                         ldb_debug_set(ldb, LDB_DEBUG_ERROR,
                                       __location__"": Searching for schema USN failed: %s\n"",
                                       ldb_errstring(ldb));
                         return ldb_operr(ldb);
                 }
 
                 /* current_usn can be lesser than msds_intid_struct-> if there is
                  * uncommited changes.
                  */
                 if (current_usn > msds_intid_struct->usn) {
                         /* oups something has changed, someone/something
                          * else is modifying or has modified the schema
                          * we'd better check this intid is the database directly
                          */
 
                         DEBUG(2, (""Schema has changed, searching the database for the unicity of %d\n"",
                                         msds_intid));
 
                         ret = dsdb_module_search(ac->module, ac,
                                                 &ldb_res,
                                                 schema_dn, LDB_SCOPE_ONELEVEL, NULL,
                                                 DSDB_FLAG_NEXT_MODULE,
                                                 ac->req,
                                                 ""(msDS-IntId=%d)"", msds_intid);
                         if (ret != LDB_SUCCESS) {
                                 ldb_debug_set(ldb, LDB_DEBUG_ERROR,
                                         __location__"": Searching for msDS-IntId=%d failed - %s\n"",
                                         msds_intid,
                                         ldb_errstring(ldb));
                                 return ldb_operr(ldb);
                         }
                         id_exists = (ldb_res->count > 0);
                         talloc_free(ldb_res);
                 } else {
                         id_exists = 0;
                 }
 
         } while(id_exists);
         msds_intid_struct->msds_intid = msds_intid;
         ldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);
 
         return samdb_msg_add_int(ldb, ac->msg, ac->msg, ""msDS-IntId"",
                                  msds_intid);
 }
 
 
 /*
  * samldb_add_entry (async)
  */
 
 static int samldb_add_entry_callback(struct ldb_request *req,
                                         struct ldb_reply *ares)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
         int ret;
 
         ac = talloc_get_type(req->context, struct samldb_ctx);
         ldb = ldb_module_get_ctx(ac->module);
 
         if (!ares) {
                 return ldb_module_done(ac->req, NULL, NULL,
                                         LDB_ERR_OPERATIONS_ERROR);
         }
 
         if (ares->type == LDB_REPLY_REFERRAL) {
                 return ldb_module_send_referral(ac->req, ares->referral);
         }
 
         if (ares->error != LDB_SUCCESS) {
                 return ldb_module_done(ac->req, ares->controls,
                                         ares->response, ares->error);
         }
         if (ares->type != LDB_REPLY_DONE) {
                 ldb_asprintf_errstring(ldb, ""Invalid LDB reply type %d"", ares->type);
                 return ldb_module_done(ac->req, NULL, NULL,
                                         LDB_ERR_OPERATIONS_ERROR);
         }
 
         /* The caller may wish to get controls back from the add */
         ac->ares = talloc_steal(ac, ares);
 
         ret = samldb_next_step(ac);
         if (ret != LDB_SUCCESS) {
                 return ldb_module_done(ac->req, NULL, NULL, ret);
         }
         return ret;
 }
 
 static int samldb_add_entry(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb;
         struct ldb_request *req;
         int ret;
 
         ldb = ldb_module_get_ctx(ac->module);
 
         ret = ldb_build_add_req(&req, ldb, ac,
                                 ac->msg,
                                 ac->req->controls,
                                 ac, samldb_add_entry_callback,
                                 ac->req);
         LDB_REQ_SET_LOCATION(req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         return ldb_next_request(ac->module, req);
 }
 
 /*
  * return true if msg carries an attributeSchema that is intended to be RODC
  * filtered but is also a system-critical attribute.
  */
 static bool check_rodc_critical_attribute(struct ldb_message *msg)
 {
         uint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;
 
         schemaFlagsEx = ldb_msg_find_attr_as_uint(msg, ""schemaFlagsEx"", 0);
         searchFlags = ldb_msg_find_attr_as_uint(msg, ""searchFlags"", 0);
         rodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE
                               | SEARCH_FLAG_CONFIDENTIAL);
 
         if ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&
                 ((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {
                 return true;
         } else {
                 return false;
         }
 }
 
 
 static int samldb_fill_object(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         int ret;
 
         /* Add information for the different account types */
         switch(ac->type) {
         case SAMLDB_TYPE_USER: {
                 struct ldb_control *rodc_control = ldb_request_get_control(ac->req,
                                                                            LDB_CONTROL_RODC_DCPROMO_OID);
                 if (rodc_control != NULL) {
                         /* see [MS-ADTS] 3.1.1.3.4.1.23 LDAP_SERVER_RODC_DCPROMO_OID */
                         rodc_control->critical = false;
                         ret = samldb_add_step(ac, samldb_rodc_add);
                         if (ret != LDB_SUCCESS) return ret;
                 }
 
                 /* check if we have a valid sAMAccountName */
                 ret = samldb_add_step(ac, samldb_check_sAMAccountName);
                 if (ret != LDB_SUCCESS) return ret;
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
                 break;
         }
 
         case SAMLDB_TYPE_GROUP: {
                 /* check if we have a valid sAMAccountName */
                 ret = samldb_add_step(ac, samldb_check_sAMAccountName);
                 if (ret != LDB_SUCCESS) return ret;
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
                 break;
         }
 
         case SAMLDB_TYPE_CLASS: {
                 const struct ldb_val *rdn_value, *def_obj_cat_val;
                 unsigned int v = ldb_msg_find_attr_as_uint(ac->msg, ""objectClassCategory"", -2);
 
                 /* As discussed with Microsoft through dochelp in April 2012 this is the behavior of windows*/
                 if (!ldb_msg_find_element(ac->msg, ""subClassOf"")) {
                         ret = ldb_msg_add_string(ac->msg, ""subClassOf"", ""top"");
                         if (ret != LDB_SUCCESS) return ret;
                 }
 
                 ret = samdb_find_or_add_attribute(ldb, ac->msg,
                                                   ""rdnAttId"", ""cn"");
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* do not allow to mark an attributeSchema as RODC filtered if it
                  * is system-critical */
                 if (check_rodc_critical_attribute(ac->msg)) {
                         ldb_asprintf_errstring(ldb, ""Refusing schema add of %s - cannot combine critical class with RODC filtering"",
                                                ldb_dn_get_linearized(ac->msg->dn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
 
                 rdn_value = ldb_dn_get_rdn_val(ac->msg->dn);
                 if (rdn_value == NULL) {
                         return ldb_operr(ldb);
                 }
                 if (!ldb_msg_find_element(ac->msg, ""lDAPDisplayName"")) {
                         /* the RDN has prefix ""CN"" */
                         ret = ldb_msg_add_string(ac->msg, ""lDAPDisplayName"",
                                 samdb_cn_to_lDAPDisplayName(ac->msg,
                                                             (const char *) rdn_value->data));
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 if (!ldb_msg_find_element(ac->msg, ""schemaIDGUID"")) {
                         struct GUID guid;
                         /* a new GUID */
                         guid = GUID_random();
                         ret = dsdb_msg_add_guid(ac->msg, &guid, ""schemaIDGUID"");
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 def_obj_cat_val = ldb_msg_find_ldb_val(ac->msg,
                                                        ""defaultObjectCategory"");
                 if (def_obj_cat_val != NULL) {
                         /* ""defaultObjectCategory"" has been set by the caller.
                          * Do some checks for consistency.
                          * NOTE: The real constraint check (that
                          * 'defaultObjectCategory' is the DN of the new
                          * objectclass or any parent of it) is still incomplete.
                          * For now we say that 'defaultObjectCategory' is valid
                          * if it exists and it is of objectclass ""classSchema"".
                          */
                         ac->dn = ldb_dn_from_ldb_val(ac, ldb, def_obj_cat_val);
                         if (ac->dn == NULL) {
                                 ldb_set_errstring(ldb,
                                                   ""Invalid DN for 'defaultObjectCategory'!"");
                                 return LDB_ERR_CONSTRAINT_VIOLATION;
                         }
                 } else {
                         /* ""defaultObjectCategory"" has not been set by the
                          * caller. Use the entry DN for it. */
                         ac->dn = ac->msg->dn;
 
                         ret = ldb_msg_add_string(ac->msg, ""defaultObjectCategory"",
                                                  ldb_dn_alloc_linearized(ac->msg, ac->dn));
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* Now perform the checks for the 'defaultObjectCategory'. The
                  * lookup DN was already saved in ""ac->dn"" */
                 ret = samldb_add_step(ac, samldb_find_for_defaultObjectCategory);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* -2 is not a valid objectClassCategory so it means the attribute wasn't present */
                 if (v == -2) {
                         /* Windows 2003 does this*/
                         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""objectClassCategory"", 0);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                 }
                 break;
         }
 
         case SAMLDB_TYPE_ATTRIBUTE: {
                 const struct ldb_val *rdn_value;
                 struct ldb_message_element *el;
                 rdn_value = ldb_dn_get_rdn_val(ac->msg->dn);
                 if (rdn_value == NULL) {
                         return ldb_operr(ldb);
                 }
                 if (!ldb_msg_find_element(ac->msg, ""lDAPDisplayName"")) {
                         /* the RDN has prefix ""CN"" */
                         ret = ldb_msg_add_string(ac->msg, ""lDAPDisplayName"",
                                 samdb_cn_to_lDAPDisplayName(ac->msg,
                                                             (const char *) rdn_value->data));
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 /* do not allow to mark an attributeSchema as RODC filtered if it
                  * is system-critical */
                 if (check_rodc_critical_attribute(ac->msg)) {
                         ldb_asprintf_errstring(ldb,
                                                ""samldb: refusing schema add of %s - cannot combine critical attribute with RODC filtering"",
                                                ldb_dn_get_linearized(ac->msg->dn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
 
                 ret = samdb_find_or_add_attribute(ldb, ac->msg,
                                                   ""isSingleValued"", ""FALSE"");
                 if (ret != LDB_SUCCESS) return ret;
 
                 if (!ldb_msg_find_element(ac->msg, ""schemaIDGUID"")) {
                         struct GUID guid;
                         /* a new GUID */
                         guid = GUID_random();
                         ret = dsdb_msg_add_guid(ac->msg, &guid, ""schemaIDGUID"");
                         if (ret != LDB_SUCCESS) {
                                 ldb_oom(ldb);
                                 return ret;
                         }
                 }
 
                 el = ldb_msg_find_element(ac->msg, ""attributeSyntax"");
                 if (el) {
                         /*
                          * No need to scream if there isn't as we have code later on
                          * that will take care of it.
                          */
                         const struct dsdb_syntax *syntax = find_syntax_map_by_ad_oid((const char *)el->values[0].data);
                         if (!syntax) {
                                 DEBUG(9, (""Can't find dsdb_syntax object for attributeSyntax %s\n"",
                                                 (const char *)el->values[0].data));
                         } else {
                                 unsigned int v = ldb_msg_find_attr_as_uint(ac->msg, ""oMSyntax"", 0);
                                 const struct ldb_val *val = ldb_msg_find_ldb_val(ac->msg, ""oMObjectClass"");
 
                                 if (v == 0) {
                                         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""oMSyntax"", syntax->oMSyntax);
                                         if (ret != LDB_SUCCESS) {
                                                 return ret;
                                         }
                                 }
                                 if (!val) {
                                         struct ldb_val val2 = ldb_val_dup(ldb, &syntax->oMObjectClass);
                                         if (val2.length > 0) {
                                                 ret = ldb_msg_add_value(ac->msg, ""oMObjectClass"", &val2, NULL);
                                                 if (ret != LDB_SUCCESS) {
                                                         return ret;
                                                 }
                                         }
                                 }
                         }
                 }
 
                 /* handle msDS-IntID attribute */
                 ret = samldb_add_handle_msDS_IntId(ac);
                 if (ret != LDB_SUCCESS) return ret;
 
                 ret = samldb_add_step(ac, samldb_add_entry);
                 if (ret != LDB_SUCCESS) return ret;
                 break;
         }
 
         default:
                 ldb_asprintf_errstring(ldb, ""Invalid entry type!"");
                 return LDB_ERR_OPERATIONS_ERROR;
                 break;
         }
 
         return samldb_first_step(ac);
 }
 
 static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb;
         const struct ldb_val *rdn_value;
         struct dom_sid *sid;
         int ret;
 
         ldb = ldb_module_get_ctx(ac->module);
 
         sid = samdb_result_dom_sid(ac->msg, ac->msg, ""objectSid"");
         if (sid == NULL) {
                 rdn_value = ldb_dn_get_rdn_val(ac->msg->dn);
                 if (rdn_value == NULL) {
                         return ldb_operr(ldb);
                 }
                 sid = dom_sid_parse_talloc(ac->msg,
                                            (const char *)rdn_value->data);
                 if (sid == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: No valid SID found in ForeignSecurityPrincipal CN!"");
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 }
                 if (! samldb_msg_add_sid(ac->msg, ""objectSid"", sid)) {
                         return ldb_operr(ldb);
                 }
         }
 
         /* finally proceed with adding the entry */
         ret = samldb_add_step(ac, samldb_add_entry);
         if (ret != LDB_SUCCESS) return ret;
 
         return samldb_first_step(ac);
 }
 
 static int samldb_schema_info_update(struct samldb_ctx *ac)
 {
         int ret;
         struct ldb_context *ldb;
         struct dsdb_schema *schema;
 
         /* replicated update should always go through */
         if (ldb_request_get_control(ac->req,
                                     DSDB_CONTROL_REPLICATED_UPDATE_OID)) {
                 return LDB_SUCCESS;
         }
 
         /* do not update schemaInfo during provisioning */
         if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {
                 return LDB_SUCCESS;
         }
 
         ldb = ldb_module_get_ctx(ac->module);
         schema = dsdb_get_schema(ldb, NULL);
         if (!schema) {
                 ldb_debug_set(ldb, LDB_DEBUG_FATAL,
                               ""samldb_schema_info_update: no dsdb_schema loaded"");
                 DEBUG(0,(__location__ "": %s\n"", ldb_errstring(ldb)));
                 return ldb_operr(ldb);
         }
 
         ret = dsdb_module_schema_info_update(ac->module, schema,
                                              DSDB_FLAG_NEXT_MODULE|
                                              DSDB_FLAG_AS_SYSTEM,
                                              ac->req);
         if (ret != LDB_SUCCESS) {
                 ldb_asprintf_errstring(ldb,
                                        ""samldb_schema_info_update: dsdb_module_schema_info_update failed with %s"",
                                        ldb_errstring(ldb));
                 return ret;
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid);
 static int samldb_check_user_account_control_rules(struct samldb_ctx *ac,
                                                    struct dom_sid *sid,
                                                    uint32_t user_account_control,
                                                    uint32_t user_account_control_old);
 
 /*
  * ""Objectclass"" trigger (MS-SAMR 3.1.1.8.1)
  *
  * Has to be invoked on ""add"" and ""modify"" operations on ""user"", ""computer"" and
  * ""group"" objects.
  * ac->msg contains the ""add""/""modify"" message
  * ac->type contains the object type (main objectclass)
  */
 static int samldb_objectclass_trigger(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         void *skip_allocate_sids = ldb_get_opaque(ldb,
                                                   ""skip_allocate_sids"");
         struct ldb_message_element *el, *el2;
         struct dom_sid *sid;
         int ret;
 
         /* make sure that ""sAMAccountType"" is not specified */
         el = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
         if (el != NULL) {
                 ldb_set_errstring(ldb,
                                   ""samldb: sAMAccountType must not be specified!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Step 1: objectSid assignment */
 
         /* Don't allow the objectSid to be changed. But beside the RELAX
          * control we have also to guarantee that it can always be set with
          * SYSTEM permissions. This is needed for the ""samba3sam"" backend. */
         sid = samdb_result_dom_sid(ac, ac->msg, ""objectSid"");
         if ((sid != NULL) && (!dsdb_module_am_system(ac->module)) &&
             (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {
                 ldb_set_errstring(ldb,
                                   ""samldb: objectSid must not be specified!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* but generate a new SID when we do have an add operations */
         if ((sid == NULL) && (ac->req->operation == LDB_ADD) && !skip_allocate_sids) {
                 ret = samldb_add_step(ac, samldb_allocate_sid);
                 if (ret != LDB_SUCCESS) return ret;
         }
 
         switch(ac->type) {
         case SAMLDB_TYPE_USER: {
                 bool uac_generated = false, uac_add_flags = false;
 
                 /* Step 1.2: Default values */
                 ret = dsdb_user_obj_set_defaults(ldb, ac->msg);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* On add operations we might need to generate a
                  * ""userAccountControl"" (if it isn't specified). */
                 el = ldb_msg_find_element(ac->msg, ""userAccountControl"");
                 if ((el == NULL) && (ac->req->operation == LDB_ADD)) {
                         ret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,
                                                  ""userAccountControl"",
                                                  UF_NORMAL_ACCOUNT);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                         uac_generated = true;
                         uac_add_flags = true;
                 }
 
                 el = ldb_msg_find_element(ac->msg, ""userAccountControl"");
                 if (el != NULL) {
                         uint32_t user_account_control;
                         /* Step 1.3: ""userAccountControl"" -> ""sAMAccountType"" mapping */
                         user_account_control = ldb_msg_find_attr_as_uint(ac->msg,
                                                                          ""userAccountControl"",
                                                                          0);
                         /*
                          * ""userAccountControl"" = 0 or missing one of
                          * the types means ""UF_NORMAL_ACCOUNT"".  See
                          * MS-SAMR 3.1.1.8.10 point 8
                          */
                         if ((user_account_control & UF_ACCOUNT_TYPE_MASK) == 0) {
                                 user_account_control = UF_NORMAL_ACCOUNT | user_account_control;
                                 uac_generated = true;
                         }
 
                         /*
                          * As per MS-SAMR 3.1.1.8.10 these flags have not to be set
                          */
                         if ((user_account_control & UF_LOCKOUT) != 0) {
                                 user_account_control &= ~UF_LOCKOUT;
                                 uac_generated = true;
                         }
                         if ((user_account_control & UF_PASSWORD_EXPIRED) != 0) {
                                 user_account_control &= ~UF_PASSWORD_EXPIRED;
                                 uac_generated = true;
                         }
 
                         ret = samldb_check_user_account_control_rules(ac, NULL,
                                                                       user_account_control, 0);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
 
                         /* Workstation and (read-only) DC objects do need objectclass ""computer"" */
                         if ((samdb_find_attribute(ldb, ac->msg,
                                                   ""objectclass"", ""computer"") == NULL) &&
                             (user_account_control &
                              (UF_SERVER_TRUST_ACCOUNT | UF_WORKSTATION_TRUST_ACCOUNT))) {
                                 ldb_set_errstring(ldb,
                                                   ""samldb: Requested account type does need objectclass 'computer'!"");
                                 return LDB_ERR_OBJECT_CLASS_VIOLATION;
                         }
 
                         /* add ""sAMAccountType"" attribute */
                         ret = dsdb_user_obj_set_account_type(ldb, ac->msg, user_account_control, NULL);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
 
                         /* ""isCriticalSystemObject"" might be set */
                         if (user_account_control &
                             (UF_SERVER_TRUST_ACCOUNT | UF_PARTIAL_SECRETS_ACCOUNT)) {
                                 ret = ldb_msg_add_string(ac->msg, ""isCriticalSystemObject"",
                                                          ""TRUE"");
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                                 el2 = ldb_msg_find_element(ac->msg,
                                                            ""isCriticalSystemObject"");
                                 el2->flags = LDB_FLAG_MOD_REPLACE;
                         } else if (user_account_control & UF_WORKSTATION_TRUST_ACCOUNT) {
                                 ret = ldb_msg_add_string(ac->msg, ""isCriticalSystemObject"",
                                                          ""FALSE"");
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                                 el2 = ldb_msg_find_element(ac->msg,
                                                            ""isCriticalSystemObject"");
                                 el2->flags = LDB_FLAG_MOD_REPLACE;
                         }
 
                         /* Step 1.4: ""userAccountControl"" -> ""primaryGroupID"" mapping */
                         if (!ldb_msg_find_element(ac->msg, ""primaryGroupID"")) {
                                 uint32_t rid;
 
                                 ret = dsdb_user_obj_set_primary_group_id(ldb, ac->msg, user_account_control, &rid);
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                                 /*
                                  * Older AD deployments don't know about the
                                  * RODC group
                                  */
                                 if (rid == DOMAIN_RID_READONLY_DCS) {
                                         ret = samldb_prim_group_tester(ac, rid);
                                         if (ret != LDB_SUCCESS) {
                                                 return ret;
                                         }
                                 }
                         }
 
                         /* Step 1.5: Add additional flags when needed */
                         /* Obviously this is done when the ""userAccountControl""
                          * has been generated here (tested against Windows
                          * Server) */
                         if (uac_generated) {
                                 if (uac_add_flags) {
                                         user_account_control |= UF_ACCOUNTDISABLE;
                                         user_account_control |= UF_PASSWD_NOTREQD;
                                 }
 
                                 ret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,
                                                          ""userAccountControl"",
                                                          user_account_control);
                                 if (ret != LDB_SUCCESS) {
                                         return ret;
                                 }
                         }
 
                 }
                 break;
         }
 
         case SAMLDB_TYPE_GROUP: {
                 const char *tempstr;
 
                 /* Step 2.2: Default values */
                 tempstr = talloc_asprintf(ac->msg, ""%d"",
                                           GTYPE_SECURITY_GLOBAL_GROUP);
                 if (tempstr == NULL) return ldb_operr(ldb);
                 ret = samdb_find_or_add_attribute(ldb, ac->msg,
                         ""groupType"", tempstr);
                 if (ret != LDB_SUCCESS) return ret;
 
                 /* Step 2.3: ""groupType"" -> ""sAMAccountType"" */
                 el = ldb_msg_find_element(ac->msg, ""groupType"");
                 if (el != NULL) {
                         uint32_t group_type, account_type;
 
                         group_type = ldb_msg_find_attr_as_uint(ac->msg,
                                                                ""groupType"", 0);
 
                         /* The creation of builtin groups requires the
                          * RELAX control */
                         if (group_type == GTYPE_SECURITY_BUILTIN_LOCAL_GROUP) {
                                 if (ldb_request_get_control(ac->req,
                                                             LDB_CONTROL_RELAX_OID) == NULL) {
                                         return LDB_ERR_UNWILLING_TO_PERFORM;
                                 }
                         }
 
                         account_type = ds_gtype2atype(group_type);
                         if (account_type == 0) {
                                 ldb_set_errstring(ldb, ""samldb: Unrecognized account type!"");
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                                  ""sAMAccountType"",
                                                  account_type);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                         el2 = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
                         el2->flags = LDB_FLAG_MOD_REPLACE;
                 }
                 break;
         }
 
         default:
                 ldb_asprintf_errstring(ldb,
                                 ""Invalid entry type!"");
                 return LDB_ERR_OPERATIONS_ERROR;
                 break;
         }
 
         return LDB_SUCCESS;
 }
 
 /*
  * ""Primary group ID"" trigger (MS-SAMR 3.1.1.8.2)
  *
  * Has to be invoked on ""add"" and ""modify"" operations on ""user"" and ""computer""
  * objects.
  * ac->msg contains the ""add""/""modify"" message
  */
 
 static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct dom_sid *sid;
         struct ldb_result *res;
         int ret;
         const char * const noattrs[] = { NULL };
 
         sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);
         if (sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE,
                                  noattrs, DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectSid=%s)"",
                                  ldap_encode_ndr_dom_sid(ac, sid));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 talloc_free(res);
                 ldb_asprintf_errstring(ldb,
                                        ""Failed to find primary group with RID %u!"",
                                        rid);
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 static int samldb_prim_group_set(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t rid;
 
         rid = ldb_msg_find_attr_as_uint(ac->msg, ""primaryGroupID"", (uint32_t) -1);
         if (rid == (uint32_t) -1) {
                 /* we aren't affected of any primary group set */
                 return LDB_SUCCESS;
 
         } else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {
                 ldb_set_errstring(ldb,
                                   ""The primary group isn't settable on add operations!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         return samldb_prim_group_tester(ac, rid);
 }
 
 static int samldb_prim_group_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const attrs[] = {
                 ""primaryGroupID"",
                 ""memberOf"",
                 ""userAccountControl"",
                 NULL };
         struct ldb_result *res, *group_res;
         struct ldb_message_element *el;
         struct ldb_message *msg;
         uint32_t prev_rid, new_rid, uac;
         struct dom_sid *prev_sid, *new_sid;
         struct ldb_dn *prev_prim_group_dn, *new_prim_group_dn;
         int ret;
         const char * const noattrs[] = { NULL };
 
         el = dsdb_get_single_valued_attr(ac->msg, ""primaryGroupID"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Fetch information from the existing object */
 
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
                                     DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         uac = ldb_msg_find_attr_as_uint(res->msgs[0], ""userAccountControl"", 0);
 
         /* Finds out the DN of the old primary group */
 
         prev_rid = ldb_msg_find_attr_as_uint(res->msgs[0], ""primaryGroupID"",
                                              (uint32_t) -1);
         if (prev_rid == (uint32_t) -1) {
                 /* User objects do always have a mandatory ""primaryGroupID""
                  * attribute. If this doesn't exist then the object is of the
                  * wrong type. This is the exact Windows error code */
                 return LDB_ERR_OBJECT_CLASS_VIOLATION;
         }
 
         prev_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), prev_rid);
         if (prev_sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* Finds out the DN of the new primary group
          * Notice: in order to parse the primary group ID correctly we create
          * a temporary message here. */
 
         msg = ldb_msg_new(ac->msg);
         if (msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         new_rid = ldb_msg_find_attr_as_uint(msg, ""primaryGroupID"", (uint32_t) -1);
         talloc_free(msg);
         if (new_rid == (uint32_t) -1) {
                 /* we aren't affected of any primary group change */
                 return LDB_SUCCESS;
         }
 
         if (prev_rid == new_rid) {
                 return LDB_SUCCESS;
         }
 
         if ((uac & UF_SERVER_TRUST_ACCOUNT) && new_rid != DOMAIN_RID_DCS) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: UF_SERVER_TRUST_ACCOUNT requires ""
                         ""primaryGroupID=%u!"",
                         W_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),
                         DOMAIN_RID_DCS);
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         if ((uac & UF_PARTIAL_SECRETS_ACCOUNT) && new_rid != DOMAIN_RID_READONLY_DCS) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT requires ""
                         ""primaryGroupID=%u!"",
                         W_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),
                         DOMAIN_RID_READONLY_DCS);
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         ret = dsdb_module_search(ac->module, ac, &group_res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE,
                                  noattrs, DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectSid=%s)"",
                                  ldap_encode_ndr_dom_sid(ac, prev_sid));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (group_res->count != 1) {
                 return ldb_operr(ldb);
         }
         prev_prim_group_dn = group_res->msgs[0]->dn;
 
         new_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), new_rid);
         if (new_sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         ret = dsdb_module_search(ac->module, ac, &group_res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE,
                                  noattrs, DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(objectSid=%s)"",
                                  ldap_encode_ndr_dom_sid(ac, new_sid));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (group_res->count != 1) {
                 /* Here we know if the specified new primary group candidate is
                  * valid or not. */
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
         new_prim_group_dn = group_res->msgs[0]->dn;
 
         /* We need to be already a normal member of the new primary
          * group in order to be successful. */
         el = samdb_find_attribute(ldb, res->msgs[0], ""memberOf"",
                                   ldb_dn_get_linearized(new_prim_group_dn));
         if (el == NULL) {
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Remove the ""member"" attribute on the new primary group */
         msg = ldb_msg_new(ac->msg);
         if (msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         msg->dn = new_prim_group_dn;
 
         ret = samdb_msg_add_delval(ldb, msg, msg, ""member"",
                                    ldb_dn_get_linearized(ac->msg->dn));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         ret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         talloc_free(msg);
 
         /* Add a ""member"" attribute for the previous primary group */
         msg = ldb_msg_new(ac->msg);
         if (msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         msg->dn = prev_prim_group_dn;
 
         ret = samdb_msg_add_addval(ldb, msg, msg, ""member"",
                                    ldb_dn_get_linearized(ac->msg->dn));
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         ret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         talloc_free(msg);
 
         return LDB_SUCCESS;
 }
 
 static int samldb_prim_group_trigger(struct samldb_ctx *ac)
 {
         int ret;
 
         if (ac->req->operation == LDB_ADD) {
                 ret = samldb_prim_group_set(ac);
         } else {
                 ret = samldb_prim_group_change(ac);
         }
 
         return ret;
 }
 
 static int samldb_check_user_account_control_invariants(struct samldb_ctx *ac,
                                                     uint32_t user_account_control)
 {
         int i, ret = 0;
         bool need_check = false;
         const struct uac_to_guid {
                 uint32_t uac;
                 bool never;
                 uint32_t needs;
                 uint32_t not_with;
                 const char *error_string;
         } map[] = {
                 {
                         .uac = UF_TEMP_DUPLICATE_ACCOUNT,
                         .never = true,
                         .error_string = ""Updating the UF_TEMP_DUPLICATE_ACCOUNT flag is never allowed""
                 },
                 {
                         .uac = UF_PARTIAL_SECRETS_ACCOUNT,
                         .needs = UF_WORKSTATION_TRUST_ACCOUNT,
                         .error_string = ""Setting UF_PARTIAL_SECRETS_ACCOUNT only permitted with UF_WORKSTATION_TRUST_ACCOUNT""
                 },
                 {
                         .uac = UF_TRUSTED_FOR_DELEGATION,
                         .not_with = UF_PARTIAL_SECRETS_ACCOUNT,
                         .error_string = ""Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT""
                 },
                 {
                         .uac = UF_NORMAL_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_NORMAL_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_WORKSTATION_TRUST_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_INTERDOMAIN_TRUST_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_SERVER_TRUST_ACCOUNT,
                         .not_with = UF_ACCOUNT_TYPE_MASK & ~UF_SERVER_TRUST_ACCOUNT,
                         .error_string = ""Setting more than one account type not permitted""
                 },
                 {
                         .uac = UF_TRUSTED_FOR_DELEGATION,
                         .not_with = UF_PARTIAL_SECRETS_ACCOUNT,
                         .error_string = ""Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT""
                 }
         };
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 if (user_account_control & map[i].uac) {
                         need_check = true;
                         break;
                 }
         }
         if (need_check == false) {
                 return LDB_SUCCESS;
         }
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 uint32_t this_uac = user_account_control & map[i].uac;
                 if (this_uac != 0) {
                         if (map[i].never) {
                                 ret = LDB_ERR_OTHER;
                                 break;
                         } else if (map[i].needs != 0) {
                                 if ((map[i].needs & user_account_control) == 0) {
                                         ret = LDB_ERR_OTHER;
                                         break;
                                 }
                         } else if (map[i].not_with != 0) {
                                 if ((map[i].not_with & user_account_control) != 0) {
                                         ret = LDB_ERR_OTHER;
                                         break;
                                 }
                         }
                 }
         }
         if (ret != LDB_SUCCESS) {
                 switch (ac->req->operation) {
                 case LDB_ADD:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to add %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 case LDB_MODIFY:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to modify %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 default:
                         return ldb_module_operr(ac->module);
                 }
         }
         return ret;
 }
 
 /**
  * Validate that the restriction in point 5 of MS-SAMR 3.1.1.8.10 userAccountControl is honoured
  *
  */
 static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                                                  struct dom_sid *sid,
                                                  uint32_t user_account_control,
                                                  uint32_t user_account_control_old)
 {
         int i, ret = 0;
         bool need_acl_check = false;
         struct ldb_result *res;
         const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
         struct security_token *user_token;
         struct security_descriptor *domain_sd;
         struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const struct uac_to_guid {
                 uint32_t uac;
                 uint32_t priv_to_change_from;
                 const char *oid;
                 const char *guid;
                 enum sec_privilege privilege;
                 bool delete_is_privileged;
                 bool admin_required;
                 const char *error_string;
         } map[] = {
                 {
                         .uac = UF_PASSWD_NOTREQD,
                         .guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,
                         .error_string = ""Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_DONT_EXPIRE_PASSWD,
                         .guid = GUID_DRS_UNEXPIRE_PASSWORD,
                         .error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                         .guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
                         .error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_SERVER_TRUST_ACCOUNT,
                         .guid = GUID_DRS_DS_INSTALL_REPLICA,
                         .error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_PARTIAL_SECRETS_ACCOUNT,
                         .guid = GUID_DRS_DS_INSTALL_REPLICA,
                         .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                 },
                 {
                         .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                         .priv_to_change_from = UF_NORMAL_ACCOUNT,
                         .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
                 },
                 {
                         .uac = UF_NORMAL_ACCOUNT,
                         .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                         .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
                 },
                 {
                         .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                         .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
                         .error_string = ""Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface"",
                         .delete_is_privileged = true
                 },
                 {
                         .uac = UF_TRUSTED_FOR_DELEGATION,
                         .privilege = SEC_PRIV_ENABLE_DELEGATION,
                         .delete_is_privileged = true,
                         .error_string = ""Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
                 },
                 {
                         .uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
                         .privilege = SEC_PRIV_ENABLE_DELEGATION,
                         .delete_is_privileged = true,
                         .error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
                 }
 
         };
 
         if (dsdb_module_am_system(ac->module)) {
                 return LDB_SUCCESS;
         }
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 if (user_account_control & map[i].uac) {
                         need_acl_check = true;
                         break;
                 }
         }
         if (need_acl_check == false) {
                 return LDB_SUCCESS;
         }
 
         user_token = acl_user_token(ac->module);
         if (user_token == NULL) {
                 return LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
         }
 
         ret = dsdb_module_search_dn(ac->module, ac, &res,
                                     domain_dn,
                                     sd_attrs,
                                     DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
                                     ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 return ldb_module_operr(ac->module);
         }
 
         ret = dsdb_get_sd_from_ldb_message(ldb,
                                            ac, res->msgs[0], &domain_sd);
 
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         for (i = 0; i < ARRAY_SIZE(map); i++) {
                 uint32_t this_uac_new = user_account_control & map[i].uac;
                 uint32_t this_uac_old = user_account_control_old & map[i].uac;
                 if (this_uac_new != this_uac_old) {
                         if (this_uac_old != 0) {
                                 if (map[i].delete_is_privileged == false) {
                                         continue;
                                 }
                         }
                         if (map[i].oid) {
                                 struct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);
                                 if (control == NULL) {
                                         ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                 }
                         } else if (map[i].privilege != SEC_PRIV_INVALID) {
                                 bool have_priv = security_token_has_privilege(user_token,
                                                                               map[i].privilege);
                                 if (have_priv == false) {
                                         ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                 }
                         } else if (map[i].priv_to_change_from & user_account_control_old) {
                                 bool is_admin = security_token_has_builtin_administrators(user_token);
                                 if (is_admin == false) {
                                         ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                 }
                         } else if (map[i].guid) {
                                 ret = acl_check_extended_right(ac, domain_sd,
                                                                user_token,
                                                                map[i].guid,
                                                                SEC_ADS_CONTROL_ACCESS,
                                                                sid);
                         } else {
                                 ret = LDB_SUCCESS;
                         }
                         if (ret != LDB_SUCCESS) {
                                 break;
                         }
                 }
         }
         if (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {
                 switch (ac->req->operation) {
                 case LDB_ADD:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to add %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 case LDB_MODIFY:
                         ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
                                                ""Failed to modify %s: %s"",
                                                ldb_dn_get_linearized(ac->msg->dn),
                                                map[i].error_string);
                         break;
                 default:
                         return ldb_module_operr(ac->module);
                 }
                 if (map[i].guid) {
                         dsdb_acl_debug(domain_sd, acl_user_token(ac->module),
                                        domain_dn,
                                        true,
                                        10);
                 }
         }
         return ret;
 }
 
 static int samldb_check_user_account_control_rules(struct samldb_ctx *ac,
                                                    struct dom_sid *sid,
                                                    uint32_t user_account_control,
                                                    uint32_t user_account_control_old)
 {
         int ret;
         ret = samldb_check_user_account_control_invariants(ac, user_account_control);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         ret = samldb_check_user_account_control_acl(ac, sid, user_account_control, user_account_control_old);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         return ret;
 }
 
 
 /**
  * This function is called on LDB modify operations. It performs some additions/
  * replaces on the current LDB message when ""userAccountControl"" changes.
  */
 static int samldb_user_account_control_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t old_uac;
         uint32_t new_uac;
         uint32_t raw_uac;
         uint32_t old_ufa;
         uint32_t new_ufa;
         uint32_t old_uac_computed;
         uint32_t clear_uac;
         uint32_t old_atype;
         uint32_t new_atype;
         uint32_t old_pgrid;
         uint32_t new_pgrid;
         NTTIME old_lockoutTime;
         struct ldb_message_element *el;
         struct ldb_val *val;
         struct ldb_val computer_val;
         struct ldb_message *tmp_msg;
         struct dom_sid *sid;
         int ret;
         struct ldb_result *res;
         const char * const attrs[] = {
                 ""objectClass"",
                 ""isCriticalSystemObject"",
                 ""userAccountControl"",
                 ""msDS-User-Account-Control-Computed"",
                 ""lockoutTime"",
                 ""objectSid"",
                 NULL
         };
         bool is_computer = false;
         bool old_is_critical = false;
         bool new_is_critical = false;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""userAccountControl"",
                                          ac->req->operation);
         if (el == NULL || el->num_values == 0) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: 'userAccountControl' can't be deleted!"",
                         W_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Create a temporary message for fetching the ""userAccountControl"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         raw_uac = ldb_msg_find_attr_as_uint(tmp_msg,
                                             ""userAccountControl"",
                                             0);
         talloc_free(tmp_msg);
         /*
          * UF_LOCKOUT, UF_PASSWD_CANT_CHANGE and UF_PASSWORD_EXPIRED
          * are only generated and not stored. We ignore them almost
          * completely, along with unknown bits and UF_SCRIPT.
          *
          * The only exception is ACB_AUTOLOCK, which features in
          * clear_acb when the bit is cleared in this modify operation.
          *
          * MS-SAMR 2.2.1.13 UF_FLAG Codes states that some bits are
          * ignored by clients and servers
          */
         new_uac = raw_uac & UF_SETTABLE_BITS;
 
         /* Fetch the old ""userAccountControl"" and ""objectClass"" */
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
                                     DSDB_FLAG_NEXT_MODULE, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         old_uac = ldb_msg_find_attr_as_uint(res->msgs[0], ""userAccountControl"", 0);
         if (old_uac == 0) {
                 return ldb_operr(ldb);
         }
         old_uac_computed = ldb_msg_find_attr_as_uint(res->msgs[0],
                                                      ""msDS-User-Account-Control-Computed"", 0);
         old_lockoutTime = ldb_msg_find_attr_as_int64(res->msgs[0],
                                                      ""lockoutTime"", 0);
         old_is_critical = ldb_msg_find_attr_as_bool(res->msgs[0],
                                                     ""isCriticalSystemObject"", 0);
         /* When we do not have objectclass ""computer"" we cannot switch to a (read-only) DC */
         el = ldb_msg_find_element(res->msgs[0], ""objectClass"");
         if (el == NULL) {
                 return ldb_operr(ldb);
         }
         computer_val = data_blob_string_const(""computer"");
         val = ldb_msg_find_val(el, &computer_val);
         if (val != NULL) {
                 is_computer = true;
         }
 
         old_ufa = old_uac & UF_ACCOUNT_TYPE_MASK;
         old_atype = ds_uf2atype(old_ufa);
         old_pgrid = ds_uf2prim_group_rid(old_uac);
 
         new_ufa = new_uac & UF_ACCOUNT_TYPE_MASK;
         if (new_ufa == 0) {
                 /*
                  * ""userAccountControl"" = 0 or missing one of the
                  * types means ""UF_NORMAL_ACCOUNT"".  See MS-SAMR
                  * 3.1.1.8.10 point 8
                  */
                 new_ufa = UF_NORMAL_ACCOUNT;
                 new_uac |= new_ufa;
         }
         sid = samdb_result_dom_sid(res, res->msgs[0], ""objectSid"");
         if (sid == NULL) {
                 return ldb_module_operr(ac->module);
         }
 
         ret = samldb_check_user_account_control_rules(ac, sid, new_uac, old_uac);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         new_atype = ds_uf2atype(new_ufa);
         new_pgrid = ds_uf2prim_group_rid(new_uac);
 
         clear_uac = (old_uac | old_uac_computed) & ~raw_uac;
 
         switch (new_ufa) {
         case UF_NORMAL_ACCOUNT:
                 new_is_critical = old_is_critical;
                 break;
 
         case UF_INTERDOMAIN_TRUST_ACCOUNT:
                 new_is_critical = true;
                 break;
 
         case UF_WORKSTATION_TRUST_ACCOUNT:
                 new_is_critical = false;
                 if (new_uac & UF_PARTIAL_SECRETS_ACCOUNT) {
                         if (!is_computer) {
                                 ldb_asprintf_errstring(ldb,
                                                        ""%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT ""
                                                        ""requires objectclass 'computer'!"",
                                                        W_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                         new_is_critical = true;
                 }
                 break;
 
         case UF_SERVER_TRUST_ACCOUNT:
                 if (!is_computer) {
                         ldb_asprintf_errstring(ldb,
                                 ""%08X: samldb: UF_SERVER_TRUST_ACCOUNT ""
                                 ""requires objectclass 'computer'!"",
                                 W_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
                 new_is_critical = true;
                 break;
 
         default:
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: invalid userAccountControl[0x%08X]"",
                         W_ERROR_V(WERR_INVALID_PARAMETER), raw_uac);
                 return LDB_ERR_OTHER;
         }
 
         if (old_atype != new_atype) {
                 ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                          ""sAMAccountType"", new_atype);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         /* As per MS-SAMR 3.1.1.8.10 these flags have not to be set */
         if ((clear_uac & UF_LOCKOUT) && (old_lockoutTime != 0)) {
                 /* ""pwdLastSet"" reset as password expiration has been forced  */
                 ldb_msg_remove_attr(ac->msg, ""lockoutTime"");
                 ret = samdb_msg_add_uint64(ldb, ac->msg, ac->msg, ""lockoutTime"",
                                            (NTTIME)0);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg, ""lockoutTime"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         /* ""isCriticalSystemObject"" might be set/changed */
         if (old_is_critical != new_is_critical) {
                 ret = ldb_msg_add_string(ac->msg, ""isCriticalSystemObject"",
                                          new_is_critical ? ""TRUE"": ""FALSE"");
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg,
                                            ""isCriticalSystemObject"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         if (!ldb_msg_find_element(ac->msg, ""primaryGroupID"") &&
             (old_pgrid != new_pgrid)) {
                 /* Older AD deployments don't know about the RODC group */
                 if (new_pgrid == DOMAIN_RID_READONLY_DCS) {
                         ret = samldb_prim_group_tester(ac, new_pgrid);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                 }
 
                 ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,
                                          ""primaryGroupID"", new_pgrid);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 el = ldb_msg_find_element(ac->msg,
                                            ""primaryGroupID"");
                 el->flags = LDB_FLAG_MOD_REPLACE;
         }
 
         /* Propagate eventual ""userAccountControl"" attribute changes */
         if (old_uac != new_uac) {
                 char *tempstr = talloc_asprintf(ac->msg, ""%d"",
                                                 new_uac);
                 if (tempstr == NULL) {
                         return ldb_module_oom(ac->module);
                 }
 
                 /* Overwrite ""userAccountControl"" correctly */
                 el = dsdb_get_single_valued_attr(ac->msg, ""userAccountControl"",
                                                  ac->req->operation);
                 el->values[0].data = (uint8_t *) tempstr;
                 el->values[0].length = strlen(tempstr);
         } else {
                 ldb_msg_remove_attr(ac->msg, ""userAccountControl"");
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_lockout_time(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         NTTIME lockoutTime;
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""lockoutTime"",
                                          ac->req->operation);
         if (el == NULL || el->num_values == 0) {
                 ldb_asprintf_errstring(ldb,
                         ""%08X: samldb: 'lockoutTime' can't be deleted!"",
                         W_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Create a temporary message for fetching the ""lockoutTime"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         lockoutTime = ldb_msg_find_attr_as_int64(tmp_msg,
                                                  ""lockoutTime"",
                                                  0);
         talloc_free(tmp_msg);
 
         if (lockoutTime != 0) {
                 return LDB_SUCCESS;
         }
 
         /* lockoutTime == 0 resets badPwdCount */
         ldb_msg_remove_attr(ac->msg, ""badPwdCount"");
         ret = samdb_msg_add_int(ldb, ac->msg, ac->msg,
                                 ""badPwdCount"", 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         el = ldb_msg_find_element(ac->msg, ""badPwdCount"");
         el->flags = LDB_FLAG_MOD_REPLACE;
 
         return LDB_SUCCESS;
 }
 
 static int samldb_group_type_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         uint32_t group_type, old_group_type, account_type;
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         int ret;
         struct ldb_result *res;
         const char * const attrs[] = { ""groupType"", NULL };
 
         el = dsdb_get_single_valued_attr(ac->msg, ""groupType"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""groupType"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         group_type = ldb_msg_find_attr_as_uint(tmp_msg, ""groupType"", 0);
         talloc_free(tmp_msg);
 
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
                                     DSDB_FLAG_NEXT_MODULE |
                                     DSDB_SEARCH_SHOW_DELETED, ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         old_group_type = ldb_msg_find_attr_as_uint(res->msgs[0], ""groupType"", 0);
         if (old_group_type == 0) {
                 return ldb_operr(ldb);
         }
 
         /* Group type switching isn't so easy as it seems: We can only
          * change in this directions: global <-> universal <-> local
          * On each step also the group type itself
          * (security/distribution) is variable. */
 
         if (ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID) == NULL) {
                 switch (group_type) {
                 case GTYPE_SECURITY_GLOBAL_GROUP:
                 case GTYPE_DISTRIBUTION_GLOBAL_GROUP:
                         /* change to ""universal"" allowed */
                         if ((old_group_type == GTYPE_SECURITY_DOMAIN_LOCAL_GROUP) ||
                         (old_group_type == GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP)) {
                                 ldb_set_errstring(ldb,
                                         ""samldb: Change from security/distribution local group forbidden!"");
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                 break;
 
                 case GTYPE_SECURITY_UNIVERSAL_GROUP:
                 case GTYPE_DISTRIBUTION_UNIVERSAL_GROUP:
                         /* each change allowed */
                 break;
                 case GTYPE_SECURITY_DOMAIN_LOCAL_GROUP:
                 case GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP:
                         /* change to ""universal"" allowed */
                         if ((old_group_type == GTYPE_SECURITY_GLOBAL_GROUP) ||
                         (old_group_type == GTYPE_DISTRIBUTION_GLOBAL_GROUP)) {
                                 ldb_set_errstring(ldb,
                                         ""samldb: Change from security/distribution global group forbidden!"");
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                 break;
 
                 case GTYPE_SECURITY_BUILTIN_LOCAL_GROUP:
                 default:
                         /* we don't allow this ""groupType"" values */
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 break;
                 }
         }
 
         account_type =  ds_gtype2atype(group_type);
         if (account_type == 0) {
                 ldb_set_errstring(ldb, ""samldb: Unrecognized account type!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
         ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""sAMAccountType"",
                                  account_type);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         el = ldb_msg_find_element(ac->msg, ""sAMAccountType"");
         el->flags = LDB_FLAG_MOD_REPLACE;
 
         return LDB_SUCCESS;
 }
 
 static int samldb_sam_accountname_check(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const no_attrs[] = { NULL };
         struct ldb_result *res;
         const char *sam_accountname, *enc_str;
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""sAMAccountName"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""sAMAccountName"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         /* We must not steal the original string, it belongs to the caller! */
         sam_accountname = talloc_strdup(ac, 
                                         ldb_msg_find_attr_as_string(tmp_msg, ""sAMAccountName"", NULL));
         talloc_free(tmp_msg);
 
         if (sam_accountname == NULL) {
                 /* The ""sAMAccountName"" cannot be nothing */
                 ldb_set_errstring(ldb,
                                   ""samldb: Empty account names aren't allowed!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         enc_str = ldb_binary_encode_string(ac, sam_accountname);
         if (enc_str == NULL) {
                 return ldb_module_oom(ac->module);
         }
 
         /* Make sure that a ""sAMAccountName"" is only used once */
 
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE, no_attrs,
                                  DSDB_FLAG_NEXT_MODULE, ac->req,
                                  ""(sAMAccountName=%s)"", enc_str);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count > 1) {
                 return ldb_operr(ldb);
         } else if (res->count == 1) {
                 if (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""samldb: Account name (sAMAccountName) '%s' already in use!"",
                                                sam_accountname);
                         return LDB_ERR_ENTRY_ALREADY_EXISTS;
                 }
         }
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 static int samldb_member_check(struct samldb_ctx *ac)
 {
         const char * const attrs[] = { ""objectSid"", NULL };
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_message_element *el;
         struct ldb_dn *member_dn;
         struct dom_sid *sid;
         struct ldb_result *res;
         struct dom_sid *group_sid;
         unsigned int i, j;
         int ret;
 
         /* Fetch information from the existing object */
 
         ret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,
                                  DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req, NULL);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 return ldb_operr(ldb);
         }
 
         group_sid = samdb_result_dom_sid(res, res->msgs[0], ""objectSid"");
         if (group_sid == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* We've to walk over all modification entries and consider the ""member""
          * ones. */
         for (i = 0; i < ac->msg->num_elements; i++) {
                 if (ldb_attr_cmp(ac->msg->elements[i].name, ""member"") != 0) {
                         continue;
                 }
 
                 el = &ac->msg->elements[i];
                 for (j = 0; j < el->num_values; j++) {
                         struct ldb_result *group_res;
                         const char *group_attrs[] = { ""primaryGroupID"" , NULL };
                         uint32_t prim_group_rid;
 
                         if (LDB_FLAG_MOD_TYPE(el->flags) == LDB_FLAG_MOD_DELETE) {
                                 /* Deletes will be handled in
                                  * repl_meta_data, and deletes not
                                  * matching a member will return
                                  * LDB_ERR_UNWILLING_TO_PERFORM
                                  * there */
                                 continue;
                         }
 
                         member_dn = ldb_dn_from_ldb_val(ac, ldb,
                                                         &el->values[j]);
                         if (!ldb_dn_validate(member_dn)) {
                                 return ldb_operr(ldb);
                         }
 
                         /* Denies to add ""member""s to groups which are primary
                          * ones for them - in this case return
                          * ERR_ENTRY_ALREADY_EXISTS. */
 
                         ret = dsdb_module_search_dn(ac->module, ac, &group_res,
                                                     member_dn, group_attrs,
                                                     DSDB_FLAG_NEXT_MODULE, ac->req);
                         if (ret == LDB_ERR_NO_SUCH_OBJECT) {
                                 /* member DN doesn't exist yet */
                                 continue;
                         }
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                         prim_group_rid = ldb_msg_find_attr_as_uint(group_res->msgs[0], ""primaryGroupID"", (uint32_t)-1);
                         if (prim_group_rid == (uint32_t) -1) {
                                 /* the member hasn't to be a user account ->
                                  * therefore no check needed in this case. */
                                 continue;
                         }
 
                         sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb),
                                               prim_group_rid);
                         if (sid == NULL) {
                                 return ldb_operr(ldb);
                         }
 
                         if (dom_sid_equal(group_sid, sid)) {
                                 ldb_asprintf_errstring(ldb,
                                                        ""samldb: member %s already set via primaryGroupID %u"",
                                                        ldb_dn_get_linearized(member_dn), prim_group_rid);
                                 return LDB_ERR_ENTRY_ALREADY_EXISTS;
                         }
                 }
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 /* SAM objects have special rules regarding the ""description"" attribute on
  * modify operations. */
 static int samldb_description_check(struct samldb_ctx *ac, bool *modified)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const attrs[] = { ""objectClass"", ""description"", NULL };
         struct ldb_result *res;
         unsigned int i;
         int ret;
 
         /* Fetch information from the existing object */
         ret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,
                                  DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req,
                                  ""(|(objectclass=user)(objectclass=group)(objectclass=samDomain)(objectclass=samServer))"");
         if (ret != LDB_SUCCESS) {
                 /* don't treat it specially ... let normal error codes
                    happen from other places */
                 ldb_reset_err_string(ldb);
                 return LDB_SUCCESS;
         }
         if (res->count == 0) {
                 /* we didn't match the filter */
                 talloc_free(res);
                 return LDB_SUCCESS;
         }
 
         /* We've to walk over all modification entries and consider the
          * ""description"" ones. */
         for (i = 0; i < ac->msg->num_elements; i++) {
                 if (ldb_attr_cmp(ac->msg->elements[i].name, ""description"") == 0) {
                         ac->msg->elements[i].flags |= LDB_FLAG_INTERNAL_FORCE_SINGLE_VALUE_CHECK;
                         *modified = true;
                 }
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 /* This trigger adapts the ""servicePrincipalName"" attributes if the
  * ""dNSHostName"" and/or ""sAMAccountName"" attribute change(s) */
 static int samldb_service_principal_names_change(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_message_element *el = NULL, *el2 = NULL;
         struct ldb_message *msg;
         const char * const attrs[] = { ""servicePrincipalName"", NULL };
         struct ldb_result *res;
         const char *dns_hostname = NULL, *old_dns_hostname = NULL,
                    *sam_accountname = NULL, *old_sam_accountname = NULL;
         unsigned int i, j;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""dNSHostName"",
                                          ac->req->operation);
         el2 = dsdb_get_single_valued_attr(ac->msg, ""sAMAccountName"",
                                           ac->req->operation);
         if ((el == NULL) && (el2 == NULL)) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""dNSHostName"" */
         if (el != NULL) {
                 const char *dns_attrs[] = { ""dNSHostName"", NULL };
                 msg = ldb_msg_new(ac->msg);
                 if (msg == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                 ret = ldb_msg_add(msg, el, 0);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 dns_hostname = talloc_strdup(ac, 
                                              ldb_msg_find_attr_as_string(msg, ""dNSHostName"", NULL));
                 if (dns_hostname == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                         
                 talloc_free(msg);
 
                 ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn,
                                             dns_attrs, DSDB_FLAG_NEXT_MODULE, ac->req);
                 if (ret == LDB_SUCCESS) {
                         old_dns_hostname = ldb_msg_find_attr_as_string(res->msgs[0], ""dNSHostName"", NULL);
                 }
         }
 
         /* Create a temporary message for fetching the ""sAMAccountName"" */
         if (el2 != NULL) {
                 char *tempstr, *tempstr2 = NULL;
                 const char *acct_attrs[] = { ""sAMAccountName"", NULL };
 
                 msg = ldb_msg_new(ac->msg);
                 if (msg == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                 ret = ldb_msg_add(msg, el2, 0);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 tempstr = talloc_strdup(ac,
                                         ldb_msg_find_attr_as_string(msg, ""sAMAccountName"", NULL));
                 talloc_free(msg);
 
                 ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, acct_attrs,
                                             DSDB_FLAG_NEXT_MODULE, ac->req);
                 if (ret == LDB_SUCCESS) {
                         tempstr2 = talloc_strdup(ac,
                                                  ldb_msg_find_attr_as_string(res->msgs[0],
                                                                              ""sAMAccountName"", NULL));
                 }
 
 
                 /* The ""sAMAccountName"" needs some additional trimming: we need
                  * to remove the trailing ""$""s if they exist. */
                 if ((tempstr != NULL) && (tempstr[0] != '\0') &&
                     (tempstr[strlen(tempstr) - 1] == '$')) {
                         tempstr[strlen(tempstr) - 1] = '\0';
                 }
                 if ((tempstr2 != NULL) && (tempstr2[0] != '\0') &&
                     (tempstr2[strlen(tempstr2) - 1] == '$')) {
                         tempstr2[strlen(tempstr2) - 1] = '\0';
                 }
                 sam_accountname = tempstr;
                 old_sam_accountname = tempstr2;
         }
 
         if (old_dns_hostname == NULL) {
                 /* we cannot change when the old name is unknown */
                 dns_hostname = NULL;
         }
         if ((old_dns_hostname != NULL) && (dns_hostname != NULL) &&
             (strcasecmp_m(old_dns_hostname, dns_hostname) == 0)) {
                 /* The ""dNSHostName"" didn't change */
                 dns_hostname = NULL;
         }
 
         if (old_sam_accountname == NULL) {
                 /* we cannot change when the old name is unknown */
                 sam_accountname = NULL;
         }
         if ((old_sam_accountname != NULL) && (sam_accountname != NULL) &&
             (strcasecmp_m(old_sam_accountname, sam_accountname) == 0)) {
                 /* The ""sAMAccountName"" didn't change */
                 sam_accountname = NULL;
         }
 
         if ((dns_hostname == NULL) && (sam_accountname == NULL)) {
                 /* Well, there are information missing (old name(s)) or the
                  * names didn't change. We've nothing to do and can exit here */
                 return LDB_SUCCESS;
         }
 
         /* Potential ""servicePrincipalName"" changes in the same request have to
          * be handled before the update (Windows behaviour). */
         el = ldb_msg_find_element(ac->msg, ""servicePrincipalName"");
         if (el != NULL) {
                 msg = ldb_msg_new(ac->msg);
                 if (msg == NULL) {
                         return ldb_module_oom(ac->module);
                 }
                 msg->dn = ac->msg->dn;
 
                 do {
                         ret = ldb_msg_add(msg, el, el->flags);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
 
                         ldb_msg_remove_element(ac->msg, el);
 
                         el = ldb_msg_find_element(ac->msg,
                                                   ""servicePrincipalName"");
                 } while (el != NULL);
 
                 ret = dsdb_module_modify(ac->module, msg,
                                          DSDB_FLAG_NEXT_MODULE, ac->req);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
                 talloc_free(msg);
         }
 
         /* Fetch the ""servicePrincipalName""s if any */
         ret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,
                                  DSDB_FLAG_NEXT_MODULE, ac->req, NULL);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if ((res->count != 1) || (res->msgs[0]->num_elements > 1)) {
                 return ldb_operr(ldb);
         }
 
         if (res->msgs[0]->num_elements == 1) {
                 /*
                  * Yes, we do have ""servicePrincipalName""s. First we update them
                  * locally, that means we do always substitute the current
                  * ""dNSHostName"" with the new one and/or ""sAMAccountName""
                  * without ""$"" with the new one and then we append the
                  * modified ""servicePrincipalName""s as a message element
                  * replace to the modification request (Windows behaviour). We
                  * need also to make sure that the values remain case-
                  * insensitively unique.
                  */
 
                 ret = ldb_msg_add_empty(ac->msg, ""servicePrincipalName"",
                                         LDB_FLAG_MOD_REPLACE, &el);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 for (i = 0; i < res->msgs[0]->elements[0].num_values; i++) {
                         char *old_str, *new_str;
                         char *pos = NULL;
                         const char *tok;
                         struct ldb_val *vals;
                         bool found = false;
 
                         old_str = (char *)
                                 res->msgs[0]->elements[0].values[i].data;
 
                         new_str = talloc_strdup(ac->msg,
                                                 strtok_r(old_str, ""/"", &pos));
                         if (new_str == NULL) {
                                 return ldb_module_oom(ac->module);
                         }
 
                         while ((tok = strtok_r(NULL, ""/"", &pos)) != NULL) {
                                 if ((dns_hostname != NULL) &&
                                     (strcasecmp_m(tok, old_dns_hostname) == 0)) {
                                         tok = dns_hostname;
                                 }
                                 if ((sam_accountname != NULL) &&
                                     (strcasecmp_m(tok, old_sam_accountname) == 0)) {
                                         tok = sam_accountname;
                                 }
 
                                 new_str = talloc_asprintf(ac->msg, ""%s/%s"",
                                                           new_str, tok);
                                 if (new_str == NULL) {
                                         return ldb_module_oom(ac->module);
                                 }
                         }
 
                         /* Uniqueness check */
                         for (j = 0; (!found) && (j < el->num_values); j++) {
                                 if (strcasecmp_m((char *)el->values[j].data,
                                                new_str) == 0) {
                                         found = true;
                                 }
                         }
                         if (found) {
                                 continue;
                         }
 
                         /*
                          * append the new ""servicePrincipalName"" -
                          * code derived from ldb_msg_add_value().
                          *
                          * Open coded to make it clear that we must
                          * append to the MOD_REPLACE el created above.
                          */
                         vals = talloc_realloc(ac->msg, el->values,
                                               struct ldb_val,
                                               el->num_values + 1);
                         if (vals == NULL) {
                                 return ldb_module_oom(ac->module);
                         }
                         el->values = vals;
                         el->values[el->num_values] = data_blob_string_const(new_str);
                         ++(el->num_values);
                 }
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 /* This checks the ""fSMORoleOwner"" attributes */
 static int samldb_fsmo_role_owner_check(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         const char * const no_attrs[] = { NULL };
         struct ldb_message_element *el;
         struct ldb_message *tmp_msg;
         struct ldb_dn *res_dn;
         struct ldb_result *res;
         int ret;
 
         el = dsdb_get_single_valued_attr(ac->msg, ""fSMORoleOwner"",
                                          ac->req->operation);
         if (el == NULL) {
                 /* we are not affected */
                 return LDB_SUCCESS;
         }
 
         /* Create a temporary message for fetching the ""fSMORoleOwner"" */
         tmp_msg = ldb_msg_new(ac->msg);
         if (tmp_msg == NULL) {
                 return ldb_module_oom(ac->module);
         }
         ret = ldb_msg_add(tmp_msg, el, 0);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         res_dn = ldb_msg_find_attr_as_dn(ldb, ac, tmp_msg, ""fSMORoleOwner"");
         talloc_free(tmp_msg);
 
         if (res_dn == NULL) {
                 ldb_set_errstring(ldb,
                                   ""samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!"");
                 if (ac->req->operation == LDB_ADD) {
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 } else {
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
 
         /* Fetched DN has to reference a ""nTDSDSA"" entry */
         ret = dsdb_module_search(ac->module, ac, &res, res_dn, LDB_SCOPE_BASE,
                                  no_attrs,
                                  DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
                                  ac->req, ""(objectClass=nTDSDSA)"");
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count != 1) {
                 ldb_set_errstring(ldb,
                                   ""samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!"");
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         talloc_free(res);
 
         return LDB_SUCCESS;
 }
 
 
 /* add */
 static int samldb_add(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
         struct ldb_message_element *el;
         int ret;
 
         ldb = ldb_module_get_ctx(module);
         ldb_debug(ldb, LDB_DEBUG_TRACE, ""samldb_add\n"");
 
         /* do not manipulate our control entries */
         if (ldb_dn_is_special(req->op.add.message->dn)) {
                 return ldb_next_request(module, req);
         }
 
         el = ldb_msg_find_element(req->op.add.message, ""userParameters"");
         if (el != NULL && ldb_req_is_untrusted(req)) {
                 const char *reason = ""samldb_add: ""
                         ""setting userParameters is not supported over LDAP, ""
                         ""see https://bugzilla.samba.org/show_bug.cgi?id=8077"";
                 ldb_debug(ldb, LDB_DEBUG_WARNING, ""%s"", reason);
                 return ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);
         }
 
         ac = samldb_ctx_init(module, req);
         if (ac == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* build the new msg */
         ac->msg = ldb_msg_copy_shallow(ac, req->op.add.message);
         if (ac->msg == NULL) {
                 talloc_free(ac);
                 ldb_debug(ldb, LDB_DEBUG_FATAL,
                           ""samldb_add: ldb_msg_copy_shallow failed!\n"");
                 return ldb_operr(ldb);
         }
 
         el = ldb_msg_find_element(ac->msg, ""fSMORoleOwner"");
         if (el != NULL) {
                 ret = samldb_fsmo_role_owner_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""user"") != NULL) {
                 ac->type = SAMLDB_TYPE_USER;
 
                 ret = samldb_prim_group_trigger(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 ret = samldb_objectclass_trigger(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 return samldb_fill_object(ac);
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""group"") != NULL) {
                 ac->type = SAMLDB_TYPE_GROUP;
 
                 ret = samldb_objectclass_trigger(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 return samldb_fill_object(ac);
         }
 
         /* perhaps a foreignSecurityPrincipal? */
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"",
                                  ""foreignSecurityPrincipal"") != NULL) {
                 return samldb_fill_foreignSecurityPrincipal_object(ac);
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""classSchema"") != NULL) {
                 ret = samldb_schema_info_update(ac);
                 if (ret != LDB_SUCCESS) {
                         talloc_free(ac);
                         return ret;
                 }
 
                 ac->type = SAMLDB_TYPE_CLASS;
                 return samldb_fill_object(ac);
         }
 
         if (samdb_find_attribute(ldb, ac->msg,
                                  ""objectclass"", ""attributeSchema"") != NULL) {
                 ret = samldb_schema_info_update(ac);
                 if (ret != LDB_SUCCESS) {
                         talloc_free(ac);
                         return ret;
                 }
 
                 ac->type = SAMLDB_TYPE_ATTRIBUTE;
                 return samldb_fill_object(ac);
         }
 
         talloc_free(ac);
 
         /* nothing matched, go on */
         return ldb_next_request(module, req);
 }
 
 /* modify */
 static int samldb_modify(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb;
         struct samldb_ctx *ac;
         struct ldb_message_element *el, *el2;
         struct ldb_control *is_undelete;
         bool modified = false;
         int ret;
 
         if (ldb_dn_is_special(req->op.mod.message->dn)) {
                 /* do not manipulate our control entries */
                 return ldb_next_request(module, req);
         }
 
         ldb = ldb_module_get_ctx(module);
 
         /*
          * we are going to need some special handling if in Undelete call.
          * Since tombstone_reanimate module will restore certain attributes,
          * we need to relax checks for: sAMAccountType, primaryGroupID
          */
         is_undelete = ldb_request_get_control(req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID);
 
         /* make sure that ""objectSid"" is not specified */
         el = ldb_msg_find_element(req->op.mod.message, ""objectSid"");
         if (el != NULL) {
                 if (ldb_request_get_control(req, LDB_CONTROL_PROVISION_OID) == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: objectSid must not be specified!"");
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
         if (is_undelete == NULL) {
                 /* make sure that ""sAMAccountType"" is not specified */
                 el = ldb_msg_find_element(req->op.mod.message, ""sAMAccountType"");
                 if (el != NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: sAMAccountType must not be specified!"");
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
         /* make sure that ""isCriticalSystemObject"" is not specified */
         el = ldb_msg_find_element(req->op.mod.message, ""isCriticalSystemObject"");
         if (el != NULL) {
                 if (ldb_request_get_control(req, LDB_CONTROL_RELAX_OID) == NULL) {
                         ldb_set_errstring(ldb,
                                           ""samldb: isCriticalSystemObject must not be specified!"");
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
 
         /* msDS-IntId is not allowed to be modified
          * except when modification comes from replication */
         if (ldb_msg_find_element(req->op.mod.message, ""msDS-IntId"")) {
                 if (!ldb_request_get_control(req,
                                              DSDB_CONTROL_REPLICATED_UPDATE_OID)) {
                         return LDB_ERR_CONSTRAINT_VIOLATION;
                 }
         }
 
         el = ldb_msg_find_element(req->op.mod.message, ""userParameters"");
         if (el != NULL && ldb_req_is_untrusted(req)) {
                 const char *reason = ""samldb: ""
                         ""setting userParameters is not supported over LDAP, ""
                         ""see https://bugzilla.samba.org/show_bug.cgi?id=8077"";
                 ldb_debug(ldb, LDB_DEBUG_WARNING, ""%s"", reason);
                 return ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);
         }
 
         ac = samldb_ctx_init(module, req);
         if (ac == NULL) {
                 return ldb_operr(ldb);
         }
 
         /* build the new msg */
         ac->msg = ldb_msg_copy_shallow(ac, req->op.mod.message);
         if (ac->msg == NULL) {
                 talloc_free(ac);
                 ldb_debug(ldb, LDB_DEBUG_FATAL,
                           ""samldb_modify: ldb_msg_copy_shallow failed!\n"");
                 return ldb_operr(ldb);
         }
 
         if (is_undelete == NULL) {
                 el = ldb_msg_find_element(ac->msg, ""primaryGroupID"");
                 if (el != NULL) {
                         ret = samldb_prim_group_trigger(ac);
                         if (ret != LDB_SUCCESS) {
                                 return ret;
                         }
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""userAccountControl"");
         if (el != NULL) {
                 modified = true;
                 ret = samldb_user_account_control_change(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""lockoutTime"");
         if (el != NULL) {
                 modified = true;
                 ret = samldb_lockout_time(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""groupType"");
         if (el != NULL) {
                 modified = true;
                 ret = samldb_group_type_change(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""sAMAccountName"");
         if (el != NULL) {
                 ret = samldb_sam_accountname_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""member"");
         if (el != NULL) {
                 ret = samldb_member_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""description"");
         if (el != NULL) {
                 ret = samldb_description_check(ac, &modified);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""dNSHostName"");
         el2 = ldb_msg_find_element(ac->msg, ""sAMAccountName"");
         if ((el != NULL) || (el2 != NULL)) {
                 modified = true;
                 ret = samldb_service_principal_names_change(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         el = ldb_msg_find_element(ac->msg, ""fSMORoleOwner"");
         if (el != NULL) {
                 ret = samldb_fsmo_role_owner_check(ac);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
         }
 
         if (modified) {
                 struct ldb_request *child_req;
 
                 /* Now perform the real modifications as a child request */
                 ret = ldb_build_mod_req(&child_req, ldb, ac,
                                         ac->msg,
                                         req->controls,
                                         req, dsdb_next_callback,
                                         req);
                 LDB_REQ_SET_LOCATION(child_req);
                 if (ret != LDB_SUCCESS) {
                         return ret;
                 }
 
                 return ldb_next_request(module, child_req);
         }
 
         talloc_free(ac);
 
         /* no change which interests us, go on */
         return ldb_next_request(module, req);
 }
 
 /* delete */
 
 static int samldb_prim_group_users_check(struct samldb_ctx *ac)
 {
         struct ldb_context *ldb;
         struct dom_sid *sid;
         uint32_t rid;
         NTSTATUS status;
         int ret;
         struct ldb_result *res;
         const char * const attrs[] = { ""objectSid"", ""isDeleted"", NULL };
         const char * const noattrs[] = { NULL };
 
         ldb = ldb_module_get_ctx(ac->module);
 
         /* Finds out the SID/RID of the SAM object */
         ret = dsdb_module_search_dn(ac->module, ac, &res, ac->req->op.del.dn,
                                         attrs,
                                         DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
                                         ac->req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         if (ldb_msg_check_string_attribute(res->msgs[0], ""isDeleted"", ""TRUE"")) {
                 return LDB_SUCCESS;
         }
 
         sid = samdb_result_dom_sid(ac, res->msgs[0], ""objectSid"");
         if (sid == NULL) {
                 /* No SID - it might not be a SAM object - therefore ok */
                 return LDB_SUCCESS;
         }
         status = dom_sid_split_rid(ac, sid, NULL, &rid);
         if (!NT_STATUS_IS_OK(status)) {
                 return ldb_operr(ldb);
         }
         if (rid == 0) {
                 /* Special object (security principal?) */
                 return LDB_SUCCESS;
         }
         /* do not allow deletion of well-known sids */
         if (rid < DSDB_SAMDB_MINIMUM_ALLOWED_RID &&
             (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {
                 return LDB_ERR_OTHER;
         }
 
         /* Deny delete requests from groups which are primary ones */
         ret = dsdb_module_search(ac->module, ac, &res,
                                  ldb_get_default_basedn(ldb),
                                  LDB_SCOPE_SUBTREE, noattrs,
                                  DSDB_FLAG_NEXT_MODULE,
                                  ac->req,
                                  ""(&(primaryGroupID=%u)(objectClass=user))"", rid);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
         if (res->count > 0) {
                 return LDB_ERR_ENTRY_ALREADY_EXISTS;
         }
 
         return LDB_SUCCESS;
 }
 
 static int samldb_delete(struct ldb_module *module, struct ldb_request *req)
 {
         struct samldb_ctx *ac;
         int ret;
 
         if (ldb_dn_is_special(req->op.del.dn)) {
                 /* do not manipulate our control entries */
                 return ldb_next_request(module, req);
         }
 
         ac = samldb_ctx_init(module, req);
         if (ac == NULL) {
                 return ldb_operr(ldb_module_get_ctx(module));
         }
 
         ret = samldb_prim_group_users_check(ac);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         talloc_free(ac);
 
         return ldb_next_request(module, req);
 }
 
 /* rename */
 
 static int check_rename_constraints(struct ldb_message *msg,
                                     struct samldb_ctx *ac,
                                     struct ldb_dn *olddn, struct ldb_dn *newdn)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
         struct ldb_dn *dn1, *dn2, *nc_root;
         int32_t systemFlags;
         bool move_op = false;
         bool rename_op = false;
         int ret;
 
         /* Skip the checks if old and new DN are the same, or if we have the
          * relax control specified or if the returned objects is already
          * deleted and needs only to be moved for consistency. */
 
         if (ldb_dn_compare(olddn, newdn) == 0) {
                 return LDB_SUCCESS;
         }
         if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) != NULL) {
                 return LDB_SUCCESS;
         }
 
         if (ldb_msg_find_attr_as_bool(msg, ""isDeleted"", false)) {
                 /*
                  * check originating request if we are supposed
                  * to ""see"" this record in first place.
                  */
                 if (ldb_request_get_control(ac->req, LDB_CONTROL_SHOW_DELETED_OID) == NULL) {
                         return LDB_ERR_NO_SUCH_OBJECT;
                 }
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* Objects under CN=System */
 
         dn1 = ldb_dn_copy(ac, ldb_get_default_basedn(ldb));
         if (dn1 == NULL) return ldb_oom(ldb);
 
         if ( ! ldb_dn_add_child_fmt(dn1, ""CN=System"")) {
                 talloc_free(dn1);
                 return LDB_ERR_OPERATIONS_ERROR;
         }
 
         if ((ldb_dn_compare_base(dn1, olddn) == 0) &&
             (ldb_dn_compare_base(dn1, newdn) != 0)) {
                 talloc_free(dn1);
                 ldb_asprintf_errstring(ldb,
                                        ""subtree_rename: Cannot move/rename %s. Objects under CN=System have to stay under it!"",
                                        ldb_dn_get_linearized(olddn));
                 return LDB_ERR_OTHER;
         }
 
         talloc_free(dn1);
 
         /* LSA objects */
 
         if ((samdb_find_attribute(ldb, msg, ""objectClass"", ""secret"") != NULL) ||
             (samdb_find_attribute(ldb, msg, ""objectClass"", ""trustedDomain"") != NULL)) {
                 ldb_asprintf_errstring(ldb,
                                        ""subtree_rename: Cannot move/rename %s. It's an LSA-specific object!"",
                                        ldb_dn_get_linearized(olddn));
                 return LDB_ERR_UNWILLING_TO_PERFORM;
         }
 
         /* systemFlags */
 
         dn1 = ldb_dn_get_parent(ac, olddn);
         if (dn1 == NULL) return ldb_oom(ldb);
         dn2 = ldb_dn_get_parent(ac, newdn);
         if (dn2 == NULL) return ldb_oom(ldb);
 
         if (ldb_dn_compare(dn1, dn2) == 0) {
                 rename_op = true;
         } else {
                 move_op = true;
         }
 
         talloc_free(dn1);
         talloc_free(dn2);
 
         systemFlags = ldb_msg_find_attr_as_int(msg, ""systemFlags"", 0);
 
         /* Fetch name context */
 
         ret = dsdb_find_nc_root(ldb, ac, olddn, &nc_root);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         if (ldb_dn_compare(nc_root, ldb_get_schema_basedn(ldb)) == 0) {
                 if (move_op) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot move %s within schema partition"",
                                                ldb_dn_get_linearized(olddn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
                 if (rename_op &&
                     (systemFlags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot rename %s within schema partition"",
                                                ldb_dn_get_linearized(olddn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         } else if (ldb_dn_compare(nc_root, ldb_get_config_basedn(ldb)) == 0) {
                 if (move_op &&
                     (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_MOVE) == 0) {
                         /* Here we have to do more: control the
                          * ""ALLOW_LIMITED_MOVE"" flag. This means that the
                          * grand-grand-parents of two objects have to be equal
                          * in order to perform the move (this is used for
                          * moving ""server"" objects in the ""sites"" container). */
                         bool limited_move =
                                 systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_LIMITED_MOVE;
 
                         if (limited_move) {
                                 dn1 = ldb_dn_copy(ac, olddn);
                                 if (dn1 == NULL) return ldb_oom(ldb);
                                 dn2 = ldb_dn_copy(ac, newdn);
                                 if (dn2 == NULL) return ldb_oom(ldb);
 
                                 limited_move &= ldb_dn_remove_child_components(dn1, 3);
                                 limited_move &= ldb_dn_remove_child_components(dn2, 3);
                                 limited_move &= ldb_dn_compare(dn1, dn2) == 0;
 
                                 talloc_free(dn1);
                                 talloc_free(dn2);
                         }
 
                         if (!limited_move
                             && ldb_request_get_control(ac->req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID) == NULL) {
                                 ldb_asprintf_errstring(ldb,
                                                        ""subtree_rename: Cannot move %s to %s in config partition"",
                                                        ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                                 return LDB_ERR_UNWILLING_TO_PERFORM;
                         }
                 }
                 if (rename_op &&
                     (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_RENAME) == 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot rename %s to %s within config partition"",
                                                ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         } else if (ldb_dn_compare(nc_root, ldb_get_default_basedn(ldb)) == 0) {
                 if (move_op &&
                     (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_MOVE) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                ""subtree_rename: Cannot move %s to %s - DISALLOW_MOVE set"",
                                                ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
                 if (rename_op &&
                     (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_RENAME) != 0) {
                         ldb_asprintf_errstring(ldb,
                                                        ""subtree_rename: Cannot rename %s to %s - DISALLOW_RENAME set"",
                                                ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));
                         return LDB_ERR_UNWILLING_TO_PERFORM;
                 }
         }
 
         talloc_free(nc_root);
 
         return LDB_SUCCESS;
 }
 
 
 static int samldb_rename_search_base_callback(struct ldb_request *req,
                                                struct ldb_reply *ares)
 {
         struct samldb_ctx *ac;
         int ret;
 
         ac = talloc_get_type(req->context, struct samldb_ctx);
 
         if (!ares) {
                 return ldb_module_done(ac->req, NULL, NULL,
                                         LDB_ERR_OPERATIONS_ERROR);
         }
         if (ares->error != LDB_SUCCESS) {
                 return ldb_module_done(ac->req, ares->controls,
                                         ares->response, ares->error);
         }
 
         switch (ares->type) {
         case LDB_REPLY_ENTRY:
                 /*
                  * This is the root entry of the originating move
                  * respectively rename request. It has been already
                  * stored in the list using ""subtree_rename_search()"".
                  * Only this one is subject to constraint checking.
                  */
                 ret = check_rename_constraints(ares->message, ac,
                                                ac->req->op.rename.olddn,
                                                ac->req->op.rename.newdn);
                 if (ret != LDB_SUCCESS) {
                         return ldb_module_done(ac->req, NULL, NULL,
                                                ret);
                 }
                 break;
 
         case LDB_REPLY_REFERRAL:
                 /* ignore */
                 break;
 
         case LDB_REPLY_DONE:
 
                 /*
                  * Great, no problem with the rename, so go ahead as
                  * if we never were here
                  */
                 ret = ldb_next_request(ac->module, ac->req);
                 talloc_free(ares);
                 return ret;
         }
 
         talloc_free(ares);
         return LDB_SUCCESS;
 }
 
 
 /* rename */
 static int samldb_rename(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb;
         static const char * const attrs[] = { ""objectClass"", ""systemFlags"",
                                               ""isDeleted"", NULL };
         struct ldb_request *search_req;
         struct samldb_ctx *ac;
         int ret;
 
         if (ldb_dn_is_special(req->op.rename.olddn)) { /* do not manipulate our control entries */
                 return ldb_next_request(module, req);
         }
 
         ldb = ldb_module_get_ctx(module);
 
         ac = samldb_ctx_init(module, req);
         if (!ac) {
                 return ldb_oom(ldb);
         }
 
         ret = ldb_build_search_req(&search_req, ldb, ac,
                                    req->op.rename.olddn,
                                    LDB_SCOPE_BASE,
                                    ""(objectClass=*)"",
                                    attrs,
                                    NULL,
                                    ac,
                                    samldb_rename_search_base_callback,
                                    req);
         LDB_REQ_SET_LOCATION(search_req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         ret = ldb_request_add_control(search_req, LDB_CONTROL_SHOW_RECYCLED_OID,
                                       true, NULL);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         return ldb_next_request(ac->module, search_req);
 }
 
 /* extended */
 
 static int samldb_extended_allocate_rid_pool(struct ldb_module *module, struct ldb_request *req)
 {
         struct ldb_context *ldb = ldb_module_get_ctx(module);
         struct dsdb_fsmo_extended_op *exop;
         int ret;
 
         exop = talloc_get_type(req->op.extended.data,
                                struct dsdb_fsmo_extended_op);
         if (!exop) {
                 ldb_set_errstring(ldb,
                                   ""samldb_extended_allocate_rid_pool: invalid extended data"");
                 return LDB_ERR_PROTOCOL_ERROR;
         }
 
         ret = ridalloc_allocate_rid_pool_fsmo(module, exop, req);
         if (ret != LDB_SUCCESS) {
                 return ret;
         }
 
         return ldb_module_done(req, NULL, NULL, LDB_SUCCESS);
 }
 
 static int samldb_extended(struct ldb_module *module, struct ldb_request *req)
 {
         if (strcmp(req->op.extended.oid, DSDB_EXTENDED_ALLOCATE_RID_POOL) == 0) {
                 return samldb_extended_allocate_rid_pool(module, req);
         }
 
         return ldb_next_request(module, req);
 }
 
 
 static const struct ldb_module_ops ldb_samldb_module_ops = {
         .name          = ""samldb"",
         .add           = samldb_add,
         .modify        = samldb_modify,
         .del           = samldb_delete,
         .rename        = samldb_rename,
         .extended      = samldb_extended
 };
 
 
 int ldb_samldb_module_init(const char *version)
 {
         LDB_MODULE_CHECK_VERSION(version);
         return ldb_register_module(&ldb_samldb_module_ops);
 }
"
CVE-2015-8467,https://www.cvedetails.com/cve/CVE-2015-8467/,CWE-264,,Bypass,2015-12-29,2016-12-30,6.0,None,Remote,Medium,Single system,Partial,Partial,Partial,"The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",Python,samba,https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,a819d2b440aafa3138d95ff6e8b824da885a70e9,"@@ -240,6 +240,16 @@ class UserAccountControlTests(samba.tests.TestCase):
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
+        try:
+            self.samdb.modify(m)
+            self.fail(""Unexpectedly able to set userAccountControl to be an Workstation on %s"" % m.dn)
+        except LdbError, (enum, estr):
+            self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
+
+        m = ldb.Message()
+        m.dn = res[0].dn
+        m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_NORMAL_ACCOUNT),
+                                                     ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.samdb.modify(m)
 
         m = ldb.Message()
@@ -306,7 +316,12 @@ class UserAccountControlTests(samba.tests.TestCase):
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
-        self.samdb.modify(m)
+        try:
+            self.samdb.modify(m)
+            self.fail(""Unexpectedly able to set userAccountControl to be an Workstation on %s"" % m.dn)
+        except LdbError, (enum, estr):
+            self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
+
 
     def test_admin_mod_uac(self):
         computername=self.computernames[0]
@@ -382,9 +397,10 @@ class UserAccountControlTests(samba.tests.TestCase):
         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                                        UF_DONT_EXPIRE_PASSWD])
 
-        # These bits really are privileged
+        # These bits really are privileged, or can't be changed from UF_NORMAL as a non-admin
         priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT,
-                         UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])
+                         UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
+                         UF_WORKSTATION_TRUST_ACCOUNT])
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
 
@@ -446,7 +462,7 @@ class UserAccountControlTests(samba.tests.TestCase):
                             int(""0x10000000"", 16), int(""0x20000000"", 16), int(""0x40000000"", 16), int(""0x80000000"", 16)])
         super_priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT])
 
-        priv_to_remove_bits = set([UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])
+        priv_to_remove_bits = set([UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, UF_WORKSTATION_TRUST_ACCOUNT])
 
         for bit in bits:
             # Reset this to the initial position, just to be sure
@@ -507,6 +523,31 @@ class UserAccountControlTests(samba.tests.TestCase):
             except LdbError, (enum, estr):
                 self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
+            res = self.admin_samdb.search(""%s"" % self.base_dn,
+                                          expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
+                                          scope=SCOPE_SUBTREE,
+                                          attrs=[""userAccountControl""])
+
+            if bit in account_types:
+                self.assertEqual(int(res[0][""userAccountControl""][0]),
+                                 bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
+                                 ""bit 0X%08x should have been added (0X%08x vs 0X%08x)""
+                                 % (bit, int(res[0][""userAccountControl""][0]),
+                                    bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))
+            elif bit in ignored_bits:
+                self.assertEqual(int(res[0][""userAccountControl""][0]),
+                                 UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
+                                 ""bit 0X%08x should have been added (0X%08x vs 0X%08x)""
+                                 % (bit, int(res[0][""userAccountControl""][0]),
+                                    UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))
+
+            else:
+                self.assertEqual(int(res[0][""userAccountControl""][0]),
+                                 bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
+                                 ""bit 0X%08x should have been added (0X%08x vs 0X%08x)""
+                                 % (bit, int(res[0][""userAccountControl""][0]),
+                                    bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))
+
             try:
                 m = ldb.Message()
                 m.dn = res[0].dn
@@ -520,7 +561,7 @@ class UserAccountControlTests(samba.tests.TestCase):
                 if bit in priv_to_remove_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                 else:
-                    self.fail(""Unexpectedly able to remove userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
+                    self.fail(""Unexpectedly unable to remove userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
@@ -528,9 +569,14 @@ class UserAccountControlTests(samba.tests.TestCase):
                                           attrs=[""userAccountControl""])
 
             if bit in priv_to_remove_bits:
-                self.assertEqual(int(res[0][""userAccountControl""][0]),
-                                 bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
-                                 ""bit 0X%08x should not have been removed"" % bit)
+                if bit in account_types:
+                    self.assertEqual(int(res[0][""userAccountControl""][0]),
+                                     bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
+                                     ""bit 0X%08x should not have been removed"" % bit)
+                else:
+                    self.assertEqual(int(res[0][""userAccountControl""][0]),
+                                     bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
+                                     ""bit 0X%08x should not have been removed"" % bit)
             else:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
@@ -553,7 +599,6 @@ class UserAccountControlTests(samba.tests.TestCase):
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
-
         # These bits are privileged, but authenticated users have that CAR by default, so this is a pain to test
         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                                        UF_DONT_EXPIRE_PASSWD])",https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/tests/python/user_account_control.py;h=16c7f81d477fe10cb547255ccb5cc7910cde261d;hb=16c7f81d477fe10cb547255ccb5cc7910cde261d,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/tests/python/user_account_control.py;h=a53c4f93c5d19a4355ef0ddb9b02113b6e855a69;hb=a53c4f93c5d19a4355ef0ddb9b02113b6e855a69," #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 # This tests the restrictions on userAccountControl that apply even if write access is permitted
 #
 # Copyright Samuel Cabrero 2014 <samuelcabrero@kernevil.me>
 # Copyright Andrew Bartlett 2014 <abartlet@samba.org>
 #
 # Licenced under the GPLv3
 #
 
 import optparse
 import sys
 import unittest
 import samba
 import samba.getopt as options
 import samba.tests
 import ldb
 import base64
 
 sys.path.insert(0, ""bin/python"")
 from samba.tests.subunitrun import TestProgram, SubunitOptions
 
 from samba.subunit.run import SubunitTestRunner
 from samba.auth import system_session
 from samba.samdb import SamDB
 from samba.dcerpc import samr, security, lsa
 from samba.credentials import Credentials
 from samba.ndr import ndr_unpack, ndr_pack
 from samba.tests import delete_force
 from samba import gensec, sd_utils
 from samba.credentials import DONT_USE_KERBEROS
 from ldb import SCOPE_SUBTREE, SCOPE_BASE, LdbError
 from ldb import Message, MessageElement, Dn
 from ldb import FLAG_MOD_ADD, FLAG_MOD_REPLACE, FLAG_MOD_DELETE
 from samba.dsdb import UF_SCRIPT, UF_ACCOUNTDISABLE, UF_00000004, UF_HOMEDIR_REQUIRED, \
     UF_LOCKOUT,UF_PASSWD_NOTREQD, UF_PASSWD_CANT_CHANGE, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,\
     UF_TEMP_DUPLICATE_ACCOUNT, UF_NORMAL_ACCOUNT, UF_00000400, UF_INTERDOMAIN_TRUST_ACCOUNT, \
     UF_WORKSTATION_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT, UF_00004000, \
     UF_00008000, UF_DONT_EXPIRE_PASSWD, UF_MNS_LOGON_ACCOUNT, UF_SMARTCARD_REQUIRED, \
     UF_TRUSTED_FOR_DELEGATION, UF_NOT_DELEGATED, UF_USE_DES_KEY_ONLY, UF_DONT_REQUIRE_PREAUTH, \
     UF_PASSWORD_EXPIRED, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, UF_NO_AUTH_DATA_REQUIRED, \
     UF_PARTIAL_SECRETS_ACCOUNT, UF_USE_AES_KEYS
 
 
 parser = optparse.OptionParser(""machine_account_privilege.py [options] <host>"")
 sambaopts = options.SambaOptions(parser)
 parser.add_option_group(sambaopts)
 parser.add_option_group(options.VersionOptions(parser))
 
 # use command line creds if available
 credopts = options.CredentialsOptions(parser)
 parser.add_option_group(credopts)
 opts, args = parser.parse_args()
 
 if len(args) < 1:
     parser.print_usage()
     sys.exit(1)
 host = args[0]
 
 if not ""://"" in host:
     ldaphost = ""ldap://%s"" % host
 else:
     ldaphost = host
     start = host.rindex(""://"")
     host = host.lstrip(start+3)
 
 lp = sambaopts.get_loadparm()
 creds = credopts.get_credentials(lp)
 creds.set_gensec_features(creds.get_gensec_features() | gensec.FEATURE_SEAL)
 
 bits = [UF_SCRIPT, UF_ACCOUNTDISABLE, UF_00000004, UF_HOMEDIR_REQUIRED,
         UF_LOCKOUT,UF_PASSWD_NOTREQD, UF_PASSWD_CANT_CHANGE,
         UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
         UF_TEMP_DUPLICATE_ACCOUNT, UF_NORMAL_ACCOUNT, UF_00000400,
         UF_INTERDOMAIN_TRUST_ACCOUNT,
         UF_WORKSTATION_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT, UF_00004000,
         UF_00008000, UF_DONT_EXPIRE_PASSWD, UF_MNS_LOGON_ACCOUNT, UF_SMARTCARD_REQUIRED,
         UF_TRUSTED_FOR_DELEGATION, UF_NOT_DELEGATED, UF_USE_DES_KEY_ONLY,
         UF_DONT_REQUIRE_PREAUTH,
         UF_PASSWORD_EXPIRED, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
         UF_NO_AUTH_DATA_REQUIRED,
         UF_PARTIAL_SECRETS_ACCOUNT, UF_USE_AES_KEYS,
         int(""0x10000000"", 16), int(""0x20000000"", 16), int(""0x40000000"", 16), int(""0x80000000"", 16)]
 
 account_types = set([UF_NORMAL_ACCOUNT, UF_WORKSTATION_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT])
 
 
 class UserAccountControlTests(samba.tests.TestCase):
     def add_computer_ldap(self, computername, others=None, samdb=None):
         if samdb is None:
             samdb = self.samdb
         dn = ""CN=%s,OU=test_computer_ou1,%s"" % (computername, self.base_dn)
         domainname = ldb.Dn(self.samdb, self.samdb.domain_dn()).canonical_str().replace(""/"", """")
         samaccountname = ""%s$"" % computername
         dnshostname = ""%s.%s"" % (computername, domainname)
         msg_dict = {
             ""dn"": dn,
             ""objectclass"": ""computer""}
         if others is not None:
             msg_dict = dict(msg_dict.items() + others.items())
 
         msg = ldb.Message.from_dict(self.samdb, msg_dict )
         msg[""sAMAccountName""] = samaccountname
 
         print ""Adding computer account %s"" % computername
         samdb.add(msg)
 
     def get_creds(self, target_username, target_password):
         creds_tmp = Credentials()
         creds_tmp.set_username(target_username)
         creds_tmp.set_password(target_password)
         creds_tmp.set_domain(creds.get_domain())
         creds_tmp.set_realm(creds.get_realm())
         creds_tmp.set_workstation(creds.get_workstation())
         creds_tmp.set_gensec_features(creds_tmp.get_gensec_features()
                                       | gensec.FEATURE_SEAL)
         creds_tmp.set_kerberos_state(DONT_USE_KERBEROS) # kinit is too expensive to use in a tight loop
         return creds_tmp
 
     def setUp(self):
         super(UserAccountControlTests, self).setUp()
         self.admin_creds = creds
         self.admin_samdb = SamDB(url=ldaphost,
                                  session_info=system_session(),
                                  credentials=self.admin_creds, lp=lp)
 
         self.unpriv_user = ""testuser1""
         self.unpriv_user_pw = ""samba123@""
         self.unpriv_creds = self.get_creds(self.unpriv_user, self.unpriv_user_pw)
 
         self.admin_samdb.newuser(self.unpriv_user, self.unpriv_user_pw)
         res = self.admin_samdb.search(""CN=%s,CN=Users,%s"" % (self.unpriv_user, self.admin_samdb.domain_dn()),
                                       scope=SCOPE_BASE,
                                       attrs=[""objectSid""])
         self.assertEqual(1, len(res))
 
         self.unpriv_user_sid = ndr_unpack(security.dom_sid, res[0][""objectSid""][0])
         self.unpriv_user_dn = res[0].dn
 
         self.samdb = SamDB(url=ldaphost, credentials=self.unpriv_creds, lp=lp)
         self.domain_sid = security.dom_sid(self.samdb.get_domain_sid())
         self.base_dn = self.samdb.domain_dn()
 
         self.samr = samr.samr(""ncacn_ip_tcp:%s[sign]"" % host, lp, self.unpriv_creds)
         self.samr_handle = self.samr.Connect2(None, security.SEC_FLAG_MAXIMUM_ALLOWED)
         self.samr_domain = self.samr.OpenDomain(self.samr_handle, security.SEC_FLAG_MAXIMUM_ALLOWED, self.domain_sid)
 
         self.sd_utils = sd_utils.SDUtils(self.admin_samdb)
 
         self.admin_samdb.create_ou(""OU=test_computer_ou1,"" + self.base_dn)
         self.unpriv_user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(self.unpriv_user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         self.add_computer_ldap(""testcomputer-t"")
 
         self.sd_utils.modify_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn, old_sd)
 
         self.computernames = [""testcomputer-0""]
 
         # Get the SD of the template account, then force it to match
         # what we expect for SeMachineAccountPrivilege accounts, so we
         # can confirm we created the accounts correctly
         self.sd_reference_cc = self.sd_utils.read_sd_on_dn(""CN=testcomputer-t,OU=test_computer_ou1,%s"" % (self.base_dn))
 
         self.sd_reference_modify = self.sd_utils.read_sd_on_dn(""CN=testcomputer-t,OU=test_computer_ou1,%s"" % (self.base_dn))
         for ace in self.sd_reference_modify.dacl.aces:
             if ace.type == security.SEC_ACE_TYPE_ACCESS_ALLOWED and ace.trustee == self.unpriv_user_sid:
                 ace.access_mask = ace.access_mask | security.SEC_ADS_SELF_WRITE | security.SEC_ADS_WRITE_PROP
 
         # Now reconnect without domain admin rights
         self.samdb = SamDB(url=ldaphost, credentials=self.unpriv_creds, lp=lp)
 
 
     def tearDown(self):
         super(UserAccountControlTests, self).tearDown()
         for computername in self.computernames:
             delete_force(self.admin_samdb, ""CN=%s,OU=test_computer_ou1,%s"" % (computername, self.base_dn))
         delete_force(self.admin_samdb, ""CN=testcomputer-t,OU=test_computer_ou1,%s"" % (self.base_dn))
         delete_force(self.admin_samdb, ""OU=test_computer_ou1,%s"" % (self.base_dn))
         delete_force(self.admin_samdb, ""CN=%s,CN=Users,%s"" % (self.unpriv_user, self.base_dn))
 
     def test_add_computer_sd_cc(self):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         sd = ldb.MessageElement((ndr_pack(self.sd_reference_modify)),
                                 ldb.FLAG_MOD_ADD,
                                 ""nTSecurityDescriptor"")
         self.add_computer_ldap(computername,
                                others={""nTSecurityDescriptor"": sd})
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""ntSecurityDescriptor""])
 
         desc = res[0][""nTSecurityDescriptor""][0]
         desc = ndr_unpack(security.descriptor, desc, allow_remaining=True)
 
         sddl = desc.as_sddl(self.domain_sid)
         self.assertEqual(self.sd_reference_modify.as_sddl(self.domain_sid), sddl)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_SERVER_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to be a DC on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT|samba.dsdb.UF_PARTIAL_SECRETS_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to be an RODC on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""] = ldb.MessageElement(str(security.DOMAIN_RID_ADMINS),
                                                  ldb.FLAG_MOD_REPLACE, ""primaryGroupID"")
         try:
             self.samdb.modify(m)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_UNWILLING_TO_PERFORM, enum)
             return
         self.fail()
 
     def test_mod_computer_cc(self):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         self.add_computer_ldap(computername)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[])
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT|samba.dsdb.UF_PARTIAL_SECRETS_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_SERVER_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
              self.samdb.modify(m)
              self.fail()
         except LdbError, (enum, estr):
              self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_NORMAL_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.samdb.modify(m)
 
     def test_admin_mod_uac(self):
         computername=self.computernames[0]
         self.add_computer_ldap(computername, samdb=self.admin_samdb)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
 
         self.assertEqual(int(res[0][""userAccountControl""][0]), UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT|UF_TRUSTED_FOR_DELEGATION),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.admin_samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT|UF_TRUSTED_FOR_DELEGATION on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_OTHER, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.admin_samdb.modify(m)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
 
         self.assertEqual(int(res[0][""userAccountControl""][0]), UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT)
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(UF_ACCOUNTDISABLE),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.admin_samdb.modify(m)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
 
         self.assertEqual(int(res[0][""userAccountControl""][0]), UF_NORMAL_ACCOUNT| UF_ACCOUNTDISABLE)
 
 
     def test_uac_bits_set(self):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         self.add_computer_ldap(computername)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[])
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         # These bits are privileged, but authenticated users have that CAR by default, so this is a pain to test
         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                                        UF_DONT_EXPIRE_PASSWD])
 
         # These bits really are privileged
         priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT,
                          UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
 
         for bit in bits:
             m = ldb.Message()
             m.dn = res[0].dn
             m[""userAccountControl""] = ldb.MessageElement(str(bit|UF_PASSWD_NOTREQD),
                                                          ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
             try:
                 self.samdb.modify(m)
                 if (bit in priv_bits):
                     self.fail(""Unexpectedly able to set userAccountControl bit 0x%08X on %s"" % (bit, m.dn))
             except LdbError, (enum, estr):
                 if bit in invalid_bits:
                     self.assertEqual(enum, ldb.ERR_OTHER, ""was not able to set 0x%08X on %s"" % (bit, m.dn))
                     # No point going on, try the next bit
                     continue
                 elif (bit in priv_bits):
                     self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
                 else:
                     self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
 
     def uac_bits_unrelated_modify_helper(self, account_type):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         self.add_computer_ldap(computername, others={""userAccountControl"": [str(account_type)]})
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
         self.assertEqual(int(res[0][""userAccountControl""][0]), account_type)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
 
         # UF_LOCKOUT isn't actually ignored, it changes other
         # attributes but does not stick here.  See MS-SAMR 2.2.1.13
         # UF_FLAG Codes clarification that UF_SCRIPT and
         # UF_PASSWD_CANT_CHANGE are simply ignored by both clients and
         # servers.  Other bits are ignored as they are undefined, or
         # are not set into the attribute (instead triggering other
         # events).
         ignored_bits = set([UF_SCRIPT, UF_00000004, UF_LOCKOUT, UF_PASSWD_CANT_CHANGE,
                             UF_00000400, UF_00004000, UF_00008000, UF_PASSWORD_EXPIRED,
                             int(""0x10000000"", 16), int(""0x20000000"", 16), int(""0x40000000"", 16), int(""0x80000000"", 16)])
         super_priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT])
 
         priv_to_remove_bits = set([UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])
 
         for bit in bits:
             # Reset this to the initial position, just to be sure
             m = ldb.Message()
             m.dn = res[0].dn
             m[""userAccountControl""] = ldb.MessageElement(str(account_type),
                                                          ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
             self.admin_samdb.modify(m)
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             self.assertEqual(int(res[0][""userAccountControl""][0]), account_type)
 
             m = ldb.Message()
             m.dn = res[0].dn
             m[""userAccountControl""] = ldb.MessageElement(str(bit|UF_PASSWD_NOTREQD),
                                                          ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
             try:
                 self.admin_samdb.modify(m)
                 if bit in invalid_bits:
                     self.fail(""Should have been unable to set userAccountControl bit 0x%08X on %s"" % (bit, m.dn))
 
             except LdbError, (enum, estr):
                 if bit in invalid_bits:
                     self.assertEqual(enum, ldb.ERR_OTHER)
                     # No point going on, try the next bit
                     continue
                 elif bit in super_priv_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                     # No point going on, try the next bit
                     continue
                 else:
                     self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             if bit in ignored_bits:
                 self.assertEqual(int(res[0][""userAccountControl""][0]), UF_NORMAL_ACCOUNT|UF_PASSWD_NOTREQD, ""Bit 0x%08x shouldn't stick"" % bit)
             else:
                 if bit in account_types:
                     self.assertEqual(int(res[0][""userAccountControl""][0]), bit|UF_PASSWD_NOTREQD, ""Bit 0x%08x didn't stick"" % bit)
                 else:
                     self.assertEqual(int(res[0][""userAccountControl""][0]), bit|UF_NORMAL_ACCOUNT|UF_PASSWD_NOTREQD, ""Bit 0x%08x didn't stick"" % bit)
 
             try:
                 m = ldb.Message()
                 m.dn = res[0].dn
                 m[""userAccountControl""] = ldb.MessageElement(str(bit|UF_PASSWD_NOTREQD|UF_ACCOUNTDISABLE),
                                                              ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
                 self.samdb.modify(m)
 
             except LdbError, (enum, estr):
                 self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             try:
                 m = ldb.Message()
                 m.dn = res[0].dn
                 m[""userAccountControl""] = ldb.MessageElement(str(UF_PASSWD_NOTREQD|UF_ACCOUNTDISABLE),
                                                              ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
                 self.samdb.modify(m)
                 if bit in priv_to_remove_bits:
                     self.fail(""Should have been unable to remove userAccountControl bit 0x%08X on %s"" % (bit, m.dn))
 
             except LdbError, (enum, estr):
                 if bit in priv_to_remove_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                 else:
                     self.fail(""Unexpectedly able to remove userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             if bit in priv_to_remove_bits:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                  ""bit 0X%08x should not have been removed"" % bit)
             else:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                  ""bit 0X%08x should have been removed"" % bit)
 
     def test_uac_bits_unrelated_modify_normal(self):
         self.uac_bits_unrelated_modify_helper(UF_NORMAL_ACCOUNT)
 
     def test_uac_bits_unrelated_modify_workstation(self):
         self.uac_bits_unrelated_modify_helper(UF_WORKSTATION_TRUST_ACCOUNT)
 
     def test_uac_bits_add(self):
         computername=self.computernames[0]
 
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
 
         # These bits are privileged, but authenticated users have that CAR by default, so this is a pain to test
         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                                        UF_DONT_EXPIRE_PASSWD])
 
         # These bits really are privileged
         priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT,
                          UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])
 
         for bit in bits:
             try:
                 self.add_computer_ldap(computername, others={""userAccountControl"": [str(bit)]})
                 delete_force(self.admin_samdb, ""CN=%s,OU=test_computer_ou1,%s"" % (computername, self.base_dn))
                 if bit in priv_bits:
                     self.fail(""Unexpectdly able to set userAccountControl bit 0x%08X on %s"" % (bit, computername))
 
             except LdbError, (enum, estr):
                 if bit in invalid_bits:
                     self.assertEqual(enum, ldb.ERR_OTHER, ""Invalid bit 0x%08X was able to be set on %s"" % (bit, computername))
                     # No point going on, try the next bit
                     continue
                 elif bit in priv_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                     continue
                 else:
                     self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, computername, estr))
 
     def test_primarygroupID_cc_add(self):
         computername=self.computernames[0]
 
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
         try:
             # When creating a new object, you can not ever set the primaryGroupID
             self.add_computer_ldap(computername, others={""primaryGroupID"": [str(security.DOMAIN_RID_ADMINS)]})
             self.fail(""Unexpectedly able to set primaryGruopID to be an admin on %s"" % computername)
         except LdbError, (enum, estr):
             self.assertEqual(enum, ldb.ERR_UNWILLING_TO_PERFORM)
 
 
     def test_primarygroupID_priv_DC_modify(self):
         computername=self.computernames[0]
 
         self.add_computer_ldap(computername,
                                others={""userAccountControl"": [str(UF_SERVER_TRUST_ACCOUNT)]},
                                samdb=self.admin_samdb)
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""""])
 
 
         m = ldb.Message()
         m.dn = ldb.Dn(self.admin_samdb, ""<SID=%s-%d>"" % (str(self.domain_sid),
                                                          security.DOMAIN_RID_USERS))
         m[""member""]= ldb.MessageElement(
             [str(res[0].dn)], ldb.FLAG_MOD_ADD,
             ""member"")
         self.admin_samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""]= ldb.MessageElement(
             [str(security.DOMAIN_RID_USERS)], ldb.FLAG_MOD_REPLACE,
             ""primaryGroupID"")
         try:
             self.admin_samdb.modify(m)
 
             # When creating a new object, you can not ever set the primaryGroupID
             self.fail(""Unexpectedly able to set primaryGroupID to be other than DCS on %s"" % computername)
         except LdbError, (enum, estr):
             self.assertEqual(enum, ldb.ERR_UNWILLING_TO_PERFORM)
 
     def test_primarygroupID_priv_member_modify(self):
         computername=self.computernames[0]
 
         self.add_computer_ldap(computername,
                                others={""userAccountControl"": [str(UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT)]},
                                samdb=self.admin_samdb)
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""""])
 
 
         m = ldb.Message()
         m.dn = ldb.Dn(self.admin_samdb, ""<SID=%s-%d>"" % (str(self.domain_sid),
                                                          security.DOMAIN_RID_USERS))
         m[""member""]= ldb.MessageElement(
             [str(res[0].dn)], ldb.FLAG_MOD_ADD,
             ""member"")
         self.admin_samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""]= ldb.MessageElement(
             [str(security.DOMAIN_RID_USERS)], ldb.FLAG_MOD_REPLACE,
             ""primaryGroupID"")
         try:
             self.admin_samdb.modify(m)
 
             # When creating a new object, you can not ever set the primaryGroupID
             self.fail(""Unexpectedly able to set primaryGroupID to be other than DCS on %s"" % computername)
         except LdbError, (enum, estr):
             self.assertEqual(enum, ldb.ERR_UNWILLING_TO_PERFORM)
 
 
     def test_primarygroupID_priv_user_modify(self):
         computername=self.computernames[0]
 
         self.add_computer_ldap(computername,
                                others={""userAccountControl"": [str(UF_WORKSTATION_TRUST_ACCOUNT)]},
                                samdb=self.admin_samdb)
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""""])
 
 
         m = ldb.Message()
         m.dn = ldb.Dn(self.admin_samdb, ""<SID=%s-%d>"" % (str(self.domain_sid),
                                                          security.DOMAIN_RID_ADMINS))
         m[""member""]= ldb.MessageElement(
             [str(res[0].dn)], ldb.FLAG_MOD_ADD,
             ""member"")
         self.admin_samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""]= ldb.MessageElement(
             [str(security.DOMAIN_RID_ADMINS)], ldb.FLAG_MOD_REPLACE,
             ""primaryGroupID"")
         self.admin_samdb.modify(m)
 
 
 runner = SubunitTestRunner()
 rc = 0
 if not runner.run(unittest.makeSuite(UserAccountControlTests)).wasSuccessful():
     rc = 1
 sys.exit(rc)
"," #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 # This tests the restrictions on userAccountControl that apply even if write access is permitted
 #
 # Copyright Samuel Cabrero 2014 <samuelcabrero@kernevil.me>
 # Copyright Andrew Bartlett 2014 <abartlet@samba.org>
 #
 # Licenced under the GPLv3
 #
 
 import optparse
 import sys
 import unittest
 import samba
 import samba.getopt as options
 import samba.tests
 import ldb
 import base64
 
 sys.path.insert(0, ""bin/python"")
 from samba.tests.subunitrun import TestProgram, SubunitOptions
 
 from samba.subunit.run import SubunitTestRunner
 from samba.auth import system_session
 from samba.samdb import SamDB
 from samba.dcerpc import samr, security, lsa
 from samba.credentials import Credentials
 from samba.ndr import ndr_unpack, ndr_pack
 from samba.tests import delete_force
 from samba import gensec, sd_utils
 from samba.credentials import DONT_USE_KERBEROS
 from ldb import SCOPE_SUBTREE, SCOPE_BASE, LdbError
 from ldb import Message, MessageElement, Dn
 from ldb import FLAG_MOD_ADD, FLAG_MOD_REPLACE, FLAG_MOD_DELETE
 from samba.dsdb import UF_SCRIPT, UF_ACCOUNTDISABLE, UF_00000004, UF_HOMEDIR_REQUIRED, \
     UF_LOCKOUT,UF_PASSWD_NOTREQD, UF_PASSWD_CANT_CHANGE, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,\
     UF_TEMP_DUPLICATE_ACCOUNT, UF_NORMAL_ACCOUNT, UF_00000400, UF_INTERDOMAIN_TRUST_ACCOUNT, \
     UF_WORKSTATION_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT, UF_00004000, \
     UF_00008000, UF_DONT_EXPIRE_PASSWD, UF_MNS_LOGON_ACCOUNT, UF_SMARTCARD_REQUIRED, \
     UF_TRUSTED_FOR_DELEGATION, UF_NOT_DELEGATED, UF_USE_DES_KEY_ONLY, UF_DONT_REQUIRE_PREAUTH, \
     UF_PASSWORD_EXPIRED, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, UF_NO_AUTH_DATA_REQUIRED, \
     UF_PARTIAL_SECRETS_ACCOUNT, UF_USE_AES_KEYS
 
 
 parser = optparse.OptionParser(""machine_account_privilege.py [options] <host>"")
 sambaopts = options.SambaOptions(parser)
 parser.add_option_group(sambaopts)
 parser.add_option_group(options.VersionOptions(parser))
 
 # use command line creds if available
 credopts = options.CredentialsOptions(parser)
 parser.add_option_group(credopts)
 opts, args = parser.parse_args()
 
 if len(args) < 1:
     parser.print_usage()
     sys.exit(1)
 host = args[0]
 
 if not ""://"" in host:
     ldaphost = ""ldap://%s"" % host
 else:
     ldaphost = host
     start = host.rindex(""://"")
     host = host.lstrip(start+3)
 
 lp = sambaopts.get_loadparm()
 creds = credopts.get_credentials(lp)
 creds.set_gensec_features(creds.get_gensec_features() | gensec.FEATURE_SEAL)
 
 bits = [UF_SCRIPT, UF_ACCOUNTDISABLE, UF_00000004, UF_HOMEDIR_REQUIRED,
         UF_LOCKOUT,UF_PASSWD_NOTREQD, UF_PASSWD_CANT_CHANGE,
         UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
         UF_TEMP_DUPLICATE_ACCOUNT, UF_NORMAL_ACCOUNT, UF_00000400,
         UF_INTERDOMAIN_TRUST_ACCOUNT,
         UF_WORKSTATION_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT, UF_00004000,
         UF_00008000, UF_DONT_EXPIRE_PASSWD, UF_MNS_LOGON_ACCOUNT, UF_SMARTCARD_REQUIRED,
         UF_TRUSTED_FOR_DELEGATION, UF_NOT_DELEGATED, UF_USE_DES_KEY_ONLY,
         UF_DONT_REQUIRE_PREAUTH,
         UF_PASSWORD_EXPIRED, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
         UF_NO_AUTH_DATA_REQUIRED,
         UF_PARTIAL_SECRETS_ACCOUNT, UF_USE_AES_KEYS,
         int(""0x10000000"", 16), int(""0x20000000"", 16), int(""0x40000000"", 16), int(""0x80000000"", 16)]
 
 account_types = set([UF_NORMAL_ACCOUNT, UF_WORKSTATION_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT])
 
 
 class UserAccountControlTests(samba.tests.TestCase):
     def add_computer_ldap(self, computername, others=None, samdb=None):
         if samdb is None:
             samdb = self.samdb
         dn = ""CN=%s,OU=test_computer_ou1,%s"" % (computername, self.base_dn)
         domainname = ldb.Dn(self.samdb, self.samdb.domain_dn()).canonical_str().replace(""/"", """")
         samaccountname = ""%s$"" % computername
         dnshostname = ""%s.%s"" % (computername, domainname)
         msg_dict = {
             ""dn"": dn,
             ""objectclass"": ""computer""}
         if others is not None:
             msg_dict = dict(msg_dict.items() + others.items())
 
         msg = ldb.Message.from_dict(self.samdb, msg_dict )
         msg[""sAMAccountName""] = samaccountname
 
         print ""Adding computer account %s"" % computername
         samdb.add(msg)
 
     def get_creds(self, target_username, target_password):
         creds_tmp = Credentials()
         creds_tmp.set_username(target_username)
         creds_tmp.set_password(target_password)
         creds_tmp.set_domain(creds.get_domain())
         creds_tmp.set_realm(creds.get_realm())
         creds_tmp.set_workstation(creds.get_workstation())
         creds_tmp.set_gensec_features(creds_tmp.get_gensec_features()
                                       | gensec.FEATURE_SEAL)
         creds_tmp.set_kerberos_state(DONT_USE_KERBEROS) # kinit is too expensive to use in a tight loop
         return creds_tmp
 
     def setUp(self):
         super(UserAccountControlTests, self).setUp()
         self.admin_creds = creds
         self.admin_samdb = SamDB(url=ldaphost,
                                  session_info=system_session(),
                                  credentials=self.admin_creds, lp=lp)
 
         self.unpriv_user = ""testuser1""
         self.unpriv_user_pw = ""samba123@""
         self.unpriv_creds = self.get_creds(self.unpriv_user, self.unpriv_user_pw)
 
         self.admin_samdb.newuser(self.unpriv_user, self.unpriv_user_pw)
         res = self.admin_samdb.search(""CN=%s,CN=Users,%s"" % (self.unpriv_user, self.admin_samdb.domain_dn()),
                                       scope=SCOPE_BASE,
                                       attrs=[""objectSid""])
         self.assertEqual(1, len(res))
 
         self.unpriv_user_sid = ndr_unpack(security.dom_sid, res[0][""objectSid""][0])
         self.unpriv_user_dn = res[0].dn
 
         self.samdb = SamDB(url=ldaphost, credentials=self.unpriv_creds, lp=lp)
         self.domain_sid = security.dom_sid(self.samdb.get_domain_sid())
         self.base_dn = self.samdb.domain_dn()
 
         self.samr = samr.samr(""ncacn_ip_tcp:%s[sign]"" % host, lp, self.unpriv_creds)
         self.samr_handle = self.samr.Connect2(None, security.SEC_FLAG_MAXIMUM_ALLOWED)
         self.samr_domain = self.samr.OpenDomain(self.samr_handle, security.SEC_FLAG_MAXIMUM_ALLOWED, self.domain_sid)
 
         self.sd_utils = sd_utils.SDUtils(self.admin_samdb)
 
         self.admin_samdb.create_ou(""OU=test_computer_ou1,"" + self.base_dn)
         self.unpriv_user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(self.unpriv_user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         self.add_computer_ldap(""testcomputer-t"")
 
         self.sd_utils.modify_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn, old_sd)
 
         self.computernames = [""testcomputer-0""]
 
         # Get the SD of the template account, then force it to match
         # what we expect for SeMachineAccountPrivilege accounts, so we
         # can confirm we created the accounts correctly
         self.sd_reference_cc = self.sd_utils.read_sd_on_dn(""CN=testcomputer-t,OU=test_computer_ou1,%s"" % (self.base_dn))
 
         self.sd_reference_modify = self.sd_utils.read_sd_on_dn(""CN=testcomputer-t,OU=test_computer_ou1,%s"" % (self.base_dn))
         for ace in self.sd_reference_modify.dacl.aces:
             if ace.type == security.SEC_ACE_TYPE_ACCESS_ALLOWED and ace.trustee == self.unpriv_user_sid:
                 ace.access_mask = ace.access_mask | security.SEC_ADS_SELF_WRITE | security.SEC_ADS_WRITE_PROP
 
         # Now reconnect without domain admin rights
         self.samdb = SamDB(url=ldaphost, credentials=self.unpriv_creds, lp=lp)
 
 
     def tearDown(self):
         super(UserAccountControlTests, self).tearDown()
         for computername in self.computernames:
             delete_force(self.admin_samdb, ""CN=%s,OU=test_computer_ou1,%s"" % (computername, self.base_dn))
         delete_force(self.admin_samdb, ""CN=testcomputer-t,OU=test_computer_ou1,%s"" % (self.base_dn))
         delete_force(self.admin_samdb, ""OU=test_computer_ou1,%s"" % (self.base_dn))
         delete_force(self.admin_samdb, ""CN=%s,CN=Users,%s"" % (self.unpriv_user, self.base_dn))
 
     def test_add_computer_sd_cc(self):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         sd = ldb.MessageElement((ndr_pack(self.sd_reference_modify)),
                                 ldb.FLAG_MOD_ADD,
                                 ""nTSecurityDescriptor"")
         self.add_computer_ldap(computername,
                                others={""nTSecurityDescriptor"": sd})
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""ntSecurityDescriptor""])
 
         desc = res[0][""nTSecurityDescriptor""][0]
         desc = ndr_unpack(security.descriptor, desc, allow_remaining=True)
 
         sddl = desc.as_sddl(self.domain_sid)
         self.assertEqual(self.sd_reference_modify.as_sddl(self.domain_sid), sddl)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_SERVER_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to be a DC on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT|samba.dsdb.UF_PARTIAL_SECRETS_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to be an RODC on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to be an Workstation on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_NORMAL_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""] = ldb.MessageElement(str(security.DOMAIN_RID_ADMINS),
                                                  ldb.FLAG_MOD_REPLACE, ""primaryGroupID"")
         try:
             self.samdb.modify(m)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_UNWILLING_TO_PERFORM, enum)
             return
         self.fail()
 
     def test_mod_computer_cc(self):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         self.add_computer_ldap(computername)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[])
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT|samba.dsdb.UF_PARTIAL_SECRETS_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_SERVER_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
              self.samdb.modify(m)
              self.fail()
         except LdbError, (enum, estr):
              self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_NORMAL_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to be an Workstation on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
 
 
     def test_admin_mod_uac(self):
         computername=self.computernames[0]
         self.add_computer_ldap(computername, samdb=self.admin_samdb)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
 
         self.assertEqual(int(res[0][""userAccountControl""][0]), UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT|UF_TRUSTED_FOR_DELEGATION),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         try:
             self.admin_samdb.modify(m)
             self.fail(""Unexpectedly able to set userAccountControl to UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT|UF_TRUSTED_FOR_DELEGATION on %s"" % m.dn)
         except LdbError, (enum, estr):
             self.assertEqual(ldb.ERR_OTHER, enum)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.admin_samdb.modify(m)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
 
         self.assertEqual(int(res[0][""userAccountControl""][0]), UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT)
         m = ldb.Message()
         m.dn = res[0].dn
         m[""userAccountControl""] = ldb.MessageElement(str(UF_ACCOUNTDISABLE),
                                                      ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
         self.admin_samdb.modify(m)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
 
         self.assertEqual(int(res[0][""userAccountControl""][0]), UF_NORMAL_ACCOUNT| UF_ACCOUNTDISABLE)
 
 
     def test_uac_bits_set(self):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         self.add_computer_ldap(computername)
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[])
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         # These bits are privileged, but authenticated users have that CAR by default, so this is a pain to test
         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                                        UF_DONT_EXPIRE_PASSWD])
 
         # These bits really are privileged, or can't be changed from UF_NORMAL as a non-admin
         priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT,
                          UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
                          UF_WORKSTATION_TRUST_ACCOUNT])
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
 
         for bit in bits:
             m = ldb.Message()
             m.dn = res[0].dn
             m[""userAccountControl""] = ldb.MessageElement(str(bit|UF_PASSWD_NOTREQD),
                                                          ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
             try:
                 self.samdb.modify(m)
                 if (bit in priv_bits):
                     self.fail(""Unexpectedly able to set userAccountControl bit 0x%08X on %s"" % (bit, m.dn))
             except LdbError, (enum, estr):
                 if bit in invalid_bits:
                     self.assertEqual(enum, ldb.ERR_OTHER, ""was not able to set 0x%08X on %s"" % (bit, m.dn))
                     # No point going on, try the next bit
                     continue
                 elif (bit in priv_bits):
                     self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)
                 else:
                     self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
 
     def uac_bits_unrelated_modify_helper(self, account_type):
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         computername=self.computernames[0]
         self.add_computer_ldap(computername, others={""userAccountControl"": [str(account_type)]})
 
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""userAccountControl""])
         self.assertEqual(int(res[0][""userAccountControl""][0]), account_type)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""description""]= ldb.MessageElement(
             (""A description""), ldb.FLAG_MOD_REPLACE,
             ""description"")
         self.samdb.modify(m)
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
 
         # UF_LOCKOUT isn't actually ignored, it changes other
         # attributes but does not stick here.  See MS-SAMR 2.2.1.13
         # UF_FLAG Codes clarification that UF_SCRIPT and
         # UF_PASSWD_CANT_CHANGE are simply ignored by both clients and
         # servers.  Other bits are ignored as they are undefined, or
         # are not set into the attribute (instead triggering other
         # events).
         ignored_bits = set([UF_SCRIPT, UF_00000004, UF_LOCKOUT, UF_PASSWD_CANT_CHANGE,
                             UF_00000400, UF_00004000, UF_00008000, UF_PASSWORD_EXPIRED,
                             int(""0x10000000"", 16), int(""0x20000000"", 16), int(""0x40000000"", 16), int(""0x80000000"", 16)])
         super_priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT])
 
         priv_to_remove_bits = set([UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, UF_WORKSTATION_TRUST_ACCOUNT])
 
         for bit in bits:
             # Reset this to the initial position, just to be sure
             m = ldb.Message()
             m.dn = res[0].dn
             m[""userAccountControl""] = ldb.MessageElement(str(account_type),
                                                          ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
             self.admin_samdb.modify(m)
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             self.assertEqual(int(res[0][""userAccountControl""][0]), account_type)
 
             m = ldb.Message()
             m.dn = res[0].dn
             m[""userAccountControl""] = ldb.MessageElement(str(bit|UF_PASSWD_NOTREQD),
                                                          ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
             try:
                 self.admin_samdb.modify(m)
                 if bit in invalid_bits:
                     self.fail(""Should have been unable to set userAccountControl bit 0x%08X on %s"" % (bit, m.dn))
 
             except LdbError, (enum, estr):
                 if bit in invalid_bits:
                     self.assertEqual(enum, ldb.ERR_OTHER)
                     # No point going on, try the next bit
                     continue
                 elif bit in super_priv_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                     # No point going on, try the next bit
                     continue
                 else:
                     self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             if bit in ignored_bits:
                 self.assertEqual(int(res[0][""userAccountControl""][0]), UF_NORMAL_ACCOUNT|UF_PASSWD_NOTREQD, ""Bit 0x%08x shouldn't stick"" % bit)
             else:
                 if bit in account_types:
                     self.assertEqual(int(res[0][""userAccountControl""][0]), bit|UF_PASSWD_NOTREQD, ""Bit 0x%08x didn't stick"" % bit)
                 else:
                     self.assertEqual(int(res[0][""userAccountControl""][0]), bit|UF_NORMAL_ACCOUNT|UF_PASSWD_NOTREQD, ""Bit 0x%08x didn't stick"" % bit)
 
             try:
                 m = ldb.Message()
                 m.dn = res[0].dn
                 m[""userAccountControl""] = ldb.MessageElement(str(bit|UF_PASSWD_NOTREQD|UF_ACCOUNTDISABLE),
                                                              ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
                 self.samdb.modify(m)
 
             except LdbError, (enum, estr):
                 self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             if bit in account_types:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                  ""bit 0X%08x should have been added (0X%08x vs 0X%08x)""
                                  % (bit, int(res[0][""userAccountControl""][0]),
                                     bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))
             elif bit in ignored_bits:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                  ""bit 0X%08x should have been added (0X%08x vs 0X%08x)""
                                  % (bit, int(res[0][""userAccountControl""][0]),
                                     UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))
 
             else:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                  ""bit 0X%08x should have been added (0X%08x vs 0X%08x)""
                                  % (bit, int(res[0][""userAccountControl""][0]),
                                     bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))
 
             try:
                 m = ldb.Message()
                 m.dn = res[0].dn
                 m[""userAccountControl""] = ldb.MessageElement(str(UF_PASSWD_NOTREQD|UF_ACCOUNTDISABLE),
                                                              ldb.FLAG_MOD_REPLACE, ""userAccountControl"")
                 self.samdb.modify(m)
                 if bit in priv_to_remove_bits:
                     self.fail(""Should have been unable to remove userAccountControl bit 0x%08X on %s"" % (bit, m.dn))
 
             except LdbError, (enum, estr):
                 if bit in priv_to_remove_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                 else:
                     self.fail(""Unexpectedly unable to remove userAccountControl bit 0x%08X on %s: %s"" % (bit, m.dn, estr))
 
             res = self.admin_samdb.search(""%s"" % self.base_dn,
                                           expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                           scope=SCOPE_SUBTREE,
                                           attrs=[""userAccountControl""])
 
             if bit in priv_to_remove_bits:
                 if bit in account_types:
                     self.assertEqual(int(res[0][""userAccountControl""][0]),
                                      bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                      ""bit 0X%08x should not have been removed"" % bit)
                 else:
                     self.assertEqual(int(res[0][""userAccountControl""][0]),
                                      bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                      ""bit 0X%08x should not have been removed"" % bit)
             else:
                 self.assertEqual(int(res[0][""userAccountControl""][0]),
                                  UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,
                                  ""bit 0X%08x should have been removed"" % bit)
 
     def test_uac_bits_unrelated_modify_normal(self):
         self.uac_bits_unrelated_modify_helper(UF_NORMAL_ACCOUNT)
 
     def test_uac_bits_unrelated_modify_workstation(self):
         self.uac_bits_unrelated_modify_helper(UF_WORKSTATION_TRUST_ACCOUNT)
 
     def test_uac_bits_add(self):
         computername=self.computernames[0]
 
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
 
         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])
         # These bits are privileged, but authenticated users have that CAR by default, so this is a pain to test
         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
                                        UF_DONT_EXPIRE_PASSWD])
 
         # These bits really are privileged
         priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT,
                          UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])
 
         for bit in bits:
             try:
                 self.add_computer_ldap(computername, others={""userAccountControl"": [str(bit)]})
                 delete_force(self.admin_samdb, ""CN=%s,OU=test_computer_ou1,%s"" % (computername, self.base_dn))
                 if bit in priv_bits:
                     self.fail(""Unexpectdly able to set userAccountControl bit 0x%08X on %s"" % (bit, computername))
 
             except LdbError, (enum, estr):
                 if bit in invalid_bits:
                     self.assertEqual(enum, ldb.ERR_OTHER, ""Invalid bit 0x%08X was able to be set on %s"" % (bit, computername))
                     # No point going on, try the next bit
                     continue
                 elif bit in priv_bits:
                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)
                     continue
                 else:
                     self.fail(""Unable to set userAccountControl bit 0x%08X on %s: %s"" % (bit, computername, estr))
 
     def test_primarygroupID_cc_add(self):
         computername=self.computernames[0]
 
         user_sid = self.sd_utils.get_object_sid(self.unpriv_user_dn)
         mod = ""(OA;;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;%s)"" % str(user_sid)
 
         old_sd = self.sd_utils.read_sd_on_dn(""OU=test_computer_ou1,"" + self.base_dn)
 
         self.sd_utils.dacl_add_ace(""OU=test_computer_ou1,"" + self.base_dn, mod)
         try:
             # When creating a new object, you can not ever set the primaryGroupID
             self.add_computer_ldap(computername, others={""primaryGroupID"": [str(security.DOMAIN_RID_ADMINS)]})
             self.fail(""Unexpectedly able to set primaryGruopID to be an admin on %s"" % computername)
         except LdbError, (enum, estr):
             self.assertEqual(enum, ldb.ERR_UNWILLING_TO_PERFORM)
 
 
     def test_primarygroupID_priv_DC_modify(self):
         computername=self.computernames[0]
 
         self.add_computer_ldap(computername,
                                others={""userAccountControl"": [str(UF_SERVER_TRUST_ACCOUNT)]},
                                samdb=self.admin_samdb)
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""""])
 
 
         m = ldb.Message()
         m.dn = ldb.Dn(self.admin_samdb, ""<SID=%s-%d>"" % (str(self.domain_sid),
                                                          security.DOMAIN_RID_USERS))
         m[""member""]= ldb.MessageElement(
             [str(res[0].dn)], ldb.FLAG_MOD_ADD,
             ""member"")
         self.admin_samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""]= ldb.MessageElement(
             [str(security.DOMAIN_RID_USERS)], ldb.FLAG_MOD_REPLACE,
             ""primaryGroupID"")
         try:
             self.admin_samdb.modify(m)
 
             # When creating a new object, you can not ever set the primaryGroupID
             self.fail(""Unexpectedly able to set primaryGroupID to be other than DCS on %s"" % computername)
         except LdbError, (enum, estr):
             self.assertEqual(enum, ldb.ERR_UNWILLING_TO_PERFORM)
 
     def test_primarygroupID_priv_member_modify(self):
         computername=self.computernames[0]
 
         self.add_computer_ldap(computername,
                                others={""userAccountControl"": [str(UF_WORKSTATION_TRUST_ACCOUNT|UF_PARTIAL_SECRETS_ACCOUNT)]},
                                samdb=self.admin_samdb)
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""""])
 
 
         m = ldb.Message()
         m.dn = ldb.Dn(self.admin_samdb, ""<SID=%s-%d>"" % (str(self.domain_sid),
                                                          security.DOMAIN_RID_USERS))
         m[""member""]= ldb.MessageElement(
             [str(res[0].dn)], ldb.FLAG_MOD_ADD,
             ""member"")
         self.admin_samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""]= ldb.MessageElement(
             [str(security.DOMAIN_RID_USERS)], ldb.FLAG_MOD_REPLACE,
             ""primaryGroupID"")
         try:
             self.admin_samdb.modify(m)
 
             # When creating a new object, you can not ever set the primaryGroupID
             self.fail(""Unexpectedly able to set primaryGroupID to be other than DCS on %s"" % computername)
         except LdbError, (enum, estr):
             self.assertEqual(enum, ldb.ERR_UNWILLING_TO_PERFORM)
 
 
     def test_primarygroupID_priv_user_modify(self):
         computername=self.computernames[0]
 
         self.add_computer_ldap(computername,
                                others={""userAccountControl"": [str(UF_WORKSTATION_TRUST_ACCOUNT)]},
                                samdb=self.admin_samdb)
         res = self.admin_samdb.search(""%s"" % self.base_dn,
                                       expression=""(&(objectClass=computer)(samAccountName=%s$))"" % computername,
                                       scope=SCOPE_SUBTREE,
                                       attrs=[""""])
 
 
         m = ldb.Message()
         m.dn = ldb.Dn(self.admin_samdb, ""<SID=%s-%d>"" % (str(self.domain_sid),
                                                          security.DOMAIN_RID_ADMINS))
         m[""member""]= ldb.MessageElement(
             [str(res[0].dn)], ldb.FLAG_MOD_ADD,
             ""member"")
         self.admin_samdb.modify(m)
 
         m = ldb.Message()
         m.dn = res[0].dn
         m[""primaryGroupID""]= ldb.MessageElement(
             [str(security.DOMAIN_RID_ADMINS)], ldb.FLAG_MOD_REPLACE,
             ""primaryGroupID"")
         self.admin_samdb.modify(m)
 
 
 runner = SubunitTestRunner()
 rc = 0
 if not runner.run(unittest.makeSuite(UserAccountControlTests)).wasSuccessful():
     rc = 1
 sys.exit(rc)
"
CVE-2009-4411,https://www.cvedetails.com/cve/CVE-2009-4411/,CWE-264,,,2009-12-24,2017-08-16,3.7,None,Local,High,Not required,Partial,Partial,Partial,"The (1) setfacl and (2) getfacl commands in XFS acl 2.2.47, when running in recursive (-R) mode, follow symbolic links even when the --physical (aka -P) or -L option is specified, which might allow local users to modify the ACL for arbitrary files or directories via a symlink attack.",C,savannah,https://git.savannah.gnu.org/cgit/acl.git/commit/?id=63451a0,63451a06b7484d220750ed8574d3ee84e156daf5,943f82dfa6ac250be30e4efe147831e9765cda93,"@@ -1,3 +1,6 @@+* Make sure that getfacl -R only calls stat(2) on symlinks when it needs to.+  This fixes http://oss.sgi.com/bugzilla/show_bug.cgi?id=790 ""getfacl follows+  symlinks, even without -L"". * Stop quoting nonprintable characters in the getfacl output: what is printable   or not depends on the locale settings, and getfacl often gets it wrong. We   still need to quote a few special characters like newlines so that setfacldiff --git a/getfacl/getfacl.c b/getfacl/getfacl.c
index fc650e3..b3e6200 100644
--- a/getfacl/getfacl.c
+++ b/getfacl/getfacl.c@@ -70,7 +70,7 @@ struct option long_options[] = { const char *progname; const char *cmd_line_options; -int walk_flags = WALK_TREE_DEREFERENCE;+int walk_flags = WALK_TREE_DEREFERENCE_TOPLEVEL; int opt_print_acl; int opt_print_default_acl; int opt_strip_leading_slash = 1;@@ -642,7 +642,7 @@ int main(int argc, char *argv[])                         case 'L':  /* follow all symlinks */                                 if (posixly_correct)                                         goto synopsis;-                                walk_flags |= WALK_TREE_LOGICAL;+                                walk_flags |= WALK_TREE_LOGICAL | WALK_TREE_DEREFERENCE;                                 walk_flags &= ~WALK_TREE_PHYSICAL;                                 break; @@ -650,7 +650,8 @@ int main(int argc, char *argv[])                                 if (posixly_correct)                                         goto synopsis;                                 walk_flags |= WALK_TREE_PHYSICAL;-                                walk_flags &= ~WALK_TREE_LOGICAL;+                                walk_flags &= ~(WALK_TREE_LOGICAL | WALK_TREE_DEREFERENCE |+                                                WALK_TREE_DEREFERENCE_TOPLEVEL);                                 break;                          case 's':  /* skip files with only base entries */",https://git.savannah.gnu.org/cgit/acl.git/tree/getfacl/getfacl.c?id=943f82dfa6ac250be30e4efe147831e9765cda93,https://git.savannah.gnu.org/cgit/acl.git/tree/getfacl/getfacl.c?id=63451a06b7484d220750ed8574d3ee84e156daf5,"<!DOCTYPE html>
<html lang='en'>
<head>
<title>getfacl.c\getfacl - acl.git - acl</title>
<meta name='generator' content='cgit v1.2.1'/>
<meta name='robots' content='index, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit/cgit.css'/>
<link rel='shortcut icon' href='/gitweb/git-favicon.png'/>
<link rel='alternate' title='Atom feed' href='https://git.savannah.gnu.org/cgit/acl.git/atom/getfacl/getfacl.c?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.savannah.gnu.org/acl.git' title='acl.git Git repository'/>
<link rel='vcs-git' href='https://git.savannah.gnu.org/git/acl.git' title='acl.git Git repository'/>
<link rel='vcs-git' href='ssh://git.savannah.gnu.org/srv/git/acl.git' title='acl.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/cgit/'><img src='/cgit/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/cgit/'>index</a> : <a title='acl.git' href='/cgit/acl.git/'>acl.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='943f82dfa6ac250be30e4efe147831e9765cda93'/><select name='h' onchange='this.form.submit();'>
<option value='master' selected='selected'>master</option>
<option value='misc'>misc</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>acl</td><td class='sub right'></td></tr></table>
<table class='tabs'><tr><td>
<a href='/cgit/acl.git/'>summary</a><a href='/cgit/acl.git/refs/?id=943f82dfa6ac250be30e4efe147831e9765cda93'>refs</a><a href='/cgit/acl.git/log/getfacl/getfacl.c'>log</a><a class='active' href='/cgit/acl.git/tree/getfacl/getfacl.c?id=943f82dfa6ac250be30e4efe147831e9765cda93'>tree</a><a href='/cgit/acl.git/commit/getfacl/getfacl.c?id=943f82dfa6ac250be30e4efe147831e9765cda93'>commit</a><a href='/cgit/acl.git/diff/getfacl/getfacl.c?id=943f82dfa6ac250be30e4efe147831e9765cda93'>diff</a></td><td class='form'><form class='right' method='get' action='/cgit/acl.git/log/getfacl/getfacl.c'>
<input type='hidden' name='id' value='943f82dfa6ac250be30e4efe147831e9765cda93'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='path'>path: <a href='/cgit/acl.git/tree/?id=943f82dfa6ac250be30e4efe147831e9765cda93'>root</a>/<a href='/cgit/acl.git/tree/getfacl?id=943f82dfa6ac250be30e4efe147831e9765cda93'>getfacl</a>/<a href='/cgit/acl.git/tree/getfacl/getfacl.c?id=943f82dfa6ac250be30e4efe147831e9765cda93'>getfacl.c</a></div><div class='content'>blob: fc650e3e98351b4671133146f7c6703ec20b9dfe (<a href='/cgit/acl.git/plain/getfacl/getfacl.c?id=943f82dfa6ac250be30e4efe147831e9765cda93'>plain</a>)
<table summary='blob content' class='blob'>
<tr><td class='linenumbers'><pre><a id='n1' href='#n1'>1</a>
<a id='n2' href='#n2'>2</a>
<a id='n3' href='#n3'>3</a>
<a id='n4' href='#n4'>4</a>
<a id='n5' href='#n5'>5</a>
<a id='n6' href='#n6'>6</a>
<a id='n7' href='#n7'>7</a>
<a id='n8' href='#n8'>8</a>
<a id='n9' href='#n9'>9</a>
<a id='n10' href='#n10'>10</a>
<a id='n11' href='#n11'>11</a>
<a id='n12' href='#n12'>12</a>
<a id='n13' href='#n13'>13</a>
<a id='n14' href='#n14'>14</a>
<a id='n15' href='#n15'>15</a>
<a id='n16' href='#n16'>16</a>
<a id='n17' href='#n17'>17</a>
<a id='n18' href='#n18'>18</a>
<a id='n19' href='#n19'>19</a>
<a id='n20' href='#n20'>20</a>
<a id='n21' href='#n21'>21</a>
<a id='n22' href='#n22'>22</a>
<a id='n23' href='#n23'>23</a>
<a id='n24' href='#n24'>24</a>
<a id='n25' href='#n25'>25</a>
<a id='n26' href='#n26'>26</a>
<a id='n27' href='#n27'>27</a>
<a id='n28' href='#n28'>28</a>
<a id='n29' href='#n29'>29</a>
<a id='n30' href='#n30'>30</a>
<a id='n31' href='#n31'>31</a>
<a id='n32' href='#n32'>32</a>
<a id='n33' href='#n33'>33</a>
<a id='n34' href='#n34'>34</a>
<a id='n35' href='#n35'>35</a>
<a id='n36' href='#n36'>36</a>
<a id='n37' href='#n37'>37</a>
<a id='n38' href='#n38'>38</a>
<a id='n39' href='#n39'>39</a>
<a id='n40' href='#n40'>40</a>
<a id='n41' href='#n41'>41</a>
<a id='n42' href='#n42'>42</a>
<a id='n43' href='#n43'>43</a>
<a id='n44' href='#n44'>44</a>
<a id='n45' href='#n45'>45</a>
<a id='n46' href='#n46'>46</a>
<a id='n47' href='#n47'>47</a>
<a id='n48' href='#n48'>48</a>
<a id='n49' href='#n49'>49</a>
<a id='n50' href='#n50'>50</a>
<a id='n51' href='#n51'>51</a>
<a id='n52' href='#n52'>52</a>
<a id='n53' href='#n53'>53</a>
<a id='n54' href='#n54'>54</a>
<a id='n55' href='#n55'>55</a>
<a id='n56' href='#n56'>56</a>
<a id='n57' href='#n57'>57</a>
<a id='n58' href='#n58'>58</a>
<a id='n59' href='#n59'>59</a>
<a id='n60' href='#n60'>60</a>
<a id='n61' href='#n61'>61</a>
<a id='n62' href='#n62'>62</a>
<a id='n63' href='#n63'>63</a>
<a id='n64' href='#n64'>64</a>
<a id='n65' href='#n65'>65</a>
<a id='n66' href='#n66'>66</a>
<a id='n67' href='#n67'>67</a>
<a id='n68' href='#n68'>68</a>
<a id='n69' href='#n69'>69</a>
<a id='n70' href='#n70'>70</a>
<a id='n71' href='#n71'>71</a>
<a id='n72' href='#n72'>72</a>
<a id='n73' href='#n73'>73</a>
<a id='n74' href='#n74'>74</a>
<a id='n75' href='#n75'>75</a>
<a id='n76' href='#n76'>76</a>
<a id='n77' href='#n77'>77</a>
<a id='n78' href='#n78'>78</a>
<a id='n79' href='#n79'>79</a>
<a id='n80' href='#n80'>80</a>
<a id='n81' href='#n81'>81</a>
<a id='n82' href='#n82'>82</a>
<a id='n83' href='#n83'>83</a>
<a id='n84' href='#n84'>84</a>
<a id='n85' href='#n85'>85</a>
<a id='n86' href='#n86'>86</a>
<a id='n87' href='#n87'>87</a>
<a id='n88' href='#n88'>88</a>
<a id='n89' href='#n89'>89</a>
<a id='n90' href='#n90'>90</a>
<a id='n91' href='#n91'>91</a>
<a id='n92' href='#n92'>92</a>
<a id='n93' href='#n93'>93</a>
<a id='n94' href='#n94'>94</a>
<a id='n95' href='#n95'>95</a>
<a id='n96' href='#n96'>96</a>
<a id='n97' href='#n97'>97</a>
<a id='n98' href='#n98'>98</a>
<a id='n99' href='#n99'>99</a>
<a id='n100' href='#n100'>100</a>
<a id='n101' href='#n101'>101</a>
<a id='n102' href='#n102'>102</a>
<a id='n103' href='#n103'>103</a>
<a id='n104' href='#n104'>104</a>
<a id='n105' href='#n105'>105</a>
<a id='n106' href='#n106'>106</a>
<a id='n107' href='#n107'>107</a>
<a id='n108' href='#n108'>108</a>
<a id='n109' href='#n109'>109</a>
<a id='n110' href='#n110'>110</a>
<a id='n111' href='#n111'>111</a>
<a id='n112' href='#n112'>112</a>
<a id='n113' href='#n113'>113</a>
<a id='n114' href='#n114'>114</a>
<a id='n115' href='#n115'>115</a>
<a id='n116' href='#n116'>116</a>
<a id='n117' href='#n117'>117</a>
<a id='n118' href='#n118'>118</a>
<a id='n119' href='#n119'>119</a>
<a id='n120' href='#n120'>120</a>
<a id='n121' href='#n121'>121</a>
<a id='n122' href='#n122'>122</a>
<a id='n123' href='#n123'>123</a>
<a id='n124' href='#n124'>124</a>
<a id='n125' href='#n125'>125</a>
<a id='n126' href='#n126'>126</a>
<a id='n127' href='#n127'>127</a>
<a id='n128' href='#n128'>128</a>
<a id='n129' href='#n129'>129</a>
<a id='n130' href='#n130'>130</a>
<a id='n131' href='#n131'>131</a>
<a id='n132' href='#n132'>132</a>
<a id='n133' href='#n133'>133</a>
<a id='n134' href='#n134'>134</a>
<a id='n135' href='#n135'>135</a>
<a id='n136' href='#n136'>136</a>
<a id='n137' href='#n137'>137</a>
<a id='n138' href='#n138'>138</a>
<a id='n139' href='#n139'>139</a>
<a id='n140' href='#n140'>140</a>
<a id='n141' href='#n141'>141</a>
<a id='n142' href='#n142'>142</a>
<a id='n143' href='#n143'>143</a>
<a id='n144' href='#n144'>144</a>
<a id='n145' href='#n145'>145</a>
<a id='n146' href='#n146'>146</a>
<a id='n147' href='#n147'>147</a>
<a id='n148' href='#n148'>148</a>
<a id='n149' href='#n149'>149</a>
<a id='n150' href='#n150'>150</a>
<a id='n151' href='#n151'>151</a>
<a id='n152' href='#n152'>152</a>
<a id='n153' href='#n153'>153</a>
<a id='n154' href='#n154'>154</a>
<a id='n155' href='#n155'>155</a>
<a id='n156' href='#n156'>156</a>
<a id='n157' href='#n157'>157</a>
<a id='n158' href='#n158'>158</a>
<a id='n159' href='#n159'>159</a>
<a id='n160' href='#n160'>160</a>
<a id='n161' href='#n161'>161</a>
<a id='n162' href='#n162'>162</a>
<a id='n163' href='#n163'>163</a>
<a id='n164' href='#n164'>164</a>
<a id='n165' href='#n165'>165</a>
<a id='n166' href='#n166'>166</a>
<a id='n167' href='#n167'>167</a>
<a id='n168' href='#n168'>168</a>
<a id='n169' href='#n169'>169</a>
<a id='n170' href='#n170'>170</a>
<a id='n171' href='#n171'>171</a>
<a id='n172' href='#n172'>172</a>
<a id='n173' href='#n173'>173</a>
<a id='n174' href='#n174'>174</a>
<a id='n175' href='#n175'>175</a>
<a id='n176' href='#n176'>176</a>
<a id='n177' href='#n177'>177</a>
<a id='n178' href='#n178'>178</a>
<a id='n179' href='#n179'>179</a>
<a id='n180' href='#n180'>180</a>
<a id='n181' href='#n181'>181</a>
<a id='n182' href='#n182'>182</a>
<a id='n183' href='#n183'>183</a>
<a id='n184' href='#n184'>184</a>
<a id='n185' href='#n185'>185</a>
<a id='n186' href='#n186'>186</a>
<a id='n187' href='#n187'>187</a>
<a id='n188' href='#n188'>188</a>
<a id='n189' href='#n189'>189</a>
<a id='n190' href='#n190'>190</a>
<a id='n191' href='#n191'>191</a>
<a id='n192' href='#n192'>192</a>
<a id='n193' href='#n193'>193</a>
<a id='n194' href='#n194'>194</a>
<a id='n195' href='#n195'>195</a>
<a id='n196' href='#n196'>196</a>
<a id='n197' href='#n197'>197</a>
<a id='n198' href='#n198'>198</a>
<a id='n199' href='#n199'>199</a>
<a id='n200' href='#n200'>200</a>
<a id='n201' href='#n201'>201</a>
<a id='n202' href='#n202'>202</a>
<a id='n203' href='#n203'>203</a>
<a id='n204' href='#n204'>204</a>
<a id='n205' href='#n205'>205</a>
<a id='n206' href='#n206'>206</a>
<a id='n207' href='#n207'>207</a>
<a id='n208' href='#n208'>208</a>
<a id='n209' href='#n209'>209</a>
<a id='n210' href='#n210'>210</a>
<a id='n211' href='#n211'>211</a>
<a id='n212' href='#n212'>212</a>
<a id='n213' href='#n213'>213</a>
<a id='n214' href='#n214'>214</a>
<a id='n215' href='#n215'>215</a>
<a id='n216' href='#n216'>216</a>
<a id='n217' href='#n217'>217</a>
<a id='n218' href='#n218'>218</a>
<a id='n219' href='#n219'>219</a>
<a id='n220' href='#n220'>220</a>
<a id='n221' href='#n221'>221</a>
<a id='n222' href='#n222'>222</a>
<a id='n223' href='#n223'>223</a>
<a id='n224' href='#n224'>224</a>
<a id='n225' href='#n225'>225</a>
<a id='n226' href='#n226'>226</a>
<a id='n227' href='#n227'>227</a>
<a id='n228' href='#n228'>228</a>
<a id='n229' href='#n229'>229</a>
<a id='n230' href='#n230'>230</a>
<a id='n231' href='#n231'>231</a>
<a id='n232' href='#n232'>232</a>
<a id='n233' href='#n233'>233</a>
<a id='n234' href='#n234'>234</a>
<a id='n235' href='#n235'>235</a>
<a id='n236' href='#n236'>236</a>
<a id='n237' href='#n237'>237</a>
<a id='n238' href='#n238'>238</a>
<a id='n239' href='#n239'>239</a>
<a id='n240' href='#n240'>240</a>
<a id='n241' href='#n241'>241</a>
<a id='n242' href='#n242'>242</a>
<a id='n243' href='#n243'>243</a>
<a id='n244' href='#n244'>244</a>
<a id='n245' href='#n245'>245</a>
<a id='n246' href='#n246'>246</a>
<a id='n247' href='#n247'>247</a>
<a id='n248' href='#n248'>248</a>
<a id='n249' href='#n249'>249</a>
<a id='n250' href='#n250'>250</a>
<a id='n251' href='#n251'>251</a>
<a id='n252' href='#n252'>252</a>
<a id='n253' href='#n253'>253</a>
<a id='n254' href='#n254'>254</a>
<a id='n255' href='#n255'>255</a>
<a id='n256' href='#n256'>256</a>
<a id='n257' href='#n257'>257</a>
<a id='n258' href='#n258'>258</a>
<a id='n259' href='#n259'>259</a>
<a id='n260' href='#n260'>260</a>
<a id='n261' href='#n261'>261</a>
<a id='n262' href='#n262'>262</a>
<a id='n263' href='#n263'>263</a>
<a id='n264' href='#n264'>264</a>
<a id='n265' href='#n265'>265</a>
<a id='n266' href='#n266'>266</a>
<a id='n267' href='#n267'>267</a>
<a id='n268' href='#n268'>268</a>
<a id='n269' href='#n269'>269</a>
<a id='n270' href='#n270'>270</a>
<a id='n271' href='#n271'>271</a>
<a id='n272' href='#n272'>272</a>
<a id='n273' href='#n273'>273</a>
<a id='n274' href='#n274'>274</a>
<a id='n275' href='#n275'>275</a>
<a id='n276' href='#n276'>276</a>
<a id='n277' href='#n277'>277</a>
<a id='n278' href='#n278'>278</a>
<a id='n279' href='#n279'>279</a>
<a id='n280' href='#n280'>280</a>
<a id='n281' href='#n281'>281</a>
<a id='n282' href='#n282'>282</a>
<a id='n283' href='#n283'>283</a>
<a id='n284' href='#n284'>284</a>
<a id='n285' href='#n285'>285</a>
<a id='n286' href='#n286'>286</a>
<a id='n287' href='#n287'>287</a>
<a id='n288' href='#n288'>288</a>
<a id='n289' href='#n289'>289</a>
<a id='n290' href='#n290'>290</a>
<a id='n291' href='#n291'>291</a>
<a id='n292' href='#n292'>292</a>
<a id='n293' href='#n293'>293</a>
<a id='n294' href='#n294'>294</a>
<a id='n295' href='#n295'>295</a>
<a id='n296' href='#n296'>296</a>
<a id='n297' href='#n297'>297</a>
<a id='n298' href='#n298'>298</a>
<a id='n299' href='#n299'>299</a>
<a id='n300' href='#n300'>300</a>
<a id='n301' href='#n301'>301</a>
<a id='n302' href='#n302'>302</a>
<a id='n303' href='#n303'>303</a>
<a id='n304' href='#n304'>304</a>
<a id='n305' href='#n305'>305</a>
<a id='n306' href='#n306'>306</a>
<a id='n307' href='#n307'>307</a>
<a id='n308' href='#n308'>308</a>
<a id='n309' href='#n309'>309</a>
<a id='n310' href='#n310'>310</a>
<a id='n311' href='#n311'>311</a>
<a id='n312' href='#n312'>312</a>
<a id='n313' href='#n313'>313</a>
<a id='n314' href='#n314'>314</a>
<a id='n315' href='#n315'>315</a>
<a id='n316' href='#n316'>316</a>
<a id='n317' href='#n317'>317</a>
<a id='n318' href='#n318'>318</a>
<a id='n319' href='#n319'>319</a>
<a id='n320' href='#n320'>320</a>
<a id='n321' href='#n321'>321</a>
<a id='n322' href='#n322'>322</a>
<a id='n323' href='#n323'>323</a>
<a id='n324' href='#n324'>324</a>
<a id='n325' href='#n325'>325</a>
<a id='n326' href='#n326'>326</a>
<a id='n327' href='#n327'>327</a>
<a id='n328' href='#n328'>328</a>
<a id='n329' href='#n329'>329</a>
<a id='n330' href='#n330'>330</a>
<a id='n331' href='#n331'>331</a>
<a id='n332' href='#n332'>332</a>
<a id='n333' href='#n333'>333</a>
<a id='n334' href='#n334'>334</a>
<a id='n335' href='#n335'>335</a>
<a id='n336' href='#n336'>336</a>
<a id='n337' href='#n337'>337</a>
<a id='n338' href='#n338'>338</a>
<a id='n339' href='#n339'>339</a>
<a id='n340' href='#n340'>340</a>
<a id='n341' href='#n341'>341</a>
<a id='n342' href='#n342'>342</a>
<a id='n343' href='#n343'>343</a>
<a id='n344' href='#n344'>344</a>
<a id='n345' href='#n345'>345</a>
<a id='n346' href='#n346'>346</a>
<a id='n347' href='#n347'>347</a>
<a id='n348' href='#n348'>348</a>
<a id='n349' href='#n349'>349</a>
<a id='n350' href='#n350'>350</a>
<a id='n351' href='#n351'>351</a>
<a id='n352' href='#n352'>352</a>
<a id='n353' href='#n353'>353</a>
<a id='n354' href='#n354'>354</a>
<a id='n355' href='#n355'>355</a>
<a id='n356' href='#n356'>356</a>
<a id='n357' href='#n357'>357</a>
<a id='n358' href='#n358'>358</a>
<a id='n359' href='#n359'>359</a>
<a id='n360' href='#n360'>360</a>
<a id='n361' href='#n361'>361</a>
<a id='n362' href='#n362'>362</a>
<a id='n363' href='#n363'>363</a>
<a id='n364' href='#n364'>364</a>
<a id='n365' href='#n365'>365</a>
<a id='n366' href='#n366'>366</a>
<a id='n367' href='#n367'>367</a>
<a id='n368' href='#n368'>368</a>
<a id='n369' href='#n369'>369</a>
<a id='n370' href='#n370'>370</a>
<a id='n371' href='#n371'>371</a>
<a id='n372' href='#n372'>372</a>
<a id='n373' href='#n373'>373</a>
<a id='n374' href='#n374'>374</a>
<a id='n375' href='#n375'>375</a>
<a id='n376' href='#n376'>376</a>
<a id='n377' href='#n377'>377</a>
<a id='n378' href='#n378'>378</a>
<a id='n379' href='#n379'>379</a>
<a id='n380' href='#n380'>380</a>
<a id='n381' href='#n381'>381</a>
<a id='n382' href='#n382'>382</a>
<a id='n383' href='#n383'>383</a>
<a id='n384' href='#n384'>384</a>
<a id='n385' href='#n385'>385</a>
<a id='n386' href='#n386'>386</a>
<a id='n387' href='#n387'>387</a>
<a id='n388' href='#n388'>388</a>
<a id='n389' href='#n389'>389</a>
<a id='n390' href='#n390'>390</a>
<a id='n391' href='#n391'>391</a>
<a id='n392' href='#n392'>392</a>
<a id='n393' href='#n393'>393</a>
<a id='n394' href='#n394'>394</a>
<a id='n395' href='#n395'>395</a>
<a id='n396' href='#n396'>396</a>
<a id='n397' href='#n397'>397</a>
<a id='n398' href='#n398'>398</a>
<a id='n399' href='#n399'>399</a>
<a id='n400' href='#n400'>400</a>
<a id='n401' href='#n401'>401</a>
<a id='n402' href='#n402'>402</a>
<a id='n403' href='#n403'>403</a>
<a id='n404' href='#n404'>404</a>
<a id='n405' href='#n405'>405</a>
<a id='n406' href='#n406'>406</a>
<a id='n407' href='#n407'>407</a>
<a id='n408' href='#n408'>408</a>
<a id='n409' href='#n409'>409</a>
<a id='n410' href='#n410'>410</a>
<a id='n411' href='#n411'>411</a>
<a id='n412' href='#n412'>412</a>
<a id='n413' href='#n413'>413</a>
<a id='n414' href='#n414'>414</a>
<a id='n415' href='#n415'>415</a>
<a id='n416' href='#n416'>416</a>
<a id='n417' href='#n417'>417</a>
<a id='n418' href='#n418'>418</a>
<a id='n419' href='#n419'>419</a>
<a id='n420' href='#n420'>420</a>
<a id='n421' href='#n421'>421</a>
<a id='n422' href='#n422'>422</a>
<a id='n423' href='#n423'>423</a>
<a id='n424' href='#n424'>424</a>
<a id='n425' href='#n425'>425</a>
<a id='n426' href='#n426'>426</a>
<a id='n427' href='#n427'>427</a>
<a id='n428' href='#n428'>428</a>
<a id='n429' href='#n429'>429</a>
<a id='n430' href='#n430'>430</a>
<a id='n431' href='#n431'>431</a>
<a id='n432' href='#n432'>432</a>
<a id='n433' href='#n433'>433</a>
<a id='n434' href='#n434'>434</a>
<a id='n435' href='#n435'>435</a>
<a id='n436' href='#n436'>436</a>
<a id='n437' href='#n437'>437</a>
<a id='n438' href='#n438'>438</a>
<a id='n439' href='#n439'>439</a>
<a id='n440' href='#n440'>440</a>
<a id='n441' href='#n441'>441</a>
<a id='n442' href='#n442'>442</a>
<a id='n443' href='#n443'>443</a>
<a id='n444' href='#n444'>444</a>
<a id='n445' href='#n445'>445</a>
<a id='n446' href='#n446'>446</a>
<a id='n447' href='#n447'>447</a>
<a id='n448' href='#n448'>448</a>
<a id='n449' href='#n449'>449</a>
<a id='n450' href='#n450'>450</a>
<a id='n451' href='#n451'>451</a>
<a id='n452' href='#n452'>452</a>
<a id='n453' href='#n453'>453</a>
<a id='n454' href='#n454'>454</a>
<a id='n455' href='#n455'>455</a>
<a id='n456' href='#n456'>456</a>
<a id='n457' href='#n457'>457</a>
<a id='n458' href='#n458'>458</a>
<a id='n459' href='#n459'>459</a>
<a id='n460' href='#n460'>460</a>
<a id='n461' href='#n461'>461</a>
<a id='n462' href='#n462'>462</a>
<a id='n463' href='#n463'>463</a>
<a id='n464' href='#n464'>464</a>
<a id='n465' href='#n465'>465</a>
<a id='n466' href='#n466'>466</a>
<a id='n467' href='#n467'>467</a>
<a id='n468' href='#n468'>468</a>
<a id='n469' href='#n469'>469</a>
<a id='n470' href='#n470'>470</a>
<a id='n471' href='#n471'>471</a>
<a id='n472' href='#n472'>472</a>
<a id='n473' href='#n473'>473</a>
<a id='n474' href='#n474'>474</a>
<a id='n475' href='#n475'>475</a>
<a id='n476' href='#n476'>476</a>
<a id='n477' href='#n477'>477</a>
<a id='n478' href='#n478'>478</a>
<a id='n479' href='#n479'>479</a>
<a id='n480' href='#n480'>480</a>
<a id='n481' href='#n481'>481</a>
<a id='n482' href='#n482'>482</a>
<a id='n483' href='#n483'>483</a>
<a id='n484' href='#n484'>484</a>
<a id='n485' href='#n485'>485</a>
<a id='n486' href='#n486'>486</a>
<a id='n487' href='#n487'>487</a>
<a id='n488' href='#n488'>488</a>
<a id='n489' href='#n489'>489</a>
<a id='n490' href='#n490'>490</a>
<a id='n491' href='#n491'>491</a>
<a id='n492' href='#n492'>492</a>
<a id='n493' href='#n493'>493</a>
<a id='n494' href='#n494'>494</a>
<a id='n495' href='#n495'>495</a>
<a id='n496' href='#n496'>496</a>
<a id='n497' href='#n497'>497</a>
<a id='n498' href='#n498'>498</a>
<a id='n499' href='#n499'>499</a>
<a id='n500' href='#n500'>500</a>
<a id='n501' href='#n501'>501</a>
<a id='n502' href='#n502'>502</a>
<a id='n503' href='#n503'>503</a>
<a id='n504' href='#n504'>504</a>
<a id='n505' href='#n505'>505</a>
<a id='n506' href='#n506'>506</a>
<a id='n507' href='#n507'>507</a>
<a id='n508' href='#n508'>508</a>
<a id='n509' href='#n509'>509</a>
<a id='n510' href='#n510'>510</a>
<a id='n511' href='#n511'>511</a>
<a id='n512' href='#n512'>512</a>
<a id='n513' href='#n513'>513</a>
<a id='n514' href='#n514'>514</a>
<a id='n515' href='#n515'>515</a>
<a id='n516' href='#n516'>516</a>
<a id='n517' href='#n517'>517</a>
<a id='n518' href='#n518'>518</a>
<a id='n519' href='#n519'>519</a>
<a id='n520' href='#n520'>520</a>
<a id='n521' href='#n521'>521</a>
<a id='n522' href='#n522'>522</a>
<a id='n523' href='#n523'>523</a>
<a id='n524' href='#n524'>524</a>
<a id='n525' href='#n525'>525</a>
<a id='n526' href='#n526'>526</a>
<a id='n527' href='#n527'>527</a>
<a id='n528' href='#n528'>528</a>
<a id='n529' href='#n529'>529</a>
<a id='n530' href='#n530'>530</a>
<a id='n531' href='#n531'>531</a>
<a id='n532' href='#n532'>532</a>
<a id='n533' href='#n533'>533</a>
<a id='n534' href='#n534'>534</a>
<a id='n535' href='#n535'>535</a>
<a id='n536' href='#n536'>536</a>
<a id='n537' href='#n537'>537</a>
<a id='n538' href='#n538'>538</a>
<a id='n539' href='#n539'>539</a>
<a id='n540' href='#n540'>540</a>
<a id='n541' href='#n541'>541</a>
<a id='n542' href='#n542'>542</a>
<a id='n543' href='#n543'>543</a>
<a id='n544' href='#n544'>544</a>
<a id='n545' href='#n545'>545</a>
<a id='n546' href='#n546'>546</a>
<a id='n547' href='#n547'>547</a>
<a id='n548' href='#n548'>548</a>
<a id='n549' href='#n549'>549</a>
<a id='n550' href='#n550'>550</a>
<a id='n551' href='#n551'>551</a>
<a id='n552' href='#n552'>552</a>
<a id='n553' href='#n553'>553</a>
<a id='n554' href='#n554'>554</a>
<a id='n555' href='#n555'>555</a>
<a id='n556' href='#n556'>556</a>
<a id='n557' href='#n557'>557</a>
<a id='n558' href='#n558'>558</a>
<a id='n559' href='#n559'>559</a>
<a id='n560' href='#n560'>560</a>
<a id='n561' href='#n561'>561</a>
<a id='n562' href='#n562'>562</a>
<a id='n563' href='#n563'>563</a>
<a id='n564' href='#n564'>564</a>
<a id='n565' href='#n565'>565</a>
<a id='n566' href='#n566'>566</a>
<a id='n567' href='#n567'>567</a>
<a id='n568' href='#n568'>568</a>
<a id='n569' href='#n569'>569</a>
<a id='n570' href='#n570'>570</a>
<a id='n571' href='#n571'>571</a>
<a id='n572' href='#n572'>572</a>
<a id='n573' href='#n573'>573</a>
<a id='n574' href='#n574'>574</a>
<a id='n575' href='#n575'>575</a>
<a id='n576' href='#n576'>576</a>
<a id='n577' href='#n577'>577</a>
<a id='n578' href='#n578'>578</a>
<a id='n579' href='#n579'>579</a>
<a id='n580' href='#n580'>580</a>
<a id='n581' href='#n581'>581</a>
<a id='n582' href='#n582'>582</a>
<a id='n583' href='#n583'>583</a>
<a id='n584' href='#n584'>584</a>
<a id='n585' href='#n585'>585</a>
<a id='n586' href='#n586'>586</a>
<a id='n587' href='#n587'>587</a>
<a id='n588' href='#n588'>588</a>
<a id='n589' href='#n589'>589</a>
<a id='n590' href='#n590'>590</a>
<a id='n591' href='#n591'>591</a>
<a id='n592' href='#n592'>592</a>
<a id='n593' href='#n593'>593</a>
<a id='n594' href='#n594'>594</a>
<a id='n595' href='#n595'>595</a>
<a id='n596' href='#n596'>596</a>
<a id='n597' href='#n597'>597</a>
<a id='n598' href='#n598'>598</a>
<a id='n599' href='#n599'>599</a>
<a id='n600' href='#n600'>600</a>
<a id='n601' href='#n601'>601</a>
<a id='n602' href='#n602'>602</a>
<a id='n603' href='#n603'>603</a>
<a id='n604' href='#n604'>604</a>
<a id='n605' href='#n605'>605</a>
<a id='n606' href='#n606'>606</a>
<a id='n607' href='#n607'>607</a>
<a id='n608' href='#n608'>608</a>
<a id='n609' href='#n609'>609</a>
<a id='n610' href='#n610'>610</a>
<a id='n611' href='#n611'>611</a>
<a id='n612' href='#n612'>612</a>
<a id='n613' href='#n613'>613</a>
<a id='n614' href='#n614'>614</a>
<a id='n615' href='#n615'>615</a>
<a id='n616' href='#n616'>616</a>
<a id='n617' href='#n617'>617</a>
<a id='n618' href='#n618'>618</a>
<a id='n619' href='#n619'>619</a>
<a id='n620' href='#n620'>620</a>
<a id='n621' href='#n621'>621</a>
<a id='n622' href='#n622'>622</a>
<a id='n623' href='#n623'>623</a>
<a id='n624' href='#n624'>624</a>
<a id='n625' href='#n625'>625</a>
<a id='n626' href='#n626'>626</a>
<a id='n627' href='#n627'>627</a>
<a id='n628' href='#n628'>628</a>
<a id='n629' href='#n629'>629</a>
<a id='n630' href='#n630'>630</a>
<a id='n631' href='#n631'>631</a>
<a id='n632' href='#n632'>632</a>
<a id='n633' href='#n633'>633</a>
<a id='n634' href='#n634'>634</a>
<a id='n635' href='#n635'>635</a>
<a id='n636' href='#n636'>636</a>
<a id='n637' href='#n637'>637</a>
<a id='n638' href='#n638'>638</a>
<a id='n639' href='#n639'>639</a>
<a id='n640' href='#n640'>640</a>
<a id='n641' href='#n641'>641</a>
<a id='n642' href='#n642'>642</a>
<a id='n643' href='#n643'>643</a>
<a id='n644' href='#n644'>644</a>
<a id='n645' href='#n645'>645</a>
<a id='n646' href='#n646'>646</a>
<a id='n647' href='#n647'>647</a>
<a id='n648' href='#n648'>648</a>
<a id='n649' href='#n649'>649</a>
<a id='n650' href='#n650'>650</a>
<a id='n651' href='#n651'>651</a>
<a id='n652' href='#n652'>652</a>
<a id='n653' href='#n653'>653</a>
<a id='n654' href='#n654'>654</a>
<a id='n655' href='#n655'>655</a>
<a id='n656' href='#n656'>656</a>
<a id='n657' href='#n657'>657</a>
<a id='n658' href='#n658'>658</a>
<a id='n659' href='#n659'>659</a>
<a id='n660' href='#n660'>660</a>
<a id='n661' href='#n661'>661</a>
<a id='n662' href='#n662'>662</a>
<a id='n663' href='#n663'>663</a>
<a id='n664' href='#n664'>664</a>
<a id='n665' href='#n665'>665</a>
<a id='n666' href='#n666'>666</a>
<a id='n667' href='#n667'>667</a>
<a id='n668' href='#n668'>668</a>
<a id='n669' href='#n669'>669</a>
<a id='n670' href='#n670'>670</a>
<a id='n671' href='#n671'>671</a>
<a id='n672' href='#n672'>672</a>
<a id='n673' href='#n673'>673</a>
<a id='n674' href='#n674'>674</a>
<a id='n675' href='#n675'>675</a>
<a id='n676' href='#n676'>676</a>
<a id='n677' href='#n677'>677</a>
<a id='n678' href='#n678'>678</a>
<a id='n679' href='#n679'>679</a>
<a id='n680' href='#n680'>680</a>
<a id='n681' href='#n681'>681</a>
<a id='n682' href='#n682'>682</a>
<a id='n683' href='#n683'>683</a>
<a id='n684' href='#n684'>684</a>
<a id='n685' href='#n685'>685</a>
<a id='n686' href='#n686'>686</a>
<a id='n687' href='#n687'>687</a>
<a id='n688' href='#n688'>688</a>
<a id='n689' href='#n689'>689</a>
<a id='n690' href='#n690'>690</a>
<a id='n691' href='#n691'>691</a>
<a id='n692' href='#n692'>692</a>
<a id='n693' href='#n693'>693</a>
<a id='n694' href='#n694'>694</a>
<a id='n695' href='#n695'>695</a>
<a id='n696' href='#n696'>696</a>
<a id='n697' href='#n697'>697</a>
<a id='n698' href='#n698'>698</a>
<a id='n699' href='#n699'>699</a>
<a id='n700' href='#n700'>700</a>
<a id='n701' href='#n701'>701</a>
<a id='n702' href='#n702'>702</a>
<a id='n703' href='#n703'>703</a>
<a id='n704' href='#n704'>704</a>
<a id='n705' href='#n705'>705</a>
<a id='n706' href='#n706'>706</a>
<a id='n707' href='#n707'>707</a>
<a id='n708' href='#n708'>708</a>
<a id='n709' href='#n709'>709</a>
<a id='n710' href='#n710'>710</a>
<a id='n711' href='#n711'>711</a>
<a id='n712' href='#n712'>712</a>
<a id='n713' href='#n713'>713</a>
<a id='n714' href='#n714'>714</a>
<a id='n715' href='#n715'>715</a>
<a id='n716' href='#n716'>716</a>
<a id='n717' href='#n717'>717</a>
<a id='n718' href='#n718'>718</a>
<a id='n719' href='#n719'>719</a>
<a id='n720' href='#n720'>720</a>
<a id='n721' href='#n721'>721</a>
<a id='n722' href='#n722'>722</a>
<a id='n723' href='#n723'>723</a>
<a id='n724' href='#n724'>724</a>
<a id='n725' href='#n725'>725</a>
<a id='n726' href='#n726'>726</a>
<a id='n727' href='#n727'>727</a>
<a id='n728' href='#n728'>728</a>
<a id='n729' href='#n729'>729</a>
<a id='n730' href='#n730'>730</a>
<a id='n731' href='#n731'>731</a>
<a id='n732' href='#n732'>732</a>
<a id='n733' href='#n733'>733</a>
</pre></td>
<td class='lines'><pre><code>/*
  File: getfacl.c
  (Linux Access Control List Management)

  Copyright (C) 1999-2002
  Andreas Gruenbacher, &lt;a.gruenbacher@bestbits.at&gt;
 	
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or (at
  your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
  USA.
*/

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/acl.h&gt;
#include &lt;acl/libacl.h&gt;

#include &lt;limits.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
#include &lt;libgen.h&gt;
#include &lt;getopt.h&gt;
#include &lt;locale.h&gt;
#include ""config.h""
#include ""user_group.h""
#include ""walk_tree.h""
#include ""misc.h""

#define POSIXLY_CORRECT_STR ""POSIXLY_CORRECT""

#if !POSIXLY_CORRECT
#  define CMD_LINE_OPTIONS ""aceEsRLPtpndvh""
#endif
#define POSIXLY_CMD_LINE_OPTIONS ""d""

struct option long_options[] = {
#if !POSIXLY_CORRECT
	{ ""access"",	0, 0, 'a' },
	{ ""omit-header"",	0, 0, 'c' },
	{ ""all-effective"",	0, 0, 'e' },
	{ ""no-effective"",	0, 0, 'E' },
	{ ""skip-base"",	0, 0, 's' },
	{ ""recursive"",	0, 0, 'R' },
	{ ""logical"",	0, 0, 'L' },
	{ ""physical"",	0, 0, 'P' },
	{ ""tabular"",	0, 0, 't' },
	{ ""absolute-names"",	0, 0, 'p' },
	{ ""numeric"",	0, 0, 'n' },
#endif
	{ ""default"",	0, 0, 'd' },
	{ ""version"",	0, 0, 'v' },
	{ ""help"",	0, 0, 'h' },
	{ NULL,		0, 0, 0   }
};

const char *progname;
const char *cmd_line_options;

int walk_flags = WALK_TREE_DEREFERENCE;
int opt_print_acl;
int opt_print_default_acl;
int opt_strip_leading_slash = 1;
int opt_comments = 1;  /* include comments */
int opt_skip_base;  /* skip files that only have the base entries */
int opt_tabular;  /* tabular output format (alias `showacl') */
#if POSIXLY_CORRECT
const int posixly_correct = 1;  /* Posix compatible behavior! */
#else
int posixly_correct;  /* Posix compatible behavior? */
#endif
int had_errors;
int absolute_warning;  /* Absolute path warning was issued */
int print_options = TEXT_SOME_EFFECTIVE;
int opt_numeric;  /* don't convert id's to symbolic names */


static const char *xquote(const char *str, const char *quote_chars)
{
	const char *q = quote(str, quote_chars);
	if (q == NULL) {
		fprintf(stderr, ""%s: %s\n"", progname, strerror(errno));
		exit(1);
	}
	return q;
}

struct name_list {
	struct name_list *next;
	char name[0];
};

void free_list(struct name_list *names)
{
	struct name_list *next;

	while (names) {
		next = names-&gt;next;
		free(names);
		names = next;
	}
}

struct name_list *get_list(const struct stat *st, acl_t acl)
{
	struct name_list *first = NULL, *last = NULL;
	acl_entry_t ent;
	int ret = 0;

	if (acl != NULL)
		ret = acl_get_entry(acl, ACL_FIRST_ENTRY, &amp;ent);
	if (ret != 1)
		return NULL;
	while (ret &gt; 0) {
		acl_tag_t e_type;
		const id_t *id_p;
		const char *name = """";
		int len;

		acl_get_tag_type(ent, &amp;e_type);
		switch(e_type) {
			case ACL_USER_OBJ:
				name = user_name(st-&gt;st_uid, opt_numeric);
				break;

			case ACL_USER:
				id_p = acl_get_qualifier(ent);
				if (id_p != NULL)
					name = user_name(*id_p, opt_numeric);
				break;

			case ACL_GROUP_OBJ:
				name = group_name(st-&gt;st_gid, opt_numeric);
				break;

			case ACL_GROUP:
				id_p = acl_get_qualifier(ent);
				if (id_p != NULL)
					name = group_name(*id_p, opt_numeric);
				break;
		}
		name = xquote(name, ""\t\n\r"");
		len = strlen(name);
		if (last == NULL) {
			first = last = (struct name_list *)
				malloc(sizeof(struct name_list) + len + 1);
		} else {
			last-&gt;next = (struct name_list *)
				malloc(sizeof(struct name_list) + len + 1);
			last = last-&gt;next;
		}
		if (last == NULL) {
			free_list(first);
			return NULL;
		}
		last-&gt;next = NULL;
		strcpy(last-&gt;name, name);

		ret = acl_get_entry(acl, ACL_NEXT_ENTRY, &amp;ent);
	}
	return first;
}

int max_name_length(struct name_list *names)
{
	int max_len = 0;
	while (names != NULL) {
		struct name_list *next = names-&gt;next;
		int len = strlen(names-&gt;name);

		if (len &gt; max_len)
			max_len = len;
		names = next;
	}
	return max_len;
}

int names_width;

struct acl_perm_def {
	acl_tag_t	tag;
	char		c;
};

struct acl_perm_def acl_perm_defs[] = {
	{ ACL_READ,	'r' },
	{ ACL_WRITE,	'w' },
	{ ACL_EXECUTE,	'x' },
	{ 0, 0 }
};

#define ACL_PERMS (sizeof(acl_perm_defs) / sizeof(struct acl_perm_def) - 1)

void acl_perm_str(acl_entry_t entry, char *str)
{
	acl_permset_t permset;
	int n;

	acl_get_permset(entry, &amp;permset);
	for (n = 0; n &lt; (int) ACL_PERMS; n++) {
		str[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?
		          acl_perm_defs[n].c : '-');
	}
	str[n] = '\0';
}

void acl_mask_perm_str(acl_t acl, char *str)
{
	acl_entry_t entry;

	str[0] = '\0';
	if (acl_get_entry(acl, ACL_FIRST_ENTRY, &amp;entry) != 1)
		return;
	for(;;) {
		acl_tag_t tag;

		acl_get_tag_type(entry, &amp;tag);
		if (tag == ACL_MASK) {
			acl_perm_str(entry, str);
			return;
		}
		if (acl_get_entry(acl, ACL_NEXT_ENTRY, &amp;entry) != 1)
			return;
	}
}

void apply_mask(char *perm, const char *mask)
{
	while (*perm) {
		if (*mask == '-' &amp;&amp; *perm &gt;= 'a' &amp;&amp; *perm &lt;= 'z')
			*perm = *perm - 'a' + 'A';
		perm++;
		if (*mask)
			mask++;
	}
}

int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,
              acl_entry_t *acl_ent, const char *acl_mask,
              struct name_list **dacl_names, acl_t dacl,
	      acl_entry_t *dacl_ent, const char *dacl_mask)
{
	acl_tag_t tag_type;
	const char *tag, *name;
	char acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];

	if (acl) {
		acl_get_tag_type(*acl_ent, &amp;tag_type);
		name = (*acl_names)-&gt;name;
	} else {
		acl_get_tag_type(*dacl_ent, &amp;tag_type);
		name = (*dacl_names)-&gt;name;
	}

	switch(tag_type) {
		case ACL_USER_OBJ:
			tag = ""USER"";
			break;
		case ACL_USER:
			tag = ""user"";
			break;
		case ACL_GROUP_OBJ:
			tag = ""GROUP"";
			break;
		case ACL_GROUP:
			tag = ""group"";
			break;
		case ACL_MASK:
			tag = ""mask"";
			break;
		case ACL_OTHER:
			tag = ""other"";
			break;
		default:
			return -1;
	}

	memset(acl_perm, ' ', ACL_PERMS);
	acl_perm[ACL_PERMS] = '\0';
	if (acl_ent) {
		acl_perm_str(*acl_ent, acl_perm);
		if (tag_type != ACL_USER_OBJ &amp;&amp; tag_type != ACL_OTHER &amp;&amp;
		    tag_type != ACL_MASK)
			apply_mask(acl_perm, acl_mask);
	}
	memset(dacl_perm, ' ', ACL_PERMS);
	dacl_perm[ACL_PERMS] = '\0';
	if (dacl_ent) {
		acl_perm_str(*dacl_ent, dacl_perm);
		if (tag_type != ACL_USER_OBJ &amp;&amp; tag_type != ACL_OTHER &amp;&amp;
		    tag_type != ACL_MASK)
			apply_mask(dacl_perm, dacl_mask);
	}

	fprintf(stream, ""%-5s  %*s  %*s  %*s\n"",
	        tag, -names_width, name,
	        -(int)ACL_PERMS, acl_perm,
		-(int)ACL_PERMS, dacl_perm);

	if (acl_names) {
		acl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);
		(*acl_names) = (*acl_names)-&gt;next;
	}
	if (dacl_names) {
		acl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);
		(*dacl_names) = (*dacl_names)-&gt;next;
	}
	return 0;
}

int do_show(FILE *stream, const char *path_p, const struct stat *st,
            acl_t acl, acl_t dacl)
{
	struct name_list *acl_names = get_list(st, acl),
	                 *first_acl_name = acl_names;
	struct name_list *dacl_names = get_list(st, dacl),
	                 *first_dacl_name = dacl_names;
	
	int acl_names_width = max_name_length(acl_names);
	int dacl_names_width = max_name_length(dacl_names);
	acl_entry_t acl_ent;
	acl_entry_t dacl_ent;
	char acl_mask[ACL_PERMS+1], dacl_mask[ACL_PERMS+1];
	int ret;

	names_width = 8;
	if (acl_names_width &gt; names_width)
		names_width = acl_names_width;
	if (dacl_names_width &gt; names_width)
		names_width = dacl_names_width;

	acl_mask[0] = '\0';
	if (acl) {
		acl_mask_perm_str(acl, acl_mask);
		ret = acl_get_entry(acl, ACL_FIRST_ENTRY, &amp;acl_ent);
		if (ret == 0)
			acl = NULL;
		if (ret &lt; 0)
			return ret;
	}
	dacl_mask[0] = '\0';
	if (dacl) {
		acl_mask_perm_str(dacl, dacl_mask);
		ret = acl_get_entry(dacl, ACL_FIRST_ENTRY, &amp;dacl_ent);
		if (ret == 0)
			dacl = NULL;
		if (ret &lt; 0)
			return ret;
	}
	fprintf(stream, ""# file: %s\n"", xquote(path_p, ""\n\r""));
	while (acl_names != NULL || dacl_names != NULL) {
		acl_tag_t acl_tag, dacl_tag;

		if (acl)
			acl_get_tag_type(acl_ent, &amp;acl_tag);
		if (dacl)
			acl_get_tag_type(dacl_ent, &amp;dacl_tag);

		if (acl &amp;&amp; (!dacl || acl_tag &lt; dacl_tag)) {
			show_line(stream, &amp;acl_names, acl, &amp;acl_ent, acl_mask,
			          NULL, NULL, NULL, NULL);
			continue;
		} else if (dacl &amp;&amp; (!acl || dacl_tag &lt; acl_tag)) {
			show_line(stream, NULL, NULL, NULL, NULL,
			          &amp;dacl_names, dacl, &amp;dacl_ent, dacl_mask);
			continue;
		} else {
			if (acl_tag == ACL_USER || acl_tag == ACL_GROUP) {
				id_t  *acl_id_p = NULL, *dacl_id_p = NULL;
				if (acl_ent)
					acl_id_p = acl_get_qualifier(acl_ent);
				if (dacl_ent)
					dacl_id_p = acl_get_qualifier(dacl_ent);
				
				if (acl &amp;&amp; (!dacl || *acl_id_p &lt; *dacl_id_p)) {
					show_line(stream, &amp;acl_names, acl,
					          &amp;acl_ent, acl_mask,
						  NULL, NULL, NULL, NULL);
					continue;
				} else if (dacl &amp;&amp;
					(!acl || *dacl_id_p &lt; *acl_id_p)) {
					show_line(stream, NULL, NULL, NULL,
					          NULL, &amp;dacl_names, dacl,
						  &amp;dacl_ent, dacl_mask);
					continue;
				}
			}
			show_line(stream, &amp;acl_names,  acl,  &amp;acl_ent, acl_mask,
				  &amp;dacl_names, dacl, &amp;dacl_ent, dacl_mask);
		}
	}

	free_list(first_acl_name);
	free_list(first_dacl_name);

	return 0;
}

/*
 * Create an ACL from the file permission bits
 * of the file PATH_P.
 */
static acl_t
acl_get_file_mode(const char *path_p)
{
	struct stat st;

	if (stat(path_p, &amp;st) != 0)
		return NULL;
	return acl_from_mode(st.st_mode);
}

int do_print(const char *path_p, const struct stat *st, int walk_flags, void *unused)
{
	const char *default_prefix = NULL;
	acl_t acl = NULL, default_acl = NULL;
	int error = 0;

	if (walk_flags &amp; WALK_TREE_FAILED) {
		fprintf(stderr, ""%s: %s: %s\n"", progname, xquote(path_p, ""\n\r""),
			strerror(errno));
		return 1;
	}

	/*
	 * Symlinks can never have ACLs, so when doing a physical walk, we
	 * skip symlinks altogether, and when doing a half-logical walk, we
	 * skip all non-toplevel symlinks. 
	 */
	if ((walk_flags &amp; WALK_TREE_SYMLINK) &amp;&amp;
	    ((walk_flags &amp; WALK_TREE_PHYSICAL) ||
	     !(walk_flags &amp; (WALK_TREE_TOPLEVEL | WALK_TREE_LOGICAL))))
		return 0;

	if (opt_print_acl) {
		acl = acl_get_file(path_p, ACL_TYPE_ACCESS);
		if (acl == NULL &amp;&amp; (errno == ENOSYS || errno == ENOTSUP))
			acl = acl_get_file_mode(path_p);
		if (acl == NULL)
			goto fail;
	}

	if (opt_print_default_acl &amp;&amp; S_ISDIR(st-&gt;st_mode)) {
		default_acl = acl_get_file(path_p, ACL_TYPE_DEFAULT);
		if (default_acl == NULL) {
			if (errno != ENOSYS &amp;&amp; errno != ENOTSUP)
				goto fail;
		} else if (acl_entries(default_acl) == 0) {
			acl_free(default_acl);
			default_acl = NULL;
		}
	}

	if (opt_skip_base &amp;&amp;
	    (!acl || acl_equiv_mode(acl, NULL) == 0) &amp;&amp; !default_acl)
		return 0;

	if (opt_print_acl &amp;&amp; opt_print_default_acl)
		default_prefix = ""default:"";

	if (opt_strip_leading_slash) {
		if (*path_p == '/') {
			if (!absolute_warning) {
				fprintf(stderr, _(""%s: Removing leading ""
					""'/' from absolute path names\n""),
				        progname);
				absolute_warning = 1;
			}
			while (*path_p == '/')
				path_p++;
		} else if (*path_p == '.' &amp;&amp; *(path_p+1) == '/')
			while (*++path_p == '/')
				/* nothing */ ;
		if (*path_p == '\0')
			path_p = ""."";
	}

	if (opt_tabular)  {
		if (do_show(stdout, path_p, st, acl, default_acl) != 0)
			goto fail;
	} else {
		if (opt_comments) {
			printf(""# file: %s\n"", xquote(path_p, ""\n\r""));
			printf(""# owner: %s\n"",
			       xquote(user_name(st-&gt;st_uid, opt_numeric), "" \t\n\r""));
			printf(""# group: %s\n"",
			       xquote(group_name(st-&gt;st_gid, opt_numeric), "" \t\n\r""));
		}
		if (acl != NULL) {
			char *acl_text = acl_to_any_text(acl, NULL, '\n',
							 print_options);
			if (!acl_text)
				goto fail;
			if (puts(acl_text) &lt; 0) {
				acl_free(acl_text);
				goto fail;
			}
			acl_free(acl_text);
		}
		if (default_acl != NULL) {
			char *acl_text = acl_to_any_text(default_acl, 
							 default_prefix, '\n',
							 print_options);
			if (!acl_text)
				goto fail;
			if (puts(acl_text) &lt; 0) {
				acl_free(acl_text);
				goto fail;
			}
			acl_free(acl_text);
		}
	}
	if (acl || default_acl || opt_comments)
		printf(""\n"");

cleanup:
	if (acl)
		acl_free(acl);
	if (default_acl)
		acl_free(default_acl);
	return error;

fail:
	fprintf(stderr, ""%s: %s: %s\n"", progname, xquote(path_p, ""\n\r""),
		strerror(errno));
	error = -1;
	goto cleanup;
}


void help(void)
{
	printf(_(""%s %s -- get file access control lists\n""),
	       progname, VERSION);
	printf(_(""Usage: %s [-%s] file ...\n""),
	         progname, cmd_line_options);
#if !POSIXLY_CORRECT
	if (posixly_correct) {
#endif
		printf(_(
""  -d, --default           display the default access control list\n""));
#if !POSIXLY_CORRECT
	} else {
		printf(_(
""  -a,  --access           display the file access control list only\n""
""  -d, --default           display the default access control list only\n""
""  -c, --omit-header       do not display the comment header\n""
""  -e, --all-effective     print all effective rights\n""
""  -E, --no-effective      print no effective rights\n""
""  -s, --skip-base         skip files that only have the base entries\n""
""  -R, --recursive         recurse into subdirectories\n""
""  -L, --logical           logical walk, follow symbolic links\n""
""  -P, --physical          physical walk, do not follow symbolic links\n""
""  -t, --tabular           use tabular output format\n""
""  -n, --numeric           print numeric user/group identifiers\n""
""  -p, --absolute-names    don't strip leading '/' in pathnames\n""));
	}
#endif
	printf(_(
""  -v, --version           print version and exit\n""
""  -h, --help              this help text\n""));
}

int main(int argc, char *argv[])
{
	int opt;
	char *line;

	progname = basename(argv[0]);

#if POSIXLY_CORRECT
	cmd_line_options = POSIXLY_CMD_LINE_OPTIONS;
#else
	if (getenv(POSIXLY_CORRECT_STR))
		posixly_correct = 1;
	if (!posixly_correct)
		cmd_line_options = CMD_LINE_OPTIONS;
	else
		cmd_line_options = POSIXLY_CMD_LINE_OPTIONS;
#endif

	setlocale(LC_CTYPE, """");
	setlocale(LC_MESSAGES, """");
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);

	/* Align `#effective:' comments to column 40 for tty's */
	if (!posixly_correct &amp;&amp; isatty(fileno(stdout)))
		print_options |= TEXT_SMART_INDENT;

	while ((opt = getopt_long(argc, argv, cmd_line_options,
		                 long_options, NULL)) != -1) {
		switch (opt) {
			case 'a':  /* acl only */
				if (posixly_correct)
					goto synopsis;
				opt_print_acl = 1;
				break;

			case 'd':  /* default acl only */
				opt_print_default_acl = 1;
				break;

			case 'c':  /* no comments */
				if (posixly_correct)
					goto synopsis;
				opt_comments = 0;
				break;

			case 'e':  /* all #effective comments */
				if (posixly_correct)
					goto synopsis;
				print_options |= TEXT_ALL_EFFECTIVE;
				break;

			case 'E':  /* no #effective comments */
				if (posixly_correct)
					goto synopsis;
				print_options &amp;= ~(TEXT_SOME_EFFECTIVE |
				                   TEXT_ALL_EFFECTIVE);
				break;

			case 'R':  /* recursive */
				if (posixly_correct)
					goto synopsis;
				walk_flags |= WALK_TREE_RECURSIVE;
				break;

			case 'L':  /* follow all symlinks */
				if (posixly_correct)
					goto synopsis;
				walk_flags |= WALK_TREE_LOGICAL;
				walk_flags &amp;= ~WALK_TREE_PHYSICAL;
				break;

			case 'P':  /* skip all symlinks */
				if (posixly_correct)
					goto synopsis;
				walk_flags |= WALK_TREE_PHYSICAL;
				walk_flags &amp;= ~WALK_TREE_LOGICAL;
				break;

			case 's':  /* skip files with only base entries */
				if (posixly_correct)
					goto synopsis;
				opt_skip_base = 1;
				break;

			case 'p':
				if (posixly_correct)
					goto synopsis;
				opt_strip_leading_slash = 0;
				break;

			case 't':
				if (posixly_correct)
					goto synopsis;
				opt_tabular = 1;
				break;

			case 'n':  /* numeric */
				opt_numeric = 1;
				print_options |= TEXT_NUMERIC_IDS;
				break;

			case 'v':  /* print version */
				printf(""%s "" VERSION ""\n"", progname);
				return 0;

			case 'h':  /* help */
				help();
				return 0;

			case ':':  /* option missing */
			case '?':  /* unknown option */
			default:
				goto synopsis;
		}
	}

	if (!(opt_print_acl || opt_print_default_acl)) {
		opt_print_acl = 1;
		if (!posixly_correct)
			opt_print_default_acl = 1;
	}
		
	if ((optind == argc) &amp;&amp; !posixly_correct)
		goto synopsis;

	do {
		if (optind == argc ||
		    strcmp(argv[optind], ""-"") == 0) {
			while ((line = next_line(stdin)) != NULL) {
				if (*line == '\0')
					continue;

				had_errors += walk_tree(line, walk_flags, 0,
							do_print, NULL);
			}
			if (!feof(stdin)) {
				fprintf(stderr, _(""%s: Standard input: %s\n""),
				        progname, strerror(errno));
				had_errors++;
			}
		} else
			had_errors += walk_tree(argv[optind], walk_flags, 0,
						do_print, NULL);
		optind++;
	} while (optind &lt; argc);

	return had_errors ? 1 : 0;

synopsis:
	fprintf(stderr, _(""Usage: %s [-%s] file ...\n""),
	        progname, cmd_line_options);
	fprintf(stderr, _(""Try `%s --help' for more information.\n""),
		progname);
	return 2;
}

</code></pre></td></tr></table>
</div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit v1.2.1</a> (<a href='https://git-scm.com/'>git 2.18.0</a>) at 2020-05-09 06:49:57 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
","<!DOCTYPE html>
<html lang='en'>
<head>
<title>getfacl.c\getfacl - acl.git - acl</title>
<meta name='generator' content='cgit v1.2.1'/>
<meta name='robots' content='index, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit/cgit.css'/>
<link rel='shortcut icon' href='/gitweb/git-favicon.png'/>
<link rel='alternate' title='Atom feed' href='https://git.savannah.gnu.org/cgit/acl.git/atom/getfacl/getfacl.c?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.savannah.gnu.org/acl.git' title='acl.git Git repository'/>
<link rel='vcs-git' href='https://git.savannah.gnu.org/git/acl.git' title='acl.git Git repository'/>
<link rel='vcs-git' href='ssh://git.savannah.gnu.org/srv/git/acl.git' title='acl.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/cgit/'><img src='/cgit/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/cgit/'>index</a> : <a title='acl.git' href='/cgit/acl.git/'>acl.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='63451a06b7484d220750ed8574d3ee84e156daf5'/><select name='h' onchange='this.form.submit();'>
<option value='master' selected='selected'>master</option>
<option value='misc'>misc</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>acl</td><td class='sub right'></td></tr></table>
<table class='tabs'><tr><td>
<a href='/cgit/acl.git/'>summary</a><a href='/cgit/acl.git/refs/?id=63451a06b7484d220750ed8574d3ee84e156daf5'>refs</a><a href='/cgit/acl.git/log/getfacl/getfacl.c'>log</a><a class='active' href='/cgit/acl.git/tree/getfacl/getfacl.c?id=63451a06b7484d220750ed8574d3ee84e156daf5'>tree</a><a href='/cgit/acl.git/commit/getfacl/getfacl.c?id=63451a06b7484d220750ed8574d3ee84e156daf5'>commit</a><a href='/cgit/acl.git/diff/getfacl/getfacl.c?id=63451a06b7484d220750ed8574d3ee84e156daf5'>diff</a></td><td class='form'><form class='right' method='get' action='/cgit/acl.git/log/getfacl/getfacl.c'>
<input type='hidden' name='id' value='63451a06b7484d220750ed8574d3ee84e156daf5'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='path'>path: <a href='/cgit/acl.git/tree/?id=63451a06b7484d220750ed8574d3ee84e156daf5'>root</a>/<a href='/cgit/acl.git/tree/getfacl?id=63451a06b7484d220750ed8574d3ee84e156daf5'>getfacl</a>/<a href='/cgit/acl.git/tree/getfacl/getfacl.c?id=63451a06b7484d220750ed8574d3ee84e156daf5'>getfacl.c</a></div><div class='content'>blob: b3e6200384fa9518edca84021c5c090a8d7d28e5 (<a href='/cgit/acl.git/plain/getfacl/getfacl.c?id=63451a06b7484d220750ed8574d3ee84e156daf5'>plain</a>)
<table summary='blob content' class='blob'>
<tr><td class='linenumbers'><pre><a id='n1' href='#n1'>1</a>
<a id='n2' href='#n2'>2</a>
<a id='n3' href='#n3'>3</a>
<a id='n4' href='#n4'>4</a>
<a id='n5' href='#n5'>5</a>
<a id='n6' href='#n6'>6</a>
<a id='n7' href='#n7'>7</a>
<a id='n8' href='#n8'>8</a>
<a id='n9' href='#n9'>9</a>
<a id='n10' href='#n10'>10</a>
<a id='n11' href='#n11'>11</a>
<a id='n12' href='#n12'>12</a>
<a id='n13' href='#n13'>13</a>
<a id='n14' href='#n14'>14</a>
<a id='n15' href='#n15'>15</a>
<a id='n16' href='#n16'>16</a>
<a id='n17' href='#n17'>17</a>
<a id='n18' href='#n18'>18</a>
<a id='n19' href='#n19'>19</a>
<a id='n20' href='#n20'>20</a>
<a id='n21' href='#n21'>21</a>
<a id='n22' href='#n22'>22</a>
<a id='n23' href='#n23'>23</a>
<a id='n24' href='#n24'>24</a>
<a id='n25' href='#n25'>25</a>
<a id='n26' href='#n26'>26</a>
<a id='n27' href='#n27'>27</a>
<a id='n28' href='#n28'>28</a>
<a id='n29' href='#n29'>29</a>
<a id='n30' href='#n30'>30</a>
<a id='n31' href='#n31'>31</a>
<a id='n32' href='#n32'>32</a>
<a id='n33' href='#n33'>33</a>
<a id='n34' href='#n34'>34</a>
<a id='n35' href='#n35'>35</a>
<a id='n36' href='#n36'>36</a>
<a id='n37' href='#n37'>37</a>
<a id='n38' href='#n38'>38</a>
<a id='n39' href='#n39'>39</a>
<a id='n40' href='#n40'>40</a>
<a id='n41' href='#n41'>41</a>
<a id='n42' href='#n42'>42</a>
<a id='n43' href='#n43'>43</a>
<a id='n44' href='#n44'>44</a>
<a id='n45' href='#n45'>45</a>
<a id='n46' href='#n46'>46</a>
<a id='n47' href='#n47'>47</a>
<a id='n48' href='#n48'>48</a>
<a id='n49' href='#n49'>49</a>
<a id='n50' href='#n50'>50</a>
<a id='n51' href='#n51'>51</a>
<a id='n52' href='#n52'>52</a>
<a id='n53' href='#n53'>53</a>
<a id='n54' href='#n54'>54</a>
<a id='n55' href='#n55'>55</a>
<a id='n56' href='#n56'>56</a>
<a id='n57' href='#n57'>57</a>
<a id='n58' href='#n58'>58</a>
<a id='n59' href='#n59'>59</a>
<a id='n60' href='#n60'>60</a>
<a id='n61' href='#n61'>61</a>
<a id='n62' href='#n62'>62</a>
<a id='n63' href='#n63'>63</a>
<a id='n64' href='#n64'>64</a>
<a id='n65' href='#n65'>65</a>
<a id='n66' href='#n66'>66</a>
<a id='n67' href='#n67'>67</a>
<a id='n68' href='#n68'>68</a>
<a id='n69' href='#n69'>69</a>
<a id='n70' href='#n70'>70</a>
<a id='n71' href='#n71'>71</a>
<a id='n72' href='#n72'>72</a>
<a id='n73' href='#n73'>73</a>
<a id='n74' href='#n74'>74</a>
<a id='n75' href='#n75'>75</a>
<a id='n76' href='#n76'>76</a>
<a id='n77' href='#n77'>77</a>
<a id='n78' href='#n78'>78</a>
<a id='n79' href='#n79'>79</a>
<a id='n80' href='#n80'>80</a>
<a id='n81' href='#n81'>81</a>
<a id='n82' href='#n82'>82</a>
<a id='n83' href='#n83'>83</a>
<a id='n84' href='#n84'>84</a>
<a id='n85' href='#n85'>85</a>
<a id='n86' href='#n86'>86</a>
<a id='n87' href='#n87'>87</a>
<a id='n88' href='#n88'>88</a>
<a id='n89' href='#n89'>89</a>
<a id='n90' href='#n90'>90</a>
<a id='n91' href='#n91'>91</a>
<a id='n92' href='#n92'>92</a>
<a id='n93' href='#n93'>93</a>
<a id='n94' href='#n94'>94</a>
<a id='n95' href='#n95'>95</a>
<a id='n96' href='#n96'>96</a>
<a id='n97' href='#n97'>97</a>
<a id='n98' href='#n98'>98</a>
<a id='n99' href='#n99'>99</a>
<a id='n100' href='#n100'>100</a>
<a id='n101' href='#n101'>101</a>
<a id='n102' href='#n102'>102</a>
<a id='n103' href='#n103'>103</a>
<a id='n104' href='#n104'>104</a>
<a id='n105' href='#n105'>105</a>
<a id='n106' href='#n106'>106</a>
<a id='n107' href='#n107'>107</a>
<a id='n108' href='#n108'>108</a>
<a id='n109' href='#n109'>109</a>
<a id='n110' href='#n110'>110</a>
<a id='n111' href='#n111'>111</a>
<a id='n112' href='#n112'>112</a>
<a id='n113' href='#n113'>113</a>
<a id='n114' href='#n114'>114</a>
<a id='n115' href='#n115'>115</a>
<a id='n116' href='#n116'>116</a>
<a id='n117' href='#n117'>117</a>
<a id='n118' href='#n118'>118</a>
<a id='n119' href='#n119'>119</a>
<a id='n120' href='#n120'>120</a>
<a id='n121' href='#n121'>121</a>
<a id='n122' href='#n122'>122</a>
<a id='n123' href='#n123'>123</a>
<a id='n124' href='#n124'>124</a>
<a id='n125' href='#n125'>125</a>
<a id='n126' href='#n126'>126</a>
<a id='n127' href='#n127'>127</a>
<a id='n128' href='#n128'>128</a>
<a id='n129' href='#n129'>129</a>
<a id='n130' href='#n130'>130</a>
<a id='n131' href='#n131'>131</a>
<a id='n132' href='#n132'>132</a>
<a id='n133' href='#n133'>133</a>
<a id='n134' href='#n134'>134</a>
<a id='n135' href='#n135'>135</a>
<a id='n136' href='#n136'>136</a>
<a id='n137' href='#n137'>137</a>
<a id='n138' href='#n138'>138</a>
<a id='n139' href='#n139'>139</a>
<a id='n140' href='#n140'>140</a>
<a id='n141' href='#n141'>141</a>
<a id='n142' href='#n142'>142</a>
<a id='n143' href='#n143'>143</a>
<a id='n144' href='#n144'>144</a>
<a id='n145' href='#n145'>145</a>
<a id='n146' href='#n146'>146</a>
<a id='n147' href='#n147'>147</a>
<a id='n148' href='#n148'>148</a>
<a id='n149' href='#n149'>149</a>
<a id='n150' href='#n150'>150</a>
<a id='n151' href='#n151'>151</a>
<a id='n152' href='#n152'>152</a>
<a id='n153' href='#n153'>153</a>
<a id='n154' href='#n154'>154</a>
<a id='n155' href='#n155'>155</a>
<a id='n156' href='#n156'>156</a>
<a id='n157' href='#n157'>157</a>
<a id='n158' href='#n158'>158</a>
<a id='n159' href='#n159'>159</a>
<a id='n160' href='#n160'>160</a>
<a id='n161' href='#n161'>161</a>
<a id='n162' href='#n162'>162</a>
<a id='n163' href='#n163'>163</a>
<a id='n164' href='#n164'>164</a>
<a id='n165' href='#n165'>165</a>
<a id='n166' href='#n166'>166</a>
<a id='n167' href='#n167'>167</a>
<a id='n168' href='#n168'>168</a>
<a id='n169' href='#n169'>169</a>
<a id='n170' href='#n170'>170</a>
<a id='n171' href='#n171'>171</a>
<a id='n172' href='#n172'>172</a>
<a id='n173' href='#n173'>173</a>
<a id='n174' href='#n174'>174</a>
<a id='n175' href='#n175'>175</a>
<a id='n176' href='#n176'>176</a>
<a id='n177' href='#n177'>177</a>
<a id='n178' href='#n178'>178</a>
<a id='n179' href='#n179'>179</a>
<a id='n180' href='#n180'>180</a>
<a id='n181' href='#n181'>181</a>
<a id='n182' href='#n182'>182</a>
<a id='n183' href='#n183'>183</a>
<a id='n184' href='#n184'>184</a>
<a id='n185' href='#n185'>185</a>
<a id='n186' href='#n186'>186</a>
<a id='n187' href='#n187'>187</a>
<a id='n188' href='#n188'>188</a>
<a id='n189' href='#n189'>189</a>
<a id='n190' href='#n190'>190</a>
<a id='n191' href='#n191'>191</a>
<a id='n192' href='#n192'>192</a>
<a id='n193' href='#n193'>193</a>
<a id='n194' href='#n194'>194</a>
<a id='n195' href='#n195'>195</a>
<a id='n196' href='#n196'>196</a>
<a id='n197' href='#n197'>197</a>
<a id='n198' href='#n198'>198</a>
<a id='n199' href='#n199'>199</a>
<a id='n200' href='#n200'>200</a>
<a id='n201' href='#n201'>201</a>
<a id='n202' href='#n202'>202</a>
<a id='n203' href='#n203'>203</a>
<a id='n204' href='#n204'>204</a>
<a id='n205' href='#n205'>205</a>
<a id='n206' href='#n206'>206</a>
<a id='n207' href='#n207'>207</a>
<a id='n208' href='#n208'>208</a>
<a id='n209' href='#n209'>209</a>
<a id='n210' href='#n210'>210</a>
<a id='n211' href='#n211'>211</a>
<a id='n212' href='#n212'>212</a>
<a id='n213' href='#n213'>213</a>
<a id='n214' href='#n214'>214</a>
<a id='n215' href='#n215'>215</a>
<a id='n216' href='#n216'>216</a>
<a id='n217' href='#n217'>217</a>
<a id='n218' href='#n218'>218</a>
<a id='n219' href='#n219'>219</a>
<a id='n220' href='#n220'>220</a>
<a id='n221' href='#n221'>221</a>
<a id='n222' href='#n222'>222</a>
<a id='n223' href='#n223'>223</a>
<a id='n224' href='#n224'>224</a>
<a id='n225' href='#n225'>225</a>
<a id='n226' href='#n226'>226</a>
<a id='n227' href='#n227'>227</a>
<a id='n228' href='#n228'>228</a>
<a id='n229' href='#n229'>229</a>
<a id='n230' href='#n230'>230</a>
<a id='n231' href='#n231'>231</a>
<a id='n232' href='#n232'>232</a>
<a id='n233' href='#n233'>233</a>
<a id='n234' href='#n234'>234</a>
<a id='n235' href='#n235'>235</a>
<a id='n236' href='#n236'>236</a>
<a id='n237' href='#n237'>237</a>
<a id='n238' href='#n238'>238</a>
<a id='n239' href='#n239'>239</a>
<a id='n240' href='#n240'>240</a>
<a id='n241' href='#n241'>241</a>
<a id='n242' href='#n242'>242</a>
<a id='n243' href='#n243'>243</a>
<a id='n244' href='#n244'>244</a>
<a id='n245' href='#n245'>245</a>
<a id='n246' href='#n246'>246</a>
<a id='n247' href='#n247'>247</a>
<a id='n248' href='#n248'>248</a>
<a id='n249' href='#n249'>249</a>
<a id='n250' href='#n250'>250</a>
<a id='n251' href='#n251'>251</a>
<a id='n252' href='#n252'>252</a>
<a id='n253' href='#n253'>253</a>
<a id='n254' href='#n254'>254</a>
<a id='n255' href='#n255'>255</a>
<a id='n256' href='#n256'>256</a>
<a id='n257' href='#n257'>257</a>
<a id='n258' href='#n258'>258</a>
<a id='n259' href='#n259'>259</a>
<a id='n260' href='#n260'>260</a>
<a id='n261' href='#n261'>261</a>
<a id='n262' href='#n262'>262</a>
<a id='n263' href='#n263'>263</a>
<a id='n264' href='#n264'>264</a>
<a id='n265' href='#n265'>265</a>
<a id='n266' href='#n266'>266</a>
<a id='n267' href='#n267'>267</a>
<a id='n268' href='#n268'>268</a>
<a id='n269' href='#n269'>269</a>
<a id='n270' href='#n270'>270</a>
<a id='n271' href='#n271'>271</a>
<a id='n272' href='#n272'>272</a>
<a id='n273' href='#n273'>273</a>
<a id='n274' href='#n274'>274</a>
<a id='n275' href='#n275'>275</a>
<a id='n276' href='#n276'>276</a>
<a id='n277' href='#n277'>277</a>
<a id='n278' href='#n278'>278</a>
<a id='n279' href='#n279'>279</a>
<a id='n280' href='#n280'>280</a>
<a id='n281' href='#n281'>281</a>
<a id='n282' href='#n282'>282</a>
<a id='n283' href='#n283'>283</a>
<a id='n284' href='#n284'>284</a>
<a id='n285' href='#n285'>285</a>
<a id='n286' href='#n286'>286</a>
<a id='n287' href='#n287'>287</a>
<a id='n288' href='#n288'>288</a>
<a id='n289' href='#n289'>289</a>
<a id='n290' href='#n290'>290</a>
<a id='n291' href='#n291'>291</a>
<a id='n292' href='#n292'>292</a>
<a id='n293' href='#n293'>293</a>
<a id='n294' href='#n294'>294</a>
<a id='n295' href='#n295'>295</a>
<a id='n296' href='#n296'>296</a>
<a id='n297' href='#n297'>297</a>
<a id='n298' href='#n298'>298</a>
<a id='n299' href='#n299'>299</a>
<a id='n300' href='#n300'>300</a>
<a id='n301' href='#n301'>301</a>
<a id='n302' href='#n302'>302</a>
<a id='n303' href='#n303'>303</a>
<a id='n304' href='#n304'>304</a>
<a id='n305' href='#n305'>305</a>
<a id='n306' href='#n306'>306</a>
<a id='n307' href='#n307'>307</a>
<a id='n308' href='#n308'>308</a>
<a id='n309' href='#n309'>309</a>
<a id='n310' href='#n310'>310</a>
<a id='n311' href='#n311'>311</a>
<a id='n312' href='#n312'>312</a>
<a id='n313' href='#n313'>313</a>
<a id='n314' href='#n314'>314</a>
<a id='n315' href='#n315'>315</a>
<a id='n316' href='#n316'>316</a>
<a id='n317' href='#n317'>317</a>
<a id='n318' href='#n318'>318</a>
<a id='n319' href='#n319'>319</a>
<a id='n320' href='#n320'>320</a>
<a id='n321' href='#n321'>321</a>
<a id='n322' href='#n322'>322</a>
<a id='n323' href='#n323'>323</a>
<a id='n324' href='#n324'>324</a>
<a id='n325' href='#n325'>325</a>
<a id='n326' href='#n326'>326</a>
<a id='n327' href='#n327'>327</a>
<a id='n328' href='#n328'>328</a>
<a id='n329' href='#n329'>329</a>
<a id='n330' href='#n330'>330</a>
<a id='n331' href='#n331'>331</a>
<a id='n332' href='#n332'>332</a>
<a id='n333' href='#n333'>333</a>
<a id='n334' href='#n334'>334</a>
<a id='n335' href='#n335'>335</a>
<a id='n336' href='#n336'>336</a>
<a id='n337' href='#n337'>337</a>
<a id='n338' href='#n338'>338</a>
<a id='n339' href='#n339'>339</a>
<a id='n340' href='#n340'>340</a>
<a id='n341' href='#n341'>341</a>
<a id='n342' href='#n342'>342</a>
<a id='n343' href='#n343'>343</a>
<a id='n344' href='#n344'>344</a>
<a id='n345' href='#n345'>345</a>
<a id='n346' href='#n346'>346</a>
<a id='n347' href='#n347'>347</a>
<a id='n348' href='#n348'>348</a>
<a id='n349' href='#n349'>349</a>
<a id='n350' href='#n350'>350</a>
<a id='n351' href='#n351'>351</a>
<a id='n352' href='#n352'>352</a>
<a id='n353' href='#n353'>353</a>
<a id='n354' href='#n354'>354</a>
<a id='n355' href='#n355'>355</a>
<a id='n356' href='#n356'>356</a>
<a id='n357' href='#n357'>357</a>
<a id='n358' href='#n358'>358</a>
<a id='n359' href='#n359'>359</a>
<a id='n360' href='#n360'>360</a>
<a id='n361' href='#n361'>361</a>
<a id='n362' href='#n362'>362</a>
<a id='n363' href='#n363'>363</a>
<a id='n364' href='#n364'>364</a>
<a id='n365' href='#n365'>365</a>
<a id='n366' href='#n366'>366</a>
<a id='n367' href='#n367'>367</a>
<a id='n368' href='#n368'>368</a>
<a id='n369' href='#n369'>369</a>
<a id='n370' href='#n370'>370</a>
<a id='n371' href='#n371'>371</a>
<a id='n372' href='#n372'>372</a>
<a id='n373' href='#n373'>373</a>
<a id='n374' href='#n374'>374</a>
<a id='n375' href='#n375'>375</a>
<a id='n376' href='#n376'>376</a>
<a id='n377' href='#n377'>377</a>
<a id='n378' href='#n378'>378</a>
<a id='n379' href='#n379'>379</a>
<a id='n380' href='#n380'>380</a>
<a id='n381' href='#n381'>381</a>
<a id='n382' href='#n382'>382</a>
<a id='n383' href='#n383'>383</a>
<a id='n384' href='#n384'>384</a>
<a id='n385' href='#n385'>385</a>
<a id='n386' href='#n386'>386</a>
<a id='n387' href='#n387'>387</a>
<a id='n388' href='#n388'>388</a>
<a id='n389' href='#n389'>389</a>
<a id='n390' href='#n390'>390</a>
<a id='n391' href='#n391'>391</a>
<a id='n392' href='#n392'>392</a>
<a id='n393' href='#n393'>393</a>
<a id='n394' href='#n394'>394</a>
<a id='n395' href='#n395'>395</a>
<a id='n396' href='#n396'>396</a>
<a id='n397' href='#n397'>397</a>
<a id='n398' href='#n398'>398</a>
<a id='n399' href='#n399'>399</a>
<a id='n400' href='#n400'>400</a>
<a id='n401' href='#n401'>401</a>
<a id='n402' href='#n402'>402</a>
<a id='n403' href='#n403'>403</a>
<a id='n404' href='#n404'>404</a>
<a id='n405' href='#n405'>405</a>
<a id='n406' href='#n406'>406</a>
<a id='n407' href='#n407'>407</a>
<a id='n408' href='#n408'>408</a>
<a id='n409' href='#n409'>409</a>
<a id='n410' href='#n410'>410</a>
<a id='n411' href='#n411'>411</a>
<a id='n412' href='#n412'>412</a>
<a id='n413' href='#n413'>413</a>
<a id='n414' href='#n414'>414</a>
<a id='n415' href='#n415'>415</a>
<a id='n416' href='#n416'>416</a>
<a id='n417' href='#n417'>417</a>
<a id='n418' href='#n418'>418</a>
<a id='n419' href='#n419'>419</a>
<a id='n420' href='#n420'>420</a>
<a id='n421' href='#n421'>421</a>
<a id='n422' href='#n422'>422</a>
<a id='n423' href='#n423'>423</a>
<a id='n424' href='#n424'>424</a>
<a id='n425' href='#n425'>425</a>
<a id='n426' href='#n426'>426</a>
<a id='n427' href='#n427'>427</a>
<a id='n428' href='#n428'>428</a>
<a id='n429' href='#n429'>429</a>
<a id='n430' href='#n430'>430</a>
<a id='n431' href='#n431'>431</a>
<a id='n432' href='#n432'>432</a>
<a id='n433' href='#n433'>433</a>
<a id='n434' href='#n434'>434</a>
<a id='n435' href='#n435'>435</a>
<a id='n436' href='#n436'>436</a>
<a id='n437' href='#n437'>437</a>
<a id='n438' href='#n438'>438</a>
<a id='n439' href='#n439'>439</a>
<a id='n440' href='#n440'>440</a>
<a id='n441' href='#n441'>441</a>
<a id='n442' href='#n442'>442</a>
<a id='n443' href='#n443'>443</a>
<a id='n444' href='#n444'>444</a>
<a id='n445' href='#n445'>445</a>
<a id='n446' href='#n446'>446</a>
<a id='n447' href='#n447'>447</a>
<a id='n448' href='#n448'>448</a>
<a id='n449' href='#n449'>449</a>
<a id='n450' href='#n450'>450</a>
<a id='n451' href='#n451'>451</a>
<a id='n452' href='#n452'>452</a>
<a id='n453' href='#n453'>453</a>
<a id='n454' href='#n454'>454</a>
<a id='n455' href='#n455'>455</a>
<a id='n456' href='#n456'>456</a>
<a id='n457' href='#n457'>457</a>
<a id='n458' href='#n458'>458</a>
<a id='n459' href='#n459'>459</a>
<a id='n460' href='#n460'>460</a>
<a id='n461' href='#n461'>461</a>
<a id='n462' href='#n462'>462</a>
<a id='n463' href='#n463'>463</a>
<a id='n464' href='#n464'>464</a>
<a id='n465' href='#n465'>465</a>
<a id='n466' href='#n466'>466</a>
<a id='n467' href='#n467'>467</a>
<a id='n468' href='#n468'>468</a>
<a id='n469' href='#n469'>469</a>
<a id='n470' href='#n470'>470</a>
<a id='n471' href='#n471'>471</a>
<a id='n472' href='#n472'>472</a>
<a id='n473' href='#n473'>473</a>
<a id='n474' href='#n474'>474</a>
<a id='n475' href='#n475'>475</a>
<a id='n476' href='#n476'>476</a>
<a id='n477' href='#n477'>477</a>
<a id='n478' href='#n478'>478</a>
<a id='n479' href='#n479'>479</a>
<a id='n480' href='#n480'>480</a>
<a id='n481' href='#n481'>481</a>
<a id='n482' href='#n482'>482</a>
<a id='n483' href='#n483'>483</a>
<a id='n484' href='#n484'>484</a>
<a id='n485' href='#n485'>485</a>
<a id='n486' href='#n486'>486</a>
<a id='n487' href='#n487'>487</a>
<a id='n488' href='#n488'>488</a>
<a id='n489' href='#n489'>489</a>
<a id='n490' href='#n490'>490</a>
<a id='n491' href='#n491'>491</a>
<a id='n492' href='#n492'>492</a>
<a id='n493' href='#n493'>493</a>
<a id='n494' href='#n494'>494</a>
<a id='n495' href='#n495'>495</a>
<a id='n496' href='#n496'>496</a>
<a id='n497' href='#n497'>497</a>
<a id='n498' href='#n498'>498</a>
<a id='n499' href='#n499'>499</a>
<a id='n500' href='#n500'>500</a>
<a id='n501' href='#n501'>501</a>
<a id='n502' href='#n502'>502</a>
<a id='n503' href='#n503'>503</a>
<a id='n504' href='#n504'>504</a>
<a id='n505' href='#n505'>505</a>
<a id='n506' href='#n506'>506</a>
<a id='n507' href='#n507'>507</a>
<a id='n508' href='#n508'>508</a>
<a id='n509' href='#n509'>509</a>
<a id='n510' href='#n510'>510</a>
<a id='n511' href='#n511'>511</a>
<a id='n512' href='#n512'>512</a>
<a id='n513' href='#n513'>513</a>
<a id='n514' href='#n514'>514</a>
<a id='n515' href='#n515'>515</a>
<a id='n516' href='#n516'>516</a>
<a id='n517' href='#n517'>517</a>
<a id='n518' href='#n518'>518</a>
<a id='n519' href='#n519'>519</a>
<a id='n520' href='#n520'>520</a>
<a id='n521' href='#n521'>521</a>
<a id='n522' href='#n522'>522</a>
<a id='n523' href='#n523'>523</a>
<a id='n524' href='#n524'>524</a>
<a id='n525' href='#n525'>525</a>
<a id='n526' href='#n526'>526</a>
<a id='n527' href='#n527'>527</a>
<a id='n528' href='#n528'>528</a>
<a id='n529' href='#n529'>529</a>
<a id='n530' href='#n530'>530</a>
<a id='n531' href='#n531'>531</a>
<a id='n532' href='#n532'>532</a>
<a id='n533' href='#n533'>533</a>
<a id='n534' href='#n534'>534</a>
<a id='n535' href='#n535'>535</a>
<a id='n536' href='#n536'>536</a>
<a id='n537' href='#n537'>537</a>
<a id='n538' href='#n538'>538</a>
<a id='n539' href='#n539'>539</a>
<a id='n540' href='#n540'>540</a>
<a id='n541' href='#n541'>541</a>
<a id='n542' href='#n542'>542</a>
<a id='n543' href='#n543'>543</a>
<a id='n544' href='#n544'>544</a>
<a id='n545' href='#n545'>545</a>
<a id='n546' href='#n546'>546</a>
<a id='n547' href='#n547'>547</a>
<a id='n548' href='#n548'>548</a>
<a id='n549' href='#n549'>549</a>
<a id='n550' href='#n550'>550</a>
<a id='n551' href='#n551'>551</a>
<a id='n552' href='#n552'>552</a>
<a id='n553' href='#n553'>553</a>
<a id='n554' href='#n554'>554</a>
<a id='n555' href='#n555'>555</a>
<a id='n556' href='#n556'>556</a>
<a id='n557' href='#n557'>557</a>
<a id='n558' href='#n558'>558</a>
<a id='n559' href='#n559'>559</a>
<a id='n560' href='#n560'>560</a>
<a id='n561' href='#n561'>561</a>
<a id='n562' href='#n562'>562</a>
<a id='n563' href='#n563'>563</a>
<a id='n564' href='#n564'>564</a>
<a id='n565' href='#n565'>565</a>
<a id='n566' href='#n566'>566</a>
<a id='n567' href='#n567'>567</a>
<a id='n568' href='#n568'>568</a>
<a id='n569' href='#n569'>569</a>
<a id='n570' href='#n570'>570</a>
<a id='n571' href='#n571'>571</a>
<a id='n572' href='#n572'>572</a>
<a id='n573' href='#n573'>573</a>
<a id='n574' href='#n574'>574</a>
<a id='n575' href='#n575'>575</a>
<a id='n576' href='#n576'>576</a>
<a id='n577' href='#n577'>577</a>
<a id='n578' href='#n578'>578</a>
<a id='n579' href='#n579'>579</a>
<a id='n580' href='#n580'>580</a>
<a id='n581' href='#n581'>581</a>
<a id='n582' href='#n582'>582</a>
<a id='n583' href='#n583'>583</a>
<a id='n584' href='#n584'>584</a>
<a id='n585' href='#n585'>585</a>
<a id='n586' href='#n586'>586</a>
<a id='n587' href='#n587'>587</a>
<a id='n588' href='#n588'>588</a>
<a id='n589' href='#n589'>589</a>
<a id='n590' href='#n590'>590</a>
<a id='n591' href='#n591'>591</a>
<a id='n592' href='#n592'>592</a>
<a id='n593' href='#n593'>593</a>
<a id='n594' href='#n594'>594</a>
<a id='n595' href='#n595'>595</a>
<a id='n596' href='#n596'>596</a>
<a id='n597' href='#n597'>597</a>
<a id='n598' href='#n598'>598</a>
<a id='n599' href='#n599'>599</a>
<a id='n600' href='#n600'>600</a>
<a id='n601' href='#n601'>601</a>
<a id='n602' href='#n602'>602</a>
<a id='n603' href='#n603'>603</a>
<a id='n604' href='#n604'>604</a>
<a id='n605' href='#n605'>605</a>
<a id='n606' href='#n606'>606</a>
<a id='n607' href='#n607'>607</a>
<a id='n608' href='#n608'>608</a>
<a id='n609' href='#n609'>609</a>
<a id='n610' href='#n610'>610</a>
<a id='n611' href='#n611'>611</a>
<a id='n612' href='#n612'>612</a>
<a id='n613' href='#n613'>613</a>
<a id='n614' href='#n614'>614</a>
<a id='n615' href='#n615'>615</a>
<a id='n616' href='#n616'>616</a>
<a id='n617' href='#n617'>617</a>
<a id='n618' href='#n618'>618</a>
<a id='n619' href='#n619'>619</a>
<a id='n620' href='#n620'>620</a>
<a id='n621' href='#n621'>621</a>
<a id='n622' href='#n622'>622</a>
<a id='n623' href='#n623'>623</a>
<a id='n624' href='#n624'>624</a>
<a id='n625' href='#n625'>625</a>
<a id='n626' href='#n626'>626</a>
<a id='n627' href='#n627'>627</a>
<a id='n628' href='#n628'>628</a>
<a id='n629' href='#n629'>629</a>
<a id='n630' href='#n630'>630</a>
<a id='n631' href='#n631'>631</a>
<a id='n632' href='#n632'>632</a>
<a id='n633' href='#n633'>633</a>
<a id='n634' href='#n634'>634</a>
<a id='n635' href='#n635'>635</a>
<a id='n636' href='#n636'>636</a>
<a id='n637' href='#n637'>637</a>
<a id='n638' href='#n638'>638</a>
<a id='n639' href='#n639'>639</a>
<a id='n640' href='#n640'>640</a>
<a id='n641' href='#n641'>641</a>
<a id='n642' href='#n642'>642</a>
<a id='n643' href='#n643'>643</a>
<a id='n644' href='#n644'>644</a>
<a id='n645' href='#n645'>645</a>
<a id='n646' href='#n646'>646</a>
<a id='n647' href='#n647'>647</a>
<a id='n648' href='#n648'>648</a>
<a id='n649' href='#n649'>649</a>
<a id='n650' href='#n650'>650</a>
<a id='n651' href='#n651'>651</a>
<a id='n652' href='#n652'>652</a>
<a id='n653' href='#n653'>653</a>
<a id='n654' href='#n654'>654</a>
<a id='n655' href='#n655'>655</a>
<a id='n656' href='#n656'>656</a>
<a id='n657' href='#n657'>657</a>
<a id='n658' href='#n658'>658</a>
<a id='n659' href='#n659'>659</a>
<a id='n660' href='#n660'>660</a>
<a id='n661' href='#n661'>661</a>
<a id='n662' href='#n662'>662</a>
<a id='n663' href='#n663'>663</a>
<a id='n664' href='#n664'>664</a>
<a id='n665' href='#n665'>665</a>
<a id='n666' href='#n666'>666</a>
<a id='n667' href='#n667'>667</a>
<a id='n668' href='#n668'>668</a>
<a id='n669' href='#n669'>669</a>
<a id='n670' href='#n670'>670</a>
<a id='n671' href='#n671'>671</a>
<a id='n672' href='#n672'>672</a>
<a id='n673' href='#n673'>673</a>
<a id='n674' href='#n674'>674</a>
<a id='n675' href='#n675'>675</a>
<a id='n676' href='#n676'>676</a>
<a id='n677' href='#n677'>677</a>
<a id='n678' href='#n678'>678</a>
<a id='n679' href='#n679'>679</a>
<a id='n680' href='#n680'>680</a>
<a id='n681' href='#n681'>681</a>
<a id='n682' href='#n682'>682</a>
<a id='n683' href='#n683'>683</a>
<a id='n684' href='#n684'>684</a>
<a id='n685' href='#n685'>685</a>
<a id='n686' href='#n686'>686</a>
<a id='n687' href='#n687'>687</a>
<a id='n688' href='#n688'>688</a>
<a id='n689' href='#n689'>689</a>
<a id='n690' href='#n690'>690</a>
<a id='n691' href='#n691'>691</a>
<a id='n692' href='#n692'>692</a>
<a id='n693' href='#n693'>693</a>
<a id='n694' href='#n694'>694</a>
<a id='n695' href='#n695'>695</a>
<a id='n696' href='#n696'>696</a>
<a id='n697' href='#n697'>697</a>
<a id='n698' href='#n698'>698</a>
<a id='n699' href='#n699'>699</a>
<a id='n700' href='#n700'>700</a>
<a id='n701' href='#n701'>701</a>
<a id='n702' href='#n702'>702</a>
<a id='n703' href='#n703'>703</a>
<a id='n704' href='#n704'>704</a>
<a id='n705' href='#n705'>705</a>
<a id='n706' href='#n706'>706</a>
<a id='n707' href='#n707'>707</a>
<a id='n708' href='#n708'>708</a>
<a id='n709' href='#n709'>709</a>
<a id='n710' href='#n710'>710</a>
<a id='n711' href='#n711'>711</a>
<a id='n712' href='#n712'>712</a>
<a id='n713' href='#n713'>713</a>
<a id='n714' href='#n714'>714</a>
<a id='n715' href='#n715'>715</a>
<a id='n716' href='#n716'>716</a>
<a id='n717' href='#n717'>717</a>
<a id='n718' href='#n718'>718</a>
<a id='n719' href='#n719'>719</a>
<a id='n720' href='#n720'>720</a>
<a id='n721' href='#n721'>721</a>
<a id='n722' href='#n722'>722</a>
<a id='n723' href='#n723'>723</a>
<a id='n724' href='#n724'>724</a>
<a id='n725' href='#n725'>725</a>
<a id='n726' href='#n726'>726</a>
<a id='n727' href='#n727'>727</a>
<a id='n728' href='#n728'>728</a>
<a id='n729' href='#n729'>729</a>
<a id='n730' href='#n730'>730</a>
<a id='n731' href='#n731'>731</a>
<a id='n732' href='#n732'>732</a>
<a id='n733' href='#n733'>733</a>
<a id='n734' href='#n734'>734</a>
</pre></td>
<td class='lines'><pre><code>/*
  File: getfacl.c
  (Linux Access Control List Management)

  Copyright (C) 1999-2002
  Andreas Gruenbacher, &lt;a.gruenbacher@bestbits.at&gt;
 	
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or (at
  your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
  USA.
*/

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/acl.h&gt;
#include &lt;acl/libacl.h&gt;

#include &lt;limits.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
#include &lt;libgen.h&gt;
#include &lt;getopt.h&gt;
#include &lt;locale.h&gt;
#include ""config.h""
#include ""user_group.h""
#include ""walk_tree.h""
#include ""misc.h""

#define POSIXLY_CORRECT_STR ""POSIXLY_CORRECT""

#if !POSIXLY_CORRECT
#  define CMD_LINE_OPTIONS ""aceEsRLPtpndvh""
#endif
#define POSIXLY_CMD_LINE_OPTIONS ""d""

struct option long_options[] = {
#if !POSIXLY_CORRECT
	{ ""access"",	0, 0, 'a' },
	{ ""omit-header"",	0, 0, 'c' },
	{ ""all-effective"",	0, 0, 'e' },
	{ ""no-effective"",	0, 0, 'E' },
	{ ""skip-base"",	0, 0, 's' },
	{ ""recursive"",	0, 0, 'R' },
	{ ""logical"",	0, 0, 'L' },
	{ ""physical"",	0, 0, 'P' },
	{ ""tabular"",	0, 0, 't' },
	{ ""absolute-names"",	0, 0, 'p' },
	{ ""numeric"",	0, 0, 'n' },
#endif
	{ ""default"",	0, 0, 'd' },
	{ ""version"",	0, 0, 'v' },
	{ ""help"",	0, 0, 'h' },
	{ NULL,		0, 0, 0   }
};

const char *progname;
const char *cmd_line_options;

int walk_flags = WALK_TREE_DEREFERENCE_TOPLEVEL;
int opt_print_acl;
int opt_print_default_acl;
int opt_strip_leading_slash = 1;
int opt_comments = 1;  /* include comments */
int opt_skip_base;  /* skip files that only have the base entries */
int opt_tabular;  /* tabular output format (alias `showacl') */
#if POSIXLY_CORRECT
const int posixly_correct = 1;  /* Posix compatible behavior! */
#else
int posixly_correct;  /* Posix compatible behavior? */
#endif
int had_errors;
int absolute_warning;  /* Absolute path warning was issued */
int print_options = TEXT_SOME_EFFECTIVE;
int opt_numeric;  /* don't convert id's to symbolic names */


static const char *xquote(const char *str, const char *quote_chars)
{
	const char *q = quote(str, quote_chars);
	if (q == NULL) {
		fprintf(stderr, ""%s: %s\n"", progname, strerror(errno));
		exit(1);
	}
	return q;
}

struct name_list {
	struct name_list *next;
	char name[0];
};

void free_list(struct name_list *names)
{
	struct name_list *next;

	while (names) {
		next = names-&gt;next;
		free(names);
		names = next;
	}
}

struct name_list *get_list(const struct stat *st, acl_t acl)
{
	struct name_list *first = NULL, *last = NULL;
	acl_entry_t ent;
	int ret = 0;

	if (acl != NULL)
		ret = acl_get_entry(acl, ACL_FIRST_ENTRY, &amp;ent);
	if (ret != 1)
		return NULL;
	while (ret &gt; 0) {
		acl_tag_t e_type;
		const id_t *id_p;
		const char *name = """";
		int len;

		acl_get_tag_type(ent, &amp;e_type);
		switch(e_type) {
			case ACL_USER_OBJ:
				name = user_name(st-&gt;st_uid, opt_numeric);
				break;

			case ACL_USER:
				id_p = acl_get_qualifier(ent);
				if (id_p != NULL)
					name = user_name(*id_p, opt_numeric);
				break;

			case ACL_GROUP_OBJ:
				name = group_name(st-&gt;st_gid, opt_numeric);
				break;

			case ACL_GROUP:
				id_p = acl_get_qualifier(ent);
				if (id_p != NULL)
					name = group_name(*id_p, opt_numeric);
				break;
		}
		name = xquote(name, ""\t\n\r"");
		len = strlen(name);
		if (last == NULL) {
			first = last = (struct name_list *)
				malloc(sizeof(struct name_list) + len + 1);
		} else {
			last-&gt;next = (struct name_list *)
				malloc(sizeof(struct name_list) + len + 1);
			last = last-&gt;next;
		}
		if (last == NULL) {
			free_list(first);
			return NULL;
		}
		last-&gt;next = NULL;
		strcpy(last-&gt;name, name);

		ret = acl_get_entry(acl, ACL_NEXT_ENTRY, &amp;ent);
	}
	return first;
}

int max_name_length(struct name_list *names)
{
	int max_len = 0;
	while (names != NULL) {
		struct name_list *next = names-&gt;next;
		int len = strlen(names-&gt;name);

		if (len &gt; max_len)
			max_len = len;
		names = next;
	}
	return max_len;
}

int names_width;

struct acl_perm_def {
	acl_tag_t	tag;
	char		c;
};

struct acl_perm_def acl_perm_defs[] = {
	{ ACL_READ,	'r' },
	{ ACL_WRITE,	'w' },
	{ ACL_EXECUTE,	'x' },
	{ 0, 0 }
};

#define ACL_PERMS (sizeof(acl_perm_defs) / sizeof(struct acl_perm_def) - 1)

void acl_perm_str(acl_entry_t entry, char *str)
{
	acl_permset_t permset;
	int n;

	acl_get_permset(entry, &amp;permset);
	for (n = 0; n &lt; (int) ACL_PERMS; n++) {
		str[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?
		          acl_perm_defs[n].c : '-');
	}
	str[n] = '\0';
}

void acl_mask_perm_str(acl_t acl, char *str)
{
	acl_entry_t entry;

	str[0] = '\0';
	if (acl_get_entry(acl, ACL_FIRST_ENTRY, &amp;entry) != 1)
		return;
	for(;;) {
		acl_tag_t tag;

		acl_get_tag_type(entry, &amp;tag);
		if (tag == ACL_MASK) {
			acl_perm_str(entry, str);
			return;
		}
		if (acl_get_entry(acl, ACL_NEXT_ENTRY, &amp;entry) != 1)
			return;
	}
}

void apply_mask(char *perm, const char *mask)
{
	while (*perm) {
		if (*mask == '-' &amp;&amp; *perm &gt;= 'a' &amp;&amp; *perm &lt;= 'z')
			*perm = *perm - 'a' + 'A';
		perm++;
		if (*mask)
			mask++;
	}
}

int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,
              acl_entry_t *acl_ent, const char *acl_mask,
              struct name_list **dacl_names, acl_t dacl,
	      acl_entry_t *dacl_ent, const char *dacl_mask)
{
	acl_tag_t tag_type;
	const char *tag, *name;
	char acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];

	if (acl) {
		acl_get_tag_type(*acl_ent, &amp;tag_type);
		name = (*acl_names)-&gt;name;
	} else {
		acl_get_tag_type(*dacl_ent, &amp;tag_type);
		name = (*dacl_names)-&gt;name;
	}

	switch(tag_type) {
		case ACL_USER_OBJ:
			tag = ""USER"";
			break;
		case ACL_USER:
			tag = ""user"";
			break;
		case ACL_GROUP_OBJ:
			tag = ""GROUP"";
			break;
		case ACL_GROUP:
			tag = ""group"";
			break;
		case ACL_MASK:
			tag = ""mask"";
			break;
		case ACL_OTHER:
			tag = ""other"";
			break;
		default:
			return -1;
	}

	memset(acl_perm, ' ', ACL_PERMS);
	acl_perm[ACL_PERMS] = '\0';
	if (acl_ent) {
		acl_perm_str(*acl_ent, acl_perm);
		if (tag_type != ACL_USER_OBJ &amp;&amp; tag_type != ACL_OTHER &amp;&amp;
		    tag_type != ACL_MASK)
			apply_mask(acl_perm, acl_mask);
	}
	memset(dacl_perm, ' ', ACL_PERMS);
	dacl_perm[ACL_PERMS] = '\0';
	if (dacl_ent) {
		acl_perm_str(*dacl_ent, dacl_perm);
		if (tag_type != ACL_USER_OBJ &amp;&amp; tag_type != ACL_OTHER &amp;&amp;
		    tag_type != ACL_MASK)
			apply_mask(dacl_perm, dacl_mask);
	}

	fprintf(stream, ""%-5s  %*s  %*s  %*s\n"",
	        tag, -names_width, name,
	        -(int)ACL_PERMS, acl_perm,
		-(int)ACL_PERMS, dacl_perm);

	if (acl_names) {
		acl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);
		(*acl_names) = (*acl_names)-&gt;next;
	}
	if (dacl_names) {
		acl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);
		(*dacl_names) = (*dacl_names)-&gt;next;
	}
	return 0;
}

int do_show(FILE *stream, const char *path_p, const struct stat *st,
            acl_t acl, acl_t dacl)
{
	struct name_list *acl_names = get_list(st, acl),
	                 *first_acl_name = acl_names;
	struct name_list *dacl_names = get_list(st, dacl),
	                 *first_dacl_name = dacl_names;
	
	int acl_names_width = max_name_length(acl_names);
	int dacl_names_width = max_name_length(dacl_names);
	acl_entry_t acl_ent;
	acl_entry_t dacl_ent;
	char acl_mask[ACL_PERMS+1], dacl_mask[ACL_PERMS+1];
	int ret;

	names_width = 8;
	if (acl_names_width &gt; names_width)
		names_width = acl_names_width;
	if (dacl_names_width &gt; names_width)
		names_width = dacl_names_width;

	acl_mask[0] = '\0';
	if (acl) {
		acl_mask_perm_str(acl, acl_mask);
		ret = acl_get_entry(acl, ACL_FIRST_ENTRY, &amp;acl_ent);
		if (ret == 0)
			acl = NULL;
		if (ret &lt; 0)
			return ret;
	}
	dacl_mask[0] = '\0';
	if (dacl) {
		acl_mask_perm_str(dacl, dacl_mask);
		ret = acl_get_entry(dacl, ACL_FIRST_ENTRY, &amp;dacl_ent);
		if (ret == 0)
			dacl = NULL;
		if (ret &lt; 0)
			return ret;
	}
	fprintf(stream, ""# file: %s\n"", xquote(path_p, ""\n\r""));
	while (acl_names != NULL || dacl_names != NULL) {
		acl_tag_t acl_tag, dacl_tag;

		if (acl)
			acl_get_tag_type(acl_ent, &amp;acl_tag);
		if (dacl)
			acl_get_tag_type(dacl_ent, &amp;dacl_tag);

		if (acl &amp;&amp; (!dacl || acl_tag &lt; dacl_tag)) {
			show_line(stream, &amp;acl_names, acl, &amp;acl_ent, acl_mask,
			          NULL, NULL, NULL, NULL);
			continue;
		} else if (dacl &amp;&amp; (!acl || dacl_tag &lt; acl_tag)) {
			show_line(stream, NULL, NULL, NULL, NULL,
			          &amp;dacl_names, dacl, &amp;dacl_ent, dacl_mask);
			continue;
		} else {
			if (acl_tag == ACL_USER || acl_tag == ACL_GROUP) {
				id_t  *acl_id_p = NULL, *dacl_id_p = NULL;
				if (acl_ent)
					acl_id_p = acl_get_qualifier(acl_ent);
				if (dacl_ent)
					dacl_id_p = acl_get_qualifier(dacl_ent);
				
				if (acl &amp;&amp; (!dacl || *acl_id_p &lt; *dacl_id_p)) {
					show_line(stream, &amp;acl_names, acl,
					          &amp;acl_ent, acl_mask,
						  NULL, NULL, NULL, NULL);
					continue;
				} else if (dacl &amp;&amp;
					(!acl || *dacl_id_p &lt; *acl_id_p)) {
					show_line(stream, NULL, NULL, NULL,
					          NULL, &amp;dacl_names, dacl,
						  &amp;dacl_ent, dacl_mask);
					continue;
				}
			}
			show_line(stream, &amp;acl_names,  acl,  &amp;acl_ent, acl_mask,
				  &amp;dacl_names, dacl, &amp;dacl_ent, dacl_mask);
		}
	}

	free_list(first_acl_name);
	free_list(first_dacl_name);

	return 0;
}

/*
 * Create an ACL from the file permission bits
 * of the file PATH_P.
 */
static acl_t
acl_get_file_mode(const char *path_p)
{
	struct stat st;

	if (stat(path_p, &amp;st) != 0)
		return NULL;
	return acl_from_mode(st.st_mode);
}

int do_print(const char *path_p, const struct stat *st, int walk_flags, void *unused)
{
	const char *default_prefix = NULL;
	acl_t acl = NULL, default_acl = NULL;
	int error = 0;

	if (walk_flags &amp; WALK_TREE_FAILED) {
		fprintf(stderr, ""%s: %s: %s\n"", progname, xquote(path_p, ""\n\r""),
			strerror(errno));
		return 1;
	}

	/*
	 * Symlinks can never have ACLs, so when doing a physical walk, we
	 * skip symlinks altogether, and when doing a half-logical walk, we
	 * skip all non-toplevel symlinks. 
	 */
	if ((walk_flags &amp; WALK_TREE_SYMLINK) &amp;&amp;
	    ((walk_flags &amp; WALK_TREE_PHYSICAL) ||
	     !(walk_flags &amp; (WALK_TREE_TOPLEVEL | WALK_TREE_LOGICAL))))
		return 0;

	if (opt_print_acl) {
		acl = acl_get_file(path_p, ACL_TYPE_ACCESS);
		if (acl == NULL &amp;&amp; (errno == ENOSYS || errno == ENOTSUP))
			acl = acl_get_file_mode(path_p);
		if (acl == NULL)
			goto fail;
	}

	if (opt_print_default_acl &amp;&amp; S_ISDIR(st-&gt;st_mode)) {
		default_acl = acl_get_file(path_p, ACL_TYPE_DEFAULT);
		if (default_acl == NULL) {
			if (errno != ENOSYS &amp;&amp; errno != ENOTSUP)
				goto fail;
		} else if (acl_entries(default_acl) == 0) {
			acl_free(default_acl);
			default_acl = NULL;
		}
	}

	if (opt_skip_base &amp;&amp;
	    (!acl || acl_equiv_mode(acl, NULL) == 0) &amp;&amp; !default_acl)
		return 0;

	if (opt_print_acl &amp;&amp; opt_print_default_acl)
		default_prefix = ""default:"";

	if (opt_strip_leading_slash) {
		if (*path_p == '/') {
			if (!absolute_warning) {
				fprintf(stderr, _(""%s: Removing leading ""
					""'/' from absolute path names\n""),
				        progname);
				absolute_warning = 1;
			}
			while (*path_p == '/')
				path_p++;
		} else if (*path_p == '.' &amp;&amp; *(path_p+1) == '/')
			while (*++path_p == '/')
				/* nothing */ ;
		if (*path_p == '\0')
			path_p = ""."";
	}

	if (opt_tabular)  {
		if (do_show(stdout, path_p, st, acl, default_acl) != 0)
			goto fail;
	} else {
		if (opt_comments) {
			printf(""# file: %s\n"", xquote(path_p, ""\n\r""));
			printf(""# owner: %s\n"",
			       xquote(user_name(st-&gt;st_uid, opt_numeric), "" \t\n\r""));
			printf(""# group: %s\n"",
			       xquote(group_name(st-&gt;st_gid, opt_numeric), "" \t\n\r""));
		}
		if (acl != NULL) {
			char *acl_text = acl_to_any_text(acl, NULL, '\n',
							 print_options);
			if (!acl_text)
				goto fail;
			if (puts(acl_text) &lt; 0) {
				acl_free(acl_text);
				goto fail;
			}
			acl_free(acl_text);
		}
		if (default_acl != NULL) {
			char *acl_text = acl_to_any_text(default_acl, 
							 default_prefix, '\n',
							 print_options);
			if (!acl_text)
				goto fail;
			if (puts(acl_text) &lt; 0) {
				acl_free(acl_text);
				goto fail;
			}
			acl_free(acl_text);
		}
	}
	if (acl || default_acl || opt_comments)
		printf(""\n"");

cleanup:
	if (acl)
		acl_free(acl);
	if (default_acl)
		acl_free(default_acl);
	return error;

fail:
	fprintf(stderr, ""%s: %s: %s\n"", progname, xquote(path_p, ""\n\r""),
		strerror(errno));
	error = -1;
	goto cleanup;
}


void help(void)
{
	printf(_(""%s %s -- get file access control lists\n""),
	       progname, VERSION);
	printf(_(""Usage: %s [-%s] file ...\n""),
	         progname, cmd_line_options);
#if !POSIXLY_CORRECT
	if (posixly_correct) {
#endif
		printf(_(
""  -d, --default           display the default access control list\n""));
#if !POSIXLY_CORRECT
	} else {
		printf(_(
""  -a,  --access           display the file access control list only\n""
""  -d, --default           display the default access control list only\n""
""  -c, --omit-header       do not display the comment header\n""
""  -e, --all-effective     print all effective rights\n""
""  -E, --no-effective      print no effective rights\n""
""  -s, --skip-base         skip files that only have the base entries\n""
""  -R, --recursive         recurse into subdirectories\n""
""  -L, --logical           logical walk, follow symbolic links\n""
""  -P, --physical          physical walk, do not follow symbolic links\n""
""  -t, --tabular           use tabular output format\n""
""  -n, --numeric           print numeric user/group identifiers\n""
""  -p, --absolute-names    don't strip leading '/' in pathnames\n""));
	}
#endif
	printf(_(
""  -v, --version           print version and exit\n""
""  -h, --help              this help text\n""));
}

int main(int argc, char *argv[])
{
	int opt;
	char *line;

	progname = basename(argv[0]);

#if POSIXLY_CORRECT
	cmd_line_options = POSIXLY_CMD_LINE_OPTIONS;
#else
	if (getenv(POSIXLY_CORRECT_STR))
		posixly_correct = 1;
	if (!posixly_correct)
		cmd_line_options = CMD_LINE_OPTIONS;
	else
		cmd_line_options = POSIXLY_CMD_LINE_OPTIONS;
#endif

	setlocale(LC_CTYPE, """");
	setlocale(LC_MESSAGES, """");
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);

	/* Align `#effective:' comments to column 40 for tty's */
	if (!posixly_correct &amp;&amp; isatty(fileno(stdout)))
		print_options |= TEXT_SMART_INDENT;

	while ((opt = getopt_long(argc, argv, cmd_line_options,
		                 long_options, NULL)) != -1) {
		switch (opt) {
			case 'a':  /* acl only */
				if (posixly_correct)
					goto synopsis;
				opt_print_acl = 1;
				break;

			case 'd':  /* default acl only */
				opt_print_default_acl = 1;
				break;

			case 'c':  /* no comments */
				if (posixly_correct)
					goto synopsis;
				opt_comments = 0;
				break;

			case 'e':  /* all #effective comments */
				if (posixly_correct)
					goto synopsis;
				print_options |= TEXT_ALL_EFFECTIVE;
				break;

			case 'E':  /* no #effective comments */
				if (posixly_correct)
					goto synopsis;
				print_options &amp;= ~(TEXT_SOME_EFFECTIVE |
				                   TEXT_ALL_EFFECTIVE);
				break;

			case 'R':  /* recursive */
				if (posixly_correct)
					goto synopsis;
				walk_flags |= WALK_TREE_RECURSIVE;
				break;

			case 'L':  /* follow all symlinks */
				if (posixly_correct)
					goto synopsis;
				walk_flags |= WALK_TREE_LOGICAL | WALK_TREE_DEREFERENCE;
				walk_flags &amp;= ~WALK_TREE_PHYSICAL;
				break;

			case 'P':  /* skip all symlinks */
				if (posixly_correct)
					goto synopsis;
				walk_flags |= WALK_TREE_PHYSICAL;
				walk_flags &amp;= ~(WALK_TREE_LOGICAL | WALK_TREE_DEREFERENCE |
						WALK_TREE_DEREFERENCE_TOPLEVEL);
				break;

			case 's':  /* skip files with only base entries */
				if (posixly_correct)
					goto synopsis;
				opt_skip_base = 1;
				break;

			case 'p':
				if (posixly_correct)
					goto synopsis;
				opt_strip_leading_slash = 0;
				break;

			case 't':
				if (posixly_correct)
					goto synopsis;
				opt_tabular = 1;
				break;

			case 'n':  /* numeric */
				opt_numeric = 1;
				print_options |= TEXT_NUMERIC_IDS;
				break;

			case 'v':  /* print version */
				printf(""%s "" VERSION ""\n"", progname);
				return 0;

			case 'h':  /* help */
				help();
				return 0;

			case ':':  /* option missing */
			case '?':  /* unknown option */
			default:
				goto synopsis;
		}
	}

	if (!(opt_print_acl || opt_print_default_acl)) {
		opt_print_acl = 1;
		if (!posixly_correct)
			opt_print_default_acl = 1;
	}
		
	if ((optind == argc) &amp;&amp; !posixly_correct)
		goto synopsis;

	do {
		if (optind == argc ||
		    strcmp(argv[optind], ""-"") == 0) {
			while ((line = next_line(stdin)) != NULL) {
				if (*line == '\0')
					continue;

				had_errors += walk_tree(line, walk_flags, 0,
							do_print, NULL);
			}
			if (!feof(stdin)) {
				fprintf(stderr, _(""%s: Standard input: %s\n""),
				        progname, strerror(errno));
				had_errors++;
			}
		} else
			had_errors += walk_tree(argv[optind], walk_flags, 0,
						do_print, NULL);
		optind++;
	} while (optind &lt; argc);

	return had_errors ? 1 : 0;

synopsis:
	fprintf(stderr, _(""Usage: %s [-%s] file ...\n""),
	        progname, cmd_line_options);
	fprintf(stderr, _(""Try `%s --help' for more information.\n""),
		progname);
	return 2;
}

</code></pre></td></tr></table>
</div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit v1.2.1</a> (<a href='https://git-scm.com/'>git 2.18.0</a>) at 2020-05-09 06:49:58 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
"
CVE-2015-8382,https://www.cvedetails.com/cve/CVE-2015-8382/,CWE-119,,DoS Overflow +Info,2015-12-01,2016-12-27,6.4,None,Remote,Low,Not required,Partial,None,Partial,"The match function in pcre_exec.c in PCRE before 8.37 mishandles the /(?:((abcd))|(((?:(?:(?:(?:abc|(?:abcdef))))b)abcdefghi)abc)|((*ACCEPT)))/ pattern and related patterns involving (*ACCEPT), which allows remote attackers to obtain sensitive information from process memory or cause a denial of service (partially initialized memory and application crash) via a crafted regular expression, as demonstrated by a JavaScript RegExp object encountered by Konqueror, aka ZDI-CAN-2547.",C,php,https://git.php.net/?p=php-src.git;a=commit;h=c351b47ce85a3a147cfa801fa9f0149ab4160834,c351b47ce85a3a147cfa801fa9f0149ab4160834,1a2ec3fc60e428c47fd59c9dd7966c71ca44024d,"@@ -640,7 +640,7 @@ PHPAPI void php_pcre_match_impl(pcre_cache_entry *pce, char *subject, int subjec
        }
 
        offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
-
+       memset(offsets, 0, size_offsets*sizeof(int));
        /* Allocate match sets array and initialize the values. */
        if (global && subpats && subpats_order == PREG_PATTERN_ORDER) {
                match_sets = (zval **)safe_emalloc(num_subpats, sizeof(zval *), 0);",https://git.php.net/?p=php-src.git;a=blob;f=ext/pcre/php_pcre.c;h=bd93f723d626c4a784bf52d794a96f6701adabf1;hb=bd93f723d626c4a784bf52d794a96f6701adabf1,https://git.php.net/?p=php-src.git;a=blob;f=ext/pcre/php_pcre.c;h=d7a4309b24d15977dae6c61c16950b882471644c;hb=d7a4309b24d15977dae6c61c16950b882471644c," /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
    | Copyright (c) 1997-2014 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
    | available through the world-wide-web at the following url:           |
    | http://www.php.net/license/3_01.txt                                  |
    | If you did not receive a copy of the PHP license and are unable to   |
    | obtain it through the world-wide-web, please send a note to          |
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Author: Andrei Zmievski <andrei@php.net>                             |
    +----------------------------------------------------------------------+
  */
 
 /* $Id$ */
 
 #include ""php.h""
 #include ""php_ini.h""
 #include ""php_globals.h""
 #include ""php_pcre.h""
 #include ""ext/standard/info.h""
 #include ""ext/standard/php_smart_str.h""
 
 #if HAVE_PCRE || HAVE_BUNDLED_PCRE
 
 #include ""ext/standard/php_string.h""
 
 #define PREG_PATTERN_ORDER                      1
 #define PREG_SET_ORDER                          2
 #define PREG_OFFSET_CAPTURE                     (1<<8)
 
 #define PREG_SPLIT_NO_EMPTY                     (1<<0)
 #define PREG_SPLIT_DELIM_CAPTURE        (1<<1)
 #define PREG_SPLIT_OFFSET_CAPTURE       (1<<2)
 
 #define PREG_REPLACE_EVAL                       (1<<0)
 
 #define PREG_GREP_INVERT                        (1<<0)
 
 #define PCRE_CACHE_SIZE 4096
 
 enum {
         PHP_PCRE_NO_ERROR = 0,
         PHP_PCRE_INTERNAL_ERROR,
         PHP_PCRE_BACKTRACK_LIMIT_ERROR,
         PHP_PCRE_RECURSION_LIMIT_ERROR,
         PHP_PCRE_BAD_UTF8_ERROR,
         PHP_PCRE_BAD_UTF8_OFFSET_ERROR
 };
 
 
 ZEND_DECLARE_MODULE_GLOBALS(pcre)
 
 
 static void pcre_handle_exec_error(int pcre_code TSRMLS_DC) /* {{{ */
 {
         int preg_code = 0;
 
         switch (pcre_code) {
                 case PCRE_ERROR_MATCHLIMIT:
                         preg_code = PHP_PCRE_BACKTRACK_LIMIT_ERROR;
                         break;
 
                 case PCRE_ERROR_RECURSIONLIMIT:
                         preg_code = PHP_PCRE_RECURSION_LIMIT_ERROR;
                         break;
 
                 case PCRE_ERROR_BADUTF8:
                         preg_code = PHP_PCRE_BAD_UTF8_ERROR;
                         break;
 
                 case PCRE_ERROR_BADUTF8_OFFSET:
                         preg_code = PHP_PCRE_BAD_UTF8_OFFSET_ERROR;
                         break;
 
                 default:
                         preg_code = PHP_PCRE_INTERNAL_ERROR;
                         break;
         }
 
         PCRE_G(error_code) = preg_code;
 }
 /* }}} */
 
 static void php_free_pcre_cache(void *data) /* {{{ */
 {
         pcre_cache_entry *pce = (pcre_cache_entry *) data;
         if (!pce) return;
         pefree(pce->re, 1);
         if (pce->extra) pefree(pce->extra, 1);
 #if HAVE_SETLOCALE
         if ((void*)pce->tables) pefree((void*)pce->tables, 1);
         pefree(pce->locale, 1);
 #endif
 }
 /* }}} */
 
 static PHP_GINIT_FUNCTION(pcre) /* {{{ */
 {
         zend_hash_init(&pcre_globals->pcre_cache, 0, NULL, php_free_pcre_cache, 1);
         pcre_globals->backtrack_limit = 0;
         pcre_globals->recursion_limit = 0;
         pcre_globals->error_code      = PHP_PCRE_NO_ERROR;
 }
 /* }}} */
 
 static PHP_GSHUTDOWN_FUNCTION(pcre) /* {{{ */
 {
         zend_hash_destroy(&pcre_globals->pcre_cache);
 }
 /* }}} */
 
 PHP_INI_BEGIN()
         STD_PHP_INI_ENTRY(""pcre.backtrack_limit"", ""1000000"", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)
         STD_PHP_INI_ENTRY(""pcre.recursion_limit"", ""100000"", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)
 PHP_INI_END()
 
 
 /* {{{ PHP_MINFO_FUNCTION(pcre) */
 static PHP_MINFO_FUNCTION(pcre)
 {
         php_info_print_table_start();
         php_info_print_table_row(2, ""PCRE (Perl Compatible Regular Expressions) Support"", ""enabled"" );
         php_info_print_table_row(2, ""PCRE Library Version"", pcre_version() );
         php_info_print_table_end();
 
         DISPLAY_INI_ENTRIES();
 }
 /* }}} */
 
 /* {{{ PHP_MINIT_FUNCTION(pcre) */
 static PHP_MINIT_FUNCTION(pcre)
 {
         REGISTER_INI_ENTRIES();
         
         REGISTER_LONG_CONSTANT(""PREG_PATTERN_ORDER"", PREG_PATTERN_ORDER, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SET_ORDER"", PREG_SET_ORDER, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_OFFSET_CAPTURE"", PREG_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SPLIT_NO_EMPTY"", PREG_SPLIT_NO_EMPTY, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SPLIT_DELIM_CAPTURE"", PREG_SPLIT_DELIM_CAPTURE, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SPLIT_OFFSET_CAPTURE"", PREG_SPLIT_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_GREP_INVERT"", PREG_GREP_INVERT, CONST_CS | CONST_PERSISTENT);
 
         REGISTER_LONG_CONSTANT(""PREG_NO_ERROR"", PHP_PCRE_NO_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_INTERNAL_ERROR"", PHP_PCRE_INTERNAL_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_BACKTRACK_LIMIT_ERROR"", PHP_PCRE_BACKTRACK_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_RECURSION_LIMIT_ERROR"", PHP_PCRE_RECURSION_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_BAD_UTF8_ERROR"", PHP_PCRE_BAD_UTF8_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_BAD_UTF8_OFFSET_ERROR"", PHP_PCRE_BAD_UTF8_OFFSET_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_STRING_CONSTANT(""PCRE_VERSION"", (char *)pcre_version(), CONST_CS | CONST_PERSISTENT);
 
         return SUCCESS;
 }
 /* }}} */
 
 /* {{{ PHP_MSHUTDOWN_FUNCTION(pcre) */
 static PHP_MSHUTDOWN_FUNCTION(pcre)
 {
         UNREGISTER_INI_ENTRIES();
 
         return SUCCESS;
 }
 /* }}} */
 
 /* {{{ static pcre_clean_cache */
 static int pcre_clean_cache(void *data, void *arg TSRMLS_DC)
 {
         int *num_clean = (int *)arg;
 
         if (*num_clean > 0) {
                 (*num_clean)--;
                 return 1;
         } else {
                 return 0;
         }
 }
 /* }}} */
 
 /* {{{ static make_subpats_table */
 static char **make_subpats_table(int num_subpats, pcre_cache_entry *pce TSRMLS_DC)
 {
         pcre_extra *extra = pce->extra;
         int name_cnt = 0, name_size, ni = 0;
         int rc;
         char *name_table;
         unsigned short name_idx;
         char **subpat_names = (char **)ecalloc(num_subpats, sizeof(char *));
 
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMECOUNT, &name_cnt);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 efree(subpat_names);
                 return NULL;
         }
         if (name_cnt > 0) {
                 int rc1, rc2;
 
                 rc1 = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMETABLE, &name_table);
                 rc2 = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMEENTRYSIZE, &name_size);
                 rc = rc2 ? rc2 : rc1;
                 if (rc < 0) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                         efree(subpat_names);
                         return NULL;
                 }
 
                 while (ni++ < name_cnt) {
                         name_idx = 0xff * (unsigned char)name_table[0] + (unsigned char)name_table[1];
                         subpat_names[name_idx] = name_table + 2;
                         if (is_numeric_string(subpat_names[name_idx], strlen(subpat_names[name_idx]), NULL, NULL, 0) > 0) {
                                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Numeric named subpatterns are not allowed"");
                                 efree(subpat_names);
                                 return NULL;
                         }
                         name_table += name_size;
                 }
         }
 
         return subpat_names;
 }
 /* }}} */
 
 /* {{{ pcre_get_compiled_regex_cache
  */
 PHPAPI pcre_cache_entry* pcre_get_compiled_regex_cache(char *regex, int regex_len TSRMLS_DC)
 {
         pcre                            *re = NULL;
         pcre_extra                      *extra;
         int                                      coptions = 0;
         int                                      soptions = 0;
         const char                      *error;
         int                                      erroffset;
         char                             delimiter;
         char                             start_delimiter;
         char                             end_delimiter;
         char                            *p, *pp;
         char                            *pattern;
         int                                      do_study = 0;
         int                                      poptions = 0;
         int                             count = 0;
         unsigned const char *tables = NULL;
 #if HAVE_SETLOCALE
         char                            *locale;
 #endif
         pcre_cache_entry        *pce;
         pcre_cache_entry         new_entry;
         char                *tmp = NULL;
 
 #if HAVE_SETLOCALE
 # if defined(PHP_WIN32) && defined(ZTS)
         _configthreadlocale(_ENABLE_PER_THREAD_LOCALE);
 # endif
         locale = setlocale(LC_CTYPE, NULL);
 #endif
 
         /* Try to lookup the cached regex entry, and if successful, just pass
            back the compiled pattern, otherwise go on and compile it. */
         if (zend_hash_find(&PCRE_G(pcre_cache), regex, regex_len+1, (void **)&pce) == SUCCESS) {
                 /*
                  * We use a quick pcre_fullinfo() check to see whether cache is corrupted, and if it
                  * is, we flush it and compile the pattern from scratch.
                  */
                 if (pcre_fullinfo(pce->re, NULL, PCRE_INFO_CAPTURECOUNT, &count) == PCRE_ERROR_BADMAGIC) {
                         zend_hash_clean(&PCRE_G(pcre_cache));
                 } else {
 #if HAVE_SETLOCALE
                         if (!strcmp(pce->locale, locale)) {
 #endif
                                 return pce;
 #if HAVE_SETLOCALE
                         }
 #endif
                 }
         }
         
         p = regex;
         
         /* Parse through the leading whitespace, and display a warning if we
            get to the end without encountering a delimiter. */
         while (isspace((int)*(unsigned char *)p)) p++;
         if (*p == 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, 
                                                  p < regex + regex_len ? ""Null byte in regex"" : ""Empty regular expression"");
                 return NULL;
         }
         
         /* Get the delimiter and display a warning if it is alphanumeric
            or a backslash. */
         delimiter = *p++;
         if (isalnum((int)*(unsigned char *)&delimiter) || delimiter == '\\') {
                 php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Delimiter must not be alphanumeric or backslash"");
                 return NULL;
         }
 
         start_delimiter = delimiter;
         if ((pp = strchr(""([{< )]}> )]}>"", delimiter)))
                 delimiter = pp[5];
         end_delimiter = delimiter;
 
         pp = p;
 
         if (start_delimiter == end_delimiter) {
                 /* We need to iterate through the pattern, searching for the ending delimiter,
                    but skipping the backslashed delimiters.  If the ending delimiter is not
                    found, display a warning. */
                 while (*pp != 0) {
                         if (*pp == '\\' && pp[1] != 0) pp++;
                         else if (*pp == delimiter)
                                 break;
                         pp++;
                 }
         } else {
                 /* We iterate through the pattern, searching for the matching ending
                  * delimiter. For each matching starting delimiter, we increment nesting
                  * level, and decrement it for each matching ending delimiter. If we
                  * reach the end of the pattern without matching, display a warning.
                  */
                 int brackets = 1;       /* brackets nesting level */
                 while (*pp != 0) {
                         if (*pp == '\\' && pp[1] != 0) pp++;
                         else if (*pp == end_delimiter && --brackets <= 0)
                                 break;
                         else if (*pp == start_delimiter)
                                 brackets++;
                         pp++;
                 }
         }
 
         if (*pp == 0) {
                 if (pp < regex + regex_len) {
                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Null byte in regex"");
                 } else if (start_delimiter == end_delimiter) {
                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""No ending delimiter '%c' found"", delimiter);
                 } else {
                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""No ending matching delimiter '%c' found"", delimiter);
                 }
                 return NULL;
         }
         
         /* Make a copy of the actual pattern. */
         pattern = estrndup(p, pp-p);
 
         /* Move on to the options */
         pp++;
 
         /* Parse through the options, setting appropriate flags.  Display
            a warning if we encounter an unknown modifier. */    
         while (pp < regex + regex_len) {
                 switch (*pp++) {
                         /* Perl compatible options */
                         case 'i':       coptions |= PCRE_CASELESS;              break;
                         case 'm':       coptions |= PCRE_MULTILINE;             break;
                         case 's':       coptions |= PCRE_DOTALL;                break;
                         case 'x':       coptions |= PCRE_EXTENDED;              break;
                         
                         /* PCRE specific options */
                         case 'A':       coptions |= PCRE_ANCHORED;              break;
                         case 'D':       coptions |= PCRE_DOLLAR_ENDONLY;break;
                         case 'S':       do_study  = 1;                                  break;
                         case 'U':       coptions |= PCRE_UNGREEDY;              break;
                         case 'X':       coptions |= PCRE_EXTRA;                 break;
                         case 'u':       coptions |= PCRE_UTF8;
         /* In  PCRE,  by  default, \d, \D, \s, \S, \w, and \W recognize only ASCII
        characters, even in UTF-8 mode. However, this can be changed by setting
        the PCRE_UCP option. */
 #ifdef PCRE_UCP
                                                 coptions |= PCRE_UCP;
 #endif                  
                                 break;
 
                         /* Custom preg options */
                         case 'e':       poptions |= PREG_REPLACE_EVAL;  break;
                         
                         case ' ':
                         case '\n':
                                 break;
 
                         default:
                                 if (pp[-1]) {
                                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Unknown modifier '%c'"", pp[-1]);
                                 } else {
                                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Null byte in regex"");
                                 }
                                 efree(pattern);
                                 return NULL;
                 }
         }
 
 #if HAVE_SETLOCALE
         if (strcmp(locale, ""C""))
                 tables = pcre_maketables();
 #endif
 
         /* Compile pattern and display a warning if compilation failed. */
         re = pcre_compile(pattern,
                                           coptions,
                                           &error,
                                           &erroffset,
                                           tables);
 
         if (re == NULL) {
                 php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Compilation failed: %s at offset %d"", error, erroffset);
                 efree(pattern);
                 if (tables) {
                         pefree((void*)tables, 1);
                 }
                 return NULL;
         }
 
         /* If study option was specified, study the pattern and
            store the result in extra for passing to pcre_exec. */
         if (do_study) {
                 extra = pcre_study(re, soptions, &error);
                 if (extra) {
                         extra->flags |= PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 }
                 if (error != NULL) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while studying pattern"");
                 }
         } else {
                 extra = NULL;
         }
 
         efree(pattern);
 
         /*
          * If we reached cache limit, clean out the items from the head of the list;
          * these are supposedly the oldest ones (but not necessarily the least used
          * ones).
          */
         if (zend_hash_num_elements(&PCRE_G(pcre_cache)) == PCRE_CACHE_SIZE) {
                 int num_clean = PCRE_CACHE_SIZE / 8;
                 zend_hash_apply_with_argument(&PCRE_G(pcre_cache), pcre_clean_cache, &num_clean TSRMLS_CC);
         }
 
         /* Store the compiled pattern and extra info in the cache. */
         new_entry.re = re;
         new_entry.extra = extra;
         new_entry.preg_options = poptions;
         new_entry.compile_options = coptions;
 #if HAVE_SETLOCALE
         new_entry.locale = pestrdup(locale, 1);
         new_entry.tables = tables;
 #endif
 
         /*
          * Interned strings are not duplicated when stored in HashTable,
          * but all the interned strings created during HTTP request are removed
          * at end of request. However PCRE_G(pcre_cache) must be consistent
          * on the next request as well. So we disable usage of interned strings
          * as hash keys especually for this table.
          * See bug #63180 
          */
         if (IS_INTERNED(regex)) {
                 regex = tmp = estrndup(regex, regex_len);
         }
 
         zend_hash_update(&PCRE_G(pcre_cache), regex, regex_len+1, (void *)&new_entry,
                                                 sizeof(pcre_cache_entry), (void**)&pce);
 
         if (tmp) {
                 efree(tmp);
         }
 
         return pce;
 }
 /* }}} */
 
 /* {{{ pcre_get_compiled_regex
  */
 PHPAPI pcre* pcre_get_compiled_regex(char *regex, pcre_extra **extra, int *preg_options TSRMLS_DC)
 {
         pcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex, strlen(regex) TSRMLS_CC);
 
         if (extra) {
                 *extra = pce ? pce->extra : NULL;
         }
         if (preg_options) {
                 *preg_options = pce ? pce->preg_options : 0;
         }
         
         return pce ? pce->re : NULL;
 }
 /* }}} */
 
 /* {{{ pcre_get_compiled_regex_ex
  */
 PHPAPI pcre* pcre_get_compiled_regex_ex(char *regex, pcre_extra **extra, int *preg_options, int *compile_options TSRMLS_DC)
 {
         pcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex, strlen(regex) TSRMLS_CC);
         
         if (extra) {
                 *extra = pce ? pce->extra : NULL;
         }
         if (preg_options) {
                 *preg_options = pce ? pce->preg_options : 0;
         }
         if (compile_options) {
                 *compile_options = pce ? pce->compile_options : 0;
         }
         
         return pce ? pce->re : NULL;
 }
 /* }}} */
 
 /* {{{ add_offset_pair */
 static inline void add_offset_pair(zval *result, char *str, int len, int offset, char *name)
 {
         zval *match_pair;
 
         ALLOC_ZVAL(match_pair);
         array_init(match_pair);
         INIT_PZVAL(match_pair);
 
         /* Add (match, offset) to the return value */
         add_next_index_stringl(match_pair, str, len, 1);
         add_next_index_long(match_pair, offset);
         
         if (name) {
                 zval_add_ref(&match_pair);
                 zend_hash_update(Z_ARRVAL_P(result), name, strlen(name)+1, &match_pair, sizeof(zval *), NULL);
         }
         zend_hash_next_index_insert(Z_ARRVAL_P(result), &match_pair, sizeof(zval *), NULL);
 }
 /* }}} */
 
 static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
 {
         /* parameters */
         char                     *regex;                        /* Regular expression */
         char                     *subject;                      /* String to match against */
         int                               regex_len;
         int                               subject_len;
         pcre_cache_entry *pce;                          /* Compiled regular expression */
         zval                     *subpats = NULL;       /* Array for subpatterns */
         long                      flags = 0;            /* Match control flags */
         long                      start_offset = 0;     /* Where the new search starts */
 
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
                                                           &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
                 RETURN_FALSE;
         }
         
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 RETURN_FALSE;
         }
 
         php_pcre_match_impl(pce, subject, subject_len, return_value, subpats, 
                 global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ php_pcre_match_impl() */
 PHPAPI void php_pcre_match_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *return_value,
         zval *subpats, int global, int use_flags, long flags, long start_offset TSRMLS_DC)
 {
         zval                    *result_set,            /* Holds a set of subpatterns after
                                                                                    a global match */
                                    **match_sets = NULL; /* An array of sets of matches for each
                                                                                    subpattern after a global match */
         pcre_extra              *extra = pce->extra;/* Holds results of studying */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                              exoptions = 0;         /* Execution options */
         int                              count = 0;                     /* Count of matched subpatterns */
         int                             *offsets;                       /* Array of subpattern offsets */
         int                              num_subpats;           /* Number of captured subpatterns */
         int                              size_offsets;          /* Size of the offsets array */
         int                              matched;                       /* Has anything matched */
         int                              g_notempty = 0;        /* If the match should not be empty */
         const char         **stringlist;                /* Holds list of subpatterns */
         char               **subpat_names;              /* Array for named subpatterns */
         int                              i, rc;
         int                              subpats_order;         /* Order of subpattern matches */
         int                              offset_capture;    /* Capture match offsets: yes/no */
 
         /* Overwrite the passed-in value for subpatterns with an empty array. */
         if (subpats != NULL) {
                 zval_dtor(subpats);
                 array_init(subpats);
         }
 
         subpats_order = global ? PREG_PATTERN_ORDER : 0;
 
         if (use_flags) {
                 offset_capture = flags & PREG_OFFSET_CAPTURE;
 
                 /*
                  * subpats_order is pre-set to pattern mode so we change it only if
                  * necessary.
                  */
                 if (flags & 0xff) {
                         subpats_order = flags & 0xff;
                 }
                 if ((global && (subpats_order < PREG_PATTERN_ORDER || subpats_order > PREG_SET_ORDER)) ||
                         (!global && subpats_order != 0)) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid flags specified"");
                         return;
                 }
         } else {
                 offset_capture = 0;
         }
 
         /* Negative offset counts from the end of the string. */
         if (start_offset < 0) {
                 start_offset = subject_len + start_offset;
                 if (start_offset < 0) {
                         start_offset = 0;
                 }
         }
 
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &num_subpats);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 RETURN_FALSE;
         }
         num_subpats++;
         size_offsets = num_subpats * 3;
 
         /*
          * Build a mapping from subpattern numbers to their names. We will always
          * allocate the table, even though there may be no named subpatterns. This
          * avoids somewhat more complicated logic in the inner loops.
          */
         subpat_names = make_subpats_table(num_subpats, pce TSRMLS_CC);
         if (!subpat_names) {
                 RETURN_FALSE;
         }
 
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
 
         /* Allocate match sets array and initialize the values. */
         if (global && subpats && subpats_order == PREG_PATTERN_ORDER) {
                 match_sets = (zval **)safe_emalloc(num_subpats, sizeof(zval *), 0);
                 for (i=0; i<num_subpats; i++) {
                         ALLOC_ZVAL(match_sets[i]);
                         array_init(match_sets[i]);
                         INIT_PZVAL(match_sets[i]);
                 }
         }
 
         matched = 0;
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
         
         do {
                 /* Execute the regular expression. */
                 count = pcre_exec(pce->re, extra, subject, subject_len, start_offset,
                                                   exoptions|g_notempty, offsets, size_offsets);
 
                 /* the string was already proved to be valid UTF-8 */
                 exoptions |= PCRE_NO_UTF8_CHECK;
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 }
 
                 /* If something has matched */
                 if (count > 0) {
                         matched++;
 
                         /* If subpatterns array has been passed, fill it in with values. */
                         if (subpats != NULL) {
                                 /* Try to get the list of substrings and display a warning if failed. */
                                 if (pcre_get_substring_list(subject, offsets, count, &stringlist) < 0) {
                                         efree(subpat_names);
                                         efree(offsets);
                                         if (match_sets) efree(match_sets);
                                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Get subpatterns list failed"");
                                         RETURN_FALSE;
                                 }
 
                                 if (global) {   /* global pattern matching */
                                         if (subpats && subpats_order == PREG_PATTERN_ORDER) {
                                                 /* For each subpattern, insert it into the appropriate array. */
                                                 for (i = 0; i < count; i++) {
                                                         if (offset_capture) {
                                                                 add_offset_pair(match_sets[i], (char *)stringlist[i],
                                                                                                 offsets[(i<<1)+1] - offsets[i<<1], offsets[i<<1], NULL);
                                                         } else {
                                                                 add_next_index_stringl(match_sets[i], (char *)stringlist[i],
                                                                                                            offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                         }
                                                 }
                                                 /*
                                                  * If the number of captured subpatterns on this run is
                                                  * less than the total possible number, pad the result
                                                  * arrays with empty strings.
                                                  */
                                                 if (count < num_subpats) {
                                                         for (; i < num_subpats; i++) {
                                                                 add_next_index_string(match_sets[i], """", 1);
                                                         }
                                                 }
                                         } else {
                                                 /* Allocate the result set array */
                                                 ALLOC_ZVAL(result_set);
                                                 array_init(result_set);
                                                 INIT_PZVAL(result_set);
                                                 
                                                 /* Add all the subpatterns to it */
                                                 for (i = 0; i < count; i++) {
                                                         if (offset_capture) {
                                                                 add_offset_pair(result_set, (char *)stringlist[i],
                                                                                                 offsets[(i<<1)+1] - offsets[i<<1], offsets[i<<1], subpat_names[i]);
                                                         } else {
                                                                 if (subpat_names[i]) {
                                                                         add_assoc_stringl(result_set, subpat_names[i], (char *)stringlist[i],
                                                                                                                    offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                                 }
                                                                 add_next_index_stringl(result_set, (char *)stringlist[i],
                                                                                                            offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                         }
                                                 }
                                                 /* And add it to the output array */
                                                 zend_hash_next_index_insert(Z_ARRVAL_P(subpats), &result_set, sizeof(zval *), NULL);
                                         }
                                 } else {                        /* single pattern matching */
                                         /* For each subpattern, insert it into the subpatterns array. */
                                         for (i = 0; i < count; i++) {
                                                 if (offset_capture) {
                                                         add_offset_pair(subpats, (char *)stringlist[i],
                                                                                         offsets[(i<<1)+1] - offsets[i<<1],
                                                                                         offsets[i<<1], subpat_names[i]);
                                                 } else {
                                                         if (subpat_names[i]) {
                                                                 add_assoc_stringl(subpats, subpat_names[i], (char *)stringlist[i],
                                                                                                   offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                         }
                                                         add_next_index_stringl(subpats, (char *)stringlist[i],
                                                                                                    offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                 }
                                         }
                                 }
 
                                 pcre_free((void *) stringlist);
                         }
                 } else if (count == PCRE_ERROR_NOMATCH) {
                         /* If we previously set PCRE_NOTEMPTY after a null match,
                            this is not necessarily the end. We need to advance
                            the start offset, and continue. Fudge the offset values
                            to achieve this, unless we're already at the end of the string. */
                         if (g_notempty != 0 && start_offset < subject_len) {
                                 offsets[0] = start_offset;
                                 offsets[1] = start_offset + 1;
                         } else
                                 break;
                 } else {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         break;
                 }
                 
                 /* If we have matched an empty string, mimic what Perl's /g options does.
                    This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try
                    the match again at the same point. If this fails (picked up above) we
                    advance to the next character. */
                 g_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;
                 
                 /* Advance to the position right after the last full match */
                 start_offset = offsets[1];
         } while (global);
 
         /* Add the match sets to the output array and clean up */
         if (global && subpats && subpats_order == PREG_PATTERN_ORDER) {
                 for (i = 0; i < num_subpats; i++) {
                         if (subpat_names[i]) {
                                 zend_hash_update(Z_ARRVAL_P(subpats), subpat_names[i],
                                                                  strlen(subpat_names[i])+1, &match_sets[i], sizeof(zval *), NULL);
                                 Z_ADDREF_P(match_sets[i]);
                         }
                         zend_hash_next_index_insert(Z_ARRVAL_P(subpats), &match_sets[i], sizeof(zval *), NULL);
                 }
                 efree(match_sets);
         }
         
         efree(offsets);
         efree(subpat_names);
 
         /* Did we encounter an error? */
         if (PCRE_G(error_code) == PHP_PCRE_NO_ERROR) {
                 RETVAL_LONG(matched);
         } else {
                 RETVAL_FALSE;
         }
 }
 /* }}} */
 
 /* {{{ proto int preg_match(string pattern, string subject [, array &subpatterns [, int flags [, int offset]]])
    Perform a Perl-style regular expression match */
 static PHP_FUNCTION(preg_match)
 {
         php_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
 }
 /* }}} */
 
 /* {{{ proto int preg_match_all(string pattern, string subject [, array &subpatterns [, int flags [, int offset]]])
    Perform a Perl-style global regular expression match */
 static PHP_FUNCTION(preg_match_all)
 {
         php_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
 }
 /* }}} */
 
 /* {{{ preg_get_backref
  */
 static int preg_get_backref(char **str, int *backref)
 {
         register char in_brace = 0;
         register char *walk = *str;
 
         if (walk[1] == 0)
                 return 0;
 
         if (*walk == '$' && walk[1] == '{') {
                 in_brace = 1;
                 walk++;
         }
         walk++;
 
         if (*walk >= '0' && *walk <= '9') {
                 *backref = *walk - '0';
                 walk++;
         } else
                 return 0;
         
         if (*walk && *walk >= '0' && *walk <= '9') {
                 *backref = *backref * 10 + *walk - '0';
                 walk++;
         }
 
         if (in_brace) {
                 if (*walk == 0 || *walk != '}')
                         return 0;
                 else
                         walk++;
         }
         
         *str = walk;
         return 1;       
 }
 /* }}} */
 
 /* {{{ preg_do_repl_func
  */
 static int preg_do_repl_func(zval *function, char *subject, int *offsets, char **subpat_names, int count, char **result TSRMLS_DC)
 {
         zval            *retval_ptr;            /* Function return value */
         zval       **args[1];                   /* Argument to pass to function */
         zval            *subpats;                       /* Captured subpatterns */ 
         int                      result_len;            /* Return value length */
         int                      i;
 
         MAKE_STD_ZVAL(subpats);
         array_init(subpats);
         for (i = 0; i < count; i++) {
                 if (subpat_names[i]) {
                         add_assoc_stringl(subpats, subpat_names[i], &subject[offsets[i<<1]] , offsets[(i<<1)+1] - offsets[i<<1], 1);
                 }
                 add_next_index_stringl(subpats, &subject[offsets[i<<1]], offsets[(i<<1)+1] - offsets[i<<1], 1);
         }
         args[0] = &subpats;
 
         if (call_user_function_ex(EG(function_table), NULL, function, &retval_ptr, 1, args, 0, NULL TSRMLS_CC) == SUCCESS && retval_ptr) {
                 convert_to_string_ex(&retval_ptr);
                 *result = estrndup(Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
                 result_len = Z_STRLEN_P(retval_ptr);
                 zval_ptr_dtor(&retval_ptr);
         } else {
                 if (!EG(exception)) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
                 }
                 result_len = offsets[1] - offsets[0];
                 *result = estrndup(&subject[offsets[0]], result_len);
         }
 
         zval_ptr_dtor(&subpats);
 
         return result_len;
 }
 /* }}} */
 
 /* {{{ preg_do_eval
  */
 static int preg_do_eval(char *eval_str, int eval_str_len, char *subject,
                                                 int *offsets, int count, char **result TSRMLS_DC)
 {
         zval             retval;                        /* Return value from evaluation */
         char            *eval_str_end,          /* End of eval string */
                                 *match,                         /* Current match for a backref */
                                 *esc_match,                     /* Quote-escaped match */
                                 *walk,                          /* Used to walk the code string */
                                 *segment,                       /* Start of segment to append while walking */
                                  walk_last;                     /* Last walked character */
         int                      match_len;                     /* Length of the match */
         int                      esc_match_len;         /* Length of the quote-escaped match */
         int                      result_len;            /* Length of the result of the evaluation */
         int                      backref;                       /* Current backref */
         char        *compiled_string_description;
         smart_str    code = {0};
         
         eval_str_end = eval_str + eval_str_len;
         walk = segment = eval_str;
         walk_last = 0;
         
         while (walk < eval_str_end) {
                 /* If found a backreference.. */
                 if ('\\' == *walk || '$' == *walk) {
                         smart_str_appendl(&code, segment, walk - segment);
                         if (walk_last == '\\') {
                                 code.c[code.len-1] = *walk++;
                                 segment = walk;
                                 walk_last = 0;
                                 continue;
                         }
                         segment = walk;
                         if (preg_get_backref(&walk, &backref)) {
                                 if (backref < count) {
                                         /* Find the corresponding string match and substitute it
                                            in instead of the backref */
                                         match = subject + offsets[backref<<1];
                                         match_len = offsets[(backref<<1)+1] - offsets[backref<<1];
                                         if (match_len) {
                                                 esc_match = php_addslashes(match, match_len, &esc_match_len, 0 TSRMLS_CC);
                                         } else {
                                                 esc_match = match;
                                                 esc_match_len = 0;
                                         }
                                 } else {
                                         esc_match = """";
                                         esc_match_len = 0;
                                 }
                                 smart_str_appendl(&code, esc_match, esc_match_len);
 
                                 segment = walk;
 
                                 /* Clean up and reassign */
                                 if (esc_match_len)
                                         efree(esc_match);
                                 continue;
                         }
                 }
                 walk++;
                 walk_last = walk[-1];
         }
         smart_str_appendl(&code, segment, walk - segment);
         smart_str_0(&code);
 
         compiled_string_description = zend_make_compiled_string_description(""regexp code"" TSRMLS_CC);
         /* Run the code */
         if (zend_eval_stringl(code.c, code.len, &retval, compiled_string_description TSRMLS_CC) == FAILURE) {
                 efree(compiled_string_description);
                 php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, code.c);
                 /* zend_error() does not return in this case */
         }
         efree(compiled_string_description);
         convert_to_string(&retval);
         
         /* Save the return value and its length */
         *result = estrndup(Z_STRVAL(retval), Z_STRLEN(retval));
         result_len = Z_STRLEN(retval);
         
         /* Clean up */
         zval_dtor(&retval);
         smart_str_free(&code);
         
         return result_len;
 }
 /* }}} */
 
 /* {{{ php_pcre_replace
  */
 PHPAPI char *php_pcre_replace(char *regex,   int regex_len,
                                                           char *subject, int subject_len,
                                                           zval *replace_val, int is_callable_replace,
                                                           int *result_len, int limit, int *replace_count TSRMLS_DC)
 {
         pcre_cache_entry        *pce;                       /* Compiled regular expression */
 
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 return NULL;
         }
 
         return php_pcre_replace_impl(pce, subject, subject_len, replace_val, 
                 is_callable_replace, result_len, limit, replace_count TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ php_pcre_replace_impl() */
 PHPAPI char *php_pcre_replace_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *replace_val, 
         int is_callable_replace, int *result_len, int limit, int *replace_count TSRMLS_DC)
 {
         pcre_extra              *extra = pce->extra;/* Holds results of studying */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                              exoptions = 0;         /* Execution options */
         int                              count = 0;                     /* Count of matched subpatterns */
         int                             *offsets;                       /* Array of subpattern offsets */
         char                    **subpat_names;         /* Array for named subpatterns */
         int                              num_subpats;           /* Number of captured subpatterns */
         int                              size_offsets;          /* Size of the offsets array */
         int                              new_len;                       /* Length of needed storage */
         int                              alloc_len;                     /* Actual allocated length */
         int                              eval_result_len=0;     /* Length of the eval'ed or
                                                                                    function-returned string */
         int                              match_len;                     /* Length of the current match */
         int                              backref;                       /* Backreference number */
         int                              eval;                          /* If the replacement string should be eval'ed */
         int                              start_offset;          /* Where the new search starts */
         int                              g_notempty=0;          /* If the match should not be empty */
         int                              replace_len=0;         /* Length of replacement string */
         char                    *result,                        /* Result of replacement */
                                         *replace=NULL,          /* Replacement string */
                                         *new_buf,                       /* Temporary buffer for re-allocation */
                                         *walkbuf,                       /* Location of current replacement in the result */
                                         *walk,                          /* Used to walk the replacement string */
                                         *match,                         /* The current match */
                                         *piece,                         /* The current piece of subject */
                                         *replace_end=NULL,      /* End of replacement string */
                                         *eval_result,           /* Result of eval or custom function */
                                          walk_last;                     /* Last walked character */
         int                              rc;
 
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
 
         eval = pce->preg_options & PREG_REPLACE_EVAL;
         if (is_callable_replace) {
                 if (eval) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Modifier /e cannot be used with replacement callback"");
                         return NULL;
                 }
         } else {
                 replace = Z_STRVAL_P(replace_val);
                 replace_len = Z_STRLEN_P(replace_val);
                 replace_end = replace + replace_len;
         }
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &num_subpats);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 return NULL;
         }
         num_subpats++;
         size_offsets = num_subpats * 3;
 
         /*
          * Build a mapping from subpattern numbers to their names. We will always
          * allocate the table, even though there may be no named subpatterns. This
          * avoids somewhat more complicated logic in the inner loops.
          */
         subpat_names = make_subpats_table(num_subpats, pce TSRMLS_CC);
         if (!subpat_names) {
                 return NULL;
         }
 
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         
         alloc_len = 2 * subject_len + 1;
         result = safe_emalloc(alloc_len, sizeof(char), 0);
 
         /* Initialize */
         match = NULL;
         *result_len = 0;
         start_offset = 0;
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
         
         while (1) {
                 /* Execute the regular expression. */
                 count = pcre_exec(pce->re, extra, subject, subject_len, start_offset,
                                                   exoptions|g_notempty, offsets, size_offsets);
 
                 /* the string was already proved to be valid UTF-8 */
                 exoptions |= PCRE_NO_UTF8_CHECK;
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC,E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 }
 
                 piece = subject + start_offset;
 
                 if (count > 0 && (limit == -1 || limit > 0)) {
                         if (replace_count) {
                                 ++*replace_count;
                         }
                         /* Set the match location in subject */
                         match = subject + offsets[0];
 
                         new_len = *result_len + offsets[0] - start_offset; /* part before the match */
                         
                         /* If evaluating, do it and add the return string's length */
                         if (eval) {
                                 eval_result_len = preg_do_eval(replace, replace_len, subject,
                                                                                            offsets, count, &eval_result TSRMLS_CC);
                                 new_len += eval_result_len;
                         } else if (is_callable_replace) {
                                 /* Use custom function to get replacement string and its length. */
                                 eval_result_len = preg_do_repl_func(replace_val, subject, offsets, subpat_names, count, &eval_result TSRMLS_CC);
                                 new_len += eval_result_len;
                         } else { /* do regular substitution */
                                 walk = replace;
                                 walk_last = 0;
                                 while (walk < replace_end) {
                                         if ('\\' == *walk || '$' == *walk) {
                                                 if (walk_last == '\\') {
                                                         walk++;
                                                         walk_last = 0;
                                                         continue;
                                                 }
                                                 if (preg_get_backref(&walk, &backref)) {
                                                         if (backref < count)
                                                                 new_len += offsets[(backref<<1)+1] - offsets[backref<<1];
                                                         continue;
                                                 }
                                         }
                                         new_len++;
                                         walk++;
                                         walk_last = walk[-1];
                                 }
                         }
 
                         if (new_len + 1 > alloc_len) {
                                 alloc_len = 1 + alloc_len + 2 * new_len;
                                 new_buf = emalloc(alloc_len);
                                 memcpy(new_buf, result, *result_len);
                                 efree(result);
                                 result = new_buf;
                         }
                         /* copy the part of the string before the match */
                         memcpy(&result[*result_len], piece, match-piece);
                         *result_len += match-piece;
 
                         /* copy replacement and backrefs */
                         walkbuf = result + *result_len;
                         
                         /* If evaluating or using custom function, copy result to the buffer
                          * and clean up. */
                         if (eval || is_callable_replace) {
                                 memcpy(walkbuf, eval_result, eval_result_len);
                                 *result_len += eval_result_len;
                                 STR_FREE(eval_result);
                         } else { /* do regular backreference copying */
                                 walk = replace;
                                 walk_last = 0;
                                 while (walk < replace_end) {
                                         if ('\\' == *walk || '$' == *walk) {
                                                 if (walk_last == '\\') {
                                                         *(walkbuf-1) = *walk++;
                                                         walk_last = 0;
                                                         continue;
                                                 }
                                                 if (preg_get_backref(&walk, &backref)) {
                                                         if (backref < count) {
                                                                 match_len = offsets[(backref<<1)+1] - offsets[backref<<1];
                                                                 memcpy(walkbuf, subject + offsets[backref<<1], match_len);
                                                                 walkbuf += match_len;
                                                         }
                                                         continue;
                                                 }
                                         }
                                         *walkbuf++ = *walk++;
                                         walk_last = walk[-1];
                                 }
                                 *walkbuf = '\0';
                                 /* increment the result length by how much we've added to the string */
                                 *result_len += walkbuf - (result + *result_len);
                         }
 
                         if (limit != -1)
                                 limit--;
 
                 } else if (count == PCRE_ERROR_NOMATCH || limit == 0) {
                         /* If we previously set PCRE_NOTEMPTY after a null match,
                            this is not necessarily the end. We need to advance
                            the start offset, and continue. Fudge the offset values
                            to achieve this, unless we're already at the end of the string. */
                         if (g_notempty != 0 && start_offset < subject_len) {
                                 offsets[0] = start_offset;
                                 offsets[1] = start_offset + 1;
                                 memcpy(&result[*result_len], piece, 1);
                                 (*result_len)++;
                         } else {
                                 new_len = *result_len + subject_len - start_offset;
                                 if (new_len + 1 > alloc_len) {
                                         alloc_len = new_len + 1; /* now we know exactly how long it is */
                                         new_buf = safe_emalloc(alloc_len, sizeof(char), 0);
                                         memcpy(new_buf, result, *result_len);
                                         efree(result);
                                         result = new_buf;
                                 }
                                 /* stick that last bit of string on our output */
                                 memcpy(&result[*result_len], piece, subject_len - start_offset);
                                 *result_len += subject_len - start_offset;
                                 result[*result_len] = '\0';
                                 break;
                         }
                 } else {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         efree(result);
                         result = NULL;
                         break;
                 }
                         
                 /* If we have matched an empty string, mimic what Perl's /g options does.
                    This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try
                    the match again at the same point. If this fails (picked up above) we
                    advance to the next character. */
                 g_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;
                 
                 /* Advance to the next piece. */
                 start_offset = offsets[1];
         }
 
         efree(offsets);
         efree(subpat_names);
 
         return result;
 }
 /* }}} */
 
 /* {{{ php_replace_in_subject
  */
 static char *php_replace_in_subject(zval *regex, zval *replace, zval **subject, int *result_len, int limit, int is_callable_replace, int *replace_count TSRMLS_DC)
 {
         zval            **regex_entry,
                                 **replace_entry = NULL,
                                  *replace_value,
                                   empty_replace;
         char            *subject_value,
                                 *result;
         int                      subject_len;
 
         /* Make sure we're dealing with strings. */     
         convert_to_string_ex(subject);
         /* FIXME: This might need to be changed to STR_EMPTY_ALLOC(). Check if this zval could be dtor()'ed somehow */
         ZVAL_STRINGL(&empty_replace, """", 0, 0);
         
         /* If regex is an array */
         if (Z_TYPE_P(regex) == IS_ARRAY) {
                 /* Duplicate subject string for repeated replacement */
                 subject_value = estrndup(Z_STRVAL_PP(subject), Z_STRLEN_PP(subject));
                 subject_len = Z_STRLEN_PP(subject);
                 *result_len = subject_len;
                 
                 zend_hash_internal_pointer_reset(Z_ARRVAL_P(regex));
 
                 replace_value = replace;
                 if (Z_TYPE_P(replace) == IS_ARRAY && !is_callable_replace)
                         zend_hash_internal_pointer_reset(Z_ARRVAL_P(replace));
 
                 /* For each entry in the regex array, get the entry */
                 while (zend_hash_get_current_data(Z_ARRVAL_P(regex), (void **)&regex_entry) == SUCCESS) {
                         /* Make sure we're dealing with strings. */     
                         convert_to_string_ex(regex_entry);
                 
                         /* If replace is an array and not a callable construct */
                         if (Z_TYPE_P(replace) == IS_ARRAY && !is_callable_replace) {
                                 /* Get current entry */
                                 if (zend_hash_get_current_data(Z_ARRVAL_P(replace), (void **)&replace_entry) == SUCCESS) {
                                         if (!is_callable_replace) {
                                                 convert_to_string_ex(replace_entry);
                                         }
                                         replace_value = *replace_entry;
                                         zend_hash_move_forward(Z_ARRVAL_P(replace));
                                 } else {
                                         /* We've run out of replacement strings, so use an empty one */
                                         replace_value = &empty_replace;
                                 }
                         }
                         
                         /* Do the actual replacement and put the result back into subject_value
                            for further replacements. */
                         if ((result = php_pcre_replace(Z_STRVAL_PP(regex_entry),
                                                                                    Z_STRLEN_PP(regex_entry),
                                                                                    subject_value,
                                                                                    subject_len,
                                                                                    replace_value,
                                                                                    is_callable_replace,
                                                                                    result_len,
                                                                                    limit,
                                                                                    replace_count TSRMLS_CC)) != NULL) {
                                 efree(subject_value);
                                 subject_value = result;
                                 subject_len = *result_len;
                         } else {
                                 efree(subject_value);
                                 return NULL;
                         }
 
                         zend_hash_move_forward(Z_ARRVAL_P(regex));
                 }
 
                 return subject_value;
         } else {
                 result = php_pcre_replace(Z_STRVAL_P(regex),
                                                                   Z_STRLEN_P(regex),
                                                                   Z_STRVAL_PP(subject),
                                                                   Z_STRLEN_PP(subject),
                                                                   replace,
                                                                   is_callable_replace,
                                                                   result_len,
                                                                   limit,
                                                                   replace_count TSRMLS_CC);
                 return result;
         }
 }
 /* }}} */
 
 /* {{{ preg_replace_impl
  */
 static void preg_replace_impl(INTERNAL_FUNCTION_PARAMETERS, int is_callable_replace, int is_filter)
 {
         zval               **regex,
                                    **replace,
                                    **subject,
                                    **subject_entry,
                                    **zcount = NULL;
         char                    *result;
         int                              result_len;
         int                              limit_val = -1;
         long                    limit = -1;
         char                    *string_key;
         ulong                    num_key;
         char                    *callback_name;
         int                              replace_count=0, old_replace_count;
         
         /* Get function parameters and do error-checking. */
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZZ|lZ"", &regex, &replace, &subject, &limit, &zcount) == FAILURE) {
                 return;
         }
         
         if (!is_callable_replace && Z_TYPE_PP(replace) == IS_ARRAY && Z_TYPE_PP(regex) != IS_ARRAY) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Parameter mismatch, pattern is a string while replacement is an array"");
                 RETURN_FALSE;
         }
 
         SEPARATE_ZVAL(replace);
         if (Z_TYPE_PP(replace) != IS_ARRAY && (Z_TYPE_PP(replace) != IS_OBJECT || !is_callable_replace)) {
                 convert_to_string_ex(replace);
         }
         if (is_callable_replace) {
                 if (!zend_is_callable(*replace, 0, &callback_name TSRMLS_CC)) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires argument 2, '%s', to be a valid callback"", callback_name);
                         efree(callback_name);
                         MAKE_COPY_ZVAL(subject, return_value);
                         return;
                 }
                 efree(callback_name);
         }
 
         SEPARATE_ZVAL(regex);
         SEPARATE_ZVAL(subject);
 
         if (ZEND_NUM_ARGS() > 3) {
                 limit_val = limit;
         }
                 
         if (Z_TYPE_PP(regex) != IS_ARRAY)
                 convert_to_string_ex(regex);
         
         /* if subject is an array */
         if (Z_TYPE_PP(subject) == IS_ARRAY) {
                 array_init(return_value);
                 zend_hash_internal_pointer_reset(Z_ARRVAL_PP(subject));
 
                 /* For each subject entry, convert it to string, then perform replacement
                    and add the result to the return_value array. */
                 while (zend_hash_get_current_data(Z_ARRVAL_PP(subject), (void **)&subject_entry) == SUCCESS) {
                         SEPARATE_ZVAL(subject_entry);
                         old_replace_count = replace_count;
                         if ((result = php_replace_in_subject(*regex, *replace, subject_entry, &result_len, limit_val, is_callable_replace, &replace_count TSRMLS_CC)) != NULL) {
                                 if (!is_filter || replace_count > old_replace_count) {
                                         /* Add to return array */
                                         switch(zend_hash_get_current_key(Z_ARRVAL_PP(subject), &string_key, &num_key, 0))
                                         {
                                         case HASH_KEY_IS_STRING:
                                                 add_assoc_stringl(return_value, string_key, result, result_len, 0);
                                                 break;
 
                                         case HASH_KEY_IS_LONG:
                                                 add_index_stringl(return_value, num_key, result, result_len, 0);
                                                 break;
                                         }
                                 } else {
                                         efree(result);
                                 }
                         }
                 
                         zend_hash_move_forward(Z_ARRVAL_PP(subject));
                 }
         } else {        /* if subject is not an array */
                 old_replace_count = replace_count;
                 if ((result = php_replace_in_subject(*regex, *replace, subject, &result_len, limit_val, is_callable_replace, &replace_count TSRMLS_CC)) != NULL) {
                         if (!is_filter || replace_count > old_replace_count) {
                                 RETVAL_STRINGL(result, result_len, 0);
                         } else {
                                 efree(result);
                         }
                 }
         }
         if (ZEND_NUM_ARGS() > 4) {
                 zval_dtor(*zcount);
                 ZVAL_LONG(*zcount, replace_count);
         }
         
 }
 /* }}} */
 
 /* {{{ proto mixed preg_replace(mixed regex, mixed replace, mixed subject [, int limit [, int &count]])
    Perform Perl-style regular expression replacement. */
 static PHP_FUNCTION(preg_replace)
 {
         preg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
 }
 /* }}} */
 
 /* {{{ proto mixed preg_replace_callback(mixed regex, mixed callback, mixed subject [, int limit [, int &count]])
    Perform Perl-style regular expression replacement using replacement callback. */
 static PHP_FUNCTION(preg_replace_callback)
 {
         preg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 0);
 }
 /* }}} */
 
 /* {{{ proto mixed preg_filter(mixed regex, mixed replace, mixed subject [, int limit [, int &count]])
    Perform Perl-style regular expression replacement and only return matches. */
 static PHP_FUNCTION(preg_filter)
 {
         preg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);
 }
 /* }}} */
 
 /* {{{ proto array preg_split(string pattern, string subject [, int limit [, int flags]]) 
    Split string into an array using a perl-style regular expression as a delimiter */
 static PHP_FUNCTION(preg_split)
 {
         char                            *regex;                 /* Regular expression */
         char                            *subject;               /* String to match against */
         int                                      regex_len;
         int                                      subject_len;
         long                             limit_val = -1;/* Integer value of limit */
         long                             flags = 0;             /* Match control flags */
         pcre_cache_entry        *pce;                   /* Compiled regular expression */
 
         /* Get function parameters and do error checking */     
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|ll"", &regex, &regex_len,
                                                           &subject, &subject_len, &limit_val, &flags) == FAILURE) {
                 RETURN_FALSE;
         }
         
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 RETURN_FALSE;
         }
 
         php_pcre_split_impl(pce, subject, subject_len, return_value, limit_val, flags TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ php_pcre_split
  */
 PHPAPI void php_pcre_split_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *return_value,
         long limit_val, long flags TSRMLS_DC)
 {
         pcre_extra              *extra = NULL;          /* Holds results of studying */
         pcre                    *re_bump = NULL;        /* Regex instance for empty matches */
         pcre_extra              *extra_bump = NULL;     /* Almost dummy */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                             *offsets;                       /* Array of subpattern offsets */
         int                              size_offsets;          /* Size of the offsets array */
         int                              exoptions = 0;         /* Execution options */
         int                              count = 0;                     /* Count of matched subpatterns */
         int                              start_offset;          /* Where the new search starts */
         int                              next_offset;           /* End of the last delimiter match + 1 */
         int                              g_notempty = 0;        /* If the match should not be empty */
         char                    *last_match;            /* Location of last match */
         int                              rc;
         int                              no_empty;                      /* If NO_EMPTY flag is set */
         int                              delim_capture;         /* If delimiters should be captured */
         int                              offset_capture;        /* If offsets should be captured */
 
         no_empty = flags & PREG_SPLIT_NO_EMPTY;
         delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE;
         offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE;
         
         if (limit_val == 0) {
                 limit_val = -1;
         }
 
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
         
         /* Initialize return value */
         array_init(return_value);
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &size_offsets);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 RETURN_FALSE;
         }
         size_offsets = (size_offsets + 1) * 3;
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         
         /* Start at the beginning of the string */
         start_offset = 0;
         next_offset = 0;
         last_match = subject;
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
         
         /* Get next piece if no limit or limit not yet reached and something matched*/
         while ((limit_val == -1 || limit_val > 1)) {
                 count = pcre_exec(pce->re, extra, subject,
                                                   subject_len, start_offset,
                                                   exoptions|g_notempty, offsets, size_offsets);
 
                 /* the string was already proved to be valid UTF-8 */
                 exoptions |= PCRE_NO_UTF8_CHECK;
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC,E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 }
                                 
                 /* If something matched */
                 if (count > 0) {
                         if (!no_empty || &subject[offsets[0]] != last_match) {
 
                                 if (offset_capture) {
                                         /* Add (match, offset) pair to the return value */
                                         add_offset_pair(return_value, last_match, &subject[offsets[0]]-last_match, next_offset, NULL);
                                 } else {
                                         /* Add the piece to the return value */
                                         add_next_index_stringl(return_value, last_match,
                                                                            &subject[offsets[0]]-last_match, 1);
                                 }
 
                                 /* One less left to do */
                                 if (limit_val != -1)
                                         limit_val--;
                         }
                         
                         last_match = &subject[offsets[1]];
                         next_offset = offsets[1];
 
                         if (delim_capture) {
                                 int i, match_len;
                                 for (i = 1; i < count; i++) {
                                         match_len = offsets[(i<<1)+1] - offsets[i<<1];
                                         /* If we have matched a delimiter */
                                         if (!no_empty || match_len > 0) {
                                                 if (offset_capture) {
                                                         add_offset_pair(return_value, &subject[offsets[i<<1]], match_len, offsets[i<<1], NULL);
                                                 } else {
                                                         add_next_index_stringl(return_value,
                                                                                                    &subject[offsets[i<<1]],
                                                                                                    match_len, 1);
                                                 }
                                         }
                                 }
                         }
                 } else if (count == PCRE_ERROR_NOMATCH) {
                         /* If we previously set PCRE_NOTEMPTY after a null match,
                            this is not necessarily the end. We need to advance
                            the start offset, and continue. Fudge the offset values
                            to achieve this, unless we're already at the end of the string. */
                         if (g_notempty != 0 && start_offset < subject_len) {
                                 if (pce->compile_options & PCRE_UTF8) {
                                         if (re_bump == NULL) {
                                                 int dummy;
 
                                                 if ((re_bump = pcre_get_compiled_regex(""/./us"", &extra_bump, &dummy TSRMLS_CC)) == NULL) {
                                                         RETURN_FALSE;
                                                 }
                                         }
                                         count = pcre_exec(re_bump, extra_bump, subject,
                                                           subject_len, start_offset,
                                                           exoptions, offsets, size_offsets);
                                         if (count < 1) {
                                                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error"");
                                                 RETURN_FALSE;
                                         }
                                 } else {
                                         offsets[0] = start_offset;
                                         offsets[1] = start_offset + 1;
                                 }
                         } else
                                 break;
                 } else {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         break;
                 }
 
                 /* If we have matched an empty string, mimic what Perl's /g options does.
                    This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try
                    the match again at the same point. If this fails (picked up above) we
                    advance to the next character. */
                 g_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;
                 
                 /* Advance to the position right after the last full match */
                 start_offset = offsets[1];
         }
 
 
         start_offset = last_match - subject; /* the offset might have been incremented, but without further successful matches */
 
         if (!no_empty || start_offset < subject_len)
         {
                 if (offset_capture) {
                         /* Add the last (match, offset) pair to the return value */
                         add_offset_pair(return_value, &subject[start_offset], subject_len - start_offset, start_offset, NULL);
                 } else {
                         /* Add the last piece to the return value */
                         add_next_index_stringl(return_value, last_match, subject + subject_len - last_match, 1);
                 }
         }
 
         
         /* Clean up */
         efree(offsets);
 }
 /* }}} */
 
 /* {{{ proto string preg_quote(string str [, string delim_char])
    Quote regular expression characters plus an optional character */
 static PHP_FUNCTION(preg_quote)
 {
         int              in_str_len;
         char    *in_str;                /* Input string argument */
         char    *in_str_end;    /* End of the input string */
         int              delim_len = 0;
         char    *delim = NULL;  /* Additional delimiter argument */
         char    *out_str,               /* Output string with quoted characters */
                         *p,                             /* Iterator for input string */
                         *q,                             /* Iterator for output string */
                          delim_char=0,  /* Delimiter character to be quoted */
                          c;                             /* Current character */
         zend_bool quote_delim = 0; /* Whether to quote additional delim char */
         
         /* Get the arguments and check for errors */
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"", &in_str, &in_str_len,
                                                           &delim, &delim_len) == FAILURE) {
                 return;
         }
         
         in_str_end = in_str + in_str_len;
 
         /* Nothing to do if we got an empty string */
         if (in_str == in_str_end) {
                 RETURN_EMPTY_STRING();
         }
 
         if (delim && *delim) {
                 delim_char = delim[0];
                 quote_delim = 1;
         }
         
         /* Allocate enough memory so that even if each character
            is quoted, we won't run out of room */
         out_str = safe_emalloc(4, in_str_len, 1);
         
         /* Go through the string and quote necessary characters */
         for(p = in_str, q = out_str; p != in_str_end; p++) {
                 c = *p;
                 switch(c) {
                         case '.':
                         case '\\':
                         case '+':
                         case '*':
                         case '?':
                         case '[':
                         case '^':
                         case ']':
                         case '$':
                         case '(':
                         case ')':
                         case '{':
                         case '}':
                         case '=':
                         case '!':
                         case '>':
                         case '<':
                         case '|':
                         case ':':
                         case '-':
                                 *q++ = '\\';
                                 *q++ = c;
                                 break;
 
                         case '\0':
                                 *q++ = '\\';
                                 *q++ = '0';
                                 *q++ = '0';
                                 *q++ = '0';
                                 break;
 
                         default:
                                 if (quote_delim && c == delim_char)
                                         *q++ = '\\';
                                 *q++ = c;
                                 break;
                 }
         }
         *q = '\0';
         
         /* Reallocate string and return it */
         RETVAL_STRINGL(erealloc(out_str, q - out_str + 1), q - out_str, 0);
 }
 /* }}} */
 
 /* {{{ proto array preg_grep(string regex, array input [, int flags])
    Searches array and returns entries which match regex */
 static PHP_FUNCTION(preg_grep)
 {
         char                            *regex;                 /* Regular expression */
         int                                      regex_len;
         zval                            *input;                 /* Input array */
         long                             flags = 0;             /* Match control flags */
         pcre_cache_entry        *pce;                   /* Compiled regular expression */
 
         /* Get arguments and do error checking */
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sa|l"", &regex, &regex_len,
                                                           &input, &flags) == FAILURE) {
                 return;
         }
         
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 RETURN_FALSE;
         }
         
         php_pcre_grep_impl(pce, input, return_value, flags TSRMLS_CC);
 }
 /* }}} */
 
 PHPAPI void  php_pcre_grep_impl(pcre_cache_entry *pce, zval *input, zval *return_value, long flags TSRMLS_DC) /* {{{ */
 {
         zval               **entry;                             /* An entry in the input array */
         pcre_extra              *extra = pce->extra;/* Holds results of studying */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                             *offsets;                       /* Array of subpattern offsets */
         int                              size_offsets;          /* Size of the offsets array */
         int                              count = 0;                     /* Count of matched subpatterns */
         char                    *string_key;
         ulong                    num_key;
         zend_bool                invert;                        /* Whether to return non-matching
                                                                                    entries */
         int                              rc;
         
         invert = flags & PREG_GREP_INVERT ? 1 : 0;
         
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &size_offsets);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 RETURN_FALSE;
         }
         size_offsets = (size_offsets + 1) * 3;
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         
         /* Initialize return array */
         array_init(return_value);
 
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
 
         /* Go through the input array */
         zend_hash_internal_pointer_reset(Z_ARRVAL_P(input));
         while (zend_hash_get_current_data(Z_ARRVAL_P(input), (void **)&entry) == SUCCESS) {
                 zval subject = **entry;
 
                 if (Z_TYPE_PP(entry) != IS_STRING) {
                         zval_copy_ctor(&subject);
                         convert_to_string(&subject);
                 }
 
                 /* Perform the match */
                 count = pcre_exec(pce->re, extra, Z_STRVAL(subject),
                                                   Z_STRLEN(subject), 0,
                                                   0, offsets, size_offsets);
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 } else if (count < 0 && count != PCRE_ERROR_NOMATCH) {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         break;
                 }
 
                 /* If the entry fits our requirements */
                 if ((count > 0 && !invert) || (count == PCRE_ERROR_NOMATCH && invert)) {
 
                         Z_ADDREF_PP(entry);
 
                         /* Add to return array */
                         switch (zend_hash_get_current_key(Z_ARRVAL_P(input), &string_key, &num_key, 0))
                         {
                                 case HASH_KEY_IS_STRING:
                                         zend_hash_update(Z_ARRVAL_P(return_value), string_key,
                                                                          strlen(string_key)+1, entry, sizeof(zval *), NULL);
                                         break;
 
                                 case HASH_KEY_IS_LONG:
                                         zend_hash_index_update(Z_ARRVAL_P(return_value), num_key, entry,
                                                                                    sizeof(zval *), NULL);
                                         break;
                         }
                 }
 
                 if (Z_TYPE_PP(entry) != IS_STRING) {
                         zval_dtor(&subject);
                 }
 
                 zend_hash_move_forward(Z_ARRVAL_P(input));
         }
         zend_hash_internal_pointer_reset(Z_ARRVAL_P(input));
         /* Clean up */
         efree(offsets);
 }
 /* }}} */
 
 /* {{{ proto int preg_last_error()
    Returns the error code of the last regexp execution. */
 static PHP_FUNCTION(preg_last_error)
 {
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, """") == FAILURE) {
                 return;
         }
 
         RETURN_LONG(PCRE_G(error_code));
 }
 /* }}} */
 
 /* {{{ module definition structures */
 
 /* {{{ arginfo */
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_match, 0, 0, 2)
     ZEND_ARG_INFO(0, pattern)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(1, subpatterns) /* array */
     ZEND_ARG_INFO(0, flags)
     ZEND_ARG_INFO(0, offset)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_match_all, 0, 0, 2)
     ZEND_ARG_INFO(0, pattern)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(1, subpatterns) /* array */
     ZEND_ARG_INFO(0, flags)
     ZEND_ARG_INFO(0, offset)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_replace, 0, 0, 3)
     ZEND_ARG_INFO(0, regex)
     ZEND_ARG_INFO(0, replace)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(0, limit)
     ZEND_ARG_INFO(1, count)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_replace_callback, 0, 0, 3)
     ZEND_ARG_INFO(0, regex)
     ZEND_ARG_INFO(0, callback)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(0, limit)
     ZEND_ARG_INFO(1, count)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_split, 0, 0, 2)
     ZEND_ARG_INFO(0, pattern)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(0, limit)
     ZEND_ARG_INFO(0, flags) 
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_quote, 0, 0, 1)
     ZEND_ARG_INFO(0, str)
     ZEND_ARG_INFO(0, delim_char)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_grep, 0, 0, 2)
     ZEND_ARG_INFO(0, regex)
     ZEND_ARG_INFO(0, input) /* array */
     ZEND_ARG_INFO(0, flags)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_preg_last_error, 0)
 ZEND_END_ARG_INFO()
 /* }}} */
 
 static const zend_function_entry pcre_functions[] = {
         PHP_FE(preg_match,                              arginfo_preg_match)
         PHP_FE(preg_match_all,                  arginfo_preg_match_all)
         PHP_FE(preg_replace,                    arginfo_preg_replace)
         PHP_FE(preg_replace_callback,   arginfo_preg_replace_callback)
         PHP_FE(preg_filter,                             arginfo_preg_replace)
         PHP_FE(preg_split,                              arginfo_preg_split)
         PHP_FE(preg_quote,                              arginfo_preg_quote)
         PHP_FE(preg_grep,                               arginfo_preg_grep)
         PHP_FE(preg_last_error,                 arginfo_preg_last_error)
         PHP_FE_END
 };
 
 zend_module_entry pcre_module_entry = {
         STANDARD_MODULE_HEADER,
    ""pcre"",
         pcre_functions,
         PHP_MINIT(pcre),
         PHP_MSHUTDOWN(pcre),
         NULL,
         NULL,
         PHP_MINFO(pcre),
         NO_VERSION_YET,
         PHP_MODULE_GLOBALS(pcre),
         PHP_GINIT(pcre),
         PHP_GSHUTDOWN(pcre),
         NULL,
         STANDARD_MODULE_PROPERTIES_EX
 };
 
 #ifdef COMPILE_DL_PCRE
 ZEND_GET_MODULE(pcre)
 #endif
 
 /* }}} */
 
 #endif /* HAVE_PCRE || HAVE_BUNDLED_PCRE */
 
 /*
  * Local variables:
  * tab-width: 4
  * c-basic-offset: 4
  * End:
  * vim600: sw=4 ts=4 fdm=marker
  * vim<600: sw=4 ts=4
  */
"," /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
    | Copyright (c) 1997-2014 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
    | available through the world-wide-web at the following url:           |
    | http://www.php.net/license/3_01.txt                                  |
    | If you did not receive a copy of the PHP license and are unable to   |
    | obtain it through the world-wide-web, please send a note to          |
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Author: Andrei Zmievski <andrei@php.net>                             |
    +----------------------------------------------------------------------+
  */
 
 /* $Id$ */
 
 #include ""php.h""
 #include ""php_ini.h""
 #include ""php_globals.h""
 #include ""php_pcre.h""
 #include ""ext/standard/info.h""
 #include ""ext/standard/php_smart_str.h""
 
 #if HAVE_PCRE || HAVE_BUNDLED_PCRE
 
 #include ""ext/standard/php_string.h""
 
 #define PREG_PATTERN_ORDER                      1
 #define PREG_SET_ORDER                          2
 #define PREG_OFFSET_CAPTURE                     (1<<8)
 
 #define PREG_SPLIT_NO_EMPTY                     (1<<0)
 #define PREG_SPLIT_DELIM_CAPTURE        (1<<1)
 #define PREG_SPLIT_OFFSET_CAPTURE       (1<<2)
 
 #define PREG_REPLACE_EVAL                       (1<<0)
 
 #define PREG_GREP_INVERT                        (1<<0)
 
 #define PCRE_CACHE_SIZE 4096
 
 enum {
         PHP_PCRE_NO_ERROR = 0,
         PHP_PCRE_INTERNAL_ERROR,
         PHP_PCRE_BACKTRACK_LIMIT_ERROR,
         PHP_PCRE_RECURSION_LIMIT_ERROR,
         PHP_PCRE_BAD_UTF8_ERROR,
         PHP_PCRE_BAD_UTF8_OFFSET_ERROR
 };
 
 
 ZEND_DECLARE_MODULE_GLOBALS(pcre)
 
 
 static void pcre_handle_exec_error(int pcre_code TSRMLS_DC) /* {{{ */
 {
         int preg_code = 0;
 
         switch (pcre_code) {
                 case PCRE_ERROR_MATCHLIMIT:
                         preg_code = PHP_PCRE_BACKTRACK_LIMIT_ERROR;
                         break;
 
                 case PCRE_ERROR_RECURSIONLIMIT:
                         preg_code = PHP_PCRE_RECURSION_LIMIT_ERROR;
                         break;
 
                 case PCRE_ERROR_BADUTF8:
                         preg_code = PHP_PCRE_BAD_UTF8_ERROR;
                         break;
 
                 case PCRE_ERROR_BADUTF8_OFFSET:
                         preg_code = PHP_PCRE_BAD_UTF8_OFFSET_ERROR;
                         break;
 
                 default:
                         preg_code = PHP_PCRE_INTERNAL_ERROR;
                         break;
         }
 
         PCRE_G(error_code) = preg_code;
 }
 /* }}} */
 
 static void php_free_pcre_cache(void *data) /* {{{ */
 {
         pcre_cache_entry *pce = (pcre_cache_entry *) data;
         if (!pce) return;
         pefree(pce->re, 1);
         if (pce->extra) pefree(pce->extra, 1);
 #if HAVE_SETLOCALE
         if ((void*)pce->tables) pefree((void*)pce->tables, 1);
         pefree(pce->locale, 1);
 #endif
 }
 /* }}} */
 
 static PHP_GINIT_FUNCTION(pcre) /* {{{ */
 {
         zend_hash_init(&pcre_globals->pcre_cache, 0, NULL, php_free_pcre_cache, 1);
         pcre_globals->backtrack_limit = 0;
         pcre_globals->recursion_limit = 0;
         pcre_globals->error_code      = PHP_PCRE_NO_ERROR;
 }
 /* }}} */
 
 static PHP_GSHUTDOWN_FUNCTION(pcre) /* {{{ */
 {
         zend_hash_destroy(&pcre_globals->pcre_cache);
 }
 /* }}} */
 
 PHP_INI_BEGIN()
         STD_PHP_INI_ENTRY(""pcre.backtrack_limit"", ""1000000"", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)
         STD_PHP_INI_ENTRY(""pcre.recursion_limit"", ""100000"", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)
 PHP_INI_END()
 
 
 /* {{{ PHP_MINFO_FUNCTION(pcre) */
 static PHP_MINFO_FUNCTION(pcre)
 {
         php_info_print_table_start();
         php_info_print_table_row(2, ""PCRE (Perl Compatible Regular Expressions) Support"", ""enabled"" );
         php_info_print_table_row(2, ""PCRE Library Version"", pcre_version() );
         php_info_print_table_end();
 
         DISPLAY_INI_ENTRIES();
 }
 /* }}} */
 
 /* {{{ PHP_MINIT_FUNCTION(pcre) */
 static PHP_MINIT_FUNCTION(pcre)
 {
         REGISTER_INI_ENTRIES();
         
         REGISTER_LONG_CONSTANT(""PREG_PATTERN_ORDER"", PREG_PATTERN_ORDER, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SET_ORDER"", PREG_SET_ORDER, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_OFFSET_CAPTURE"", PREG_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SPLIT_NO_EMPTY"", PREG_SPLIT_NO_EMPTY, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SPLIT_DELIM_CAPTURE"", PREG_SPLIT_DELIM_CAPTURE, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_SPLIT_OFFSET_CAPTURE"", PREG_SPLIT_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_GREP_INVERT"", PREG_GREP_INVERT, CONST_CS | CONST_PERSISTENT);
 
         REGISTER_LONG_CONSTANT(""PREG_NO_ERROR"", PHP_PCRE_NO_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_INTERNAL_ERROR"", PHP_PCRE_INTERNAL_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_BACKTRACK_LIMIT_ERROR"", PHP_PCRE_BACKTRACK_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_RECURSION_LIMIT_ERROR"", PHP_PCRE_RECURSION_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_BAD_UTF8_ERROR"", PHP_PCRE_BAD_UTF8_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_LONG_CONSTANT(""PREG_BAD_UTF8_OFFSET_ERROR"", PHP_PCRE_BAD_UTF8_OFFSET_ERROR, CONST_CS | CONST_PERSISTENT);
         REGISTER_STRING_CONSTANT(""PCRE_VERSION"", (char *)pcre_version(), CONST_CS | CONST_PERSISTENT);
 
         return SUCCESS;
 }
 /* }}} */
 
 /* {{{ PHP_MSHUTDOWN_FUNCTION(pcre) */
 static PHP_MSHUTDOWN_FUNCTION(pcre)
 {
         UNREGISTER_INI_ENTRIES();
 
         return SUCCESS;
 }
 /* }}} */
 
 /* {{{ static pcre_clean_cache */
 static int pcre_clean_cache(void *data, void *arg TSRMLS_DC)
 {
         int *num_clean = (int *)arg;
 
         if (*num_clean > 0) {
                 (*num_clean)--;
                 return 1;
         } else {
                 return 0;
         }
 }
 /* }}} */
 
 /* {{{ static make_subpats_table */
 static char **make_subpats_table(int num_subpats, pcre_cache_entry *pce TSRMLS_DC)
 {
         pcre_extra *extra = pce->extra;
         int name_cnt = 0, name_size, ni = 0;
         int rc;
         char *name_table;
         unsigned short name_idx;
         char **subpat_names = (char **)ecalloc(num_subpats, sizeof(char *));
 
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMECOUNT, &name_cnt);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 efree(subpat_names);
                 return NULL;
         }
         if (name_cnt > 0) {
                 int rc1, rc2;
 
                 rc1 = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMETABLE, &name_table);
                 rc2 = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMEENTRYSIZE, &name_size);
                 rc = rc2 ? rc2 : rc1;
                 if (rc < 0) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                         efree(subpat_names);
                         return NULL;
                 }
 
                 while (ni++ < name_cnt) {
                         name_idx = 0xff * (unsigned char)name_table[0] + (unsigned char)name_table[1];
                         subpat_names[name_idx] = name_table + 2;
                         if (is_numeric_string(subpat_names[name_idx], strlen(subpat_names[name_idx]), NULL, NULL, 0) > 0) {
                                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Numeric named subpatterns are not allowed"");
                                 efree(subpat_names);
                                 return NULL;
                         }
                         name_table += name_size;
                 }
         }
 
         return subpat_names;
 }
 /* }}} */
 
 /* {{{ pcre_get_compiled_regex_cache
  */
 PHPAPI pcre_cache_entry* pcre_get_compiled_regex_cache(char *regex, int regex_len TSRMLS_DC)
 {
         pcre                            *re = NULL;
         pcre_extra                      *extra;
         int                                      coptions = 0;
         int                                      soptions = 0;
         const char                      *error;
         int                                      erroffset;
         char                             delimiter;
         char                             start_delimiter;
         char                             end_delimiter;
         char                            *p, *pp;
         char                            *pattern;
         int                                      do_study = 0;
         int                                      poptions = 0;
         int                             count = 0;
         unsigned const char *tables = NULL;
 #if HAVE_SETLOCALE
         char                            *locale;
 #endif
         pcre_cache_entry        *pce;
         pcre_cache_entry         new_entry;
         char                *tmp = NULL;
 
 #if HAVE_SETLOCALE
 # if defined(PHP_WIN32) && defined(ZTS)
         _configthreadlocale(_ENABLE_PER_THREAD_LOCALE);
 # endif
         locale = setlocale(LC_CTYPE, NULL);
 #endif
 
         /* Try to lookup the cached regex entry, and if successful, just pass
            back the compiled pattern, otherwise go on and compile it. */
         if (zend_hash_find(&PCRE_G(pcre_cache), regex, regex_len+1, (void **)&pce) == SUCCESS) {
                 /*
                  * We use a quick pcre_fullinfo() check to see whether cache is corrupted, and if it
                  * is, we flush it and compile the pattern from scratch.
                  */
                 if (pcre_fullinfo(pce->re, NULL, PCRE_INFO_CAPTURECOUNT, &count) == PCRE_ERROR_BADMAGIC) {
                         zend_hash_clean(&PCRE_G(pcre_cache));
                 } else {
 #if HAVE_SETLOCALE
                         if (!strcmp(pce->locale, locale)) {
 #endif
                                 return pce;
 #if HAVE_SETLOCALE
                         }
 #endif
                 }
         }
         
         p = regex;
         
         /* Parse through the leading whitespace, and display a warning if we
            get to the end without encountering a delimiter. */
         while (isspace((int)*(unsigned char *)p)) p++;
         if (*p == 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, 
                                                  p < regex + regex_len ? ""Null byte in regex"" : ""Empty regular expression"");
                 return NULL;
         }
         
         /* Get the delimiter and display a warning if it is alphanumeric
            or a backslash. */
         delimiter = *p++;
         if (isalnum((int)*(unsigned char *)&delimiter) || delimiter == '\\') {
                 php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Delimiter must not be alphanumeric or backslash"");
                 return NULL;
         }
 
         start_delimiter = delimiter;
         if ((pp = strchr(""([{< )]}> )]}>"", delimiter)))
                 delimiter = pp[5];
         end_delimiter = delimiter;
 
         pp = p;
 
         if (start_delimiter == end_delimiter) {
                 /* We need to iterate through the pattern, searching for the ending delimiter,
                    but skipping the backslashed delimiters.  If the ending delimiter is not
                    found, display a warning. */
                 while (*pp != 0) {
                         if (*pp == '\\' && pp[1] != 0) pp++;
                         else if (*pp == delimiter)
                                 break;
                         pp++;
                 }
         } else {
                 /* We iterate through the pattern, searching for the matching ending
                  * delimiter. For each matching starting delimiter, we increment nesting
                  * level, and decrement it for each matching ending delimiter. If we
                  * reach the end of the pattern without matching, display a warning.
                  */
                 int brackets = 1;       /* brackets nesting level */
                 while (*pp != 0) {
                         if (*pp == '\\' && pp[1] != 0) pp++;
                         else if (*pp == end_delimiter && --brackets <= 0)
                                 break;
                         else if (*pp == start_delimiter)
                                 brackets++;
                         pp++;
                 }
         }
 
         if (*pp == 0) {
                 if (pp < regex + regex_len) {
                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Null byte in regex"");
                 } else if (start_delimiter == end_delimiter) {
                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""No ending delimiter '%c' found"", delimiter);
                 } else {
                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""No ending matching delimiter '%c' found"", delimiter);
                 }
                 return NULL;
         }
         
         /* Make a copy of the actual pattern. */
         pattern = estrndup(p, pp-p);
 
         /* Move on to the options */
         pp++;
 
         /* Parse through the options, setting appropriate flags.  Display
            a warning if we encounter an unknown modifier. */    
         while (pp < regex + regex_len) {
                 switch (*pp++) {
                         /* Perl compatible options */
                         case 'i':       coptions |= PCRE_CASELESS;              break;
                         case 'm':       coptions |= PCRE_MULTILINE;             break;
                         case 's':       coptions |= PCRE_DOTALL;                break;
                         case 'x':       coptions |= PCRE_EXTENDED;              break;
                         
                         /* PCRE specific options */
                         case 'A':       coptions |= PCRE_ANCHORED;              break;
                         case 'D':       coptions |= PCRE_DOLLAR_ENDONLY;break;
                         case 'S':       do_study  = 1;                                  break;
                         case 'U':       coptions |= PCRE_UNGREEDY;              break;
                         case 'X':       coptions |= PCRE_EXTRA;                 break;
                         case 'u':       coptions |= PCRE_UTF8;
         /* In  PCRE,  by  default, \d, \D, \s, \S, \w, and \W recognize only ASCII
        characters, even in UTF-8 mode. However, this can be changed by setting
        the PCRE_UCP option. */
 #ifdef PCRE_UCP
                                                 coptions |= PCRE_UCP;
 #endif                  
                                 break;
 
                         /* Custom preg options */
                         case 'e':       poptions |= PREG_REPLACE_EVAL;  break;
                         
                         case ' ':
                         case '\n':
                                 break;
 
                         default:
                                 if (pp[-1]) {
                                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Unknown modifier '%c'"", pp[-1]);
                                 } else {
                                         php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Null byte in regex"");
                                 }
                                 efree(pattern);
                                 return NULL;
                 }
         }
 
 #if HAVE_SETLOCALE
         if (strcmp(locale, ""C""))
                 tables = pcre_maketables();
 #endif
 
         /* Compile pattern and display a warning if compilation failed. */
         re = pcre_compile(pattern,
                                           coptions,
                                           &error,
                                           &erroffset,
                                           tables);
 
         if (re == NULL) {
                 php_error_docref(NULL TSRMLS_CC,E_WARNING, ""Compilation failed: %s at offset %d"", error, erroffset);
                 efree(pattern);
                 if (tables) {
                         pefree((void*)tables, 1);
                 }
                 return NULL;
         }
 
         /* If study option was specified, study the pattern and
            store the result in extra for passing to pcre_exec. */
         if (do_study) {
                 extra = pcre_study(re, soptions, &error);
                 if (extra) {
                         extra->flags |= PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 }
                 if (error != NULL) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while studying pattern"");
                 }
         } else {
                 extra = NULL;
         }
 
         efree(pattern);
 
         /*
          * If we reached cache limit, clean out the items from the head of the list;
          * these are supposedly the oldest ones (but not necessarily the least used
          * ones).
          */
         if (zend_hash_num_elements(&PCRE_G(pcre_cache)) == PCRE_CACHE_SIZE) {
                 int num_clean = PCRE_CACHE_SIZE / 8;
                 zend_hash_apply_with_argument(&PCRE_G(pcre_cache), pcre_clean_cache, &num_clean TSRMLS_CC);
         }
 
         /* Store the compiled pattern and extra info in the cache. */
         new_entry.re = re;
         new_entry.extra = extra;
         new_entry.preg_options = poptions;
         new_entry.compile_options = coptions;
 #if HAVE_SETLOCALE
         new_entry.locale = pestrdup(locale, 1);
         new_entry.tables = tables;
 #endif
 
         /*
          * Interned strings are not duplicated when stored in HashTable,
          * but all the interned strings created during HTTP request are removed
          * at end of request. However PCRE_G(pcre_cache) must be consistent
          * on the next request as well. So we disable usage of interned strings
          * as hash keys especually for this table.
          * See bug #63180 
          */
         if (IS_INTERNED(regex)) {
                 regex = tmp = estrndup(regex, regex_len);
         }
 
         zend_hash_update(&PCRE_G(pcre_cache), regex, regex_len+1, (void *)&new_entry,
                                                 sizeof(pcre_cache_entry), (void**)&pce);
 
         if (tmp) {
                 efree(tmp);
         }
 
         return pce;
 }
 /* }}} */
 
 /* {{{ pcre_get_compiled_regex
  */
 PHPAPI pcre* pcre_get_compiled_regex(char *regex, pcre_extra **extra, int *preg_options TSRMLS_DC)
 {
         pcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex, strlen(regex) TSRMLS_CC);
 
         if (extra) {
                 *extra = pce ? pce->extra : NULL;
         }
         if (preg_options) {
                 *preg_options = pce ? pce->preg_options : 0;
         }
         
         return pce ? pce->re : NULL;
 }
 /* }}} */
 
 /* {{{ pcre_get_compiled_regex_ex
  */
 PHPAPI pcre* pcre_get_compiled_regex_ex(char *regex, pcre_extra **extra, int *preg_options, int *compile_options TSRMLS_DC)
 {
         pcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex, strlen(regex) TSRMLS_CC);
         
         if (extra) {
                 *extra = pce ? pce->extra : NULL;
         }
         if (preg_options) {
                 *preg_options = pce ? pce->preg_options : 0;
         }
         if (compile_options) {
                 *compile_options = pce ? pce->compile_options : 0;
         }
         
         return pce ? pce->re : NULL;
 }
 /* }}} */
 
 /* {{{ add_offset_pair */
 static inline void add_offset_pair(zval *result, char *str, int len, int offset, char *name)
 {
         zval *match_pair;
 
         ALLOC_ZVAL(match_pair);
         array_init(match_pair);
         INIT_PZVAL(match_pair);
 
         /* Add (match, offset) to the return value */
         add_next_index_stringl(match_pair, str, len, 1);
         add_next_index_long(match_pair, offset);
         
         if (name) {
                 zval_add_ref(&match_pair);
                 zend_hash_update(Z_ARRVAL_P(result), name, strlen(name)+1, &match_pair, sizeof(zval *), NULL);
         }
         zend_hash_next_index_insert(Z_ARRVAL_P(result), &match_pair, sizeof(zval *), NULL);
 }
 /* }}} */
 
 static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
 {
         /* parameters */
         char                     *regex;                        /* Regular expression */
         char                     *subject;                      /* String to match against */
         int                               regex_len;
         int                               subject_len;
         pcre_cache_entry *pce;                          /* Compiled regular expression */
         zval                     *subpats = NULL;       /* Array for subpatterns */
         long                      flags = 0;            /* Match control flags */
         long                      start_offset = 0;     /* Where the new search starts */
 
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
                                                           &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
                 RETURN_FALSE;
         }
         
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 RETURN_FALSE;
         }
 
         php_pcre_match_impl(pce, subject, subject_len, return_value, subpats, 
                 global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ php_pcre_match_impl() */
 PHPAPI void php_pcre_match_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *return_value,
         zval *subpats, int global, int use_flags, long flags, long start_offset TSRMLS_DC)
 {
         zval                    *result_set,            /* Holds a set of subpatterns after
                                                                                    a global match */
                                    **match_sets = NULL; /* An array of sets of matches for each
                                                                                    subpattern after a global match */
         pcre_extra              *extra = pce->extra;/* Holds results of studying */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                              exoptions = 0;         /* Execution options */
         int                              count = 0;                     /* Count of matched subpatterns */
         int                             *offsets;                       /* Array of subpattern offsets */
         int                              num_subpats;           /* Number of captured subpatterns */
         int                              size_offsets;          /* Size of the offsets array */
         int                              matched;                       /* Has anything matched */
         int                              g_notempty = 0;        /* If the match should not be empty */
         const char         **stringlist;                /* Holds list of subpatterns */
         char               **subpat_names;              /* Array for named subpatterns */
         int                              i, rc;
         int                              subpats_order;         /* Order of subpattern matches */
         int                              offset_capture;    /* Capture match offsets: yes/no */
 
         /* Overwrite the passed-in value for subpatterns with an empty array. */
         if (subpats != NULL) {
                 zval_dtor(subpats);
                 array_init(subpats);
         }
 
         subpats_order = global ? PREG_PATTERN_ORDER : 0;
 
         if (use_flags) {
                 offset_capture = flags & PREG_OFFSET_CAPTURE;
 
                 /*
                  * subpats_order is pre-set to pattern mode so we change it only if
                  * necessary.
                  */
                 if (flags & 0xff) {
                         subpats_order = flags & 0xff;
                 }
                 if ((global && (subpats_order < PREG_PATTERN_ORDER || subpats_order > PREG_SET_ORDER)) ||
                         (!global && subpats_order != 0)) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid flags specified"");
                         return;
                 }
         } else {
                 offset_capture = 0;
         }
 
         /* Negative offset counts from the end of the string. */
         if (start_offset < 0) {
                 start_offset = subject_len + start_offset;
                 if (start_offset < 0) {
                         start_offset = 0;
                 }
         }
 
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &num_subpats);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 RETURN_FALSE;
         }
         num_subpats++;
         size_offsets = num_subpats * 3;
 
         /*
          * Build a mapping from subpattern numbers to their names. We will always
          * allocate the table, even though there may be no named subpatterns. This
          * avoids somewhat more complicated logic in the inner loops.
          */
         subpat_names = make_subpats_table(num_subpats, pce TSRMLS_CC);
         if (!subpat_names) {
                 RETURN_FALSE;
         }
 
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         memset(offsets, 0, size_offsets*sizeof(int));
         /* Allocate match sets array and initialize the values. */
         if (global && subpats && subpats_order == PREG_PATTERN_ORDER) {
                 match_sets = (zval **)safe_emalloc(num_subpats, sizeof(zval *), 0);
                 for (i=0; i<num_subpats; i++) {
                         ALLOC_ZVAL(match_sets[i]);
                         array_init(match_sets[i]);
                         INIT_PZVAL(match_sets[i]);
                 }
         }
 
         matched = 0;
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
         
         do {
                 /* Execute the regular expression. */
                 count = pcre_exec(pce->re, extra, subject, subject_len, start_offset,
                                                   exoptions|g_notempty, offsets, size_offsets);
 
                 /* the string was already proved to be valid UTF-8 */
                 exoptions |= PCRE_NO_UTF8_CHECK;
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 }
 
                 /* If something has matched */
                 if (count > 0) {
                         matched++;
 
                         /* If subpatterns array has been passed, fill it in with values. */
                         if (subpats != NULL) {
                                 /* Try to get the list of substrings and display a warning if failed. */
                                 if (pcre_get_substring_list(subject, offsets, count, &stringlist) < 0) {
                                         efree(subpat_names);
                                         efree(offsets);
                                         if (match_sets) efree(match_sets);
                                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Get subpatterns list failed"");
                                         RETURN_FALSE;
                                 }
 
                                 if (global) {   /* global pattern matching */
                                         if (subpats && subpats_order == PREG_PATTERN_ORDER) {
                                                 /* For each subpattern, insert it into the appropriate array. */
                                                 for (i = 0; i < count; i++) {
                                                         if (offset_capture) {
                                                                 add_offset_pair(match_sets[i], (char *)stringlist[i],
                                                                                                 offsets[(i<<1)+1] - offsets[i<<1], offsets[i<<1], NULL);
                                                         } else {
                                                                 add_next_index_stringl(match_sets[i], (char *)stringlist[i],
                                                                                                            offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                         }
                                                 }
                                                 /*
                                                  * If the number of captured subpatterns on this run is
                                                  * less than the total possible number, pad the result
                                                  * arrays with empty strings.
                                                  */
                                                 if (count < num_subpats) {
                                                         for (; i < num_subpats; i++) {
                                                                 add_next_index_string(match_sets[i], """", 1);
                                                         }
                                                 }
                                         } else {
                                                 /* Allocate the result set array */
                                                 ALLOC_ZVAL(result_set);
                                                 array_init(result_set);
                                                 INIT_PZVAL(result_set);
                                                 
                                                 /* Add all the subpatterns to it */
                                                 for (i = 0; i < count; i++) {
                                                         if (offset_capture) {
                                                                 add_offset_pair(result_set, (char *)stringlist[i],
                                                                                                 offsets[(i<<1)+1] - offsets[i<<1], offsets[i<<1], subpat_names[i]);
                                                         } else {
                                                                 if (subpat_names[i]) {
                                                                         add_assoc_stringl(result_set, subpat_names[i], (char *)stringlist[i],
                                                                                                                    offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                                 }
                                                                 add_next_index_stringl(result_set, (char *)stringlist[i],
                                                                                                            offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                         }
                                                 }
                                                 /* And add it to the output array */
                                                 zend_hash_next_index_insert(Z_ARRVAL_P(subpats), &result_set, sizeof(zval *), NULL);
                                         }
                                 } else {                        /* single pattern matching */
                                         /* For each subpattern, insert it into the subpatterns array. */
                                         for (i = 0; i < count; i++) {
                                                 if (offset_capture) {
                                                         add_offset_pair(subpats, (char *)stringlist[i],
                                                                                         offsets[(i<<1)+1] - offsets[i<<1],
                                                                                         offsets[i<<1], subpat_names[i]);
                                                 } else {
                                                         if (subpat_names[i]) {
                                                                 add_assoc_stringl(subpats, subpat_names[i], (char *)stringlist[i],
                                                                                                   offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                         }
                                                         add_next_index_stringl(subpats, (char *)stringlist[i],
                                                                                                    offsets[(i<<1)+1] - offsets[i<<1], 1);
                                                 }
                                         }
                                 }
 
                                 pcre_free((void *) stringlist);
                         }
                 } else if (count == PCRE_ERROR_NOMATCH) {
                         /* If we previously set PCRE_NOTEMPTY after a null match,
                            this is not necessarily the end. We need to advance
                            the start offset, and continue. Fudge the offset values
                            to achieve this, unless we're already at the end of the string. */
                         if (g_notempty != 0 && start_offset < subject_len) {
                                 offsets[0] = start_offset;
                                 offsets[1] = start_offset + 1;
                         } else
                                 break;
                 } else {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         break;
                 }
                 
                 /* If we have matched an empty string, mimic what Perl's /g options does.
                    This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try
                    the match again at the same point. If this fails (picked up above) we
                    advance to the next character. */
                 g_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;
                 
                 /* Advance to the position right after the last full match */
                 start_offset = offsets[1];
         } while (global);
 
         /* Add the match sets to the output array and clean up */
         if (global && subpats && subpats_order == PREG_PATTERN_ORDER) {
                 for (i = 0; i < num_subpats; i++) {
                         if (subpat_names[i]) {
                                 zend_hash_update(Z_ARRVAL_P(subpats), subpat_names[i],
                                                                  strlen(subpat_names[i])+1, &match_sets[i], sizeof(zval *), NULL);
                                 Z_ADDREF_P(match_sets[i]);
                         }
                         zend_hash_next_index_insert(Z_ARRVAL_P(subpats), &match_sets[i], sizeof(zval *), NULL);
                 }
                 efree(match_sets);
         }
         
         efree(offsets);
         efree(subpat_names);
 
         /* Did we encounter an error? */
         if (PCRE_G(error_code) == PHP_PCRE_NO_ERROR) {
                 RETVAL_LONG(matched);
         } else {
                 RETVAL_FALSE;
         }
 }
 /* }}} */
 
 /* {{{ proto int preg_match(string pattern, string subject [, array &subpatterns [, int flags [, int offset]]])
    Perform a Perl-style regular expression match */
 static PHP_FUNCTION(preg_match)
 {
         php_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
 }
 /* }}} */
 
 /* {{{ proto int preg_match_all(string pattern, string subject [, array &subpatterns [, int flags [, int offset]]])
    Perform a Perl-style global regular expression match */
 static PHP_FUNCTION(preg_match_all)
 {
         php_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
 }
 /* }}} */
 
 /* {{{ preg_get_backref
  */
 static int preg_get_backref(char **str, int *backref)
 {
         register char in_brace = 0;
         register char *walk = *str;
 
         if (walk[1] == 0)
                 return 0;
 
         if (*walk == '$' && walk[1] == '{') {
                 in_brace = 1;
                 walk++;
         }
         walk++;
 
         if (*walk >= '0' && *walk <= '9') {
                 *backref = *walk - '0';
                 walk++;
         } else
                 return 0;
         
         if (*walk && *walk >= '0' && *walk <= '9') {
                 *backref = *backref * 10 + *walk - '0';
                 walk++;
         }
 
         if (in_brace) {
                 if (*walk == 0 || *walk != '}')
                         return 0;
                 else
                         walk++;
         }
         
         *str = walk;
         return 1;       
 }
 /* }}} */
 
 /* {{{ preg_do_repl_func
  */
 static int preg_do_repl_func(zval *function, char *subject, int *offsets, char **subpat_names, int count, char **result TSRMLS_DC)
 {
         zval            *retval_ptr;            /* Function return value */
         zval       **args[1];                   /* Argument to pass to function */
         zval            *subpats;                       /* Captured subpatterns */ 
         int                      result_len;            /* Return value length */
         int                      i;
 
         MAKE_STD_ZVAL(subpats);
         array_init(subpats);
         for (i = 0; i < count; i++) {
                 if (subpat_names[i]) {
                         add_assoc_stringl(subpats, subpat_names[i], &subject[offsets[i<<1]] , offsets[(i<<1)+1] - offsets[i<<1], 1);
                 }
                 add_next_index_stringl(subpats, &subject[offsets[i<<1]], offsets[(i<<1)+1] - offsets[i<<1], 1);
         }
         args[0] = &subpats;
 
         if (call_user_function_ex(EG(function_table), NULL, function, &retval_ptr, 1, args, 0, NULL TSRMLS_CC) == SUCCESS && retval_ptr) {
                 convert_to_string_ex(&retval_ptr);
                 *result = estrndup(Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
                 result_len = Z_STRLEN_P(retval_ptr);
                 zval_ptr_dtor(&retval_ptr);
         } else {
                 if (!EG(exception)) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
                 }
                 result_len = offsets[1] - offsets[0];
                 *result = estrndup(&subject[offsets[0]], result_len);
         }
 
         zval_ptr_dtor(&subpats);
 
         return result_len;
 }
 /* }}} */
 
 /* {{{ preg_do_eval
  */
 static int preg_do_eval(char *eval_str, int eval_str_len, char *subject,
                                                 int *offsets, int count, char **result TSRMLS_DC)
 {
         zval             retval;                        /* Return value from evaluation */
         char            *eval_str_end,          /* End of eval string */
                                 *match,                         /* Current match for a backref */
                                 *esc_match,                     /* Quote-escaped match */
                                 *walk,                          /* Used to walk the code string */
                                 *segment,                       /* Start of segment to append while walking */
                                  walk_last;                     /* Last walked character */
         int                      match_len;                     /* Length of the match */
         int                      esc_match_len;         /* Length of the quote-escaped match */
         int                      result_len;            /* Length of the result of the evaluation */
         int                      backref;                       /* Current backref */
         char        *compiled_string_description;
         smart_str    code = {0};
         
         eval_str_end = eval_str + eval_str_len;
         walk = segment = eval_str;
         walk_last = 0;
         
         while (walk < eval_str_end) {
                 /* If found a backreference.. */
                 if ('\\' == *walk || '$' == *walk) {
                         smart_str_appendl(&code, segment, walk - segment);
                         if (walk_last == '\\') {
                                 code.c[code.len-1] = *walk++;
                                 segment = walk;
                                 walk_last = 0;
                                 continue;
                         }
                         segment = walk;
                         if (preg_get_backref(&walk, &backref)) {
                                 if (backref < count) {
                                         /* Find the corresponding string match and substitute it
                                            in instead of the backref */
                                         match = subject + offsets[backref<<1];
                                         match_len = offsets[(backref<<1)+1] - offsets[backref<<1];
                                         if (match_len) {
                                                 esc_match = php_addslashes(match, match_len, &esc_match_len, 0 TSRMLS_CC);
                                         } else {
                                                 esc_match = match;
                                                 esc_match_len = 0;
                                         }
                                 } else {
                                         esc_match = """";
                                         esc_match_len = 0;
                                 }
                                 smart_str_appendl(&code, esc_match, esc_match_len);
 
                                 segment = walk;
 
                                 /* Clean up and reassign */
                                 if (esc_match_len)
                                         efree(esc_match);
                                 continue;
                         }
                 }
                 walk++;
                 walk_last = walk[-1];
         }
         smart_str_appendl(&code, segment, walk - segment);
         smart_str_0(&code);
 
         compiled_string_description = zend_make_compiled_string_description(""regexp code"" TSRMLS_CC);
         /* Run the code */
         if (zend_eval_stringl(code.c, code.len, &retval, compiled_string_description TSRMLS_CC) == FAILURE) {
                 efree(compiled_string_description);
                 php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, code.c);
                 /* zend_error() does not return in this case */
         }
         efree(compiled_string_description);
         convert_to_string(&retval);
         
         /* Save the return value and its length */
         *result = estrndup(Z_STRVAL(retval), Z_STRLEN(retval));
         result_len = Z_STRLEN(retval);
         
         /* Clean up */
         zval_dtor(&retval);
         smart_str_free(&code);
         
         return result_len;
 }
 /* }}} */
 
 /* {{{ php_pcre_replace
  */
 PHPAPI char *php_pcre_replace(char *regex,   int regex_len,
                                                           char *subject, int subject_len,
                                                           zval *replace_val, int is_callable_replace,
                                                           int *result_len, int limit, int *replace_count TSRMLS_DC)
 {
         pcre_cache_entry        *pce;                       /* Compiled regular expression */
 
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 return NULL;
         }
 
         return php_pcre_replace_impl(pce, subject, subject_len, replace_val, 
                 is_callable_replace, result_len, limit, replace_count TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ php_pcre_replace_impl() */
 PHPAPI char *php_pcre_replace_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *replace_val, 
         int is_callable_replace, int *result_len, int limit, int *replace_count TSRMLS_DC)
 {
         pcre_extra              *extra = pce->extra;/* Holds results of studying */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                              exoptions = 0;         /* Execution options */
         int                              count = 0;                     /* Count of matched subpatterns */
         int                             *offsets;                       /* Array of subpattern offsets */
         char                    **subpat_names;         /* Array for named subpatterns */
         int                              num_subpats;           /* Number of captured subpatterns */
         int                              size_offsets;          /* Size of the offsets array */
         int                              new_len;                       /* Length of needed storage */
         int                              alloc_len;                     /* Actual allocated length */
         int                              eval_result_len=0;     /* Length of the eval'ed or
                                                                                    function-returned string */
         int                              match_len;                     /* Length of the current match */
         int                              backref;                       /* Backreference number */
         int                              eval;                          /* If the replacement string should be eval'ed */
         int                              start_offset;          /* Where the new search starts */
         int                              g_notempty=0;          /* If the match should not be empty */
         int                              replace_len=0;         /* Length of replacement string */
         char                    *result,                        /* Result of replacement */
                                         *replace=NULL,          /* Replacement string */
                                         *new_buf,                       /* Temporary buffer for re-allocation */
                                         *walkbuf,                       /* Location of current replacement in the result */
                                         *walk,                          /* Used to walk the replacement string */
                                         *match,                         /* The current match */
                                         *piece,                         /* The current piece of subject */
                                         *replace_end=NULL,      /* End of replacement string */
                                         *eval_result,           /* Result of eval or custom function */
                                          walk_last;                     /* Last walked character */
         int                              rc;
 
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
 
         eval = pce->preg_options & PREG_REPLACE_EVAL;
         if (is_callable_replace) {
                 if (eval) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Modifier /e cannot be used with replacement callback"");
                         return NULL;
                 }
         } else {
                 replace = Z_STRVAL_P(replace_val);
                 replace_len = Z_STRLEN_P(replace_val);
                 replace_end = replace + replace_len;
         }
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &num_subpats);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 return NULL;
         }
         num_subpats++;
         size_offsets = num_subpats * 3;
 
         /*
          * Build a mapping from subpattern numbers to their names. We will always
          * allocate the table, even though there may be no named subpatterns. This
          * avoids somewhat more complicated logic in the inner loops.
          */
         subpat_names = make_subpats_table(num_subpats, pce TSRMLS_CC);
         if (!subpat_names) {
                 return NULL;
         }
 
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         
         alloc_len = 2 * subject_len + 1;
         result = safe_emalloc(alloc_len, sizeof(char), 0);
 
         /* Initialize */
         match = NULL;
         *result_len = 0;
         start_offset = 0;
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
         
         while (1) {
                 /* Execute the regular expression. */
                 count = pcre_exec(pce->re, extra, subject, subject_len, start_offset,
                                                   exoptions|g_notempty, offsets, size_offsets);
 
                 /* the string was already proved to be valid UTF-8 */
                 exoptions |= PCRE_NO_UTF8_CHECK;
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC,E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 }
 
                 piece = subject + start_offset;
 
                 if (count > 0 && (limit == -1 || limit > 0)) {
                         if (replace_count) {
                                 ++*replace_count;
                         }
                         /* Set the match location in subject */
                         match = subject + offsets[0];
 
                         new_len = *result_len + offsets[0] - start_offset; /* part before the match */
                         
                         /* If evaluating, do it and add the return string's length */
                         if (eval) {
                                 eval_result_len = preg_do_eval(replace, replace_len, subject,
                                                                                            offsets, count, &eval_result TSRMLS_CC);
                                 new_len += eval_result_len;
                         } else if (is_callable_replace) {
                                 /* Use custom function to get replacement string and its length. */
                                 eval_result_len = preg_do_repl_func(replace_val, subject, offsets, subpat_names, count, &eval_result TSRMLS_CC);
                                 new_len += eval_result_len;
                         } else { /* do regular substitution */
                                 walk = replace;
                                 walk_last = 0;
                                 while (walk < replace_end) {
                                         if ('\\' == *walk || '$' == *walk) {
                                                 if (walk_last == '\\') {
                                                         walk++;
                                                         walk_last = 0;
                                                         continue;
                                                 }
                                                 if (preg_get_backref(&walk, &backref)) {
                                                         if (backref < count)
                                                                 new_len += offsets[(backref<<1)+1] - offsets[backref<<1];
                                                         continue;
                                                 }
                                         }
                                         new_len++;
                                         walk++;
                                         walk_last = walk[-1];
                                 }
                         }
 
                         if (new_len + 1 > alloc_len) {
                                 alloc_len = 1 + alloc_len + 2 * new_len;
                                 new_buf = emalloc(alloc_len);
                                 memcpy(new_buf, result, *result_len);
                                 efree(result);
                                 result = new_buf;
                         }
                         /* copy the part of the string before the match */
                         memcpy(&result[*result_len], piece, match-piece);
                         *result_len += match-piece;
 
                         /* copy replacement and backrefs */
                         walkbuf = result + *result_len;
                         
                         /* If evaluating or using custom function, copy result to the buffer
                          * and clean up. */
                         if (eval || is_callable_replace) {
                                 memcpy(walkbuf, eval_result, eval_result_len);
                                 *result_len += eval_result_len;
                                 STR_FREE(eval_result);
                         } else { /* do regular backreference copying */
                                 walk = replace;
                                 walk_last = 0;
                                 while (walk < replace_end) {
                                         if ('\\' == *walk || '$' == *walk) {
                                                 if (walk_last == '\\') {
                                                         *(walkbuf-1) = *walk++;
                                                         walk_last = 0;
                                                         continue;
                                                 }
                                                 if (preg_get_backref(&walk, &backref)) {
                                                         if (backref < count) {
                                                                 match_len = offsets[(backref<<1)+1] - offsets[backref<<1];
                                                                 memcpy(walkbuf, subject + offsets[backref<<1], match_len);
                                                                 walkbuf += match_len;
                                                         }
                                                         continue;
                                                 }
                                         }
                                         *walkbuf++ = *walk++;
                                         walk_last = walk[-1];
                                 }
                                 *walkbuf = '\0';
                                 /* increment the result length by how much we've added to the string */
                                 *result_len += walkbuf - (result + *result_len);
                         }
 
                         if (limit != -1)
                                 limit--;
 
                 } else if (count == PCRE_ERROR_NOMATCH || limit == 0) {
                         /* If we previously set PCRE_NOTEMPTY after a null match,
                            this is not necessarily the end. We need to advance
                            the start offset, and continue. Fudge the offset values
                            to achieve this, unless we're already at the end of the string. */
                         if (g_notempty != 0 && start_offset < subject_len) {
                                 offsets[0] = start_offset;
                                 offsets[1] = start_offset + 1;
                                 memcpy(&result[*result_len], piece, 1);
                                 (*result_len)++;
                         } else {
                                 new_len = *result_len + subject_len - start_offset;
                                 if (new_len + 1 > alloc_len) {
                                         alloc_len = new_len + 1; /* now we know exactly how long it is */
                                         new_buf = safe_emalloc(alloc_len, sizeof(char), 0);
                                         memcpy(new_buf, result, *result_len);
                                         efree(result);
                                         result = new_buf;
                                 }
                                 /* stick that last bit of string on our output */
                                 memcpy(&result[*result_len], piece, subject_len - start_offset);
                                 *result_len += subject_len - start_offset;
                                 result[*result_len] = '\0';
                                 break;
                         }
                 } else {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         efree(result);
                         result = NULL;
                         break;
                 }
                         
                 /* If we have matched an empty string, mimic what Perl's /g options does.
                    This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try
                    the match again at the same point. If this fails (picked up above) we
                    advance to the next character. */
                 g_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;
                 
                 /* Advance to the next piece. */
                 start_offset = offsets[1];
         }
 
         efree(offsets);
         efree(subpat_names);
 
         return result;
 }
 /* }}} */
 
 /* {{{ php_replace_in_subject
  */
 static char *php_replace_in_subject(zval *regex, zval *replace, zval **subject, int *result_len, int limit, int is_callable_replace, int *replace_count TSRMLS_DC)
 {
         zval            **regex_entry,
                                 **replace_entry = NULL,
                                  *replace_value,
                                   empty_replace;
         char            *subject_value,
                                 *result;
         int                      subject_len;
 
         /* Make sure we're dealing with strings. */     
         convert_to_string_ex(subject);
         /* FIXME: This might need to be changed to STR_EMPTY_ALLOC(). Check if this zval could be dtor()'ed somehow */
         ZVAL_STRINGL(&empty_replace, """", 0, 0);
         
         /* If regex is an array */
         if (Z_TYPE_P(regex) == IS_ARRAY) {
                 /* Duplicate subject string for repeated replacement */
                 subject_value = estrndup(Z_STRVAL_PP(subject), Z_STRLEN_PP(subject));
                 subject_len = Z_STRLEN_PP(subject);
                 *result_len = subject_len;
                 
                 zend_hash_internal_pointer_reset(Z_ARRVAL_P(regex));
 
                 replace_value = replace;
                 if (Z_TYPE_P(replace) == IS_ARRAY && !is_callable_replace)
                         zend_hash_internal_pointer_reset(Z_ARRVAL_P(replace));
 
                 /* For each entry in the regex array, get the entry */
                 while (zend_hash_get_current_data(Z_ARRVAL_P(regex), (void **)&regex_entry) == SUCCESS) {
                         /* Make sure we're dealing with strings. */     
                         convert_to_string_ex(regex_entry);
                 
                         /* If replace is an array and not a callable construct */
                         if (Z_TYPE_P(replace) == IS_ARRAY && !is_callable_replace) {
                                 /* Get current entry */
                                 if (zend_hash_get_current_data(Z_ARRVAL_P(replace), (void **)&replace_entry) == SUCCESS) {
                                         if (!is_callable_replace) {
                                                 convert_to_string_ex(replace_entry);
                                         }
                                         replace_value = *replace_entry;
                                         zend_hash_move_forward(Z_ARRVAL_P(replace));
                                 } else {
                                         /* We've run out of replacement strings, so use an empty one */
                                         replace_value = &empty_replace;
                                 }
                         }
                         
                         /* Do the actual replacement and put the result back into subject_value
                            for further replacements. */
                         if ((result = php_pcre_replace(Z_STRVAL_PP(regex_entry),
                                                                                    Z_STRLEN_PP(regex_entry),
                                                                                    subject_value,
                                                                                    subject_len,
                                                                                    replace_value,
                                                                                    is_callable_replace,
                                                                                    result_len,
                                                                                    limit,
                                                                                    replace_count TSRMLS_CC)) != NULL) {
                                 efree(subject_value);
                                 subject_value = result;
                                 subject_len = *result_len;
                         } else {
                                 efree(subject_value);
                                 return NULL;
                         }
 
                         zend_hash_move_forward(Z_ARRVAL_P(regex));
                 }
 
                 return subject_value;
         } else {
                 result = php_pcre_replace(Z_STRVAL_P(regex),
                                                                   Z_STRLEN_P(regex),
                                                                   Z_STRVAL_PP(subject),
                                                                   Z_STRLEN_PP(subject),
                                                                   replace,
                                                                   is_callable_replace,
                                                                   result_len,
                                                                   limit,
                                                                   replace_count TSRMLS_CC);
                 return result;
         }
 }
 /* }}} */
 
 /* {{{ preg_replace_impl
  */
 static void preg_replace_impl(INTERNAL_FUNCTION_PARAMETERS, int is_callable_replace, int is_filter)
 {
         zval               **regex,
                                    **replace,
                                    **subject,
                                    **subject_entry,
                                    **zcount = NULL;
         char                    *result;
         int                              result_len;
         int                              limit_val = -1;
         long                    limit = -1;
         char                    *string_key;
         ulong                    num_key;
         char                    *callback_name;
         int                              replace_count=0, old_replace_count;
         
         /* Get function parameters and do error-checking. */
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZZ|lZ"", &regex, &replace, &subject, &limit, &zcount) == FAILURE) {
                 return;
         }
         
         if (!is_callable_replace && Z_TYPE_PP(replace) == IS_ARRAY && Z_TYPE_PP(regex) != IS_ARRAY) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Parameter mismatch, pattern is a string while replacement is an array"");
                 RETURN_FALSE;
         }
 
         SEPARATE_ZVAL(replace);
         if (Z_TYPE_PP(replace) != IS_ARRAY && (Z_TYPE_PP(replace) != IS_OBJECT || !is_callable_replace)) {
                 convert_to_string_ex(replace);
         }
         if (is_callable_replace) {
                 if (!zend_is_callable(*replace, 0, &callback_name TSRMLS_CC)) {
                         php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires argument 2, '%s', to be a valid callback"", callback_name);
                         efree(callback_name);
                         MAKE_COPY_ZVAL(subject, return_value);
                         return;
                 }
                 efree(callback_name);
         }
 
         SEPARATE_ZVAL(regex);
         SEPARATE_ZVAL(subject);
 
         if (ZEND_NUM_ARGS() > 3) {
                 limit_val = limit;
         }
                 
         if (Z_TYPE_PP(regex) != IS_ARRAY)
                 convert_to_string_ex(regex);
         
         /* if subject is an array */
         if (Z_TYPE_PP(subject) == IS_ARRAY) {
                 array_init(return_value);
                 zend_hash_internal_pointer_reset(Z_ARRVAL_PP(subject));
 
                 /* For each subject entry, convert it to string, then perform replacement
                    and add the result to the return_value array. */
                 while (zend_hash_get_current_data(Z_ARRVAL_PP(subject), (void **)&subject_entry) == SUCCESS) {
                         SEPARATE_ZVAL(subject_entry);
                         old_replace_count = replace_count;
                         if ((result = php_replace_in_subject(*regex, *replace, subject_entry, &result_len, limit_val, is_callable_replace, &replace_count TSRMLS_CC)) != NULL) {
                                 if (!is_filter || replace_count > old_replace_count) {
                                         /* Add to return array */
                                         switch(zend_hash_get_current_key(Z_ARRVAL_PP(subject), &string_key, &num_key, 0))
                                         {
                                         case HASH_KEY_IS_STRING:
                                                 add_assoc_stringl(return_value, string_key, result, result_len, 0);
                                                 break;
 
                                         case HASH_KEY_IS_LONG:
                                                 add_index_stringl(return_value, num_key, result, result_len, 0);
                                                 break;
                                         }
                                 } else {
                                         efree(result);
                                 }
                         }
                 
                         zend_hash_move_forward(Z_ARRVAL_PP(subject));
                 }
         } else {        /* if subject is not an array */
                 old_replace_count = replace_count;
                 if ((result = php_replace_in_subject(*regex, *replace, subject, &result_len, limit_val, is_callable_replace, &replace_count TSRMLS_CC)) != NULL) {
                         if (!is_filter || replace_count > old_replace_count) {
                                 RETVAL_STRINGL(result, result_len, 0);
                         } else {
                                 efree(result);
                         }
                 }
         }
         if (ZEND_NUM_ARGS() > 4) {
                 zval_dtor(*zcount);
                 ZVAL_LONG(*zcount, replace_count);
         }
         
 }
 /* }}} */
 
 /* {{{ proto mixed preg_replace(mixed regex, mixed replace, mixed subject [, int limit [, int &count]])
    Perform Perl-style regular expression replacement. */
 static PHP_FUNCTION(preg_replace)
 {
         preg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
 }
 /* }}} */
 
 /* {{{ proto mixed preg_replace_callback(mixed regex, mixed callback, mixed subject [, int limit [, int &count]])
    Perform Perl-style regular expression replacement using replacement callback. */
 static PHP_FUNCTION(preg_replace_callback)
 {
         preg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 0);
 }
 /* }}} */
 
 /* {{{ proto mixed preg_filter(mixed regex, mixed replace, mixed subject [, int limit [, int &count]])
    Perform Perl-style regular expression replacement and only return matches. */
 static PHP_FUNCTION(preg_filter)
 {
         preg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);
 }
 /* }}} */
 
 /* {{{ proto array preg_split(string pattern, string subject [, int limit [, int flags]]) 
    Split string into an array using a perl-style regular expression as a delimiter */
 static PHP_FUNCTION(preg_split)
 {
         char                            *regex;                 /* Regular expression */
         char                            *subject;               /* String to match against */
         int                                      regex_len;
         int                                      subject_len;
         long                             limit_val = -1;/* Integer value of limit */
         long                             flags = 0;             /* Match control flags */
         pcre_cache_entry        *pce;                   /* Compiled regular expression */
 
         /* Get function parameters and do error checking */     
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|ll"", &regex, &regex_len,
                                                           &subject, &subject_len, &limit_val, &flags) == FAILURE) {
                 RETURN_FALSE;
         }
         
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 RETURN_FALSE;
         }
 
         php_pcre_split_impl(pce, subject, subject_len, return_value, limit_val, flags TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ php_pcre_split
  */
 PHPAPI void php_pcre_split_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *return_value,
         long limit_val, long flags TSRMLS_DC)
 {
         pcre_extra              *extra = NULL;          /* Holds results of studying */
         pcre                    *re_bump = NULL;        /* Regex instance for empty matches */
         pcre_extra              *extra_bump = NULL;     /* Almost dummy */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                             *offsets;                       /* Array of subpattern offsets */
         int                              size_offsets;          /* Size of the offsets array */
         int                              exoptions = 0;         /* Execution options */
         int                              count = 0;                     /* Count of matched subpatterns */
         int                              start_offset;          /* Where the new search starts */
         int                              next_offset;           /* End of the last delimiter match + 1 */
         int                              g_notempty = 0;        /* If the match should not be empty */
         char                    *last_match;            /* Location of last match */
         int                              rc;
         int                              no_empty;                      /* If NO_EMPTY flag is set */
         int                              delim_capture;         /* If delimiters should be captured */
         int                              offset_capture;        /* If offsets should be captured */
 
         no_empty = flags & PREG_SPLIT_NO_EMPTY;
         delim_capture = flags & PREG_SPLIT_DELIM_CAPTURE;
         offset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE;
         
         if (limit_val == 0) {
                 limit_val = -1;
         }
 
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
         
         /* Initialize return value */
         array_init(return_value);
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &size_offsets);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 RETURN_FALSE;
         }
         size_offsets = (size_offsets + 1) * 3;
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         
         /* Start at the beginning of the string */
         start_offset = 0;
         next_offset = 0;
         last_match = subject;
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
         
         /* Get next piece if no limit or limit not yet reached and something matched*/
         while ((limit_val == -1 || limit_val > 1)) {
                 count = pcre_exec(pce->re, extra, subject,
                                                   subject_len, start_offset,
                                                   exoptions|g_notempty, offsets, size_offsets);
 
                 /* the string was already proved to be valid UTF-8 */
                 exoptions |= PCRE_NO_UTF8_CHECK;
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC,E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 }
                                 
                 /* If something matched */
                 if (count > 0) {
                         if (!no_empty || &subject[offsets[0]] != last_match) {
 
                                 if (offset_capture) {
                                         /* Add (match, offset) pair to the return value */
                                         add_offset_pair(return_value, last_match, &subject[offsets[0]]-last_match, next_offset, NULL);
                                 } else {
                                         /* Add the piece to the return value */
                                         add_next_index_stringl(return_value, last_match,
                                                                            &subject[offsets[0]]-last_match, 1);
                                 }
 
                                 /* One less left to do */
                                 if (limit_val != -1)
                                         limit_val--;
                         }
                         
                         last_match = &subject[offsets[1]];
                         next_offset = offsets[1];
 
                         if (delim_capture) {
                                 int i, match_len;
                                 for (i = 1; i < count; i++) {
                                         match_len = offsets[(i<<1)+1] - offsets[i<<1];
                                         /* If we have matched a delimiter */
                                         if (!no_empty || match_len > 0) {
                                                 if (offset_capture) {
                                                         add_offset_pair(return_value, &subject[offsets[i<<1]], match_len, offsets[i<<1], NULL);
                                                 } else {
                                                         add_next_index_stringl(return_value,
                                                                                                    &subject[offsets[i<<1]],
                                                                                                    match_len, 1);
                                                 }
                                         }
                                 }
                         }
                 } else if (count == PCRE_ERROR_NOMATCH) {
                         /* If we previously set PCRE_NOTEMPTY after a null match,
                            this is not necessarily the end. We need to advance
                            the start offset, and continue. Fudge the offset values
                            to achieve this, unless we're already at the end of the string. */
                         if (g_notempty != 0 && start_offset < subject_len) {
                                 if (pce->compile_options & PCRE_UTF8) {
                                         if (re_bump == NULL) {
                                                 int dummy;
 
                                                 if ((re_bump = pcre_get_compiled_regex(""/./us"", &extra_bump, &dummy TSRMLS_CC)) == NULL) {
                                                         RETURN_FALSE;
                                                 }
                                         }
                                         count = pcre_exec(re_bump, extra_bump, subject,
                                                           subject_len, start_offset,
                                                           exoptions, offsets, size_offsets);
                                         if (count < 1) {
                                                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error"");
                                                 RETURN_FALSE;
                                         }
                                 } else {
                                         offsets[0] = start_offset;
                                         offsets[1] = start_offset + 1;
                                 }
                         } else
                                 break;
                 } else {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         break;
                 }
 
                 /* If we have matched an empty string, mimic what Perl's /g options does.
                    This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try
                    the match again at the same point. If this fails (picked up above) we
                    advance to the next character. */
                 g_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;
                 
                 /* Advance to the position right after the last full match */
                 start_offset = offsets[1];
         }
 
 
         start_offset = last_match - subject; /* the offset might have been incremented, but without further successful matches */
 
         if (!no_empty || start_offset < subject_len)
         {
                 if (offset_capture) {
                         /* Add the last (match, offset) pair to the return value */
                         add_offset_pair(return_value, &subject[start_offset], subject_len - start_offset, start_offset, NULL);
                 } else {
                         /* Add the last piece to the return value */
                         add_next_index_stringl(return_value, last_match, subject + subject_len - last_match, 1);
                 }
         }
 
         
         /* Clean up */
         efree(offsets);
 }
 /* }}} */
 
 /* {{{ proto string preg_quote(string str [, string delim_char])
    Quote regular expression characters plus an optional character */
 static PHP_FUNCTION(preg_quote)
 {
         int              in_str_len;
         char    *in_str;                /* Input string argument */
         char    *in_str_end;    /* End of the input string */
         int              delim_len = 0;
         char    *delim = NULL;  /* Additional delimiter argument */
         char    *out_str,               /* Output string with quoted characters */
                         *p,                             /* Iterator for input string */
                         *q,                             /* Iterator for output string */
                          delim_char=0,  /* Delimiter character to be quoted */
                          c;                             /* Current character */
         zend_bool quote_delim = 0; /* Whether to quote additional delim char */
         
         /* Get the arguments and check for errors */
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"", &in_str, &in_str_len,
                                                           &delim, &delim_len) == FAILURE) {
                 return;
         }
         
         in_str_end = in_str + in_str_len;
 
         /* Nothing to do if we got an empty string */
         if (in_str == in_str_end) {
                 RETURN_EMPTY_STRING();
         }
 
         if (delim && *delim) {
                 delim_char = delim[0];
                 quote_delim = 1;
         }
         
         /* Allocate enough memory so that even if each character
            is quoted, we won't run out of room */
         out_str = safe_emalloc(4, in_str_len, 1);
         
         /* Go through the string and quote necessary characters */
         for(p = in_str, q = out_str; p != in_str_end; p++) {
                 c = *p;
                 switch(c) {
                         case '.':
                         case '\\':
                         case '+':
                         case '*':
                         case '?':
                         case '[':
                         case '^':
                         case ']':
                         case '$':
                         case '(':
                         case ')':
                         case '{':
                         case '}':
                         case '=':
                         case '!':
                         case '>':
                         case '<':
                         case '|':
                         case ':':
                         case '-':
                                 *q++ = '\\';
                                 *q++ = c;
                                 break;
 
                         case '\0':
                                 *q++ = '\\';
                                 *q++ = '0';
                                 *q++ = '0';
                                 *q++ = '0';
                                 break;
 
                         default:
                                 if (quote_delim && c == delim_char)
                                         *q++ = '\\';
                                 *q++ = c;
                                 break;
                 }
         }
         *q = '\0';
         
         /* Reallocate string and return it */
         RETVAL_STRINGL(erealloc(out_str, q - out_str + 1), q - out_str, 0);
 }
 /* }}} */
 
 /* {{{ proto array preg_grep(string regex, array input [, int flags])
    Searches array and returns entries which match regex */
 static PHP_FUNCTION(preg_grep)
 {
         char                            *regex;                 /* Regular expression */
         int                                      regex_len;
         zval                            *input;                 /* Input array */
         long                             flags = 0;             /* Match control flags */
         pcre_cache_entry        *pce;                   /* Compiled regular expression */
 
         /* Get arguments and do error checking */
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sa|l"", &regex, &regex_len,
                                                           &input, &flags) == FAILURE) {
                 return;
         }
         
         /* Compile regex or get it from cache. */
         if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
                 RETURN_FALSE;
         }
         
         php_pcre_grep_impl(pce, input, return_value, flags TSRMLS_CC);
 }
 /* }}} */
 
 PHPAPI void  php_pcre_grep_impl(pcre_cache_entry *pce, zval *input, zval *return_value, long flags TSRMLS_DC) /* {{{ */
 {
         zval               **entry;                             /* An entry in the input array */
         pcre_extra              *extra = pce->extra;/* Holds results of studying */
         pcre_extra               extra_data;            /* Used locally for exec options */
         int                             *offsets;                       /* Array of subpattern offsets */
         int                              size_offsets;          /* Size of the offsets array */
         int                              count = 0;                     /* Count of matched subpatterns */
         char                    *string_key;
         ulong                    num_key;
         zend_bool                invert;                        /* Whether to return non-matching
                                                                                    entries */
         int                              rc;
         
         invert = flags & PREG_GREP_INVERT ? 1 : 0;
         
         if (extra == NULL) {
                 extra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;
                 extra = &extra_data;
         }
         extra->match_limit = PCRE_G(backtrack_limit);
         extra->match_limit_recursion = PCRE_G(recursion_limit);
 
         /* Calculate the size of the offsets array, and allocate memory for it. */
         rc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &size_offsets);
         if (rc < 0) {
                 php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Internal pcre_fullinfo() error %d"", rc);
                 RETURN_FALSE;
         }
         size_offsets = (size_offsets + 1) * 3;
         offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);
         
         /* Initialize return array */
         array_init(return_value);
 
         PCRE_G(error_code) = PHP_PCRE_NO_ERROR;
 
         /* Go through the input array */
         zend_hash_internal_pointer_reset(Z_ARRVAL_P(input));
         while (zend_hash_get_current_data(Z_ARRVAL_P(input), (void **)&entry) == SUCCESS) {
                 zval subject = **entry;
 
                 if (Z_TYPE_PP(entry) != IS_STRING) {
                         zval_copy_ctor(&subject);
                         convert_to_string(&subject);
                 }
 
                 /* Perform the match */
                 count = pcre_exec(pce->re, extra, Z_STRVAL(subject),
                                                   Z_STRLEN(subject), 0,
                                                   0, offsets, size_offsets);
 
                 /* Check for too many substrings condition. */
                 if (count == 0) {
                         php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Matched, but too many substrings"");
                         count = size_offsets/3;
                 } else if (count < 0 && count != PCRE_ERROR_NOMATCH) {
                         pcre_handle_exec_error(count TSRMLS_CC);
                         break;
                 }
 
                 /* If the entry fits our requirements */
                 if ((count > 0 && !invert) || (count == PCRE_ERROR_NOMATCH && invert)) {
 
                         Z_ADDREF_PP(entry);
 
                         /* Add to return array */
                         switch (zend_hash_get_current_key(Z_ARRVAL_P(input), &string_key, &num_key, 0))
                         {
                                 case HASH_KEY_IS_STRING:
                                         zend_hash_update(Z_ARRVAL_P(return_value), string_key,
                                                                          strlen(string_key)+1, entry, sizeof(zval *), NULL);
                                         break;
 
                                 case HASH_KEY_IS_LONG:
                                         zend_hash_index_update(Z_ARRVAL_P(return_value), num_key, entry,
                                                                                    sizeof(zval *), NULL);
                                         break;
                         }
                 }
 
                 if (Z_TYPE_PP(entry) != IS_STRING) {
                         zval_dtor(&subject);
                 }
 
                 zend_hash_move_forward(Z_ARRVAL_P(input));
         }
         zend_hash_internal_pointer_reset(Z_ARRVAL_P(input));
         /* Clean up */
         efree(offsets);
 }
 /* }}} */
 
 /* {{{ proto int preg_last_error()
    Returns the error code of the last regexp execution. */
 static PHP_FUNCTION(preg_last_error)
 {
         if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, """") == FAILURE) {
                 return;
         }
 
         RETURN_LONG(PCRE_G(error_code));
 }
 /* }}} */
 
 /* {{{ module definition structures */
 
 /* {{{ arginfo */
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_match, 0, 0, 2)
     ZEND_ARG_INFO(0, pattern)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(1, subpatterns) /* array */
     ZEND_ARG_INFO(0, flags)
     ZEND_ARG_INFO(0, offset)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_match_all, 0, 0, 2)
     ZEND_ARG_INFO(0, pattern)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(1, subpatterns) /* array */
     ZEND_ARG_INFO(0, flags)
     ZEND_ARG_INFO(0, offset)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_replace, 0, 0, 3)
     ZEND_ARG_INFO(0, regex)
     ZEND_ARG_INFO(0, replace)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(0, limit)
     ZEND_ARG_INFO(1, count)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_replace_callback, 0, 0, 3)
     ZEND_ARG_INFO(0, regex)
     ZEND_ARG_INFO(0, callback)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(0, limit)
     ZEND_ARG_INFO(1, count)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_split, 0, 0, 2)
     ZEND_ARG_INFO(0, pattern)
     ZEND_ARG_INFO(0, subject)
     ZEND_ARG_INFO(0, limit)
     ZEND_ARG_INFO(0, flags) 
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_quote, 0, 0, 1)
     ZEND_ARG_INFO(0, str)
     ZEND_ARG_INFO(0, delim_char)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_preg_grep, 0, 0, 2)
     ZEND_ARG_INFO(0, regex)
     ZEND_ARG_INFO(0, input) /* array */
     ZEND_ARG_INFO(0, flags)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_preg_last_error, 0)
 ZEND_END_ARG_INFO()
 /* }}} */
 
 static const zend_function_entry pcre_functions[] = {
         PHP_FE(preg_match,                              arginfo_preg_match)
         PHP_FE(preg_match_all,                  arginfo_preg_match_all)
         PHP_FE(preg_replace,                    arginfo_preg_replace)
         PHP_FE(preg_replace_callback,   arginfo_preg_replace_callback)
         PHP_FE(preg_filter,                             arginfo_preg_replace)
         PHP_FE(preg_split,                              arginfo_preg_split)
         PHP_FE(preg_quote,                              arginfo_preg_quote)
         PHP_FE(preg_grep,                               arginfo_preg_grep)
         PHP_FE(preg_last_error,                 arginfo_preg_last_error)
         PHP_FE_END
 };
 
 zend_module_entry pcre_module_entry = {
         STANDARD_MODULE_HEADER,
    ""pcre"",
         pcre_functions,
         PHP_MINIT(pcre),
         PHP_MSHUTDOWN(pcre),
         NULL,
         NULL,
         PHP_MINFO(pcre),
         NO_VERSION_YET,
         PHP_MODULE_GLOBALS(pcre),
         PHP_GINIT(pcre),
         PHP_GSHUTDOWN(pcre),
         NULL,
         STANDARD_MODULE_PROPERTIES_EX
 };
 
 #ifdef COMPILE_DL_PCRE
 ZEND_GET_MODULE(pcre)
 #endif
 
 /* }}} */
 
 #endif /* HAVE_PCRE || HAVE_BUNDLED_PCRE */
 
 /*
  * Local variables:
  * tab-width: 4
  * c-basic-offset: 4
  * End:
  * vim600: sw=4 ts=4 fdm=marker
  * vim<600: sw=4 ts=4
  */
"
CVE-2018-1000801,https://www.cvedetails.com/cve/CVE-2018-1000801/,CWE-22,,Dir. Trav.,2018-09-06,2018-11-10,4.3,None,Remote,Medium,Not required,None,Partial,None,"okular version 18.08 and earlier contains a Directory Traversal vulnerability in function ""unpackDocumentArchive(...)"" in ""core/document.cpp"" that can result in Arbitrary file creation on the user workstation. This attack appear to be exploitable via he victim must open a specially crafted Okular archive. This issue appears to have been corrected in version 18.08.1",CPP,kde,https://cgit.kde.org/okular.git/commit/?id=8ff7abc14d41906ad978b6bc67e69693863b9d47,8ff7abc14d41906ad978b6bc67e69693863b9d47,86858e6cb0259e3d720092c34f31cacc3da366ba,"@@ -4819,6 +4819,18 @@ ArchiveData *DocumentPrivate::unpackDocumentArchive( const QString &archivePath         return nullptr;      const KArchiveDirectory * mainDir = okularArchive.directory();++    // Check the archive doesn't have folders, we don't create them when saving the archive+    // and folders mean paths and paths mean path traversal issues+    for ( const QString &entry : mainDir->entries() )+    {+        if ( mainDir->entry( entry )->isDirectory() )+        {+            qWarning() << ""Warning: Found a directory inside"" << archivePath << "" - Okular does not create files like that so it is most probably forged."";+            return nullptr;+        }+    }+     const KArchiveEntry * mainEntry = mainDir->entry( QStringLiteral(""content.xml"") );     if ( !mainEntry || !mainEntry->isFile() )         return nullptr;",https://cgit.kde.org/okular.git/tree/core/document.cpp?id=86858e6cb0259e3d720092c34f31cacc3da366ba,https://cgit.kde.org/okular.git/tree/core/document.cpp?id=8ff7abc14d41906ad978b6bc67e69693863b9d47,"/***************************************************************************
 *   Copyright (C) 2004-2005 by Enrico Ros <eros.kde@email.it>             *
 *   Copyright (C) 2004-2008 by Albert Astals Cid <aacid@kde.org>          *
 *   Copyright (C) 2017, 2018 Klarälvdalens Datakonsult AB, a KDAB Group         *
 *                      company, info@kdab.com. Work sponsored by the      *
 *                      LiMux project of the city of Munich                *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 ***************************************************************************/

#include ""document.h""
#include ""document_p.h""
#include ""documentcommands_p.h""

#include <limits.h>
#include <memory>
#ifdef Q_OS_WIN
#define _WIN32_WINNT 0x0500
#include <windows.h>
#elif defined(Q_OS_FREEBSD)
#include <sys/types.h>
#include <sys/sysctl.h>
#include <vm/vm_param.h>
#endif

// qt/kde/system includes
#include <QtCore/QtAlgorithms>
#include <QtCore/QDir>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>
#include <QtCore/QMap>
#include <QtCore/qtemporaryfile.h>
#include <QtCore/QTextStream>
#include <QtCore/QTimer>
#include <QtWidgets/QApplication>
#include <QtWidgets/QLabel>
#include <QtPrintSupport/QPrinter>
#include <QtPrintSupport/QPrintDialog>
#include <QStack>
#include <QUndoCommand>
#include <QMimeDatabase>
#include <QDesktopServices>
#include <QPageSize>
#include <QStandardPaths>

#include <kauthorized.h>
#include <kconfigdialog.h>
#include <kmacroexpander.h>
#include <kmessagebox.h>
#include <kmimetypetrader.h>
#include <kprocess.h>
#include <KRun>
#include <kshell.h>
#include <kzip.h>
#include <KIO/Global>
#include <KFormat>
#include <KLocalizedString>
#include <KPluginMetaData>
#include <Kdelibs4Migration>

// local includes
#include ""action.h""
#include ""annotations.h""
#include ""annotations_p.h""
#include ""audioplayer.h""
#include ""audioplayer_p.h""
#include ""bookmarkmanager.h""
#include ""chooseenginedialog_p.h""
#include ""debug_p.h""
#include ""generator_p.h""
#include ""interfaces/configinterface.h""
#include ""interfaces/guiinterface.h""
#include ""interfaces/printinterface.h""
#include ""interfaces/saveinterface.h""
#include ""observer.h""
#include ""misc.h""
#include ""page.h""
#include ""page_p.h""
#include ""pagecontroller_p.h""
#include ""scripter.h""
#include ""script/event_p.h""
#include ""settings_core.h""
#include ""sourcereference.h""
#include ""sourcereference_p.h""
#include ""texteditors_p.h""
#include ""tile.h""
#include ""tilesmanager_p.h""
#include ""utils_p.h""
#include ""view.h""
#include ""view_p.h""
#include ""form.h""
#include ""utils.h""

#include <memory>

#include <config-okular.h>

#if HAVE_MALLOC_TRIM
#include ""malloc.h""
#endif

using namespace Okular;

struct AllocatedPixmap
{
    // owner of the page
    DocumentObserver *observer;
    int page;
    qulonglong memory;
    // public constructor: initialize data
    AllocatedPixmap( DocumentObserver *o, int p, qulonglong m ) : observer( o ), page( p ), memory( m ) {}
};

struct ArchiveData
{
    ArchiveData()
    {
    }

    QString originalFileName;
    QTemporaryFile document;
    QTemporaryFile metadataFile;
};

struct RunningSearch
{
    // store search properties
    int continueOnPage;
    RegularAreaRect continueOnMatch;
    QSet< int > highlightedPages;

    // fields related to previous searches (used for 'continueSearch')
    QString cachedString;
    Document::SearchType cachedType;
    Qt::CaseSensitivity cachedCaseSensitivity;
    bool cachedViewportMove : 1;
    bool isCurrentlySearching : 1;
    QColor cachedColor;
    int pagesDone;
};

#define foreachObserver( cmd ) {\
    QSet< DocumentObserver * >::const_iterator it=d->m_observers.constBegin(), end=d->m_observers.constEnd();\
    for ( ; it != end ; ++ it ) { (*it)-> cmd ; } }

#define foreachObserverD( cmd ) {\
    QSet< DocumentObserver * >::const_iterator it = m_observers.constBegin(), end = m_observers.constEnd();\
    for ( ; it != end ; ++ it ) { (*it)-> cmd ; } }

#define OKULAR_HISTORY_MAXSTEPS 100
#define OKULAR_HISTORY_SAVEDSTEPS 10

/***** Document ******/

QString DocumentPrivate::pagesSizeString() const
{
    if (m_generator)
    {
        if (m_generator->pagesSizeMetric() != Generator::None)
        {
            QSizeF size = m_parent->allPagesSize();
            if (size.isValid()) return localizedSize(size);
            else return QString();
        }
        else return QString();
    }
    else return QString();
}

QString DocumentPrivate::namePaperSize(double inchesWidth, double inchesHeight) const
{
    const QPrinter::Orientation orientation = inchesWidth > inchesHeight ? QPrinter::Landscape : QPrinter::Portrait;

    const QSize pointsSize(inchesWidth *72.0, inchesHeight*72.0);
    const QPageSize::PageSizeId paperSize = QPageSize::id(pointsSize, QPageSize::FuzzyOrientationMatch);

    const QString paperName = QPageSize::name(paperSize);

    if (orientation == QPrinter::Portrait) {
        return i18nc(""paper type and orientation (eg: Portrait A4)"", ""Portrait %1"", paperName);
    } else {
        return i18nc(""paper type and orientation (eg: Portrait A4)"", ""Landscape %1"", paperName);
    }
}

QString DocumentPrivate::localizedSize(const QSizeF &size) const
{
    double inchesWidth = 0, inchesHeight = 0;
    switch (m_generator->pagesSizeMetric())
    {
        case Generator::Points:
            inchesWidth = size.width() / 72.0;
            inchesHeight = size.height() / 72.0;
        break;

        case Generator::Pixels:
        {
            const QSizeF dpi = m_generator->dpi();
            inchesWidth = size.width() / dpi.width();
            inchesHeight = size.height() / dpi.height();
        }
        break;

        case Generator::None:
        break;
    }
    if (QLocale::system().measurementSystem() == QLocale::ImperialSystem)
    {
        return i18nc(""%1 is width, %2 is height, %3 is paper size name"", ""%1 x %2 in (%3)"", inchesWidth, inchesHeight, namePaperSize(inchesWidth, inchesHeight));
    }
    else
    {
        return i18nc(""%1 is width, %2 is height, %3 is paper size name"", ""%1 x %2 mm (%3)"", QString::number(inchesWidth * 25.4, 'd', 0), QString::number(inchesHeight * 25.4, 'd', 0), namePaperSize(inchesWidth, inchesHeight));
    }
}

qulonglong DocumentPrivate::calculateMemoryToFree()
{
    // [MEM] choose memory parameters based on configuration profile
    qulonglong clipValue = 0;
    qulonglong memoryToFree = 0;

    switch ( SettingsCore::memoryLevel() )
    {
        case SettingsCore::EnumMemoryLevel::Low:
            memoryToFree = m_allocatedPixmapsTotalMemory;
            break;

        case SettingsCore::EnumMemoryLevel::Normal:
        {
            qulonglong thirdTotalMemory = getTotalMemory() / 3;
            qulonglong freeMemory = getFreeMemory();
            if (m_allocatedPixmapsTotalMemory > thirdTotalMemory) memoryToFree = m_allocatedPixmapsTotalMemory - thirdTotalMemory;
            if (m_allocatedPixmapsTotalMemory > freeMemory) clipValue = (m_allocatedPixmapsTotalMemory - freeMemory) / 2;
        }
        break;

        case SettingsCore::EnumMemoryLevel::Aggressive:
        {
            qulonglong freeMemory = getFreeMemory();
            if (m_allocatedPixmapsTotalMemory > freeMemory) clipValue = (m_allocatedPixmapsTotalMemory - freeMemory) / 2;
        }
        break;
        case SettingsCore::EnumMemoryLevel::Greedy:
        {
            qulonglong freeSwap;
            qulonglong freeMemory = getFreeMemory( &freeSwap );
            const qulonglong memoryLimit = qMin( qMax( freeMemory, getTotalMemory()/2 ), freeMemory+freeSwap );
            if (m_allocatedPixmapsTotalMemory > memoryLimit) clipValue = (m_allocatedPixmapsTotalMemory - memoryLimit) / 2;
        }
        break;
    }

    if ( clipValue > memoryToFree )
        memoryToFree = clipValue;

    return memoryToFree;
}

void DocumentPrivate::cleanupPixmapMemory()
{
    cleanupPixmapMemory( calculateMemoryToFree() );
}

void DocumentPrivate::cleanupPixmapMemory( qulonglong memoryToFree )
{
    if ( memoryToFree < 1 )
        return;

    const int currentViewportPage = (*m_viewportIterator).pageNumber;

    // Create a QMap of visible rects, indexed by page number
    QMap< int, VisiblePageRect * > visibleRects;
    QVector< Okular::VisiblePageRect * >::const_iterator vIt = m_pageRects.constBegin(), vEnd = m_pageRects.constEnd();
    for ( ; vIt != vEnd; ++vIt )
        visibleRects.insert( (*vIt)->pageNumber, (*vIt) );

    // Free memory starting from pages that are farthest from the current one
    int pagesFreed = 0;
    while ( memoryToFree > 0 )
    {
        AllocatedPixmap * p = searchLowestPriorityPixmap( true, true );
        if ( !p ) // No pixmap to remove
            break;

        qCDebug(OkularCoreDebug).nospace() << ""Evicting cache pixmap observer="" << p->observer << "" page="" << p->page;

        // m_allocatedPixmapsTotalMemory can't underflow because we always add or remove
        // the memory used by the AllocatedPixmap so at most it can reach zero
        m_allocatedPixmapsTotalMemory -= p->memory;
        // Make sure memoryToFree does not underflow
        if ( p->memory > memoryToFree )
            memoryToFree = 0;
        else
            memoryToFree -= p->memory;
        pagesFreed++;
        // delete pixmap
        m_pagesVector.at( p->page )->deletePixmap( p->observer );
        // delete allocation descriptor
        delete p;
    }

    // If we're still on low memory, try to free individual tiles

    // Store pages that weren't completely removed

    QLinkedList< AllocatedPixmap * > pixmapsToKeep;
    while (memoryToFree > 0)
    {
        int clean_hits = 0;
        foreach (DocumentObserver *observer, m_observers)
        {
            AllocatedPixmap * p = searchLowestPriorityPixmap( false, true, observer );
            if ( !p ) // No pixmap to remove
                continue;

            clean_hits++;

            TilesManager *tilesManager = m_pagesVector.at( p->page )->d->tilesManager( observer );
            if ( tilesManager && tilesManager->totalMemory() > 0 )
            {
                qulonglong memoryDiff = p->memory;
                NormalizedRect visibleRect;
                if ( visibleRects.contains( p->page ) )
                    visibleRect = visibleRects[ p->page ]->rect;

                // Free non visible tiles
                tilesManager->cleanupPixmapMemory( memoryToFree, visibleRect, currentViewportPage );

                p->memory = tilesManager->totalMemory();
                memoryDiff -= p->memory;
                memoryToFree = (memoryDiff < memoryToFree) ? (memoryToFree - memoryDiff) : 0;
                m_allocatedPixmapsTotalMemory -= memoryDiff;

                if ( p->memory > 0 )
                    pixmapsToKeep.append( p );
                else
                    delete p;
            }
            else
                pixmapsToKeep.append( p );
        }

        if (clean_hits == 0) break;
    }

    m_allocatedPixmaps += pixmapsToKeep;
    //p--rintf(""freeMemory A:[%d -%d = %d] \n"", m_allocatedPixmaps.count() + pagesFreed, pagesFreed, m_allocatedPixmaps.count() );
}

/* Returns the next pixmap to evict from cache, or NULL if no suitable pixmap
 * if found. If unloadableOnly is set, only unloadable pixmaps are returned. If
 * thenRemoveIt is set, the pixmap is removed from m_allocatedPixmaps before
 * returning it
 */
AllocatedPixmap * DocumentPrivate::searchLowestPriorityPixmap( bool unloadableOnly, bool thenRemoveIt, DocumentObserver *observer )
{
    QLinkedList< AllocatedPixmap * >::iterator pIt = m_allocatedPixmaps.begin();
    QLinkedList< AllocatedPixmap * >::iterator pEnd = m_allocatedPixmaps.end();
    QLinkedList< AllocatedPixmap * >::iterator farthestPixmap = pEnd;
    const int currentViewportPage = (*m_viewportIterator).pageNumber;

    /* Find the pixmap that is farthest from the current viewport */
    int maxDistance = -1;
    while ( pIt != pEnd )
    {
        const AllocatedPixmap * p = *pIt;
        // Filter by observer
        if ( observer == nullptr || p->observer == observer )
        {
            const int distance = qAbs( p->page - currentViewportPage );
            if ( maxDistance < distance && ( !unloadableOnly || p->observer->canUnloadPixmap( p->page ) ) )
            {
                maxDistance = distance;
                farthestPixmap = pIt;
            }
        }
        ++pIt;
    }

    /* No pixmap to remove */
    if ( farthestPixmap == pEnd )
        return nullptr;

    AllocatedPixmap * selectedPixmap = *farthestPixmap;
    if ( thenRemoveIt )
        m_allocatedPixmaps.erase( farthestPixmap );
    return selectedPixmap;
}

qulonglong DocumentPrivate::getTotalMemory()
{
    static qulonglong cachedValue = 0;
    if ( cachedValue )
        return cachedValue;

#if defined(Q_OS_LINUX)
    // if /proc/meminfo doesn't exist, return 128MB
    QFile memFile( QStringLiteral(""/proc/meminfo"") );
    if ( !memFile.open( QIODevice::ReadOnly ) )
        return (cachedValue = 134217728);

    QTextStream readStream( &memFile );
    while ( true )
    {
        QString entry = readStream.readLine();
        if ( entry.isNull() ) break;
        if ( entry.startsWith( QLatin1String(""MemTotal:"") ) )
            return (cachedValue = (Q_UINT64_C(1024) * entry.section( QLatin1Char ( ' ' ), -2, -2 ).toULongLong()));
    }
#elif defined(Q_OS_FREEBSD)
    qulonglong physmem;
    int mib[] = {CTL_HW, HW_PHYSMEM};
    size_t len = sizeof( physmem );
    if ( sysctl( mib, 2, &physmem, &len, NULL, 0 ) == 0 )
        return (cachedValue = physmem);
#elif defined(Q_OS_WIN)
    MEMORYSTATUSEX stat;
    stat.dwLength = sizeof(stat);
    GlobalMemoryStatusEx (&stat);

    return ( cachedValue = stat.ullTotalPhys );
#endif
    return (cachedValue = 134217728);
}

qulonglong DocumentPrivate::getFreeMemory( qulonglong *freeSwap )
{
    static QTime lastUpdate = QTime::currentTime().addSecs(-3);
    static qulonglong cachedValue = 0;
    static qulonglong cachedFreeSwap = 0;

    if ( qAbs( lastUpdate.secsTo( QTime::currentTime() ) ) <= 2 )
    {
        if (freeSwap)
            *freeSwap = cachedFreeSwap;
        return cachedValue;
    }

    /* Initialize the returned free swap value to 0. It is overwritten if the
     * actual value is available */
    if (freeSwap)
        *freeSwap = 0;

#if defined(Q_OS_LINUX)
    // if /proc/meminfo doesn't exist, return MEMORY FULL
    QFile memFile( QStringLiteral(""/proc/meminfo"") );
    if ( !memFile.open( QIODevice::ReadOnly ) )
        return 0;

    // read /proc/meminfo and sum up the contents of 'MemFree', 'Buffers'
    // and 'Cached' fields. consider swapped memory as used memory.
    qulonglong memoryFree = 0;
    QString entry;
    QTextStream readStream( &memFile );
    static const int nElems = 5;
    QString names[nElems] = { QStringLiteral(""MemFree:""), QStringLiteral(""Buffers:""), QStringLiteral(""Cached:""), QStringLiteral(""SwapFree:""), QStringLiteral(""SwapTotal:"") };
    qulonglong values[nElems] = { 0, 0, 0, 0, 0 };
    bool foundValues[nElems] = { false, false, false, false, false };
    while ( true )
    {
        entry = readStream.readLine();
        if ( entry.isNull() ) break;
        for ( int i = 0; i < nElems; ++i )
        {
            if ( entry.startsWith( names[i] ) )
            {
                values[i] = entry.section( QLatin1Char ( ' ' ), -2, -2 ).toULongLong( &foundValues[i] );
            }
        }
    }
    memFile.close();
    bool found = true;
    for ( int i = 0; found && i < nElems; ++i )
        found = found && foundValues[i];
    if ( found )
    {
        /* MemFree + Buffers + Cached - SwapUsed =
         * = MemFree + Buffers + Cached - (SwapTotal - SwapFree) =
         * = MemFree + Buffers + Cached + SwapFree - SwapTotal */
        memoryFree = values[0] + values[1] + values[2] + values[3];
        if ( values[4] > memoryFree )
            memoryFree = 0;
        else
            memoryFree -= values[4];
    }
    else
    {
        return 0;
    }

    lastUpdate = QTime::currentTime();

    if (freeSwap)
        *freeSwap = ( cachedFreeSwap = (Q_UINT64_C(1024) * values[3]) );
    return ( cachedValue = (Q_UINT64_C(1024) * memoryFree) );
#elif defined(Q_OS_FREEBSD)
    qulonglong cache, inact, free, psize;
    size_t cachelen, inactlen, freelen, psizelen;
    cachelen = sizeof( cache );
    inactlen = sizeof( inact );
    freelen = sizeof( free );
    psizelen = sizeof( psize );
    // sum up inactive, cached and free memory
    if ( sysctlbyname( ""vm.stats.vm.v_cache_count"", &cache, &cachelen, NULL, 0 ) == 0 &&
            sysctlbyname( ""vm.stats.vm.v_inactive_count"", &inact, &inactlen, NULL, 0 ) == 0 &&
            sysctlbyname( ""vm.stats.vm.v_free_count"", &free, &freelen, NULL, 0 ) == 0 &&
            sysctlbyname( ""vm.stats.vm.v_page_size"", &psize, &psizelen, NULL, 0 ) == 0 )
    {
        lastUpdate = QTime::currentTime();
        return (cachedValue = (cache + inact + free) * psize);
    }
    else
    {
        return 0;
    }
#elif defined(Q_OS_WIN)
    MEMORYSTATUSEX stat;
    stat.dwLength = sizeof(stat);
    GlobalMemoryStatusEx (&stat);

    lastUpdate = QTime::currentTime();

    if (freeSwap)
        *freeSwap = ( cachedFreeSwap = stat.ullAvailPageFile );
    return ( cachedValue = stat.ullAvailPhys );
#else
    // tell the memory is full.. will act as in LOW profile
    return 0;
#endif
}

bool DocumentPrivate::loadDocumentInfo( LoadDocumentInfoFlags loadWhat )
// note: load data and stores it internally (document or pages). observers
// are still uninitialized at this point so don't access them
{
    //qCDebug(OkularCoreDebug).nospace() << ""Using '"" << d->m_xmlFileName << ""' as document info file."";
    if ( m_xmlFileName.isEmpty() )
        return false;

    QFile infoFile( m_xmlFileName );
    return loadDocumentInfo( infoFile, loadWhat );
}

bool DocumentPrivate::loadDocumentInfo( QFile &infoFile, LoadDocumentInfoFlags loadWhat )
{
    if ( !infoFile.exists() || !infoFile.open( QIODevice::ReadOnly ) )
        return false;

    // Load DOM from XML file
    QDomDocument doc( QStringLiteral(""documentInfo"") );
    if ( !doc.setContent( &infoFile ) )
    {
        qCDebug(OkularCoreDebug) << ""Can't load XML pair! Check for broken xml."";
        infoFile.close();
        return false;
    }
    infoFile.close();

    QDomElement root = doc.documentElement();

    if ( root.tagName() != QLatin1String(""documentInfo"") )
        return false;

    QUrl documentUrl( root.attribute( ""url"" ) );
    bool loadedAnything = false; // set if something gets actually loaded

    // Parse the DOM tree
    QDomNode topLevelNode = root.firstChild();
    while ( topLevelNode.isElement() )
    {
        QString catName = topLevelNode.toElement().tagName();

        // Restore page attributes (bookmark, annotations, ...) from the DOM
        if ( catName == QLatin1String(""pageList"") && ( loadWhat & LoadPageInfo ) )
        {
            QDomNode pageNode = topLevelNode.firstChild();
            while ( pageNode.isElement() )
            {
                QDomElement pageElement = pageNode.toElement();
                if ( pageElement.hasAttribute( QStringLiteral(""number"") ) )
                {
                    // get page number (node's attribute)
                    bool ok;
                    int pageNumber = pageElement.attribute( QStringLiteral(""number"") ).toInt( &ok );

                    // pass the domElement to the right page, to read config data from
                    if ( ok && pageNumber >= 0 && pageNumber < (int)m_pagesVector.count() )
                    {
                        if ( m_pagesVector[ pageNumber ]->d->restoreLocalContents( pageElement ) )
                            loadedAnything = true;
                    }
                }
                pageNode = pageNode.nextSibling();
            }
        }

        // Restore 'general info' from the DOM
        else if ( catName == QLatin1String(""generalInfo"") && ( loadWhat & LoadGeneralInfo ) )
        {
            QDomNode infoNode = topLevelNode.firstChild();
            while ( infoNode.isElement() )
            {
                QDomElement infoElement = infoNode.toElement();

                // restore viewports history
                if ( infoElement.tagName() == QLatin1String(""history"") )
                {
                    // clear history
                    m_viewportHistory.clear();
                    // append old viewports
                    QDomNode historyNode = infoNode.firstChild();
                    while ( historyNode.isElement() )
                    {
                        QDomElement historyElement = historyNode.toElement();
                        if ( historyElement.hasAttribute( QStringLiteral(""viewport"") ) )
                        {
                            QString vpString = historyElement.attribute( QStringLiteral(""viewport"") );
                            m_viewportIterator = m_viewportHistory.insert( m_viewportHistory.end(),
                                    DocumentViewport( vpString ) );
                            loadedAnything = true;
                        }
                        historyNode = historyNode.nextSibling();
                    }
                    // consistancy check
                    if ( m_viewportHistory.isEmpty() )
                        m_viewportIterator = m_viewportHistory.insert( m_viewportHistory.end(), DocumentViewport() );
                }
                else if ( infoElement.tagName() == QLatin1String(""rotation"") )
                {
                    QString str = infoElement.text();
                    bool ok = true;
                    int newrotation = !str.isEmpty() ? ( str.toInt( &ok ) % 4 ) : 0;
                    if ( ok && newrotation != 0 )
                    {
                        setRotationInternal( newrotation, false );
                        loadedAnything = true;
                    }
                }
                else if ( infoElement.tagName() == QLatin1String(""views"") )
                {
                    QDomNode viewNode = infoNode.firstChild();
                    while ( viewNode.isElement() )
                    {
                        QDomElement viewElement = viewNode.toElement();
                        if ( viewElement.tagName() == QLatin1String(""view"") )
                        {
                            const QString viewName = viewElement.attribute( QStringLiteral(""name"") );
                            Q_FOREACH ( View * view, m_views )
                            {
                                if ( view->name() == viewName )
                                {
                                    loadViewsInfo( view, viewElement );
                                    loadedAnything = true;
                                    break;
                                }
                            }
                        }
                        viewNode = viewNode.nextSibling();
                    }
                }
                infoNode = infoNode.nextSibling();
            }
        }

        topLevelNode = topLevelNode.nextSibling();
    } // </documentInfo>

    return loadedAnything;
}

void DocumentPrivate::loadViewsInfo( View *view, const QDomElement &e )
{
    QDomNode viewNode = e.firstChild();
    while ( viewNode.isElement() )
    {
        QDomElement viewElement = viewNode.toElement();

        if ( viewElement.tagName() == QLatin1String(""zoom"") )
        {
            const QString valueString = viewElement.attribute( QStringLiteral(""value"") );
            bool newzoom_ok = true;
            const double newzoom = !valueString.isEmpty() ? valueString.toDouble( &newzoom_ok ) : 1.0;
            if ( newzoom_ok && newzoom != 0
                 && view->supportsCapability( View::Zoom )
                 && ( view->capabilityFlags( View::Zoom ) & ( View::CapabilityRead | View::CapabilitySerializable ) ) )
            {
                view->setCapability( View::Zoom, newzoom );
            }
            const QString modeString = viewElement.attribute( QStringLiteral(""mode"") );
            bool newmode_ok = true;
            const int newmode = !modeString.isEmpty() ? modeString.toInt( &newmode_ok ) : 2;
            if ( newmode_ok
                 && view->supportsCapability( View::ZoomModality )
                 && ( view->capabilityFlags( View::ZoomModality ) & ( View::CapabilityRead | View::CapabilitySerializable ) ) )
            {
                view->setCapability( View::ZoomModality, newmode );
            }
        }

        viewNode = viewNode.nextSibling();
    }
}

void DocumentPrivate::saveViewsInfo( View *view, QDomElement &e ) const
{
    if ( view->supportsCapability( View::Zoom )
         && ( view->capabilityFlags( View::Zoom ) & ( View::CapabilityRead | View::CapabilitySerializable ) )
         && view->supportsCapability( View::ZoomModality )
         && ( view->capabilityFlags( View::ZoomModality ) & ( View::CapabilityRead | View::CapabilitySerializable ) ) )
    {
        QDomElement zoomEl = e.ownerDocument().createElement( QStringLiteral(""zoom"") );
        e.appendChild( zoomEl );
        bool ok = true;
        const double zoom = view->capability( View::Zoom ).toDouble( &ok );
        if ( ok && zoom != 0 )
        {
            zoomEl.setAttribute( QStringLiteral(""value""), QString::number(zoom) );
        }
        const int mode = view->capability( View::ZoomModality ).toInt( &ok );
        if ( ok )
        {
            zoomEl.setAttribute( QStringLiteral(""mode""), mode );
        }
    }
}

QUrl DocumentPrivate::giveAbsoluteUrl( const QString & fileName ) const
{
    if ( !QDir::isRelativePath( fileName ) )
        return QUrl::fromLocalFile(fileName);

    if ( !m_url.isValid() )
        return QUrl();

    return QUrl(KIO::upUrl(m_url).toString() + fileName);
}

bool DocumentPrivate::openRelativeFile( const QString & fileName )
{
    QUrl url = giveAbsoluteUrl( fileName );
    if ( url.isEmpty() )
        return false;

    qCDebug(OkularCoreDebug).nospace() << ""openRelativeFile: '"" << url << ""'"";

    emit m_parent->openUrl( url );
    return true;
}

Generator * DocumentPrivate::loadGeneratorLibrary( const KPluginMetaData &service )
{
    KPluginLoader loader( service.fileName() );
    qCDebug(OkularCoreDebug) << service.fileName();
    KPluginFactory *factory = loader.factory();
    if ( !factory )
    {
        qCWarning(OkularCoreDebug).nospace() << ""Invalid plugin factory for "" << service.fileName() << "":"" << loader.errorString();
        return nullptr;
    }

    Generator * plugin = factory->create<Okular::Generator>();

    GeneratorInfo info( plugin, service );
    m_loadedGenerators.insert( service.pluginId(), info );
    return plugin;
}

void DocumentPrivate::loadAllGeneratorLibraries()
{
    if ( m_generatorsLoaded )
        return;

    loadServiceList( availableGenerators() );

    m_generatorsLoaded = true;
}

void DocumentPrivate::loadServiceList( const QVector<KPluginMetaData>& offers )
{
    int count = offers.count();
    if ( count <= 0 )
        return;

    for ( int i = 0; i < count; ++i )
    {
        QString id = offers.at(i).pluginId();
        // don't load already loaded generators
        QHash< QString, GeneratorInfo >::const_iterator genIt = m_loadedGenerators.constFind( id );
        if ( !m_loadedGenerators.isEmpty() && genIt != m_loadedGenerators.constEnd() )
            continue;

        Generator * g = loadGeneratorLibrary( offers.at(i) );
        (void)g;
    }
}

void DocumentPrivate::unloadGenerator( const GeneratorInfo& info )
{
    delete info.generator;
}

void DocumentPrivate::cacheExportFormats()
{
    if ( m_exportCached )
        return;

    const ExportFormat::List formats = m_generator->exportFormats();
    for ( int i = 0; i < formats.count(); ++i )
    {
        if ( formats.at( i ).mimeType().name() == QLatin1String( ""text/plain"" ) )
            m_exportToText = formats.at( i );
        else
            m_exportFormats.append( formats.at( i ) );
    }

    m_exportCached = true;
}

ConfigInterface* DocumentPrivate::generatorConfig( GeneratorInfo& info )
{
    if ( info.configChecked )
        return info.config;

    info.config = qobject_cast< Okular::ConfigInterface * >( info.generator );
    info.configChecked = true;
    return info.config;
}

SaveInterface* DocumentPrivate::generatorSave( GeneratorInfo& info )
{
    if ( info.saveChecked )
        return info.save;

    info.save = qobject_cast< Okular::SaveInterface * >( info.generator );
    info.saveChecked = true;
    return info.save;
}

Document::OpenResult DocumentPrivate::openDocumentInternal( const KPluginMetaData& offer, bool isstdin, const QString& docFile, const QByteArray& filedata, const QString& password )
{
    QString propName = offer.pluginId();
    QHash< QString, GeneratorInfo >::const_iterator genIt = m_loadedGenerators.constFind( propName );
    m_walletGenerator = nullptr;
    if ( genIt != m_loadedGenerators.constEnd() )
    {
        m_generator = genIt.value().generator;
    }
    else
    {
        m_generator = loadGeneratorLibrary( offer );
        if ( !m_generator )
            return Document::OpenError;
        genIt = m_loadedGenerators.constFind( propName );
        Q_ASSERT( genIt != m_loadedGenerators.constEnd() );
    }
    Q_ASSERT_X( m_generator, ""Document::load()"", ""null generator?!"" );

    m_generator->d_func()->m_document = this;

    // connect error reporting signals
    QObject::connect( m_generator, &Generator::error, m_parent, &Document::error );
    QObject::connect( m_generator, &Generator::warning, m_parent, &Document::warning );
    QObject::connect( m_generator, &Generator::notice, m_parent, &Document::notice );

    QApplication::setOverrideCursor( Qt::WaitCursor );

    const QSizeF dpi = Utils::realDpi(m_widget);
    qCDebug(OkularCoreDebug) << ""Output DPI:"" << dpi;
    m_generator->setDPI(dpi);

    Document::OpenResult openResult = Document::OpenError;
    if ( !isstdin )
    {
        openResult = m_generator->loadDocumentWithPassword( docFile, m_pagesVector, password );
    }
    else if ( !filedata.isEmpty() )
    {
        if ( m_generator->hasFeature( Generator::ReadRawData ) )
        {
            openResult = m_generator->loadDocumentFromDataWithPassword( filedata, m_pagesVector, password );
        }
        else
        {
            m_tempFile = new QTemporaryFile();
            if ( !m_tempFile->open() )
            {
                delete m_tempFile;
                m_tempFile = nullptr;
            }
            else
            {
                m_tempFile->write( filedata );
                QString tmpFileName = m_tempFile->fileName();
                m_tempFile->close();
                openResult = m_generator->loadDocumentWithPassword( tmpFileName, m_pagesVector, password );
            }
        }
    }

    QApplication::restoreOverrideCursor();
    if ( openResult != Document::OpenSuccess || m_pagesVector.size() <= 0 )
    {
        m_generator->d_func()->m_document = nullptr;
        QObject::disconnect( m_generator, nullptr, m_parent, nullptr );
        // TODO this is a bit of a hack, since basically means that
        // you can only call walletDataForFile after calling openDocument
        // but since in reality it's what happens I've decided not to refactor/break API
        // One solution is just kill walletDataForFile and make OpenResult be an object
        // where the wallet data is also returned when OpenNeedsPassword
        m_walletGenerator = m_generator;
        m_generator = nullptr;

        qDeleteAll( m_pagesVector );
        m_pagesVector.clear();
        delete m_tempFile;
        m_tempFile = nullptr;

        // TODO: emit a message telling the document is empty
        if ( openResult == Document::OpenSuccess )
            openResult = Document::OpenError;
    }

    return openResult;
}

bool DocumentPrivate::savePageDocumentInfo( QTemporaryFile *infoFile, int what ) const
{
    if ( infoFile->open() )
    {
        // 1. Create DOM
        QDomDocument doc( QStringLiteral(""documentInfo"") );
        QDomProcessingInstruction xmlPi = doc.createProcessingInstruction(
                QStringLiteral( ""xml"" ), QStringLiteral( ""version=\""1.0\"" encoding=\""utf-8\"""" ) );
        doc.appendChild( xmlPi );
        QDomElement root = doc.createElement( QStringLiteral(""documentInfo"") );
        doc.appendChild( root );

        // 2.1. Save page attributes (bookmark state, annotations, ... ) to DOM
        QDomElement pageList = doc.createElement( QStringLiteral(""pageList"") );
        root.appendChild( pageList );
        // <page list><page number='x'>.... </page> save pages that hold data
        QVector< Page * >::const_iterator pIt = m_pagesVector.constBegin(), pEnd = m_pagesVector.constEnd();
        for ( ; pIt != pEnd; ++pIt )
            (*pIt)->d->saveLocalContents( pageList, doc, PageItems( what ) );

        // 3. Save DOM to XML file
        QString xml = doc.toString();
        QTextStream os( infoFile );
        os.setCodec( ""UTF-8"" );
        os << xml;
        return true;
    }
    return false;
}

DocumentViewport DocumentPrivate::nextDocumentViewport() const
{
    DocumentViewport ret = m_nextDocumentViewport;
    if ( !m_nextDocumentDestination.isEmpty() && m_generator )
    {
        DocumentViewport vp( m_parent->metaData( QStringLiteral(""NamedViewport""), m_nextDocumentDestination ).toString() );
        if ( vp.isValid() )
        {
            ret = vp;
        }
    }
    return ret;
}

void DocumentPrivate::performAddPageAnnotation( int page, Annotation * annotation )
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );
    AnnotationProxy *proxy = iface ? iface->annotationProxy() : nullptr;

    // find out the page to attach annotation
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    // the annotation belongs already to a page
    if ( annotation->d_ptr->m_page )
        return;

    // add annotation to the page
    kp->addAnnotation( annotation );

    // tell the annotation proxy
    if ( proxy && proxy->supports(AnnotationProxy::Addition) )
        proxy->notifyAddition( annotation, page );

    // notify observers about the change
    notifyAnnotationChanges( page );

    if ( annotation->flags() & Annotation::ExternallyDrawn )
    {
        // Redraw everything, including ExternallyDrawn annotations
        refreshPixmaps( page );
    }
}

void DocumentPrivate::performRemovePageAnnotation( int page, Annotation * annotation )
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );
    AnnotationProxy *proxy = iface ? iface->annotationProxy() : nullptr;
    bool isExternallyDrawn;

    // find out the page
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    if ( annotation->flags() & Annotation::ExternallyDrawn )
        isExternallyDrawn = true;
    else
        isExternallyDrawn = false;

    // try to remove the annotation
    if ( m_parent->canRemovePageAnnotation( annotation ) )
    {
        // tell the annotation proxy
        if ( proxy && proxy->supports(AnnotationProxy::Removal) )
            proxy->notifyRemoval( annotation, page );

        kp->removeAnnotation( annotation ); // Also destroys the object

        // in case of success, notify observers about the change
        notifyAnnotationChanges( page );

        if ( isExternallyDrawn )
        {
            // Redraw everything, including ExternallyDrawn annotations
            refreshPixmaps( page );
        }
    }
}

void DocumentPrivate::performModifyPageAnnotation( int page, Annotation * annotation, bool appearanceChanged )
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );
    AnnotationProxy *proxy = iface ? iface->annotationProxy() : nullptr;

    // find out the page
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    // tell the annotation proxy
    if ( proxy && proxy->supports(AnnotationProxy::Modification) )
    {
        proxy->notifyModification( annotation, page, appearanceChanged );
    }

    // notify observers about the change
    notifyAnnotationChanges( page );
    if ( appearanceChanged && (annotation->flags() & Annotation::ExternallyDrawn) )
    {
        /* When an annotation is being moved, the generator will not render it.
         * Therefore there's no need to refresh pixmaps after the first time */
        if ( annotation->flags() & (Annotation::BeingMoved | Annotation::BeingResized) )
        {
            if ( m_annotationBeingModified )
                return;
            else // First time: take note
                m_annotationBeingModified = true;
        }
        else
        {
            m_annotationBeingModified = false;
        }

        // Redraw everything, including ExternallyDrawn annotations
        qCDebug(OkularCoreDebug) << ""Refreshing Pixmaps"";
        refreshPixmaps( page );
    }
}

void DocumentPrivate::performSetAnnotationContents( const QString & newContents, Annotation *annot, int pageNumber )
{
    bool appearanceChanged = false;

    // Check if appearanceChanged should be true
    switch ( annot->subType() )
    {
        // If it's an in-place TextAnnotation, set the inplace text
        case Okular::Annotation::AText:
        {
            Okular::TextAnnotation * txtann = static_cast< Okular::TextAnnotation * >( annot );
            if ( txtann->textType() == Okular::TextAnnotation::InPlace )
            {
                appearanceChanged = true;
            }
            break;
        }
        // If it's a LineAnnotation, check if caption text is visible
        case Okular::Annotation::ALine:
        {
            Okular::LineAnnotation * lineann = static_cast< Okular::LineAnnotation * >( annot );
            if ( lineann->showCaption() )
                appearanceChanged = true;
            break;
        }
        default:
            break;
    }

    // Set contents
    annot->setContents( newContents );

    // Tell the document the annotation has been modified
    performModifyPageAnnotation( pageNumber,  annot, appearanceChanged );
}

void DocumentPrivate::recalculateForms()
{
    const QVariant fco = m_parent->metaData(QLatin1String(""FormCalculateOrder""));
    const QVector<int> formCalculateOrder = fco.value<QVector<int>>();
    foreach(int formId, formCalculateOrder) {
        for ( uint pageIdx = 0; pageIdx  < m_parent->pages(); pageIdx++ )
        {
            const Page *p = m_parent->page( pageIdx );
            if (p)
            {
                bool pageNeedsRefresh = false;
                foreach( FormField *form, p->formFields() )
                {
                    if ( form->id() == formId ) {
                        Action *action = form->additionalAction( FormField::CalculateField );
                        if (action)
                        {
                            FormFieldText *fft = dynamic_cast< FormFieldText * >( form );
                            std::shared_ptr<Event> event;
                            QString oldVal;
                            if ( fft )
                            {
                                // Pepare text calculate event
                                event = Event::createFormCalculateEvent( fft, m_pagesVector[pageIdx] );
                                if ( !m_scripter )
                                    m_scripter = new Scripter( this );
                                m_scripter->setEvent( event.get() );
                                // The value maybe changed in javascript so save it first.
                                oldVal = fft->text();
                            }

                            m_parent->processAction( action );
                            if ( event && fft )
                            {
                                // Update text field from calculate
                                m_scripter->setEvent( nullptr );
                                const QString newVal = event->value().toString();
                                if ( newVal != oldVal )
                                {
                                    fft->setText( newVal );
                                    emit m_parent->refreshFormWidget( fft );
                                    pageNeedsRefresh = true;
                                }
                            }
                        }
                        else
                        {
                            qWarning() << ""Form that is part of calculate order doesn't have a calculate action"";
                        }
                    }
                }
                if ( pageNeedsRefresh )
                {
                    refreshPixmaps( p->number() );
                }
            }
        }
    }
}

void DocumentPrivate::saveDocumentInfo() const
{
    if ( m_xmlFileName.isEmpty() )
        return;

    QFile infoFile( m_xmlFileName );
    qCDebug(OkularCoreDebug) << ""About to save document info to"" << m_xmlFileName;
    if (!infoFile.open( QIODevice::WriteOnly | QIODevice::Truncate))
    {
        qCWarning(OkularCoreDebug) << ""Failed to open docdata file"" << m_xmlFileName;
        return;
    }
    // 1. Create DOM
    QDomDocument doc( QStringLiteral(""documentInfo"") );
    QDomProcessingInstruction xmlPi = doc.createProcessingInstruction(
            QStringLiteral( ""xml"" ), QStringLiteral( ""version=\""1.0\"" encoding=\""utf-8\"""" ) );
    doc.appendChild( xmlPi );
    QDomElement root = doc.createElement( QStringLiteral(""documentInfo"") );
    root.setAttribute( QStringLiteral(""url""), m_url.toDisplayString(QUrl::PreferLocalFile) );
    doc.appendChild( root );

    // 2.1. Save page attributes (bookmark state, annotations, ... ) to DOM
    //  -> do this if there are not-yet-migrated annots or forms in docdata/
    if ( m_docdataMigrationNeeded )
    {
        QDomElement pageList = doc.createElement( ""pageList"" );
        root.appendChild( pageList );
        // OriginalAnnotationPageItems and OriginalFormFieldPageItems tell to
        // store the same unmodified annotation list and form contents that we
        // read when we opened the file and ignore any change made by the user.
        // Since we don't store annotations and forms in docdata/ any more, this is
        // necessary to preserve annotations/forms that previous Okular version
        // had stored there.
        const PageItems saveWhat = AllPageItems | OriginalAnnotationPageItems | OriginalFormFieldPageItems;
        // <page list><page number='x'>.... </page> save pages that hold data
        QVector< Page * >::const_iterator pIt = m_pagesVector.constBegin(), pEnd = m_pagesVector.constEnd();
        for ( ; pIt != pEnd; ++pIt )
            (*pIt)->d->saveLocalContents( pageList, doc, saveWhat );
    }

    // 2.2. Save document info (current viewport, history, ... ) to DOM
    QDomElement generalInfo = doc.createElement( QStringLiteral(""generalInfo"") );
    root.appendChild( generalInfo );
    // create rotation node
    if ( m_rotation != Rotation0 )
    {
        QDomElement rotationNode = doc.createElement( QStringLiteral(""rotation"") );
        generalInfo.appendChild( rotationNode );
        rotationNode.appendChild( doc.createTextNode( QString::number( (int)m_rotation ) ) );
    }
    // <general info><history> ... </history> save history up to OKULAR_HISTORY_SAVEDSTEPS viewports
    QLinkedList< DocumentViewport >::const_iterator backIterator = m_viewportIterator;
    if ( backIterator != m_viewportHistory.constEnd() )
    {
        // go back up to OKULAR_HISTORY_SAVEDSTEPS steps from the current viewportIterator
        int backSteps = OKULAR_HISTORY_SAVEDSTEPS;
        while ( backSteps-- && backIterator != m_viewportHistory.constBegin() )
            --backIterator;

        // create history root node
        QDomElement historyNode = doc.createElement( QStringLiteral(""history"") );
        generalInfo.appendChild( historyNode );

        // add old[backIterator] and present[viewportIterator] items
        QLinkedList< DocumentViewport >::const_iterator endIt = m_viewportIterator;
        ++endIt;
        while ( backIterator != endIt )
        {
            QString name = (backIterator == m_viewportIterator) ? QStringLiteral (""current"") : QStringLiteral (""oldPage"");
            QDomElement historyEntry = doc.createElement( name );
            historyEntry.setAttribute( QStringLiteral(""viewport""), (*backIterator).toString() );
            historyNode.appendChild( historyEntry );
            ++backIterator;
        }
    }
    // create views root node
    QDomElement viewsNode = doc.createElement( QStringLiteral(""views"") );
    generalInfo.appendChild( viewsNode );
    Q_FOREACH ( View * view, m_views )
    {
        QDomElement viewEntry = doc.createElement( QStringLiteral(""view"") );
        viewEntry.setAttribute( QStringLiteral(""name""), view->name() );
        viewsNode.appendChild( viewEntry );
        saveViewsInfo( view, viewEntry );
    }

    // 3. Save DOM to XML file
    QString xml = doc.toString();
    QTextStream os( &infoFile );
    os.setCodec( ""UTF-8"" );
    os << xml;
    infoFile.close();
}

void DocumentPrivate::slotTimedMemoryCheck()
{
    // [MEM] clean memory (for 'free mem dependant' profiles only)
    if ( SettingsCore::memoryLevel() != SettingsCore::EnumMemoryLevel::Low &&
         m_allocatedPixmapsTotalMemory > 1024*1024 )
        cleanupPixmapMemory();
}

void DocumentPrivate::sendGeneratorPixmapRequest()
{
    /* If the pixmap cache will have to be cleaned in order to make room for the
     * next request, get the distance from the current viewport of the page
     * whose pixmap will be removed. We will ignore preload requests for pages
     * that are at the same distance or farther */
    const qulonglong memoryToFree = calculateMemoryToFree();
    const int currentViewportPage = (*m_viewportIterator).pageNumber;
    int maxDistance = INT_MAX; // Default: No maximum
    if ( memoryToFree )
    {
        AllocatedPixmap *pixmapToReplace = searchLowestPriorityPixmap( true );
        if ( pixmapToReplace )
            maxDistance = qAbs( pixmapToReplace->page - currentViewportPage );
    }

    // find a request
    PixmapRequest * request = nullptr;
    m_pixmapRequestsMutex.lock();
    while ( !m_pixmapRequestsStack.isEmpty() && !request )
    {
        PixmapRequest * r = m_pixmapRequestsStack.last();
        if (!r)
        {
            m_pixmapRequestsStack.pop_back();
            continue;
        }

        QRect requestRect = r->isTile() ? r->normalizedRect().geometry( r->width(), r->height() ) : QRect( 0, 0, r->width(), r->height() );
        TilesManager *tilesManager = r->d->tilesManager();

        // If it's a preload but the generator is not threaded no point in trying to preload
        if ( r->preload() && !m_generator->hasFeature( Generator::Threaded ) )
        {
            m_pixmapRequestsStack.pop_back();
            delete r;
        }
        // request only if page isn't already present and request has valid id
        else if ( ( !r->d->mForce && r->page()->hasPixmap( r->observer(), r->width(), r->height(), r->normalizedRect() ) ) || !m_observers.contains(r->observer()) )
        {
            m_pixmapRequestsStack.pop_back();
            delete r;
        }
        else if ( !r->d->mForce && r->preload() && qAbs( r->pageNumber() - currentViewportPage ) >= maxDistance )
        {
            m_pixmapRequestsStack.pop_back();
            //qCDebug(OkularCoreDebug) << ""Ignoring request that doesn't fit in cache"";
            delete r;
        }
        // Ignore requests for pixmaps that are already being generated
        else if ( tilesManager && tilesManager->isRequesting( r->normalizedRect(), r->width(), r->height() ) )
        {
            m_pixmapRequestsStack.pop_back();
            delete r;
        }
        // If the requested area is above 8000000 pixels, switch on the tile manager
        else if ( !tilesManager && m_generator->hasFeature( Generator::TiledRendering ) && (long)r->width() * (long)r->height() > 8000000L )
        {
            // if the image is too big. start using tiles
            qCDebug(OkularCoreDebug).nospace() << ""Start using tiles on page "" << r->pageNumber()
                << "" ("" << r->width() << ""x"" << r->height() << "" px);"";

            // fill the tiles manager with the last rendered pixmap
            const QPixmap *pixmap = r->page()->_o_nearestPixmap( r->observer(), r->width(), r->height() );
            if ( pixmap )
            {
                tilesManager = new TilesManager( r->pageNumber(), pixmap->width(), pixmap->height(), r->page()->rotation() );
                tilesManager->setPixmap( pixmap, NormalizedRect( 0, 0, 1, 1 ), true /*isPartialPixmap*/ );
                tilesManager->setSize( r->width(), r->height() );
            }
            else
            {
                // create new tiles manager
                tilesManager = new TilesManager( r->pageNumber(), r->width(), r->height(), r->page()->rotation() );
            }
            tilesManager->setRequest( r->normalizedRect(), r->width(), r->height() );
            r->page()->deletePixmap( r->observer() );
            r->page()->d->setTilesManager( r->observer(), tilesManager );
            r->setTile( true );

            // Change normalizedRect to the smallest rect that contains all
            // visible tiles.
            if ( !r->normalizedRect().isNull() )
            {
                NormalizedRect tilesRect;
                const QList<Tile> tiles = tilesManager->tilesAt( r->normalizedRect(), TilesManager::TerminalTile );
                QList<Tile>::const_iterator tIt = tiles.constBegin(), tEnd = tiles.constEnd();
                while ( tIt != tEnd )
                {
                    Tile tile = *tIt;
                    if ( tilesRect.isNull() )
                        tilesRect = tile.rect();
                    else
                        tilesRect |= tile.rect();

                    ++tIt;
                }

                r->setNormalizedRect( tilesRect );
                request = r;
            }
            else
            {
                // Discard request if normalizedRect is null. This happens in
                // preload requests issued by PageView if the requested page is
                // not visible and the user has just switched from a non-tiled
                // zoom level to a tiled one
                m_pixmapRequestsStack.pop_back();
                delete r;
            }
        }
        // If the requested area is below 6000000 pixels, switch off the tile manager
        else if ( tilesManager && (long)r->width() * (long)r->height() < 6000000L )
        {
            qCDebug(OkularCoreDebug).nospace() << ""Stop using tiles on page "" << r->pageNumber()
                << "" ("" << r->width() << ""x"" << r->height() << "" px);"";

            // page is too small. stop using tiles.
            r->page()->deletePixmap( r->observer() );
            r->setTile( false );

            request = r;
        }
        else if ( (long)requestRect.width() * (long)requestRect.height() > 200000000L && (SettingsCore::memoryLevel() != SettingsCore::EnumMemoryLevel::Greedy ) )
        {
            m_pixmapRequestsStack.pop_back();
            if ( !m_warnedOutOfMemory )
            {
                qCWarning(OkularCoreDebug).nospace() << ""Running out of memory on page "" << r->pageNumber()
                    << "" ("" << r->width() << ""x"" << r->height() << "" px);"";
                qCWarning(OkularCoreDebug) << ""this message will be reported only once."";
                m_warnedOutOfMemory = true;
            }
            delete r;
        }
        else
        {
            request = r;
        }
    }

    // if no request found (or already generated), return
    if ( !request )
    {
        m_pixmapRequestsMutex.unlock();
        return;
    }

    // [MEM] preventive memory freeing
    qulonglong pixmapBytes = 0;
    TilesManager * tm = request->d->tilesManager();
    if ( tm )
        pixmapBytes = tm->totalMemory();
    else
        pixmapBytes = 4 * request->width() * request->height();

    if ( pixmapBytes > (1024 * 1024) )
        cleanupPixmapMemory( memoryToFree /* previously calculated value */ );

    // submit the request to the generator
    if ( m_generator->canGeneratePixmap() )
    {
        QRect requestRect = !request->isTile() ? QRect(0, 0, request->width(), request->height() ) : request->normalizedRect().geometry( request->width(), request->height() );
        qCDebug(OkularCoreDebug).nospace() << ""sending request observer="" << request->observer() << "" "" <<requestRect.width() << ""x"" << requestRect.height() << ""@"" << request->pageNumber() << "" async == "" << request->asynchronous() << "" isTile == "" << request->isTile();
        m_pixmapRequestsStack.removeAll ( request );

        if ( tm )
            tm->setRequest( request->normalizedRect(), request->width(), request->height() );

        if ( (int)m_rotation % 2 )
            request->d->swap();

        if ( m_rotation != Rotation0 && !request->normalizedRect().isNull() )
            request->setNormalizedRect( TilesManager::fromRotatedRect(
                        request->normalizedRect(), m_rotation ) );

        // If set elsewhere we already know we want it to be partial
        if ( !request->partialUpdatesWanted() )
        {
            request->setPartialUpdatesWanted( request->asynchronous() && !request->page()->hasPixmap( request->observer() ) );
        }

        // we always have to unlock _before_ the generatePixmap() because
        // a sync generation would end with requestDone() -> deadlock, and
        // we can not really know if the generator can do async requests
        m_executingPixmapRequests.push_back( request );
        m_pixmapRequestsMutex.unlock();
        m_generator->generatePixmap( request );
    }
    else
    {
        m_pixmapRequestsMutex.unlock();
        // pino (7/4/2006): set the polling interval from 10 to 30
        QTimer::singleShot( 30, m_parent, SLOT(sendGeneratorPixmapRequest()) );
    }
}

void DocumentPrivate::rotationFinished( int page, Okular::Page *okularPage )
{
    Okular::Page *wantedPage = m_pagesVector.value( page, 0 );
    if ( !wantedPage || wantedPage != okularPage )
        return;

    foreach(DocumentObserver *o, m_observers)
        o->notifyPageChanged( page, DocumentObserver::Pixmap | DocumentObserver::Annotations );
}

void DocumentPrivate::slotFontReadingProgress( int page )
{
    emit m_parent->fontReadingProgress( page );

    if ( page >= (int)m_parent->pages() - 1 )
    {
        emit m_parent->fontReadingEnded();
        m_fontThread = nullptr;
        m_fontsCached = true;
    }
}

void DocumentPrivate::fontReadingGotFont( const Okular::FontInfo& font )
{
    // Try to avoid duplicate fonts
    if (m_fontsCache.indexOf(font) == -1) {
        m_fontsCache.append( font );

        emit m_parent->gotFont( font );
    }
}

void DocumentPrivate::slotGeneratorConfigChanged( const QString& )
{
    if ( !m_generator )
        return;

    // reparse generator config and if something changed clear Pages
    bool configchanged = false;
    QHash< QString, GeneratorInfo >::iterator it = m_loadedGenerators.begin(), itEnd = m_loadedGenerators.end();
    for ( ; it != itEnd; ++it )
    {
        Okular::ConfigInterface * iface = generatorConfig( it.value() );
        if ( iface )
        {
            bool it_changed = iface->reparseConfig();
            if ( it_changed && ( m_generator == it.value().generator ) )
                configchanged = true;
        }
    }
    if ( configchanged )
    {
        // invalidate pixmaps
        QVector<Page*>::const_iterator it = m_pagesVector.constBegin(), end = m_pagesVector.constEnd();
        for ( ; it != end; ++it ) {
            (*it)->deletePixmaps();
        }

        // [MEM] remove allocation descriptors
        qDeleteAll( m_allocatedPixmaps );
        m_allocatedPixmaps.clear();
        m_allocatedPixmapsTotalMemory = 0;

        // send reload signals to observers
        foreachObserverD( notifyContentsCleared( DocumentObserver::Pixmap ) );
    }

    // free memory if in 'low' profile
    if ( SettingsCore::memoryLevel() == SettingsCore::EnumMemoryLevel::Low &&
         !m_allocatedPixmaps.isEmpty() && !m_pagesVector.isEmpty() )
        cleanupPixmapMemory();
}

void DocumentPrivate::refreshPixmaps( int pageNumber )
{
    Page* page = m_pagesVector.value( pageNumber, 0 );
    if ( !page )
        return;

    QMap< DocumentObserver*, PagePrivate::PixmapObject >::ConstIterator it = page->d->m_pixmaps.constBegin(), itEnd = page->d->m_pixmaps.constEnd();
    QVector< Okular::PixmapRequest * > pixmapsToRequest;
    for ( ; it != itEnd; ++it )
    {
        const QSize size = (*it).m_pixmap->size();
        PixmapRequest * p = new PixmapRequest( it.key(), pageNumber, size.width() / qApp->devicePixelRatio(), size.height() / qApp->devicePixelRatio(), 1, PixmapRequest::Asynchronous );
        p->d->mForce = true;
        pixmapsToRequest << p;
    }

    // Need to do this ↑↓ in two steps since requestPixmaps can end up calling cancelRenderingBecauseOf
    // which changes m_pixmaps and thus breaks the loop above
    for ( PixmapRequest *pr : qAsConst( pixmapsToRequest ) )
    {
        QLinkedList< Okular::PixmapRequest * > requestedPixmaps;
        requestedPixmaps.push_back( pr );
        m_parent->requestPixmaps( requestedPixmaps, Okular::Document::NoOption );
    }

    foreach (DocumentObserver *observer, m_observers)
    {
        QLinkedList< Okular::PixmapRequest * > requestedPixmaps;

        TilesManager *tilesManager = page->d->tilesManager( observer );
        if ( tilesManager )
        {
            tilesManager->markDirty();

            PixmapRequest * p = new PixmapRequest( observer, pageNumber, tilesManager->width() / qApp->devicePixelRatio(), tilesManager->height() / qApp->devicePixelRatio(), 1, PixmapRequest::Asynchronous );

            NormalizedRect tilesRect;

            // Get the visible page rect
            NormalizedRect visibleRect;
            QVector< Okular::VisiblePageRect * >::const_iterator vIt = m_pageRects.constBegin(), vEnd = m_pageRects.constEnd();
            for ( ; vIt != vEnd; ++vIt )
            {
                if ( (*vIt)->pageNumber == pageNumber )
                {
                    visibleRect = (*vIt)->rect;
                    break;
                }
            }

            if ( !visibleRect.isNull() )
            {
                p->setNormalizedRect( visibleRect );
                p->setTile( true );
                p->d->mForce = true;
                requestedPixmaps.push_back( p );
            }
            else
            {
                delete p;
            }
        }

        m_parent->requestPixmaps( requestedPixmaps, Okular::Document::NoOption );
    }

}

void DocumentPrivate::_o_configChanged()
{
    // free text pages if needed
    calculateMaxTextPages();
    while (m_allocatedTextPagesFifo.count() > m_maxAllocatedTextPages)
    {
        int pageToKick = m_allocatedTextPagesFifo.takeFirst();
        m_pagesVector.at(pageToKick)->setTextPage( nullptr ); // deletes the textpage
    }
}

void DocumentPrivate::doContinueDirectionMatchSearch(void *doContinueDirectionMatchSearchStruct)
{
    DoContinueDirectionMatchSearchStruct *searchStruct = static_cast<DoContinueDirectionMatchSearchStruct *>(doContinueDirectionMatchSearchStruct);
    RunningSearch *search = m_searches.value(searchStruct->searchID);

    if ((m_searchCancelled && !searchStruct->match) || !search)
    {
        // if the user cancelled but he just got a match, give him the match!
        QApplication::restoreOverrideCursor();

        if (search) search->isCurrentlySearching = false;

        emit m_parent->searchFinished( searchStruct->searchID, Document::SearchCancelled );
        delete searchStruct->pagesToNotify;
        delete searchStruct;
        return;
    }

    const bool forward = search->cachedType == Document::NextMatch;
    bool doContinue = false;
    // if no match found, loop through the whole doc, starting from currentPage
    if ( !searchStruct->match )
    {
        const int pageCount = m_pagesVector.count();
        if (search->pagesDone < pageCount)
        {
            doContinue = true;
            if ( searchStruct->currentPage >= pageCount )
            {
                searchStruct->currentPage = 0;
                emit m_parent->notice(i18n(""Continuing search from beginning""), 3000);
            }
            else if ( searchStruct->currentPage < 0 )
            {
                searchStruct->currentPage = pageCount - 1;
                emit m_parent->notice(i18n(""Continuing search from bottom""), 3000);
            }
        }
    }

    if (doContinue)
    {
        // get page
        Page * page = m_pagesVector[ searchStruct->currentPage ];
        // request search page if needed
        if ( !page->hasTextPage() )
            m_parent->requestTextPage( page->number() );

        // if found a match on the current page, end the loop
        searchStruct->match = page->findText( searchStruct->searchID, search->cachedString, forward ? FromTop : FromBottom, search->cachedCaseSensitivity );
        if ( !searchStruct->match )
        {
            if (forward) searchStruct->currentPage++;
            else searchStruct->currentPage--;
            search->pagesDone++;
        }
        else
        {
            search->pagesDone = 1;
        }

        // Both of the previous if branches need to call doContinueDirectionMatchSearch
        QMetaObject::invokeMethod(m_parent, ""doContinueDirectionMatchSearch"", Qt::QueuedConnection, Q_ARG(void *, searchStruct));
    }
    else
    {
        doProcessSearchMatch( searchStruct->match, search, searchStruct->pagesToNotify, searchStruct->currentPage, searchStruct->searchID, search->cachedViewportMove, search->cachedColor );
        delete searchStruct;
    }
}

void DocumentPrivate::doProcessSearchMatch( RegularAreaRect *match, RunningSearch *search, QSet< int > *pagesToNotify, int currentPage, int searchID, bool moveViewport, const QColor & color )
{
    // reset cursor to previous shape
    QApplication::restoreOverrideCursor();

    bool foundAMatch = false;

    search->isCurrentlySearching = false;

    // if a match has been found..
    if ( match )
    {
        // update the RunningSearch structure adding this match..
        foundAMatch = true;
        search->continueOnPage = currentPage;
        search->continueOnMatch = *match;
        search->highlightedPages.insert( currentPage );
        // ..add highlight to the page..
        m_pagesVector[ currentPage ]->d->setHighlight( searchID, match, color );

        // ..queue page for notifying changes..
        pagesToNotify->insert( currentPage );

        // Create a normalized rectangle around the search match that includes a 5% buffer on all sides.
        const Okular::NormalizedRect matchRectWithBuffer = Okular::NormalizedRect( match->first().left - 0.05,
                                                                                   match->first().top - 0.05,
                                                                                   match->first().right + 0.05,
                                                                                   match->first().bottom + 0.05 );

        const bool matchRectFullyVisible = isNormalizedRectangleFullyVisible( matchRectWithBuffer, currentPage );

        // ..move the viewport to show the first of the searched word sequence centered
        if ( moveViewport && !matchRectFullyVisible )
        {
            DocumentViewport searchViewport( currentPage );
            searchViewport.rePos.enabled = true;
            searchViewport.rePos.normalizedX = (match->first().left + match->first().right) / 2.0;
            searchViewport.rePos.normalizedY = (match->first().top + match->first().bottom) / 2.0;
            m_parent->setViewport( searchViewport, nullptr, true );
        }
        delete match;
    }

    // notify observers about highlights changes
    foreach(int pageNumber, *pagesToNotify)
        foreach(DocumentObserver *observer, m_observers)
            observer->notifyPageChanged( pageNumber, DocumentObserver::Highlights );

    if (foundAMatch) emit m_parent->searchFinished( searchID, Document::MatchFound );
    else emit m_parent->searchFinished( searchID, Document::NoMatchFound );

    delete pagesToNotify;
}

void DocumentPrivate::doContinueAllDocumentSearch(void *pagesToNotifySet, void *pageMatchesMap, int currentPage, int searchID)
{
    QMap< Page *, QVector<RegularAreaRect *> > *pageMatches = static_cast< QMap< Page *, QVector<RegularAreaRect *> > * >(pageMatchesMap);
    QSet< int > *pagesToNotify = static_cast< QSet< int > * >( pagesToNotifySet );
    RunningSearch *search = m_searches.value(searchID);

    if (m_searchCancelled || !search)
    {
        typedef QVector<RegularAreaRect *> MatchesVector;

        QApplication::restoreOverrideCursor();

        if (search) search->isCurrentlySearching = false;

        emit m_parent->searchFinished( searchID, Document::SearchCancelled );
        foreach(const MatchesVector &mv, *pageMatches) qDeleteAll(mv);
        delete pageMatches;
        delete pagesToNotify;
        return;
    }

    if (currentPage < m_pagesVector.count())
    {
        // get page (from the first to the last)
        Page *page = m_pagesVector.at(currentPage);
        int pageNumber = page->number(); // redundant? is it == currentPage ?

        // request search page if needed
        if ( !page->hasTextPage() )
            m_parent->requestTextPage( pageNumber );

        // loop on a page adding highlights for all found items
        RegularAreaRect * lastMatch = nullptr;
        while ( 1 )
        {
            if ( lastMatch )
                lastMatch = page->findText( searchID, search->cachedString, NextResult, search->cachedCaseSensitivity, lastMatch );
            else
                lastMatch = page->findText( searchID, search->cachedString, FromTop, search->cachedCaseSensitivity );

            if ( !lastMatch )
                break;

            // add highligh rect to the matches map
            (*pageMatches)[page].append(lastMatch);
        }
        delete lastMatch;

        QMetaObject::invokeMethod(m_parent, ""doContinueAllDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotifySet), Q_ARG(void *, pageMatches), Q_ARG(int, currentPage + 1), Q_ARG(int, searchID));
    }
    else
    {
        // reset cursor to previous shape
        QApplication::restoreOverrideCursor();

        search->isCurrentlySearching = false;
        bool foundAMatch = pageMatches->count() != 0;
        QMap< Page *, QVector<RegularAreaRect *> >::const_iterator it, itEnd;
        it = pageMatches->constBegin();
        itEnd = pageMatches->constEnd();
        for ( ; it != itEnd; ++it)
        {
            foreach(RegularAreaRect *match, it.value())
            {
                it.key()->d->setHighlight( searchID, match, search->cachedColor );
                delete match;
            }
            search->highlightedPages.insert( it.key()->number() );
            pagesToNotify->insert( it.key()->number() );
        }

        foreach(DocumentObserver *observer, m_observers)
            observer->notifySetup( m_pagesVector, 0 );

        // notify observers about highlights changes
        foreach(int pageNumber, *pagesToNotify)
            foreach(DocumentObserver *observer, m_observers)
                observer->notifyPageChanged( pageNumber, DocumentObserver::Highlights );

        if (foundAMatch) emit m_parent->searchFinished(searchID, Document::MatchFound );
        else emit m_parent->searchFinished( searchID, Document::NoMatchFound );

        delete pageMatches;
        delete pagesToNotify;
    }
}

void DocumentPrivate::doContinueGooglesDocumentSearch(void *pagesToNotifySet, void *pageMatchesMap, int currentPage, int searchID, const QStringList & words)
{
    typedef QPair<RegularAreaRect *, QColor> MatchColor;
    QMap< Page *, QVector<MatchColor> > *pageMatches = static_cast< QMap< Page *, QVector<MatchColor> > * >(pageMatchesMap);
    QSet< int > *pagesToNotify = static_cast< QSet< int > * >( pagesToNotifySet );
    RunningSearch *search = m_searches.value(searchID);

    if (m_searchCancelled || !search)
    {
        typedef QVector<MatchColor> MatchesVector;

        QApplication::restoreOverrideCursor();

        if (search) search->isCurrentlySearching = false;

        emit m_parent->searchFinished( searchID, Document::SearchCancelled );

        foreach(const MatchesVector &mv, *pageMatches)
        {
            foreach(const MatchColor &mc, mv) delete mc.first;
        }
        delete pageMatches;
        delete pagesToNotify;
        return;
    }

    const int wordCount = words.count();
    const int hueStep = (wordCount > 1) ? (60 / (wordCount - 1)) : 60;
    int baseHue, baseSat, baseVal;
    search->cachedColor.getHsv( &baseHue, &baseSat, &baseVal );

    if (currentPage < m_pagesVector.count())
    {
        // get page (from the first to the last)
        Page *page = m_pagesVector.at(currentPage);
        int pageNumber = page->number(); // redundant? is it == currentPage ?

        // request search page if needed
        if ( !page->hasTextPage() )
            m_parent->requestTextPage( pageNumber );

        // loop on a page adding highlights for all found items
        bool allMatched = wordCount > 0,
             anyMatched = false;
        for ( int w = 0; w < wordCount; w++ )
        {
            const QString &word = words[ w ];
            int newHue = baseHue - w * hueStep;
            if ( newHue < 0 )
                newHue += 360;
            QColor wordColor = QColor::fromHsv( newHue, baseSat, baseVal );
            RegularAreaRect * lastMatch = nullptr;
            // add all highlights for current word
            bool wordMatched = false;
            while ( 1 )
            {
                if ( lastMatch )
                    lastMatch = page->findText( searchID, word, NextResult, search->cachedCaseSensitivity, lastMatch );
                else
                    lastMatch = page->findText( searchID, word, FromTop, search->cachedCaseSensitivity);

                if ( !lastMatch )
                    break;

                // add highligh rect to the matches map
                (*pageMatches)[page].append(MatchColor(lastMatch, wordColor));
                wordMatched = true;
            }
            allMatched = allMatched && wordMatched;
            anyMatched = anyMatched || wordMatched;
        }

        // if not all words are present in page, remove partial highlights
        const bool matchAll = search->cachedType == Document::GoogleAll;
        if ( !allMatched && matchAll )
        {
            QVector<MatchColor> &matches = (*pageMatches)[page];
            foreach(const MatchColor &mc, matches) delete mc.first;
            pageMatches->remove(page);
        }

        QMetaObject::invokeMethod(m_parent, ""doContinueGooglesDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotifySet), Q_ARG(void *, pageMatches), Q_ARG(int, currentPage + 1), Q_ARG(int, searchID), Q_ARG(QStringList, words));
    }
    else
    {
        // reset cursor to previous shape
        QApplication::restoreOverrideCursor();

        search->isCurrentlySearching = false;
        bool foundAMatch = pageMatches->count() != 0;
        QMap< Page *, QVector<MatchColor> >::const_iterator it, itEnd;
        it = pageMatches->constBegin();
        itEnd = pageMatches->constEnd();
        for ( ; it != itEnd; ++it)
        {
            foreach(const MatchColor &mc, it.value())
            {
                it.key()->d->setHighlight( searchID, mc.first, mc.second );
                delete mc.first;
            }
            search->highlightedPages.insert( it.key()->number() );
            pagesToNotify->insert( it.key()->number() );
        }

        // send page lists to update observers (since some filter on bookmarks)
        foreach(DocumentObserver *observer, m_observers)
            observer->notifySetup( m_pagesVector, 0 );

        // notify observers about highlights changes
        foreach(int pageNumber, *pagesToNotify)
            foreach(DocumentObserver *observer, m_observers)
                observer->notifyPageChanged( pageNumber, DocumentObserver::Highlights );

        if (foundAMatch) emit m_parent->searchFinished( searchID, Document::MatchFound );
        else emit m_parent->searchFinished( searchID, Document::NoMatchFound );

        delete pageMatches;
        delete pagesToNotify;
    }
}

QVariant DocumentPrivate::documentMetaData( const Generator::DocumentMetaDataKey key, const QVariant &option ) const
{
    switch ( key )
    {
        case Generator::PaperColorMetaData:
        {
            bool giveDefault = option.toBool();
            QColor color;
            if ( ( SettingsCore::renderMode() == SettingsCore::EnumRenderMode::Paper )
                && SettingsCore::changeColors() )
            {
                color = SettingsCore::paperColor();
            }
            else if ( giveDefault )
            {
                color = Qt::white;
            }
            return color;
        }
        break;

        case Generator::TextAntialiasMetaData:
            switch ( SettingsCore::textAntialias() )
            {
                case SettingsCore::EnumTextAntialias::Enabled:
                    return true;
                    break;
#if 0
                case Settings::EnumTextAntialias::UseKDESettings:
                    // TODO: read the KDE configuration
                    return true;
                    break;
#endif
                case SettingsCore::EnumTextAntialias::Disabled:
                    return false;
                    break;
            }
        break;

        case Generator::GraphicsAntialiasMetaData:
            switch ( SettingsCore::graphicsAntialias() )
            {
                case SettingsCore::EnumGraphicsAntialias::Enabled:
                    return true;
                    break;
                case SettingsCore::EnumGraphicsAntialias::Disabled:
                    return false;
                    break;
            }
        break;

        case Generator::TextHintingMetaData:
            switch ( SettingsCore::textHinting() )
            {
                case SettingsCore::EnumTextHinting::Enabled:
                    return true;
                    break;
                case SettingsCore::EnumTextHinting::Disabled:
                    return false;
                    break;
            }
        break;
    }
    return QVariant();
}

bool DocumentPrivate::isNormalizedRectangleFullyVisible( const Okular::NormalizedRect & rectOfInterest, int rectPage )
{
    bool rectFullyVisible = false;
    const QVector<Okular::VisiblePageRect *> & visibleRects = m_parent->visiblePageRects();
    QVector<Okular::VisiblePageRect *>::const_iterator vEnd = visibleRects.end();
    QVector<Okular::VisiblePageRect *>::const_iterator vIt = visibleRects.begin();

    for ( ; ( vIt != vEnd ) && !rectFullyVisible; ++vIt )
    {
        if ( (*vIt)->pageNumber == rectPage &&
            (*vIt)->rect.contains( rectOfInterest.left, rectOfInterest.top ) &&
            (*vIt)->rect.contains( rectOfInterest.right, rectOfInterest.bottom ) )
        {
            rectFullyVisible = true;
        }
    }
    return rectFullyVisible;
}

struct pdfsyncpoint
{
    QString file;
    qlonglong x;
    qlonglong y;
    int row;
    int column;
    int page;
};

void DocumentPrivate::loadSyncFile( const QString & filePath )
{
    QFile f( filePath + QLatin1String( ""sync"" ) );
    if ( !f.open( QIODevice::ReadOnly ) )
        return;

    QTextStream ts( &f );
    // first row: core name of the pdf output
    const QString coreName = ts.readLine();
    // second row: version string, in the form 'Version %u'
    QString versionstr = ts.readLine();
    QRegExp versionre( QStringLiteral(""Version (\\d+)"") );
    versionre.setCaseSensitivity( Qt::CaseInsensitive );
    if ( !versionre.exactMatch( versionstr ) )
        return;

    QHash<int, pdfsyncpoint> points;
    QStack<QString> fileStack;
    int currentpage = -1;
    const QLatin1String texStr( "".tex"" );
    const QChar spaceChar = QChar::fromLatin1( ' ' );

    fileStack.push( coreName + texStr );

    const QSizeF dpi = m_generator->dpi();

    QString line;
    while ( !ts.atEnd() )
    {
        line = ts.readLine();
        const QStringList tokens = line.split( spaceChar, QString::SkipEmptyParts );
        const int tokenSize = tokens.count();
        if ( tokenSize < 1 )
            continue;
        if ( tokens.first() == QLatin1String( ""l"" ) && tokenSize >= 3 )
        {
            int id = tokens.at( 1 ).toInt();
            QHash<int, pdfsyncpoint>::const_iterator it = points.constFind( id );
            if ( it == points.constEnd() )
            {
                pdfsyncpoint pt;
                pt.x = 0;
                pt.y = 0;
                pt.row = tokens.at( 2 ).toInt();
                pt.column = 0; // TODO
                pt.page = -1;
                pt.file = fileStack.top();
                points[ id ] = pt;
            }
        }
        else if ( tokens.first() == QLatin1String( ""s"" ) && tokenSize >= 2 )
        {
            currentpage = tokens.at( 1 ).toInt() - 1;
        }
        else if ( tokens.first() == QLatin1String( ""p*"" ) && tokenSize >= 4 )
        {
            // TODO
            qCDebug(OkularCoreDebug) << ""PdfSync: 'p*' line ignored"";
        }
        else if ( tokens.first() == QLatin1String( ""p"" ) && tokenSize >= 4 )
        {
            int id = tokens.at( 1 ).toInt();
            QHash<int, pdfsyncpoint>::iterator it = points.find( id );
            if ( it != points.end() )
            {
                it->x = tokens.at( 2 ).toInt();
                it->y = tokens.at( 3 ).toInt();
                it->page = currentpage;
            }
        }
        else if ( line.startsWith( QLatin1Char( '(' ) ) && tokenSize == 1 )
        {
            QString newfile = line;
            // chop the leading '('
            newfile.remove( 0, 1 );
            if ( !newfile.endsWith( texStr ) )
            {
                newfile += texStr;
            }
            fileStack.push( newfile );
        }
        else if ( line == QLatin1String( "")"" ) )
        {
            if ( !fileStack.isEmpty() )
            {
                fileStack.pop();
            }
            else
               qCDebug(OkularCoreDebug) << ""PdfSync: going one level down too much"";
        }
        else
            qCDebug(OkularCoreDebug).nospace() << ""PdfSync: unknown line format: '"" << line << ""'"";

    }

    QVector< QLinkedList< Okular::SourceRefObjectRect * > > refRects( m_pagesVector.size() );
    foreach ( const pdfsyncpoint& pt, points )
    {
        // drop pdfsync points not completely valid
        if ( pt.page < 0 || pt.page >= m_pagesVector.size() )
            continue;

        // magic numbers for TeX's RSU's (Ridiculously Small Units) conversion to pixels
        Okular::NormalizedPoint p(
            ( pt.x * dpi.width() ) / ( 72.27 * 65536.0 * m_pagesVector[pt.page]->width() ),
            ( pt.y * dpi.height() ) / ( 72.27 * 65536.0 * m_pagesVector[pt.page]->height() )
            );
        QString file = pt.file;
        Okular::SourceReference * sourceRef = new Okular::SourceReference( file, pt.row, pt.column );
        refRects[ pt.page ].append( new Okular::SourceRefObjectRect( p, sourceRef ) );
    }
    for ( int i = 0; i < refRects.size(); ++i )
        if ( !refRects.at(i).isEmpty() )
            m_pagesVector[i]->setSourceReferences( refRects.at(i) );
}

void DocumentPrivate::clearAndWaitForRequests()
{
    m_pixmapRequestsMutex.lock();
    QLinkedList< PixmapRequest * >::const_iterator sIt = m_pixmapRequestsStack.constBegin();
    QLinkedList< PixmapRequest * >::const_iterator sEnd = m_pixmapRequestsStack.constEnd();
    for ( ; sIt != sEnd; ++sIt )
        delete *sIt;
    m_pixmapRequestsStack.clear();
    m_pixmapRequestsMutex.unlock();

    QEventLoop loop;
    bool startEventLoop = false;
    do
    {
        m_pixmapRequestsMutex.lock();
        startEventLoop = !m_executingPixmapRequests.isEmpty();

        if ( m_generator->hasFeature( Generator::SupportsCancelling ) )
        {
            for ( PixmapRequest *executingRequest : qAsConst( m_executingPixmapRequests ) )
                executingRequest->d->mShouldAbortRender = 1;

            if ( m_generator->d_ptr->mTextPageGenerationThread )
                m_generator->d_ptr->mTextPageGenerationThread->abortExtraction();
        }

        m_pixmapRequestsMutex.unlock();
        if ( startEventLoop )
        {
            m_closingLoop = &loop;
            loop.exec();
            m_closingLoop = nullptr;
        }
    }
    while ( startEventLoop );
}

Document::Document( QWidget *widget )
    : QObject( nullptr ), d( new DocumentPrivate( this ) )
{
    d->m_widget = widget;
    d->m_bookmarkManager = new BookmarkManager( d );
    d->m_viewportIterator = d->m_viewportHistory.insert( d->m_viewportHistory.end(), DocumentViewport() );
    d->m_undoStack = new QUndoStack(this);

    connect( SettingsCore::self(), SIGNAL(configChanged()), this, SLOT(_o_configChanged()) );
    connect(d->m_undoStack, &QUndoStack::canUndoChanged, this, &Document::canUndoChanged);
    connect(d->m_undoStack, &QUndoStack::canRedoChanged, this, &Document::canRedoChanged);
    connect(d->m_undoStack, &QUndoStack::cleanChanged, this, &Document::undoHistoryCleanChanged);

    qRegisterMetaType<Okular::FontInfo>();
}

Document::~Document()
{
    // delete generator, pages, and related stuff
    closeDocument();

    QSet< View * >::const_iterator viewIt = d->m_views.constBegin(), viewEnd = d->m_views.constEnd();
    for ( ; viewIt != viewEnd; ++viewIt )
    {
        View *v = *viewIt;
        v->d_func()->document = nullptr;
    }

    // delete the bookmark manager
    delete d->m_bookmarkManager;

    // delete the loaded generators
    QHash< QString, GeneratorInfo >::const_iterator it = d->m_loadedGenerators.constBegin(), itEnd = d->m_loadedGenerators.constEnd();
    for ( ; it != itEnd; ++it )
        d->unloadGenerator( it.value() );
    d->m_loadedGenerators.clear();

    // delete the private structure
    delete d;
}

QString DocumentPrivate::docDataFileName(const QUrl &url, qint64 document_size)
{

    QString fn = url.fileName();
    fn = QString::number( document_size ) + QLatin1Char('.') + fn + QStringLiteral("".xml"");
    QString docdataDir = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation)
            + QStringLiteral(""/okular/docdata"");
    // make sure that the okular/docdata/ directory exists (probably this used to be handled by KStandardDirs)
    if (!QFileInfo::exists(docdataDir))
    {
        qCDebug(OkularCoreDebug) << ""creating docdata folder"" << docdataDir;
        QDir().mkpath(docdataDir);
    }
    QString newokularfile = docdataDir + QLatin1Char('/') + fn;
    // we don't want to accidentally migrate old files when running unit tests
    if (!QFile::exists( newokularfile ) && !QStandardPaths::isTestModeEnabled())
    {
        // see if an KDE4 file still exists
        static Kdelibs4Migration k4migration;
        QString oldfile = k4migration.locateLocal(""data"", QStringLiteral(""okular/docdata/"") + fn);
        if (oldfile.isEmpty())
        {
            oldfile =  k4migration.locateLocal(""data"",  QStringLiteral(""kpdf/"") + fn);
        }
        if ( !oldfile.isEmpty() && QFile::exists( oldfile ) )
        {
            // ### copy or move?
            if ( !QFile::copy( oldfile, newokularfile ) )
                return QString();
        }
    }
    return newokularfile;
}

QVector<KPluginMetaData> DocumentPrivate::availableGenerators()
{
    static QVector<KPluginMetaData> result;
    if (result.isEmpty())
    {
        result = KPluginLoader::findPlugins( QLatin1String ( ""okular/generators"" ) );
    }
    return result;
}

KPluginMetaData DocumentPrivate::generatorForMimeType(const QMimeType& type, QWidget* widget, const QVector<KPluginMetaData> &triedOffers)
{
    // First try to find an exact match, and then look for more general ones (e. g. the plain text one)
    // Ideally we would rank these by ""closeness"", but that might be overdoing it

    const QVector<KPluginMetaData> available = availableGenerators();
    QVector<KPluginMetaData> offers;
    QVector<KPluginMetaData> exactMatches;

    QMimeDatabase mimeDatabase;

    for (const KPluginMetaData& md : available)
    {
        if (triedOffers.contains(md))
            continue;

        foreach (const QString& supported, md.mimeTypes())
        {
            QMimeType mimeType = mimeDatabase.mimeTypeForName(supported);
            if (mimeType == type && !exactMatches.contains(md)) {
                exactMatches << md;
            }

            if (type.inherits(supported) && !offers.contains(md))
            {
                offers << md;
            }
        }
    }

    if (!exactMatches.isEmpty()) {
        offers = exactMatches;
    }

    if (offers.isEmpty())
    {
        return KPluginMetaData();
    }
    int hRank=0;
    // best ranked offer search
    int offercount = offers.size();
    if (offercount > 1)
    {
        // sort the offers: the offers with an higher priority come before
        auto cmp = [](const KPluginMetaData& s1, const KPluginMetaData& s2)
        {
            const QString property = QStringLiteral(""X-KDE-Priority"");
            return s1.rawData()[property].toInt() > s2.rawData()[property].toInt();
        };
        std::stable_sort(offers.begin(), offers.end(), cmp);

        if (SettingsCore::chooseGenerators())
        {
            QStringList list;
            for (int i = 0; i < offercount; ++i)
            {
                list << offers.at(i).pluginId();
            }
            ChooseEngineDialog choose(list, type, widget);

            if (choose.exec() == QDialog::Rejected)
                return KPluginMetaData();

            hRank = choose.selectedGenerator();
        }
    }
    Q_ASSERT(hRank < offers.size());
    return offers.at(hRank);
}

Document::OpenResult Document::openDocument(const QString & docFile, const QUrl &url, const QMimeType &_mime, const QString & password )
{
    QMimeDatabase db;
    QMimeType mime = _mime;
    QByteArray filedata;
    int fd = -1;
    if (url.scheme() == QLatin1String(""fd""))
    {
        bool ok;
        fd = url.path().mid(1).toInt(&ok);
        if (!ok)
        {
            return OpenError;
        }
    }
    else if (url.fileName() == QLatin1String( ""-"" ))
    {
        fd = 0;
    }
    bool triedMimeFromFileContent = false;
    if ( fd < 0 )
    {
        if ( !mime.isValid() )
            return OpenError;

        d->m_url = url;
        d->m_docFileName = docFile;

        if ( !d->updateMetadataXmlNameAndDocSize() )
            return OpenError;
    }
    else
    {
        QFile qstdin;
        const bool ret = qstdin.open( fd, QIODevice::ReadOnly, QFileDevice::AutoCloseHandle );
        if (!ret) {
            qWarning() << ""failed to read"" << url << filedata;
            return OpenError;
        }

        filedata = qstdin.readAll();
        mime = db.mimeTypeForData( filedata );
        if ( !mime.isValid() || mime.isDefault() )
            return OpenError;
        d->m_docSize = filedata.size();
        triedMimeFromFileContent = true;
    }

    const bool fromFileDescriptor = fd >= 0;

    // 0. load Generator
    // request only valid non-disabled plugins suitable for the mimetype
    KPluginMetaData offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget);
    if ( !offer.isValid() && !triedMimeFromFileContent )
    {
        QMimeType newmime = db.mimeTypeForFile(docFile, QMimeDatabase::MatchExtension);
        triedMimeFromFileContent = true;
        if ( newmime != mime )
        {
            mime = newmime;
            offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget);
        }
        if ( !offer.isValid() )
        {
            // There's still no offers, do a final mime search based on the filename
            // We need this because sometimes (e.g. when downloading from a webserver) the mimetype we
            // use is the one fed by the server, that may be wrong
            newmime = db.mimeTypeForUrl( url );

            if ( !newmime.isDefault() && newmime != mime )
            {
                mime = newmime;
                offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget);
            }
        }
    }
    if (!offer.isValid())
    {
        emit error( i18n( ""Can not find a plugin which is able to handle the document being passed."" ), -1 );
        qCWarning(OkularCoreDebug).nospace() << ""No plugin for mimetype '"" << mime.name() << ""'."";
        return OpenError;
    }

    // 1. load Document
    OpenResult openResult = d->openDocumentInternal( offer, fromFileDescriptor, docFile, filedata, password );
    if ( openResult == OpenError )
    {
        QVector<KPluginMetaData> triedOffers;
        triedOffers << offer;
        offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);

        while ( offer.isValid() )
        {
            openResult = d->openDocumentInternal( offer, fromFileDescriptor, docFile, filedata, password );

            if ( openResult == OpenError )
            {
                triedOffers << offer;
                offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);
            }
            else break;
        }

        if (openResult == OpenError && !triedMimeFromFileContent )
        {
            QMimeType newmime = db.mimeTypeForFile(docFile, QMimeDatabase::MatchExtension);
            triedMimeFromFileContent = true;
            if ( newmime != mime )
            {
                mime = newmime;
                offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);
                while ( offer.isValid() )
                {
                    openResult = d->openDocumentInternal( offer, fromFileDescriptor, docFile, filedata, password );

                    if ( openResult == OpenError )
                    {
                        triedOffers << offer;
                        offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);
                    }
                    else break;
                }
            }
        }

        if ( openResult == OpenSuccess )
        {
            // Clear errors, since we're trying various generators, maybe one of them errored out
            // but we finally succeeded
            // TODO one can still see the error message animating out but since this is a very rare
            //      condition we can leave this for future work
            emit error( QString(), -1 );
        }
    }
    if ( openResult != OpenSuccess )
    {
        return openResult;
    }

    // no need to check for the existence of a synctex file, no parser will be
    // created if none exists
    d->m_synctex_scanner = synctex_scanner_new_with_output_file( QFile::encodeName( docFile ).constData(), nullptr, 1);
    if ( !d->m_synctex_scanner && QFile::exists(docFile + QLatin1String( ""sync"" ) ) )
    {
        d->loadSyncFile(docFile);
    }

    d->m_generatorName = offer.pluginId();
    d->m_pageController = new PageController();
    connect( d->m_pageController, SIGNAL(rotationFinished(int,Okular::Page*)),
             this, SLOT(rotationFinished(int,Okular::Page*)) );

    foreach ( Page * p, d->m_pagesVector )
        p->d->m_doc = d;

    d->m_metadataLoadingCompleted = false;
    d->m_docdataMigrationNeeded = false;

    // 2. load Additional Data (bookmarks, local annotations and metadata) about the document
    if ( d->m_archiveData )
    {
        // QTemporaryFile is weird and will return false in exists if fileName wasn't called before
        d->m_archiveData->metadataFile.fileName();
        d->loadDocumentInfo( d->m_archiveData->metadataFile, LoadPageInfo );
        d->loadDocumentInfo( LoadGeneralInfo );
    }
    else
    {
        if ( d->loadDocumentInfo( LoadPageInfo ) )
            d->m_docdataMigrationNeeded = true;
        d->loadDocumentInfo( LoadGeneralInfo );
    }

    d->m_metadataLoadingCompleted = true;
    d->m_bookmarkManager->setUrl( d->m_url );

    // 3. setup observers inernal lists and data
    foreachObserver( notifySetup( d->m_pagesVector, DocumentObserver::DocumentChanged | DocumentObserver::UrlChanged ) );

    // 4. set initial page (restoring the page saved in xml if loaded)
    DocumentViewport loadedViewport = (*d->m_viewportIterator);
    if ( loadedViewport.isValid() )
    {
        (*d->m_viewportIterator) = DocumentViewport();
        if ( loadedViewport.pageNumber >= (int)d->m_pagesVector.size() )
            loadedViewport.pageNumber = d->m_pagesVector.size() - 1;
    }
    else
        loadedViewport.pageNumber = 0;
    setViewport( loadedViewport );

    // start bookmark saver timer
    if ( !d->m_saveBookmarksTimer )
    {
        d->m_saveBookmarksTimer = new QTimer( this );
        connect( d->m_saveBookmarksTimer, SIGNAL(timeout()), this, SLOT(saveDocumentInfo()) );
    }
    d->m_saveBookmarksTimer->start( 5 * 60 * 1000 );

    // start memory check timer
    if ( !d->m_memCheckTimer )
    {
        d->m_memCheckTimer = new QTimer( this );
        connect( d->m_memCheckTimer, SIGNAL(timeout()), this, SLOT(slotTimedMemoryCheck()) );
    }
    d->m_memCheckTimer->start( 2000 );

    const DocumentViewport nextViewport = d->nextDocumentViewport();
    if ( nextViewport.isValid() )
    {
        setViewport( nextViewport );
        d->m_nextDocumentViewport = DocumentViewport();
        d->m_nextDocumentDestination = QString();
    }

    AudioPlayer::instance()->d->m_currentDocument = fromFileDescriptor ? QUrl() : d->m_url;

    const QStringList docScripts = d->m_generator->metaData( QStringLiteral(""DocumentScripts""), QStringLiteral ( ""JavaScript"" ) ).toStringList();
    if ( !docScripts.isEmpty() )
    {
        d->m_scripter = new Scripter( d );
        Q_FOREACH ( const QString &docscript, docScripts )
        {
            d->m_scripter->execute( JavaScript, docscript );
        }
    }

    return OpenSuccess;
}

bool DocumentPrivate::updateMetadataXmlNameAndDocSize()
{
    // m_docFileName is always local so we can use QFileInfo on it
    QFileInfo fileReadTest( m_docFileName );
    if ( !fileReadTest.isFile() && !fileReadTest.isReadable() )
        return false;

    m_docSize = fileReadTest.size();

    // determine the related ""xml document-info"" filename
    if ( m_url.isLocalFile() )
    {
        const QString filePath = docDataFileName( m_url, m_docSize );
        qCDebug(OkularCoreDebug) << ""Metadata file is now:"" << filePath;
        m_xmlFileName = filePath;
    }
    else
    {
        qCDebug(OkularCoreDebug) << ""Metadata file: disabled"";
        m_xmlFileName = QString();
    }

    return true;
}


KXMLGUIClient* Document::guiClient()
{
    if ( d->m_generator )
    {
        Okular::GuiInterface * iface = qobject_cast< Okular::GuiInterface * >( d->m_generator );
        if ( iface )
            return iface->guiClient();
    }
    return nullptr;
}

void Document::closeDocument()
{
    // check if there's anything to close...
    if ( !d->m_generator )
        return;

    delete d->m_pageController;
    d->m_pageController = nullptr;

    delete d->m_scripter;
    d->m_scripter = nullptr;

     // remove requests left in queue
    d->clearAndWaitForRequests();

    if ( d->m_fontThread )
    {
        disconnect( d->m_fontThread, nullptr, this, nullptr );
        d->m_fontThread->stopExtraction();
        d->m_fontThread->wait();
        d->m_fontThread = nullptr;
    }

    // stop any audio playback
    AudioPlayer::instance()->stopPlaybacks();

    // close the current document and save document info if a document is still opened
    if ( d->m_generator && d->m_pagesVector.size() > 0 )
    {
        d->saveDocumentInfo();
        d->m_generator->closeDocument();
    }

    if ( d->m_synctex_scanner )
    {
        synctex_scanner_free( d->m_synctex_scanner );
        d->m_synctex_scanner = nullptr;
    }

    // stop timers
    if ( d->m_memCheckTimer )
        d->m_memCheckTimer->stop();
    if ( d->m_saveBookmarksTimer )
        d->m_saveBookmarksTimer->stop();

    if ( d->m_generator )
    {
        // disconnect the generator from this document ...
        d->m_generator->d_func()->m_document = nullptr;
        // .. and this document from the generator signals
        disconnect( d->m_generator, nullptr, this, nullptr );

        QHash< QString, GeneratorInfo >::const_iterator genIt = d->m_loadedGenerators.constFind( d->m_generatorName );
        Q_ASSERT( genIt != d->m_loadedGenerators.constEnd() );
    }
    d->m_generator = nullptr;
    d->m_generatorName = QString();
    d->m_url = QUrl();
    d->m_walletGenerator = nullptr;
    d->m_docFileName = QString();
    d->m_xmlFileName = QString();
    delete d->m_tempFile;
    d->m_tempFile = nullptr;
    delete d->m_archiveData;
    d->m_archiveData = nullptr;
    d->m_docSize = -1;
    d->m_exportCached = false;
    d->m_exportFormats.clear();
    d->m_exportToText = ExportFormat();
    d->m_fontsCached = false;
    d->m_fontsCache.clear();
    d->m_rotation = Rotation0;

    // send an empty list to observers (to free their data)
    foreachObserver( notifySetup( QVector< Page * >(), DocumentObserver::DocumentChanged | DocumentObserver::UrlChanged ) );

    // delete pages and clear 'd->m_pagesVector' container
    QVector< Page * >::const_iterator pIt = d->m_pagesVector.constBegin();
    QVector< Page * >::const_iterator pEnd = d->m_pagesVector.constEnd();
    for ( ; pIt != pEnd; ++pIt )
        delete *pIt;
    d->m_pagesVector.clear();

    // clear 'memory allocation' descriptors
    qDeleteAll( d->m_allocatedPixmaps );
    d->m_allocatedPixmaps.clear();

    // clear 'running searches' descriptors
    QMap< int, RunningSearch * >::const_iterator rIt = d->m_searches.constBegin();
    QMap< int, RunningSearch * >::const_iterator rEnd = d->m_searches.constEnd();
    for ( ; rIt != rEnd; ++rIt )
        delete *rIt;
    d->m_searches.clear();

    // clear the visible areas and notify the observers
    QVector< VisiblePageRect * >::const_iterator vIt = d->m_pageRects.constBegin();
    QVector< VisiblePageRect * >::const_iterator vEnd = d->m_pageRects.constEnd();
    for ( ; vIt != vEnd; ++vIt )
        delete *vIt;
    d->m_pageRects.clear();
    foreachObserver( notifyVisibleRectsChanged() );

    // reset internal variables

    d->m_viewportHistory.clear();
    d->m_viewportHistory.append( DocumentViewport() );
    d->m_viewportIterator = d->m_viewportHistory.begin();
    d->m_allocatedPixmapsTotalMemory = 0;
    d->m_allocatedTextPagesFifo.clear();
    d->m_pageSize = PageSize();
    d->m_pageSizes.clear();

    d->m_documentInfo = DocumentInfo();
    d->m_documentInfoAskedKeys.clear();

    AudioPlayer::instance()->d->m_currentDocument = QUrl();

    d->m_undoStack->clear();
    d->m_docdataMigrationNeeded = false;

#if HAVE_MALLOC_TRIM
    // trim unused memory, glibc should do this but it seems it does not
    // this can greatly decrease the [perceived] memory consumption of okular
    // see: https://sourceware.org/bugzilla/show_bug.cgi?id=14827
    malloc_trim(0);
#endif
}

void Document::addObserver( DocumentObserver * pObserver )
{
    Q_ASSERT( !d->m_observers.contains( pObserver ) );
    d->m_observers << pObserver;

    // if the observer is added while a document is already opened, tell it
    if ( !d->m_pagesVector.isEmpty() )
    {
        pObserver->notifySetup( d->m_pagesVector, DocumentObserver::DocumentChanged | DocumentObserver::UrlChanged );
        pObserver->notifyViewportChanged( false /*disables smoothMove*/ );
    }
}

void Document::removeObserver( DocumentObserver * pObserver )
{
    // remove observer from the set. it won't receive notifications anymore
    if ( d->m_observers.contains( pObserver ) )
    {
        // free observer's pixmap data
        QVector<Page*>::const_iterator it = d->m_pagesVector.constBegin(), end = d->m_pagesVector.constEnd();
        for ( ; it != end; ++it )
            (*it)->deletePixmap( pObserver );

        // [MEM] free observer's allocation descriptors
        QLinkedList< AllocatedPixmap * >::iterator aIt = d->m_allocatedPixmaps.begin();
        QLinkedList< AllocatedPixmap * >::iterator aEnd = d->m_allocatedPixmaps.end();
        while ( aIt != aEnd )
        {
            AllocatedPixmap * p = *aIt;
            if ( p->observer == pObserver )
            {
                aIt = d->m_allocatedPixmaps.erase( aIt );
                delete p;
            }
            else
                ++aIt;
        }

        for ( PixmapRequest *executingRequest : qAsConst( d->m_executingPixmapRequests ) )
        {
            if ( executingRequest->observer() == pObserver ) {
                d->cancelRenderingBecauseOf( executingRequest, nullptr );
            }
        }

        // remove observer entry from the set
        d->m_observers.remove( pObserver );
    }
}

void Document::reparseConfig()
{
    // reparse generator config and if something changed clear Pages
    bool configchanged = false;
    if ( d->m_generator )
    {
        Okular::ConfigInterface * iface = qobject_cast< Okular::ConfigInterface * >( d->m_generator );
        if ( iface )
            configchanged = iface->reparseConfig();
    }
    if ( configchanged )
    {
        // invalidate pixmaps
        QVector<Page*>::const_iterator it = d->m_pagesVector.constBegin(), end = d->m_pagesVector.constEnd();
        for ( ; it != end; ++it ) {
            (*it)->deletePixmaps();
        }

        // [MEM] remove allocation descriptors
        qDeleteAll( d->m_allocatedPixmaps );
        d->m_allocatedPixmaps.clear();
        d->m_allocatedPixmapsTotalMemory = 0;

        // send reload signals to observers
        foreachObserver( notifyContentsCleared( DocumentObserver::Pixmap ) );
    }

    // free memory if in 'low' profile
    if ( SettingsCore::memoryLevel() == SettingsCore::EnumMemoryLevel::Low &&
         !d->m_allocatedPixmaps.isEmpty() && !d->m_pagesVector.isEmpty() )
        d->cleanupPixmapMemory();
}


bool Document::isOpened() const
{
    return d->m_generator;
}

bool Document::canConfigurePrinter( ) const
{
    if ( d->m_generator )
    {
        Okular::PrintInterface * iface = qobject_cast< Okular::PrintInterface * >( d->m_generator );
        return iface ? true : false;
    }
    else
        return 0;
}

DocumentInfo Document::documentInfo() const
{
    QSet<DocumentInfo::Key> keys;
    for (Okular::DocumentInfo::Key ks = Okular::DocumentInfo::Title;
                                   ks < Okular::DocumentInfo::Invalid;
                                   ks = Okular::DocumentInfo::Key( ks+1 ) )
    {
        keys << ks;
    }

    return documentInfo( keys );
}

DocumentInfo Document::documentInfo( const QSet<DocumentInfo::Key> &keys ) const
{
    DocumentInfo result = d->m_documentInfo;
    const QSet<DocumentInfo::Key> missingKeys = keys - d->m_documentInfoAskedKeys;

    if ( d->m_generator && !missingKeys.isEmpty() )
    {
        DocumentInfo info = d->m_generator->generateDocumentInfo( missingKeys );

        if ( missingKeys.contains( DocumentInfo::FilePath ) )
        {
            info.set( DocumentInfo::FilePath, currentDocument().toDisplayString() );
        }

        if ( d->m_docSize != -1 && missingKeys.contains( DocumentInfo::DocumentSize ) )
        {
            const QString sizeString = KFormat().formatByteSize( d->m_docSize );
            info.set( DocumentInfo::DocumentSize, sizeString );
        }
        if ( missingKeys.contains( DocumentInfo::PagesSize ) )
        {
            const QString pagesSize = d->pagesSizeString();
            if ( !pagesSize.isEmpty() )
            {
                info.set( DocumentInfo::PagesSize, pagesSize );
            }
        }

        if ( missingKeys.contains( DocumentInfo::Pages ) && info.get( DocumentInfo::Pages ).isEmpty() ) {
            info.set( DocumentInfo::Pages, QString::number( this->pages() ) );
        }

        d->m_documentInfo.d->values.unite(info.d->values);
        d->m_documentInfo.d->titles.unite(info.d->titles);
        result.d->values.unite(info.d->values);
        result.d->titles.unite(info.d->titles);
    }
    d->m_documentInfoAskedKeys += keys;

    return result;
}

const DocumentSynopsis * Document::documentSynopsis() const
{
    return d->m_generator ? d->m_generator->generateDocumentSynopsis() : nullptr;
}

void Document::startFontReading()
{
    if ( !d->m_generator || !d->m_generator->hasFeature( Generator::FontInfo ) || d->m_fontThread )
        return;

    if ( d->m_fontsCached )
    {
        // in case we have cached fonts, simulate a reading
        // this way the API is the same, and users no need to care about the
        // internal caching
        for ( int i = 0; i < d->m_fontsCache.count(); ++i )
        {
            emit gotFont( d->m_fontsCache.at( i ) );
            emit fontReadingProgress( i / pages() );
        }
        emit fontReadingEnded();
        return;
    }

    d->m_fontThread = new FontExtractionThread( d->m_generator, pages() );
    connect( d->m_fontThread, SIGNAL(gotFont(Okular::FontInfo)), this, SLOT(fontReadingGotFont(Okular::FontInfo)) );
    connect( d->m_fontThread.data(), SIGNAL(progress(int)), this, SLOT(slotFontReadingProgress(int)) );

    d->m_fontThread->startExtraction( /*d->m_generator->hasFeature( Generator::Threaded )*/true );
}

void Document::stopFontReading()
{
    if ( !d->m_fontThread )
        return;

    disconnect( d->m_fontThread, nullptr, this, nullptr );
    d->m_fontThread->stopExtraction();
    d->m_fontThread = nullptr;
    d->m_fontsCache.clear();
}

bool Document::canProvideFontInformation() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::FontInfo ) : false;
}

const QList<EmbeddedFile*> *Document::embeddedFiles() const
{
    return d->m_generator ? d->m_generator->embeddedFiles() : nullptr;
}

const Page * Document::page( int n ) const
{
    return ( n >= 0 && n < d->m_pagesVector.count() ) ? d->m_pagesVector.at(n) : nullptr;
}

const DocumentViewport & Document::viewport() const
{
    return (*d->m_viewportIterator);
}

const QVector< VisiblePageRect * > & Document::visiblePageRects() const
{
    return d->m_pageRects;
}

void Document::setVisiblePageRects( const QVector< VisiblePageRect * > & visiblePageRects, DocumentObserver *excludeObserver )
{
    QVector< VisiblePageRect * >::const_iterator vIt = d->m_pageRects.constBegin();
    QVector< VisiblePageRect * >::const_iterator vEnd = d->m_pageRects.constEnd();
    for ( ; vIt != vEnd; ++vIt )
        delete *vIt;
    d->m_pageRects = visiblePageRects;
    // notify change to all other (different from id) observers
    foreach(DocumentObserver *o, d->m_observers)
        if ( o != excludeObserver )
            o->notifyVisibleRectsChanged();
}

uint Document::currentPage() const
{
    return (*d->m_viewportIterator).pageNumber;
}

uint Document::pages() const
{
    return d->m_pagesVector.size();
}

QUrl Document::currentDocument() const
{
    return d->m_url;
}

bool Document::isAllowed( Permission action ) const
{
    if ( action == Okular::AllowNotes && ( d->m_docdataMigrationNeeded || !d->m_annotationEditingEnabled ) )
        return false;
    if ( action == Okular::AllowFillForms && d->m_docdataMigrationNeeded )
        return false;

#if !OKULAR_FORCE_DRM
    if ( KAuthorized::authorize( QStringLiteral(""skip_drm"") ) && !SettingsCore::obeyDRM() )
        return true;
#endif

    return d->m_generator ? d->m_generator->isAllowed( action ) : false;
}

bool Document::supportsSearching() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::TextExtraction ) : false;
}

bool Document::supportsPageSizes() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::PageSizes ) : false;
}

bool Document::supportsTiles() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::TiledRendering ) : false;
}

PageSize::List Document::pageSizes() const
{
    if ( d->m_generator )
    {
        if ( d->m_pageSizes.isEmpty() )
            d->m_pageSizes = d->m_generator->pageSizes();
        return d->m_pageSizes;
    }
    return PageSize::List();
}

bool Document::canExportToText() const
{
    if ( !d->m_generator )
        return false;

    d->cacheExportFormats();
    return !d->m_exportToText.isNull();
}

bool Document::exportToText( const QString& fileName ) const
{
    if ( !d->m_generator )
        return false;

    d->cacheExportFormats();
    if ( d->m_exportToText.isNull() )
        return false;

    return d->m_generator->exportTo( fileName, d->m_exportToText );
}

ExportFormat::List Document::exportFormats() const
{
    if ( !d->m_generator )
        return ExportFormat::List();

    d->cacheExportFormats();
    return d->m_exportFormats;
}

bool Document::exportTo( const QString& fileName, const ExportFormat& format ) const
{
    return d->m_generator ? d->m_generator->exportTo( fileName, format ) : false;
}

bool Document::historyAtBegin() const
{
    return d->m_viewportIterator == d->m_viewportHistory.begin();
}

bool Document::historyAtEnd() const
{
    return d->m_viewportIterator == --(d->m_viewportHistory.end());
}

QVariant Document::metaData( const QString & key, const QVariant & option ) const
{
    // if option starts with ""src:"" assume that we are handling a
    // source reference
    if ( key == QLatin1String(""NamedViewport"")
         && option.toString().startsWith( QLatin1String(""src:""), Qt::CaseInsensitive )
         && d->m_synctex_scanner)
    {
        const QString reference = option.toString();

        // The reference is of form ""src:1111Filename"", where ""1111""
        // points to line number 1111 in the file ""Filename"".
        // Extract the file name and the numeral part from the reference string.
        // This will fail if Filename starts with a digit.
        QString name, lineString;
        // Remove ""src:"". Presence of substring has been checked before this
        // function is called.
        name = reference.mid( 4 );
        // split
        int nameLength = name.length();
        int i = 0;
        for( i = 0; i < nameLength; ++i )
        {
            if ( !name[i].isDigit() ) break;
        }
        lineString = name.left( i );
        name = name.mid( i );
        // Remove spaces.
        name = name.trimmed();
        lineString = lineString.trimmed();
        // Convert line to integer.
        bool ok;
        int line = lineString.toInt( &ok );
        if (!ok) line = -1;

        // Use column == -1 for now.
        if( synctex_display_query( d->m_synctex_scanner, QFile::encodeName(name).constData(), line, -1, 0 ) > 0 )
        {
            synctex_node_p node;
            // For now use the first hit. Could possibly be made smarter
            // in case there are multiple hits.
            while( ( node = synctex_scanner_next_result( d->m_synctex_scanner ) ) )
            {
                Okular::DocumentViewport viewport;

                // TeX pages start at 1.
                viewport.pageNumber = synctex_node_page( node ) - 1;

                if ( viewport.pageNumber >= 0 )
                {
                    const QSizeF dpi = d->m_generator->dpi();

                    // TeX small points ...
                    double px = (synctex_node_visible_h( node ) * dpi.width()) / 72.27;
                    double py = (synctex_node_visible_v( node ) * dpi.height()) / 72.27;
                    viewport.rePos.normalizedX = px / page(viewport.pageNumber)->width();
                    viewport.rePos.normalizedY = ( py + 0.5 ) / page(viewport.pageNumber)->height();
                    viewport.rePos.enabled = true;
                    viewport.rePos.pos = Okular::DocumentViewport::Center;

                    return viewport.toString();
                }
            }
        }
    }
    return d->m_generator ? d->m_generator->metaData( key, option ) : QVariant();
}

Rotation Document::rotation() const
{
    return d->m_rotation;
}

QSizeF Document::allPagesSize() const
{
    bool allPagesSameSize = true;
    QSizeF size;
    for (int i = 0; allPagesSameSize && i < d->m_pagesVector.count(); ++i)
    {
        const Page *p = d->m_pagesVector.at(i);
        if (i == 0) size = QSizeF(p->width(), p->height());
        else
        {
            allPagesSameSize = (size == QSizeF(p->width(), p->height()));
        }
    }
    if (allPagesSameSize) return size;
    else return QSizeF();
}

QString Document::pageSizeString(int page) const
{
    if (d->m_generator)
    {
        if (d->m_generator->pagesSizeMetric() != Generator::None)
        {
            const Page *p = d->m_pagesVector.at( page );
            return d->localizedSize(QSizeF(p->width(), p->height()));
        }
    }
    return QString();
}

static bool shouldCancelRenderingBecauseOf( const PixmapRequest & executingRequest, const PixmapRequest & otherRequest )
{
    // New request has higher priority -> cancel
    if ( executingRequest.priority() > otherRequest.priority() )
        return true;

    // New request has lower priority -> don't cancel
    if ( executingRequest.priority() < otherRequest.priority() )
        return false;

    // New request has same priority and is from a different observer -> don't cancel
    // AFAIK this never happens since all observers have different priorities
    if ( executingRequest.observer() != otherRequest.observer() )
        return false;

    // Same priority and observer, different page number -> don't cancel
    // may still end up cancelled later in the parent caller if none of the requests
    // is of the executingRequest page and RemoveAllPrevious is specified
    if ( executingRequest.pageNumber() != otherRequest.pageNumber() )
        return false;

    // Same priority, observer, page, different size -> cancel
    if ( executingRequest.width() != otherRequest.width() )
        return true;

    // Same priority, observer, page, different size -> cancel
    if ( executingRequest.height() != otherRequest.height() )
        return true;

    // Same priority, observer, page, different tiling -> cancel
    if ( executingRequest.isTile() != otherRequest.isTile() )
        return true;

    // Same priority, observer, page, different tiling -> cancel
    if ( executingRequest.isTile() )
    {
        const NormalizedRect bothRequestsRect = executingRequest.normalizedRect() | otherRequest.normalizedRect();
        if ( !( bothRequestsRect == executingRequest.normalizedRect() ) )
            return true;
    }

    return false;
}

bool DocumentPrivate::cancelRenderingBecauseOf( PixmapRequest *executingRequest, PixmapRequest *newRequest )
{
    // No point in aborting the rendering already finished, let it go through
    if ( !executingRequest->d->mResultImage.isNull() )
        return false;

    if ( newRequest && newRequest->asynchronous() && executingRequest->partialUpdatesWanted() ) {
        newRequest->setPartialUpdatesWanted( true );
    }

    TilesManager *tm = executingRequest->d->tilesManager();
    if ( tm )
    {
        tm->setPixmap( nullptr, executingRequest->normalizedRect(), true /*isPartialPixmap*/ );
        tm->setRequest( NormalizedRect(), 0, 0 );
    }
    PagePrivate::PixmapObject object = executingRequest->page()->d->m_pixmaps.take( executingRequest->observer() );
    delete object.m_pixmap;

    if ( executingRequest->d->mShouldAbortRender != 0)
        return false;

    executingRequest->d->mShouldAbortRender = 1;

    if ( m_generator->d_ptr->mTextPageGenerationThread && m_generator->d_ptr->mTextPageGenerationThread->page() == executingRequest->page() )
    {
        m_generator->d_ptr->mTextPageGenerationThread->abortExtraction();
    }

    return true;
}

void Document::requestPixmaps( const QLinkedList< PixmapRequest * > & requests )
{
    requestPixmaps( requests, RemoveAllPrevious );
}

void Document::requestPixmaps( const QLinkedList< PixmapRequest * > & requests, PixmapRequestFlags reqOptions )
{
    if ( requests.isEmpty() )
        return;

    if ( !d->m_pageController )
    {
        // delete requests..
        QLinkedList< PixmapRequest * >::const_iterator rIt = requests.constBegin(), rEnd = requests.constEnd();
        for ( ; rIt != rEnd; ++rIt )
            delete *rIt;
        // ..and return
        return;
    }

    QSet< DocumentObserver * > observersPixmapCleared;

    // 1. [CLEAN STACK] remove previous requests of requesterID
    DocumentObserver *requesterObserver = requests.first()->observer();
    QSet< int > requestedPages;
    {
        QLinkedList< PixmapRequest * >::const_iterator rIt = requests.constBegin(), rEnd = requests.constEnd();
        for ( ; rIt != rEnd; ++rIt )
        {
            Q_ASSERT( (*rIt)->observer() == requesterObserver );
            requestedPages.insert( (*rIt)->pageNumber() );
        }
    }
    const bool removeAllPrevious = reqOptions & RemoveAllPrevious;
    d->m_pixmapRequestsMutex.lock();
    QLinkedList< PixmapRequest * >::iterator sIt = d->m_pixmapRequestsStack.begin(), sEnd = d->m_pixmapRequestsStack.end();
    while ( sIt != sEnd )
    {
        if ( (*sIt)->observer() == requesterObserver
             && ( removeAllPrevious || requestedPages.contains( (*sIt)->pageNumber() ) ) )
        {
            // delete request and remove it from stack
            delete *sIt;
            sIt = d->m_pixmapRequestsStack.erase( sIt );
        }
        else
            ++sIt;
    }

    // 1.B [PREPROCESS REQUESTS] tweak some values of the requests
    for ( PixmapRequest *request : requests )
    {
        // set the 'page field' (see PixmapRequest) and check if it is valid
        qCDebug(OkularCoreDebug).nospace() << ""request observer="" << request->observer() << "" "" <<request->width() << ""x"" << request->height() << ""@"" << request->pageNumber();
        if ( d->m_pagesVector.value( request->pageNumber() ) == 0 )
        {
            // skip requests referencing an invalid page (must not happen)
            delete request;
            continue;
        }

        request->d->mPage = d->m_pagesVector.value( request->pageNumber() );

        if ( request->isTile() )
        {
            // Change the current request rect so that only invalid tiles are
            // requested. Also make sure the rect is tile-aligned.
            NormalizedRect tilesRect;
            const QList<Tile> tiles = request->d->tilesManager()->tilesAt( request->normalizedRect(), TilesManager::TerminalTile );
            QList<Tile>::const_iterator tIt = tiles.constBegin(), tEnd = tiles.constEnd();
            while ( tIt != tEnd )
            {
                const Tile &tile = *tIt;
                if ( !tile.isValid() )
                {
                    if ( tilesRect.isNull() )
                        tilesRect = tile.rect();
                    else
                        tilesRect |= tile.rect();
                }

                tIt++;
            }

            request->setNormalizedRect( tilesRect );
        }

        if ( !request->asynchronous() )
            request->d->mPriority = 0;
    }

    // 1.C [CANCEL REQUESTS] cancel those requests that are running and should be cancelled because of the new requests coming in
    if ( d->m_generator->hasFeature( Generator::SupportsCancelling ) )
    {
        for ( PixmapRequest *executingRequest : qAsConst( d->m_executingPixmapRequests ) )
        {
            bool newRequestsContainExecutingRequestPage = false;
            bool requestCancelled = false;
            for ( PixmapRequest *newRequest : requests )
            {
                if ( newRequest->pageNumber() == executingRequest->pageNumber() && requesterObserver == executingRequest->observer())
                {
                    newRequestsContainExecutingRequestPage = true;
                }

                if ( shouldCancelRenderingBecauseOf( *executingRequest, *newRequest ) )
                {
                    requestCancelled = d->cancelRenderingBecauseOf( executingRequest, newRequest );
                }
            }

            // If we were told to remove all the previous requests and the executing request page is not part of the new requests, cancel it
            if ( !requestCancelled && removeAllPrevious && requesterObserver == executingRequest->observer() && !newRequestsContainExecutingRequestPage )
            {
                requestCancelled = d->cancelRenderingBecauseOf( executingRequest, nullptr );
            }

            if ( requestCancelled )
            {
                observersPixmapCleared << executingRequest->observer();
            }
        }
    }

    // 2. [ADD TO STACK] add requests to stack
    for ( PixmapRequest *request : requests )
    {
        // add request to the 'stack' at the right place
        if ( !request->priority() )
            // add priority zero requests to the top of the stack
            d->m_pixmapRequestsStack.append( request );
        else
        {
            // insert in stack sorted by priority
            sIt = d->m_pixmapRequestsStack.begin();
            sEnd = d->m_pixmapRequestsStack.end();
            while ( sIt != sEnd && (*sIt)->priority() > request->priority() )
                ++sIt;
            d->m_pixmapRequestsStack.insert( sIt, request );
        }
    }
    d->m_pixmapRequestsMutex.unlock();

    // 3. [START FIRST GENERATION] if <NO>generator is ready, start a new generation,
    // or else (if gen is running) it will be started when the new contents will
    //come from generator (in requestDone())</NO>
    // all handling of requests put into sendGeneratorPixmapRequest
    //    if ( generator->canRequestPixmap() )
        d->sendGeneratorPixmapRequest();

    for ( DocumentObserver *o : qAsConst( observersPixmapCleared ) )
        o->notifyContentsCleared( Okular::DocumentObserver::Pixmap );
}

void Document::requestTextPage( uint page )
{
    Page * kp = d->m_pagesVector[ page ];
    if ( !d->m_generator || !kp )
        return;

    // Memory management for TextPages

    d->m_generator->generateTextPage( kp );
}

void DocumentPrivate::notifyAnnotationChanges( int page )
{
    foreachObserverD( notifyPageChanged( page, DocumentObserver::Annotations ) );
}

void DocumentPrivate::notifyFormChanges( int /*page*/ )
{
    recalculateForms();
}

void Document::addPageAnnotation( int page, Annotation * annotation )
{
    // Transform annotation's base boundary rectangle into unrotated coordinates
    Page *p = d->m_pagesVector[page];
    QTransform t = p->d->rotationMatrix();
    annotation->d_ptr->baseTransform(t.inverted());
    QUndoCommand *uc = new AddAnnotationCommand(this->d, annotation, page);
    d->m_undoStack->push(uc);
}

bool Document::canModifyPageAnnotation( const Annotation * annotation ) const
{
    if ( !annotation || ( annotation->flags() & Annotation::DenyWrite ) )
        return false;

    if ( !isAllowed(Okular::AllowNotes) )
        return false;

    if ( ( annotation->flags() & Annotation::External ) && !d->canModifyExternalAnnotations() )
        return false;

    switch ( annotation->subType() )
    {
        case Annotation::AText:
        case Annotation::ALine:
        case Annotation::AGeom:
        case Annotation::AHighlight:
        case Annotation::AStamp:
        case Annotation::AInk:
            return true;
        default:
            return false;
    }
}

void Document::prepareToModifyAnnotationProperties( Annotation * annotation )
{
    Q_ASSERT(d->m_prevPropsOfAnnotBeingModified.isNull());
    if (!d->m_prevPropsOfAnnotBeingModified.isNull())
    {
        qCCritical(OkularCoreDebug) << ""Error: Document::prepareToModifyAnnotationProperties has already been called since last call to Document::modifyPageAnnotationProperties"";
        return;
    }
    d->m_prevPropsOfAnnotBeingModified = annotation->getAnnotationPropertiesDomNode();
}

void Document::modifyPageAnnotationProperties( int page, Annotation * annotation )
{
    Q_ASSERT(!d->m_prevPropsOfAnnotBeingModified.isNull());
    if (d->m_prevPropsOfAnnotBeingModified.isNull())
    {
        qCCritical(OkularCoreDebug) << ""Error: Document::prepareToModifyAnnotationProperties must be called before Annotation is modified"";
        return;
    }
    QDomNode prevProps = d->m_prevPropsOfAnnotBeingModified;
    QUndoCommand *uc = new Okular::ModifyAnnotationPropertiesCommand( d,
                                                                      annotation,
                                                                      page,
                                                                      prevProps,
                                                                      annotation->getAnnotationPropertiesDomNode() );
    d->m_undoStack->push( uc );
    d->m_prevPropsOfAnnotBeingModified.clear();
}

void Document::translatePageAnnotation(int page, Annotation* annotation, const NormalizedPoint & delta )
{
    int complete = (annotation->flags() & Okular::Annotation::BeingMoved) == 0;
    QUndoCommand *uc = new Okular::TranslateAnnotationCommand( d, annotation, page, delta, complete );
    d->m_undoStack->push(uc);
}

void Document::adjustPageAnnotation( int page, Annotation *annotation, const Okular::NormalizedPoint & delta1, const Okular::NormalizedPoint & delta2 )
{
    const bool complete = (annotation->flags() & Okular::Annotation::BeingResized) == 0;
    QUndoCommand *uc = new Okular::AdjustAnnotationCommand( d, annotation, page, delta1, delta2, complete );
    d->m_undoStack->push(uc);
}

void Document::editPageAnnotationContents( int page, Annotation* annotation,
                                           const QString & newContents,
                                           int newCursorPos,
                                           int prevCursorPos,
                                           int prevAnchorPos
                                         )
{
    QString prevContents = annotation->contents();
    QUndoCommand *uc = new EditAnnotationContentsCommand( d, annotation, page, newContents, newCursorPos,
                                                            prevContents, prevCursorPos, prevAnchorPos );
    d->m_undoStack->push( uc );
}

bool Document::canRemovePageAnnotation( const Annotation * annotation ) const
{
    if ( !annotation || ( annotation->flags() & Annotation::DenyDelete ) )
        return false;

    if ( ( annotation->flags() & Annotation::External ) && !d->canRemoveExternalAnnotations() )
        return false;

    switch ( annotation->subType() )
    {
        case Annotation::AText:
        case Annotation::ALine:
        case Annotation::AGeom:
        case Annotation::AHighlight:
        case Annotation::AStamp:
        case Annotation::AInk:
        case Annotation::ACaret:
            return true;
        default:
            return false;
    }
}

void Document::removePageAnnotation( int page, Annotation * annotation )
{
    QUndoCommand *uc = new RemoveAnnotationCommand(this->d, annotation, page);
    d->m_undoStack->push(uc);
}

void Document::removePageAnnotations( int page, const QList<Annotation*> &annotations )
{
    d->m_undoStack->beginMacro(i18nc(""remove a collection of annotations from the page"", ""remove annotations""));
    foreach(Annotation* annotation, annotations)
    {
        QUndoCommand *uc = new RemoveAnnotationCommand(this->d, annotation, page);
        d->m_undoStack->push(uc);
    }
    d->m_undoStack->endMacro();
}

bool DocumentPrivate::canAddAnnotationsNatively() const
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );

    if ( iface && iface->supportsOption(Okular::SaveInterface::SaveChanges) &&
         iface->annotationProxy() && iface->annotationProxy()->supports(AnnotationProxy::Addition) )
        return true;

    return false;
}

bool DocumentPrivate::canModifyExternalAnnotations() const
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );

    if ( iface && iface->supportsOption(Okular::SaveInterface::SaveChanges) &&
         iface->annotationProxy() && iface->annotationProxy()->supports(AnnotationProxy::Modification) )
        return true;

    return false;
}

bool DocumentPrivate::canRemoveExternalAnnotations() const
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );

    if ( iface && iface->supportsOption(Okular::SaveInterface::SaveChanges) &&
         iface->annotationProxy() && iface->annotationProxy()->supports(AnnotationProxy::Removal) )
        return true;

    return false;
}

void Document::setPageTextSelection( int page, RegularAreaRect * rect, const QColor & color )
{
    Page * kp = d->m_pagesVector[ page ];
    if ( !d->m_generator || !kp )
        return;

    // add or remove the selection basing whether rect is null or not
    if ( rect )
        kp->d->setTextSelections( rect, color );
    else
        kp->d->deleteTextSelections();

    // notify observers about the change
    foreachObserver( notifyPageChanged( page, DocumentObserver::TextSelection ) );
}

bool Document::canUndo() const
{
    return d->m_undoStack->canUndo();
}

bool Document::canRedo() const
{
    return d->m_undoStack->canRedo();
}

/* REFERENCE IMPLEMENTATION: better calling setViewport from other code
void Document::setNextPage()
{
    // advance page and set viewport on observers
    if ( (*d->m_viewportIterator).pageNumber < (int)d->m_pagesVector.count() - 1 )
        setViewport( DocumentViewport( (*d->m_viewportIterator).pageNumber + 1 ) );
}

void Document::setPrevPage()
{
    // go to previous page and set viewport on observers
    if ( (*d->m_viewportIterator).pageNumber > 0 )
        setViewport( DocumentViewport( (*d->m_viewportIterator).pageNumber - 1 ) );
}
*/
void Document::setViewportPage( int page, DocumentObserver *excludeObserver, bool smoothMove )
{
    // clamp page in range [0 ... numPages-1]
    if ( page < 0 )
        page = 0;
    else if ( page > (int)d->m_pagesVector.count() )
        page = d->m_pagesVector.count() - 1;

    // make a viewport from the page and broadcast it
    setViewport( DocumentViewport( page ), excludeObserver, smoothMove );
}

void Document::setViewport( const DocumentViewport & viewport, DocumentObserver *excludeObserver, bool smoothMove )
{
    if ( !viewport.isValid() )
    {
        qCDebug(OkularCoreDebug) << ""invalid viewport:"" << viewport.toString();
        return;
    }
    if ( viewport.pageNumber >= int(d->m_pagesVector.count()) )
    {
        //qCDebug(OkularCoreDebug) << ""viewport out of document:"" << viewport.toString();
        return;
    }

    // if already broadcasted, don't redo it
    DocumentViewport & oldViewport = *d->m_viewportIterator;
    // disabled by enrico on 2005-03-18 (less debug output)
    //if ( viewport == oldViewport )
    //    qCDebug(OkularCoreDebug) << ""setViewport with the same viewport."";

    const int oldPageNumber = oldViewport.pageNumber;

    // set internal viewport taking care of history
    if ( oldViewport.pageNumber == viewport.pageNumber || !oldViewport.isValid() )
    {
        // if page is unchanged save the viewport at current position in queue
        oldViewport = viewport;
    }
    else
    {
        // remove elements after viewportIterator in queue
        d->m_viewportHistory.erase( ++d->m_viewportIterator, d->m_viewportHistory.end() );

        // keep the list to a reasonable size by removing head when needed
        if ( d->m_viewportHistory.count() >= OKULAR_HISTORY_MAXSTEPS )
            d->m_viewportHistory.pop_front();

        // add the item at the end of the queue
        d->m_viewportIterator = d->m_viewportHistory.insert( d->m_viewportHistory.end(), viewport );
    }

    const int currentViewportPage = (*d->m_viewportIterator).pageNumber;

    const bool currentPageChanged = (oldPageNumber != currentViewportPage);

    // notify change to all other (different from id) observers
    foreach(DocumentObserver *o, d->m_observers)
    {
        if ( o != excludeObserver )
            o->notifyViewportChanged( smoothMove );

        if ( currentPageChanged )
            o->notifyCurrentPageChanged( oldPageNumber, currentViewportPage );
    }
}

void Document::setZoom(int factor, DocumentObserver *excludeObserver)
{
    // notify change to all other (different from id) observers
    foreach(DocumentObserver *o, d->m_observers)
        if (o != excludeObserver)
            o->notifyZoom( factor );
}

void Document::setPrevViewport()
// restore viewport from the history
{
    if ( d->m_viewportIterator != d->m_viewportHistory.begin() )
    {
        const int oldViewportPage = (*d->m_viewportIterator).pageNumber;

        // restore previous viewport and notify it to observers
        --d->m_viewportIterator;
        foreachObserver( notifyViewportChanged( true ) );

        const int currentViewportPage = (*d->m_viewportIterator).pageNumber;
        if (oldViewportPage != currentViewportPage)
            foreachObserver( notifyCurrentPageChanged( oldViewportPage, currentViewportPage ) );
    }
}

void Document::setNextViewport()
// restore next viewport from the history
{
    QLinkedList< DocumentViewport >::const_iterator nextIterator = d->m_viewportIterator;
    ++nextIterator;
    if ( nextIterator != d->m_viewportHistory.end() )
    {
        const int oldViewportPage = (*d->m_viewportIterator).pageNumber;

        // restore next viewport and notify it to observers
        ++d->m_viewportIterator;
        foreachObserver( notifyViewportChanged( true ) );

        const int currentViewportPage = (*d->m_viewportIterator).pageNumber;
        if (oldViewportPage != currentViewportPage)
            foreachObserver( notifyCurrentPageChanged( oldViewportPage, currentViewportPage ) );
    }
}

void Document::setNextDocumentViewport( const DocumentViewport & viewport )
{
    d->m_nextDocumentViewport = viewport;
}

void Document::setNextDocumentDestination( const QString &namedDestination )
{
    d->m_nextDocumentDestination = namedDestination;
}

void Document::searchText( int searchID, const QString & text, bool fromStart, Qt::CaseSensitivity caseSensitivity,
                               SearchType type, bool moveViewport, const QColor & color )
{
    d->m_searchCancelled = false;

    // safety checks: don't perform searches on empty or unsearchable docs
    if ( !d->m_generator || !d->m_generator->hasFeature( Generator::TextExtraction ) || d->m_pagesVector.isEmpty() )
    {
        emit searchFinished( searchID, NoMatchFound );
        return;
    }

    // if searchID search not recorded, create new descriptor and init params
    QMap< int, RunningSearch * >::iterator searchIt = d->m_searches.find( searchID );
    if ( searchIt == d->m_searches.end() )
    {
        RunningSearch * search = new RunningSearch();
        search->continueOnPage = -1;
        searchIt = d->m_searches.insert( searchID, search );
    }
    RunningSearch * s = *searchIt;

    // update search structure
    bool newText = text != s->cachedString;
    s->cachedString = text;
    s->cachedType = type;
    s->cachedCaseSensitivity = caseSensitivity;
    s->cachedViewportMove = moveViewport;
    s->cachedColor = color;
    s->isCurrentlySearching = true;

    // global data for search
    QSet< int > *pagesToNotify = new QSet< int >;

    // remove highlights from pages and queue them for notifying changes
    *pagesToNotify += s->highlightedPages;
    foreach(int pageNumber, s->highlightedPages)
        d->m_pagesVector.at(pageNumber)->d->deleteHighlights( searchID );
    s->highlightedPages.clear();

    // set hourglass cursor
    QApplication::setOverrideCursor( Qt::WaitCursor );

    // 1. ALLDOC - proces all document marking pages
    if ( type == AllDocument )
    {
        QMap< Page *, QVector<RegularAreaRect *> > *pageMatches = new QMap< Page *, QVector<RegularAreaRect *> >;

        // search and highlight 'text' (as a solid phrase) on all pages
        QMetaObject::invokeMethod(this, ""doContinueAllDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotify), Q_ARG(void *, pageMatches), Q_ARG(int, 0), Q_ARG(int, searchID));
    }
    // 2. NEXTMATCH - find next matching item (or start from top)
    // 3. PREVMATCH - find previous matching item (or start from bottom)
    else if ( type == NextMatch || type == PreviousMatch )
    {
        // find out from where to start/resume search from
        const bool forward = type == NextMatch;
        const int viewportPage = (*d->m_viewportIterator).pageNumber;
        const int fromStartSearchPage = forward ? 0 : d->m_pagesVector.count() - 1;
        int currentPage = fromStart ? fromStartSearchPage : ((s->continueOnPage != -1) ? s->continueOnPage : viewportPage);
        Page * lastPage = fromStart ? 0 : d->m_pagesVector[ currentPage ];
        int pagesDone = 0;

        // continue checking last TextPage first (if it is the current page)
        RegularAreaRect * match = nullptr;
        if ( lastPage && lastPage->number() == s->continueOnPage )
        {
            if ( newText )
                match = lastPage->findText( searchID, text, forward ? FromTop : FromBottom, caseSensitivity );
            else
                match = lastPage->findText( searchID, text, forward ? NextResult : PreviousResult, caseSensitivity, &s->continueOnMatch );
            if ( !match )
            {
                if (forward) currentPage++;
                else currentPage--;
                pagesDone++;
            }
        }

        s->pagesDone = pagesDone;

        DoContinueDirectionMatchSearchStruct *searchStruct = new DoContinueDirectionMatchSearchStruct();
        searchStruct->pagesToNotify = pagesToNotify;
        searchStruct->match = match;
        searchStruct->currentPage = currentPage;
        searchStruct->searchID = searchID;

        QMetaObject::invokeMethod(this, ""doContinueDirectionMatchSearch"", Qt::QueuedConnection, Q_ARG(void *, searchStruct));
    }
    // 4. GOOGLE* - process all document marking pages
    else if ( type == GoogleAll || type == GoogleAny )
    {
        QMap< Page *, QVector< QPair<RegularAreaRect *, QColor> > > *pageMatches = new QMap< Page *, QVector<QPair<RegularAreaRect *, QColor> > >;
        const QStringList words = text.split( QLatin1Char ( ' ' ), QString::SkipEmptyParts );

        // search and highlight every word in 'text' on all pages
        QMetaObject::invokeMethod(this, ""doContinueGooglesDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotify), Q_ARG(void *, pageMatches), Q_ARG(int, 0), Q_ARG(int, searchID), Q_ARG(QStringList, words));
    }
}

void Document::continueSearch( int searchID )
{
    // check if searchID is present in runningSearches
    QMap< int, RunningSearch * >::const_iterator it = d->m_searches.constFind( searchID );
    if ( it == d->m_searches.constEnd() )
    {
        emit searchFinished( searchID, NoMatchFound );
        return;
    }

    // start search with cached parameters from last search by searchID
    RunningSearch * p = *it;
    if ( !p->isCurrentlySearching )
        searchText( searchID, p->cachedString, false, p->cachedCaseSensitivity,
                    p->cachedType, p->cachedViewportMove, p->cachedColor );
}

void Document::continueSearch( int searchID, SearchType type )
{
    // check if searchID is present in runningSearches
    QMap< int, RunningSearch * >::const_iterator it = d->m_searches.constFind( searchID );
    if ( it == d->m_searches.constEnd() )
    {
        emit searchFinished( searchID, NoMatchFound );
        return;
    }

    // start search with cached parameters from last search by searchID
    RunningSearch * p = *it;
    if ( !p->isCurrentlySearching )
        searchText( searchID, p->cachedString, false, p->cachedCaseSensitivity,
                    type, p->cachedViewportMove, p->cachedColor );
}

void Document::resetSearch( int searchID )
{
    // if we are closing down, don't bother doing anything
    if ( !d->m_generator )
        return;

    // check if searchID is present in runningSearches
    QMap< int, RunningSearch * >::iterator searchIt = d->m_searches.find( searchID );
    if ( searchIt == d->m_searches.end() )
        return;

    // get previous parameters for search
    RunningSearch * s = *searchIt;

    // unhighlight pages and inform observers about that
    foreach(int pageNumber, s->highlightedPages)
    {
        d->m_pagesVector.at(pageNumber)->d->deleteHighlights( searchID );
        foreachObserver( notifyPageChanged( pageNumber, DocumentObserver::Highlights ) );
    }

    // send the setup signal too (to update views that filter on matches)
    foreachObserver( notifySetup( d->m_pagesVector, 0 ) );

    // remove serch from the runningSearches list and delete it
    d->m_searches.erase( searchIt );
    delete s;
}

void Document::cancelSearch()
{
    d->m_searchCancelled = true;
}

void Document::undo()
{
    d->m_undoStack->undo();
}

void Document::redo()
{
    d->m_undoStack->redo();
}

void Document::editFormText( int pageNumber,
                             Okular::FormFieldText* form,
                             const QString & newContents,
                             int newCursorPos,
                             int prevCursorPos,
                             int prevAnchorPos )
{
    QUndoCommand *uc = new EditFormTextCommand( this->d, form, pageNumber, newContents, newCursorPos, form->text(), prevCursorPos, prevAnchorPos );
    d->m_undoStack->push( uc );
}

void Document::editFormList( int pageNumber,
                             FormFieldChoice* form,
                             const QList< int > & newChoices )
{
    const QList< int > prevChoices = form->currentChoices();
    QUndoCommand *uc = new EditFormListCommand( this->d, form, pageNumber, newChoices, prevChoices );
    d->m_undoStack->push( uc );
}

void Document::editFormCombo( int pageNumber,
                              FormFieldChoice* form,
                              const QString & newText,
                              int newCursorPos,
                              int prevCursorPos,
                              int prevAnchorPos )
{

    QString prevText;
    if ( form->currentChoices().isEmpty() )
    {
        prevText = form->editChoice();
    }
    else
    {
        prevText = form->choices()[form->currentChoices().constFirst()];
    }

    QUndoCommand *uc = new EditFormComboCommand( this->d, form, pageNumber, newText, newCursorPos, prevText, prevCursorPos, prevAnchorPos );
    d->m_undoStack->push( uc );
}

void Document::editFormButtons( int pageNumber, const QList< FormFieldButton* >& formButtons, const QList< bool >& newButtonStates )
{
    QUndoCommand *uc = new EditFormButtonsCommand( this->d, pageNumber, formButtons, newButtonStates );
    d->m_undoStack->push( uc );
}

void Document::reloadDocument() const
{
    const int numOfPages = pages();
    for( int i = currentPage(); i >= 0; i -- )
        d->refreshPixmaps( i );
    for( int i = currentPage() + 1; i < numOfPages; i ++ )
        d->refreshPixmaps( i );
}

BookmarkManager * Document::bookmarkManager() const
{
    return d->m_bookmarkManager;
}

QList<int> Document::bookmarkedPageList() const
{
    QList<int> list;
    uint docPages = pages();

    //pages are 0-indexed internally, but 1-indexed externally
    for ( uint i = 0; i < docPages; i++ )
    {
        if ( bookmarkManager()->isBookmarked( i ) )
        {
            list << i + 1;
        }
    }
    return list;
}

QString Document::bookmarkedPageRange() const
{
    // Code formerly in Part::slotPrint()
    // range detecting
    QString range;
    uint docPages = pages();
    int startId = -1;
    int endId = -1;

    for ( uint i = 0; i < docPages; ++i )
    {
        if ( bookmarkManager()->isBookmarked( i ) )
        {
            if ( startId < 0 )
                startId = i;
            if ( endId < 0 )
                endId = startId;
            else
                ++endId;
        }
        else if ( startId >= 0 && endId >= 0 )
        {
            if ( !range.isEmpty() )
                range += QLatin1Char ( ',' );

            if ( endId - startId > 0 )
                range += QStringLiteral( ""%1-%2"" ).arg( startId + 1 ).arg( endId + 1 );
            else
                range += QString::number( startId + 1 );
            startId = -1;
            endId = -1;
        }
    }
    if ( startId >= 0 && endId >= 0 )
    {
        if ( !range.isEmpty() )
            range += QLatin1Char ( ',' );

        if ( endId - startId > 0 )
            range += QStringLiteral( ""%1-%2"" ).arg( startId + 1 ).arg( endId + 1 );
        else
            range += QString::number( startId + 1 );
    }
    return range;
}

void Document::processAction( const Action * action )
{
    if ( !action )
        return;

    switch( action->actionType() )
    {
        case Action::Goto: {
            const GotoAction * go = static_cast< const GotoAction * >( action );
            d->m_nextDocumentViewport = go->destViewport();
            d->m_nextDocumentDestination = go->destinationName();

            // Explanation of why d->m_nextDocumentViewport is needed:
            // all openRelativeFile does is launch a signal telling we
            // want to open another URL, the problem is that when the file is
            // non local, the loading is done assynchronously so you can't
            // do a setViewport after the if as it was because you are doing the setViewport
            // on the old file and when the new arrives there is no setViewport for it and
            // it does not show anything

            // first open filename if link is pointing outside this document
            if ( go->isExternal() && !d->openRelativeFile( go->fileName() ) )
            {
                qCWarning(OkularCoreDebug).nospace() << ""Action: Error opening '"" << go->fileName() << ""'."";
                break;
            }
            else
            {
                const DocumentViewport nextViewport = d->nextDocumentViewport();
                // skip local links that point to nowhere (broken ones)
                if ( !nextViewport.isValid() )
                    break;

                setViewport( nextViewport, nullptr, true );
                d->m_nextDocumentViewport = DocumentViewport();
                d->m_nextDocumentDestination = QString();
            }

            } break;

        case Action::Execute: {
            const ExecuteAction * exe  = static_cast< const ExecuteAction * >( action );
            const QString fileName = exe->fileName();
            if ( fileName.endsWith( QLatin1String("".pdf""), Qt::CaseInsensitive ) )
            {
                d->openRelativeFile( fileName );
                break;
            }

            // Albert: the only pdf i have that has that kind of link don't define
            // an application and use the fileName as the file to open
            QUrl url = d->giveAbsoluteUrl( fileName );
            QMimeDatabase db;
            QMimeType mime = db.mimeTypeForUrl( url );
            // Check executables
            if ( KRun::isExecutableFile( url, mime.name() ) )
            {
                // Don't have any pdf that uses this code path, just a guess on how it should work
                if ( !exe->parameters().isEmpty() )
                {
                    url = d->giveAbsoluteUrl( exe->parameters() );
                    mime = db.mimeTypeForUrl( url );

                    if ( KRun::isExecutableFile( url, mime.name() ) )
                    {
                        // this case is a link pointing to an executable with a parameter
                        // that also is an executable, possibly a hand-crafted pdf
                        KMessageBox::information( d->m_widget, i18n(""The document is trying to execute an external application and, for your safety, Okular does not allow that."") );
                        break;
                    }
                }
                else
                {
                    // this case is a link pointing to an executable with no parameters
                    // core developers find unacceptable executing it even after asking the user
                    KMessageBox::information( d->m_widget, i18n(""The document is trying to execute an external application and, for your safety, Okular does not allow that."") );
                    break;
                }
            }

            KService::Ptr ptr = KMimeTypeTrader::self()->preferredService( mime.name(), QStringLiteral(""Application"") );
            if ( ptr )
            {
                QList<QUrl> lst;
                lst.append( url );
                KRun::runService( *ptr, lst, nullptr );
            }
            else
                KMessageBox::information( d->m_widget, i18n( ""No application found for opening file of mimetype %1."", mime.name() ) );
            } break;

        case Action::DocAction: {
            const DocumentAction * docaction = static_cast< const DocumentAction * >( action );
            switch( docaction->documentActionType() )
            {
                case DocumentAction::PageFirst:
                    setViewportPage( 0 );
                    break;
                case DocumentAction::PagePrev:
                    if ( (*d->m_viewportIterator).pageNumber > 0 )
                        setViewportPage( (*d->m_viewportIterator).pageNumber - 1 );
                    break;
                case DocumentAction::PageNext:
                    if ( (*d->m_viewportIterator).pageNumber < (int)d->m_pagesVector.count() - 1 )
                        setViewportPage( (*d->m_viewportIterator).pageNumber + 1 );
                    break;
                case DocumentAction::PageLast:
                    setViewportPage( d->m_pagesVector.count() - 1 );
                    break;
                case DocumentAction::HistoryBack:
                    setPrevViewport();
                    break;
                case DocumentAction::HistoryForward:
                    setNextViewport();
                    break;
                case DocumentAction::Quit:
                    emit quit();
                    break;
                case DocumentAction::Presentation:
                    emit linkPresentation();
                    break;
                case DocumentAction::EndPresentation:
                    emit linkEndPresentation();
                    break;
                case DocumentAction::Find:
                    emit linkFind();
                    break;
                case DocumentAction::GoToPage:
                    emit linkGoToPage();
                    break;
                case DocumentAction::Close:
                    emit close();
                    break;
            }
            } break;

        case Action::Browse: {
            const BrowseAction * browse = static_cast< const BrowseAction * >( action );
            QString lilySource;
            int lilyRow = 0, lilyCol = 0;
            // if the url is a mailto one, invoke mailer
            if ( browse->url().scheme() == QLatin1String(""mailto"") )
            {
                QDesktopServices::openUrl( browse->url() );
            }
            else if ( extractLilyPondSourceReference( browse->url(), &lilySource, &lilyRow, &lilyCol ) )
            {
                const SourceReference ref( lilySource, lilyRow, lilyCol );
                processSourceReference( &ref );
            }
            else
            {
                const QUrl url = browse->url();

                // fix for #100366, documents with relative links that are the form of http:foo.pdf
                if ((url.scheme() == ""http"") && url.host().isEmpty() && url.fileName().endsWith(""pdf""))
                {
                    d->openRelativeFile(url.fileName());
                    break;
                }

                // handle documents with relative path
                if ( d->m_url.isValid() )
                {
                    const QUrl realUrl = KIO::upUrl(d->m_url).resolved(url);
                    // KRun autodeletes
                    new KRun( realUrl, d->m_widget );
                }
            }
            } break;

        case Action::Sound: {
            const SoundAction * linksound = static_cast< const SoundAction * >( action );
            AudioPlayer::instance()->playSound( linksound->sound(), linksound );
            } break;

        case Action::Script: {
            const ScriptAction * linkscript = static_cast< const ScriptAction * >( action );
            if ( !d->m_scripter )
                d->m_scripter = new Scripter( d );
            d->m_scripter->execute( linkscript->scriptType(), linkscript->script() );
            } break;

        case Action::Movie:
            emit processMovieAction( static_cast< const MovieAction * >( action ) );
            break;
        case Action::Rendition: {
            const RenditionAction * linkrendition = static_cast< const RenditionAction * >( action );
            if ( !linkrendition->script().isEmpty() )
            {
                if ( !d->m_scripter )
                    d->m_scripter = new Scripter( d );
                d->m_scripter->execute( linkrendition->scriptType(), linkrendition->script() );
            }

            emit processRenditionAction( static_cast< const RenditionAction * >( action ) );
            } break;
        case Action::BackendOpaque: {
            d->m_generator->opaqueAction( static_cast< const BackendOpaqueAction * >( action ) );
            } break;

    }

    for ( const Action *a : action->nextActions() )
    {
        processAction( a );
    }
}

void Document::processSourceReference( const SourceReference * ref )
{
    if ( !ref )
        return;

    const QUrl url = d->giveAbsoluteUrl( ref->fileName() );
    if ( !url.isLocalFile() )
    {
        qCDebug(OkularCoreDebug) << url.url() << ""is not a local file."";
        return;
    }

    const QString absFileName = url.toLocalFile();
    if ( !QFile::exists( absFileName ) )
    {
        qCDebug(OkularCoreDebug) << ""No such file:"" << absFileName;
        return;
    }

    bool handled = false;
    emit sourceReferenceActivated(absFileName, ref->row(), ref->column(), &handled);
    if(handled) {
        return;
    }

    static QHash< int, QString > editors;
    // init the editors table if empty (on first run, usually)
    if ( editors.isEmpty() )
    {
        editors = buildEditorsMap();
    }

    QHash< int, QString >::const_iterator it = editors.constFind( SettingsCore::externalEditor() );
    QString p;
    if ( it != editors.constEnd() )
        p = *it;
    else
        p = SettingsCore::externalEditorCommand();
    // custom editor not yet configured
    if ( p.isEmpty() )
        return;

    // manually append the %f placeholder if not specified
    if ( p.indexOf( QLatin1String( ""%f"" ) ) == -1 )
        p.append( QLatin1String( "" %f"" ) );

    // replacing the placeholders
    QHash< QChar, QString > map;
    map.insert( QLatin1Char ( 'f' ), absFileName );
    map.insert( QLatin1Char ( 'c' ), QString::number( ref->column() ) );
    map.insert( QLatin1Char ( 'l' ), QString::number( ref->row() ) );
    const QString cmd = KMacroExpander::expandMacrosShellQuote( p, map );
    if ( cmd.isEmpty() )
        return;
    const QStringList args = KShell::splitArgs( cmd );
    if ( args.isEmpty() )
        return;

    KProcess::startDetached( args );
}

const SourceReference * Document::dynamicSourceReference( int pageNr, double absX, double absY )
{
    if  ( !d->m_synctex_scanner )
        return nullptr;

    const QSizeF dpi = d->m_generator->dpi();

    if (synctex_edit_query(d->m_synctex_scanner, pageNr + 1, absX * 72. / dpi.width(), absY * 72. / dpi.height()) > 0)
    {
        synctex_node_p node;
        // TODO what should we do if there is really more than one node?
        while (( node = synctex_scanner_next_result( d->m_synctex_scanner ) ))
        {
            int line = synctex_node_line(node);
            int col = synctex_node_column(node);
            // column extraction does not seem to be implemented in synctex so far. set the SourceReference default value.
            if ( col == -1 )
            {
                col = 0;
            }
            const char *name = synctex_scanner_get_name( d->m_synctex_scanner, synctex_node_tag( node ) );

            return new Okular::SourceReference( QFile::decodeName( name ), line, col );
        }
    }
    return nullptr;
}

Document::PrintingType Document::printingSupport() const
{
    if ( d->m_generator )
    {

        if ( d->m_generator->hasFeature( Generator::PrintNative ) )
        {
            return NativePrinting;
        }

#ifndef Q_OS_WIN
        if ( d->m_generator->hasFeature( Generator::PrintPostscript ) )
        {
            return PostscriptPrinting;
        }
#endif

    }

    return NoPrinting;
}

bool Document::supportsPrintToFile() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::PrintToFile ) : false;
}

bool Document::print( QPrinter &printer )
{
    return d->m_generator ? d->m_generator->print( printer ) : false;
}

QString Document::printError() const
{
    Okular::Generator::PrintError err = Generator::UnknownPrintError;
    if ( d->m_generator )
    {
        QMetaObject::invokeMethod( d->m_generator, ""printError"", Qt::DirectConnection, Q_RETURN_ARG(Okular::Generator::PrintError, err) );
    }
    Q_ASSERT( err != Generator::NoPrintError );
    switch ( err )
    {
        case Generator::TemporaryFileOpenPrintError:
            return i18n( ""Could not open a temporary file"" );
        case Generator::FileConversionPrintError:
            return i18n( ""Print conversion failed"" );
        case Generator::PrintingProcessCrashPrintError:
            return i18n( ""Printing process crashed"" );
        case Generator::PrintingProcessStartPrintError:
            return i18n( ""Printing process could not start"" );
        case Generator::PrintToFilePrintError:
            return i18n( ""Printing to file failed"" );
        case Generator::InvalidPrinterStatePrintError:
            return i18n( ""Printer was in invalid state"" );
        case Generator::UnableToFindFilePrintError:
            return i18n( ""Unable to find file to print"" );
        case Generator::NoFileToPrintError:
            return i18n( ""There was no file to print"" );
        case Generator::NoBinaryToPrintError:
            return i18n( ""Could not find a suitable binary for printing. Make sure CUPS lpr binary is available"" );
        case Generator::InvalidPageSizePrintError:
            return i18n( ""The page print size is invalid"" );
        case Generator::NoPrintError:
            return QString();
        case Generator::UnknownPrintError:
            return QString();
    }

    return QString();
}

QWidget* Document::printConfigurationWidget() const
{
    if ( d->m_generator )
    {
        PrintInterface * iface = qobject_cast< Okular::PrintInterface * >( d->m_generator );
        return iface ? iface->printConfigurationWidget() : nullptr;
    }
    else
        return nullptr;
}

void Document::fillConfigDialog( KConfigDialog * dialog )
{
    if ( !dialog )
        return;

    // ensure that we have all the generators with settings loaded
    QVector<KPluginMetaData> offers = DocumentPrivate::configurableGenerators();
    d->loadServiceList( offers );

    // We want the generators to be sorted by name so let's fill in a QMap
    // this sorts by internal id which is not awesome, but at least the sorting
    // is stable between runs that before it wasn't
    QMap<QString, GeneratorInfo> sortedGenerators;
    QHash< QString, GeneratorInfo >::iterator it = d->m_loadedGenerators.begin();
    QHash< QString, GeneratorInfo >::iterator itEnd = d->m_loadedGenerators.end();
    for ( ; it != itEnd; ++it )
    {
        sortedGenerators.insert(it.key(), it.value());
    }

    bool pagesAdded = false;
    QMap< QString, GeneratorInfo >::iterator sit = sortedGenerators.begin();
    QMap< QString, GeneratorInfo >::iterator sitEnd = sortedGenerators.end();
    for ( ; sit != sitEnd; ++sit )
    {
        Okular::ConfigInterface * iface = d->generatorConfig( sit.value() );
        if ( iface )
        {
            iface->addPages( dialog );
            pagesAdded = true;
        }
    }
    if ( pagesAdded )
    {
        connect( dialog, SIGNAL(settingsChanged(QString)),
                 this, SLOT(slotGeneratorConfigChanged(QString)) );
    }
}


QVector<KPluginMetaData> DocumentPrivate::configurableGenerators()
{
    const QVector<KPluginMetaData> available = availableGenerators();
    QVector<KPluginMetaData> result;
    for (const KPluginMetaData& md : available)
    {
        if (md.rawData()[QStringLiteral(""X-KDE-okularHasInternalSettings"")].toBool())
        {
            result << md;
        }
    }
    return result;
}

KPluginMetaData Document::generatorInfo() const
{
    if (!d->m_generator)
        return KPluginMetaData();

    auto genIt = d->m_loadedGenerators.constFind(d->m_generatorName);
    Q_ASSERT(genIt != d->m_loadedGenerators.constEnd());
    return genIt.value().metadata;
}

int Document::configurableGenerators() const
{
    return DocumentPrivate::configurableGenerators().size();
}

QStringList Document::supportedMimeTypes() const
{
    // TODO: make it a static member of DocumentPrivate?
    QStringList result = d->m_supportedMimeTypes;
    if (result.isEmpty())
    {
        const QVector<KPluginMetaData> available = DocumentPrivate::availableGenerators();
        for (const KPluginMetaData& md : available)
        {
            result << md.mimeTypes();
        }

        // Remove duplicate mimetypes represented by different names
        QMimeDatabase mimeDatabase;
        QSet<QMimeType> uniqueMimetypes;
        for (const QString &mimeName : result) {
            uniqueMimetypes.insert(mimeDatabase.mimeTypeForName(mimeName));
        }
        result.clear();
        for (const QMimeType &mimeType : uniqueMimetypes) {
            result.append(mimeType.name());
        }

        // Add the Okular archive mimetype
        result << QStringLiteral(""application/vnd.kde.okular-archive"");

        // Sorting by mimetype name doesn't make a ton of sense,
        // but ensures that the list is ordered the same way every time
        qSort(result);

        d->m_supportedMimeTypes = result;
    }
    return result;
}

bool Document::canSwapBackingFile() const
{
    if ( !d->m_generator )
        return false;

    return d->m_generator->hasFeature( Generator::SwapBackingFile );
}

bool Document::swapBackingFile( const QString &newFileName, const QUrl &url )
{
    if ( !d->m_generator )
        return false;

    if ( !d->m_generator->hasFeature( Generator::SwapBackingFile ) )
        return false;

    // Save metadata about the file we're about to close
    d->saveDocumentInfo();

    d->clearAndWaitForRequests();

    qCDebug(OkularCoreDebug) << ""Swapping backing file to"" << newFileName;
    QVector< Page * > newPagesVector;
    Generator::SwapBackingFileResult result = d->m_generator->swapBackingFile( newFileName, newPagesVector );
    if (result != Generator::SwapBackingFileError)
    {
        QLinkedList< ObjectRect* > rectsToDelete;
        QLinkedList< Annotation* > annotationsToDelete;
        QSet< PagePrivate* > pagePrivatesToDelete;

        if (result == Generator::SwapBackingFileReloadInternalData)
        {
            // Here we need to replace everything that the old generator
            // had created with what the new one has without making it look like
            // we have actually closed and opened the file again

            // Simple sanity check
            if (newPagesVector.count() != d->m_pagesVector.count())
                return false;

            // Update the undo stack contents
            for (int i = 0; i < d->m_undoStack->count(); ++i)
            {
                // Trust me on the const_cast ^_^
                QUndoCommand *uc = const_cast<QUndoCommand *>( d->m_undoStack->command( i ) );
                if (OkularUndoCommand *ouc = dynamic_cast<OkularUndoCommand*>( uc ))
                {
                    const bool success = ouc->refreshInternalPageReferences( newPagesVector );
                    if ( !success )
                    {
                        qWarning() << ""Document::swapBackingFile: refreshInternalPageReferences failed"" << ouc;
                        return false;
                    }
                }
                else
                {
                    qWarning() << ""Document::swapBackingFile: Unhandled undo command"" << uc;
                    return false;
                }
            }

            for (int i = 0; i < d->m_pagesVector.count(); ++i)
            {
                // switch the PagePrivate* from newPage to oldPage
                // this way everyone still holding Page* doesn't get
                // disturbed by it
                Page *oldPage = d->m_pagesVector[i];
                Page *newPage = newPagesVector[i];
                newPage->d->adoptGeneratedContents(oldPage->d);

                pagePrivatesToDelete << oldPage->d;
                oldPage->d = newPage->d;
                oldPage->d->m_page = oldPage;
                oldPage->d->m_doc = d;
                newPage->d = nullptr;

                annotationsToDelete << oldPage->m_annotations;
                rectsToDelete << oldPage->m_rects;
                oldPage->m_annotations = newPage->m_annotations;
                oldPage->m_rects = newPage->m_rects;
            }
            qDeleteAll( newPagesVector );
        }

        d->m_url = url;
        d->m_docFileName = newFileName;
        d->updateMetadataXmlNameAndDocSize();
        d->m_bookmarkManager->setUrl( d->m_url );
        d->m_documentInfo = DocumentInfo();
        d->m_documentInfoAskedKeys.clear();

        if ( d->m_synctex_scanner )
        {
            synctex_scanner_free( d->m_synctex_scanner );
            d->m_synctex_scanner = synctex_scanner_new_with_output_file( QFile::encodeName( newFileName ).constData(), nullptr, 1);
            if ( !d->m_synctex_scanner && QFile::exists(newFileName + QLatin1String( ""sync"" ) ) )
            {
                d->loadSyncFile(newFileName);
            }
        }

        foreachObserver( notifySetup( d->m_pagesVector, DocumentObserver::UrlChanged ) );

        qDeleteAll( annotationsToDelete );
        qDeleteAll( rectsToDelete );
        qDeleteAll( pagePrivatesToDelete );

        return true;
    }
    else
    {
        return false;
    }
}

bool Document::swapBackingFileArchive( const QString &newFileName, const QUrl &url )
{
    qCDebug(OkularCoreDebug) << ""Swapping backing archive to"" << newFileName;

    ArchiveData *newArchive = DocumentPrivate::unpackDocumentArchive( newFileName );
    if ( !newArchive )
        return false;

    const QString tempFileName = newArchive->document.fileName();

    const bool success = swapBackingFile( tempFileName, url );

    if ( success )
    {
        delete d->m_archiveData;
        d->m_archiveData = newArchive;
    }

    return success;
}

void Document::setHistoryClean( bool clean )
{
    if ( clean )
        d->m_undoStack->setClean();
    // Since we only use the resetClean
    // in some cases and we're past the dependency freeze
    // if you happen to compile with an old Qt you will miss
    // some extra nicety when saving an okular file with annotations to png file
    // it's quite corner case compared to how important the whole save feature
    // is so you'll have to live without it
#if QT_VERSION > QT_VERSION_CHECK(5, 8, 0)
    else
        d->m_undoStack->resetClean();
#endif
}

bool Document::canSaveChanges() const
{
    if ( !d->m_generator )
        return false;
    Q_ASSERT( !d->m_generatorName.isEmpty() );

    QHash< QString, GeneratorInfo >::iterator genIt = d->m_loadedGenerators.find( d->m_generatorName );
    Q_ASSERT( genIt != d->m_loadedGenerators.end() );
    SaveInterface* saveIface = d->generatorSave( genIt.value() );
    if ( !saveIface )
        return false;

    return saveIface->supportsOption( SaveInterface::SaveChanges );
}

bool Document::canSaveChanges( SaveCapability cap ) const
{
    switch ( cap )
    {
        case SaveFormsCapability:
            /* Assume that if the generator supports saving, forms can be saved.
             * We have no means to actually query the generator at the moment
             * TODO: Add some method to query the generator in SaveInterface */
            return canSaveChanges();

        case SaveAnnotationsCapability:
            return d->canAddAnnotationsNatively();
    }

    return false;
}

bool Document::saveChanges( const QString &fileName )
{
    QString errorText;
    return saveChanges( fileName, &errorText );
}

bool Document::saveChanges( const QString &fileName, QString *errorText )
{
    if ( !d->m_generator || fileName.isEmpty() )
        return false;
    Q_ASSERT( !d->m_generatorName.isEmpty() );

    QHash< QString, GeneratorInfo >::iterator genIt = d->m_loadedGenerators.find( d->m_generatorName );
    Q_ASSERT( genIt != d->m_loadedGenerators.end() );
    SaveInterface* saveIface = d->generatorSave( genIt.value() );
    if ( !saveIface || !saveIface->supportsOption( SaveInterface::SaveChanges ) )
        return false;

    return saveIface->save( fileName, SaveInterface::SaveChanges, errorText );
}

void Document::registerView( View *view )
{
    if ( !view )
        return;

    Document *viewDoc = view->viewDocument();
    if ( viewDoc )
    {
        // check if already registered for this document
        if ( viewDoc == this )
            return;

        viewDoc->unregisterView( view );
    }

    d->m_views.insert( view );
    view->d_func()->document = d;
}

void Document::unregisterView( View *view )
{
    if ( !view )
        return;

    Document *viewDoc = view->viewDocument();
    if ( !viewDoc || viewDoc != this )
        return;

    view->d_func()->document = nullptr;
    d->m_views.remove( view );
}

QByteArray Document::fontData(const FontInfo &font) const
{
    QByteArray result;

    if (d->m_generator)
    {
        QMetaObject::invokeMethod(d->m_generator, ""requestFontData"", Qt::DirectConnection, Q_ARG(Okular::FontInfo, font), Q_ARG(QByteArray *, &result));
    }

    return result;
}

ArchiveData *DocumentPrivate::unpackDocumentArchive( const QString &archivePath )
{
    QMimeDatabase db;
    const QMimeType mime = db.mimeTypeForFile( archivePath, QMimeDatabase::MatchExtension );
    if ( !mime.inherits( QStringLiteral(""application/vnd.kde.okular-archive"") ) )
        return nullptr;

    KZip okularArchive( archivePath );
    if ( !okularArchive.open( QIODevice::ReadOnly ) )
        return nullptr;

    const KArchiveDirectory * mainDir = okularArchive.directory();
    const KArchiveEntry * mainEntry = mainDir->entry( QStringLiteral(""content.xml"") );
    if ( !mainEntry || !mainEntry->isFile() )
        return nullptr;

    std::unique_ptr< QIODevice > mainEntryDevice( static_cast< const KZipFileEntry * >( mainEntry )->createDevice() );
    QDomDocument doc;
    if ( !doc.setContent( mainEntryDevice.get() ) )
        return nullptr;
    mainEntryDevice.reset();

    QDomElement root = doc.documentElement();
   if ( root.tagName() != QLatin1String(""OkularArchive"") )
        return nullptr;

    QString documentFileName;
    QString metadataFileName;
    QDomElement el = root.firstChild().toElement();
    for ( ; !el.isNull(); el = el.nextSibling().toElement() )
    {
        if ( el.tagName() == QLatin1String(""Files"") )
        {
            QDomElement fileEl = el.firstChild().toElement();
            for ( ; !fileEl.isNull(); fileEl = fileEl.nextSibling().toElement() )
            {
                if ( fileEl.tagName() == QLatin1String(""DocumentFileName"") )
                    documentFileName = fileEl.text();
                else if ( fileEl.tagName() == QLatin1String(""MetadataFileName"") )
                    metadataFileName = fileEl.text();
            }
        }
    }
    if ( documentFileName.isEmpty() )
        return nullptr;

    const KArchiveEntry * docEntry = mainDir->entry( documentFileName );
    if ( !docEntry || !docEntry->isFile() )
        return nullptr;

    std::unique_ptr< ArchiveData > archiveData( new ArchiveData() );
    const int dotPos = documentFileName.indexOf( QLatin1Char('.') );
    if ( dotPos != -1 )
        archiveData->document.setFileTemplate(QDir::tempPath() + QLatin1String(""/okular_XXXXXX"") + documentFileName.mid(dotPos));
    if ( !archiveData->document.open() )
        return nullptr;

    archiveData->originalFileName = documentFileName;

    {
    std::unique_ptr< QIODevice > docEntryDevice( static_cast< const KZipFileEntry * >( docEntry )->createDevice() );
    copyQIODevice( docEntryDevice.get(), &archiveData->document );
    archiveData->document.close();
    }

    const KArchiveEntry * metadataEntry = mainDir->entry( metadataFileName );
    if ( metadataEntry && metadataEntry->isFile() )
    {
        std::unique_ptr< QIODevice > metadataEntryDevice( static_cast< const KZipFileEntry * >( metadataEntry )->createDevice() );
        archiveData->metadataFile.setFileTemplate(QDir::tempPath() + QLatin1String(""/okular_XXXXXX.xml""));
        if ( archiveData->metadataFile.open() )
        {
            copyQIODevice( metadataEntryDevice.get(), &archiveData->metadataFile );
            archiveData->metadataFile.close();
        }
    }

    return archiveData.release();
}

Document::OpenResult Document::openDocumentArchive( const QString & docFile, const QUrl & url, const QString & password )
{
    d->m_archiveData = DocumentPrivate::unpackDocumentArchive( docFile );
    if ( !d->m_archiveData )
        return OpenError;

    const QString tempFileName = d->m_archiveData->document.fileName();
    QMimeDatabase db;
    const QMimeType docMime = db.mimeTypeForFile( tempFileName, QMimeDatabase::MatchContent );
    const OpenResult ret = openDocument( tempFileName, url, docMime, password );

    if ( ret != OpenSuccess )
    {
        delete d->m_archiveData;
        d->m_archiveData = nullptr;
    }

    return ret;
}

bool Document::saveDocumentArchive( const QString &fileName )
{
    if ( !d->m_generator )
        return false;

    /* If we opened an archive, use the name of original file (eg foo.pdf)
     * instead of the archive's one (eg foo.okular) */
    QString docFileName = d->m_archiveData ? d->m_archiveData->originalFileName : d->m_url.fileName();
    if ( docFileName == QLatin1String( ""-"" ) )
        return false;

    QString docPath = d->m_docFileName;
    const QFileInfo fi( docPath );
    if ( fi.isSymLink() )
        docPath = fi.symLinkTarget();

    KZip okularArchive( fileName );
    if ( !okularArchive.open( QIODevice::WriteOnly ) )
        return false;

    const KUser user;
#ifndef Q_OS_WIN
    const KUserGroup userGroup( user.groupId() );
#else
    const KUserGroup userGroup( QString( """" ) );
#endif

    QDomDocument contentDoc( QStringLiteral(""OkularArchive"") );
    QDomProcessingInstruction xmlPi = contentDoc.createProcessingInstruction(
            QStringLiteral( ""xml"" ), QStringLiteral( ""version=\""1.0\"" encoding=\""utf-8\"""" ) );
    contentDoc.appendChild( xmlPi );
    QDomElement root = contentDoc.createElement( QStringLiteral(""OkularArchive"") );
    contentDoc.appendChild( root );

    QDomElement filesNode = contentDoc.createElement( QStringLiteral(""Files"") );
    root.appendChild( filesNode );

    QDomElement fileNameNode = contentDoc.createElement( QStringLiteral(""DocumentFileName"") );
    filesNode.appendChild( fileNameNode );
    fileNameNode.appendChild( contentDoc.createTextNode( docFileName ) );

    QDomElement metadataFileNameNode = contentDoc.createElement( QStringLiteral(""MetadataFileName"") );
    filesNode.appendChild( metadataFileNameNode );
    metadataFileNameNode.appendChild( contentDoc.createTextNode( QStringLiteral(""metadata.xml"") ) );

    // If the generator can save annotations natively, do it
    QTemporaryFile modifiedFile;
    bool annotationsSavedNatively = false;
    bool formsSavedNatively = false;
    if ( d->canAddAnnotationsNatively() || canSaveChanges( SaveFormsCapability ) )
    {
        if ( !modifiedFile.open() )
            return false;

        const QString modifiedFileName = modifiedFile.fileName();

        modifiedFile.close(); // We're only interested in the file name

        QString errorText;
        if ( saveChanges( modifiedFileName, &errorText ) )
        {
            docPath = modifiedFileName; // Save this instead of the original file
            annotationsSavedNatively = d->canAddAnnotationsNatively();
            formsSavedNatively = canSaveChanges( SaveFormsCapability );
        }
        else
        {
            qCWarning(OkularCoreDebug) << ""saveChanges failed: "" << errorText;
            qCDebug(OkularCoreDebug) << ""Falling back to saving a copy of the original file"";
        }
    }

    PageItems saveWhat = None;
    if ( !annotationsSavedNatively )
        saveWhat |= AnnotationPageItems;
    if ( !formsSavedNatively )
        saveWhat |= FormFieldPageItems;

    QTemporaryFile metadataFile;
    if ( !d->savePageDocumentInfo( &metadataFile, saveWhat ) )
        return false;

    const QByteArray contentDocXml = contentDoc.toByteArray();
    const mode_t perm = 0100644;
    okularArchive.writeFile( QStringLiteral(""content.xml""), contentDocXml, perm,
                              user.loginName(), userGroup.name() );


    okularArchive.addLocalFile( docPath, docFileName );
    okularArchive.addLocalFile( metadataFile.fileName(), QStringLiteral(""metadata.xml"") );

    if ( !okularArchive.close() )
        return false;

    return true;
}

bool Document::extractArchivedFile( const QString &destFileName )
{
    if ( !d->m_archiveData )
        return false;

    // Remove existing file, if present (QFile::copy doesn't overwrite by itself)
    QFile::remove( destFileName );

    return d->m_archiveData->document.copy( destFileName );
}

QPrinter::Orientation Document::orientation() const
{
    double width, height;
    int landscape, portrait;
    const Okular::Page *currentPage;

    // if some pages are landscape and others are not, the most common wins, as
    // QPrinter does not accept a per-page setting
    landscape = 0;
    portrait = 0;
    for (uint i = 0; i < pages(); i++)
    {
        currentPage = page(i);
        width = currentPage->width();
        height = currentPage->height();
        if (currentPage->orientation() == Okular::Rotation90 || currentPage->orientation() == Okular::Rotation270) qSwap(width, height);
        if (width > height) landscape++;
        else portrait++;
    }
    return (landscape > portrait) ? QPrinter::Landscape : QPrinter::Portrait;
}

void Document::setAnnotationEditingEnabled( bool enable )
{
    d->m_annotationEditingEnabled = enable;
    foreachObserver( notifySetup( d->m_pagesVector, 0 ) );
}

void Document::walletDataForFile( const QString &fileName, QString *walletName, QString *walletFolder, QString *walletKey ) const
{
    if (d->m_generator) {
        d->m_generator->walletDataForFile( fileName, walletName, walletFolder, walletKey );
    } else if (d->m_walletGenerator) {
        d->m_walletGenerator->walletDataForFile( fileName, walletName, walletFolder, walletKey );
    }
}

bool Document::isDocdataMigrationNeeded() const
{
    return d->m_docdataMigrationNeeded;
}

void Document::docdataMigrationDone()
{
    if (d->m_docdataMigrationNeeded)
    {
        d->m_docdataMigrationNeeded = false;
        foreachObserver( notifySetup( d->m_pagesVector, 0 ) );
    }
}

QAbstractItemModel * Document::layersModel() const
{
    return d->m_generator ? d->m_generator->layersModel() : nullptr;
}

void DocumentPrivate::requestDone( PixmapRequest * req )
{
    if ( !req )
        return;

    if ( !m_generator || m_closingLoop )
    {
        m_pixmapRequestsMutex.lock();
        m_executingPixmapRequests.removeAll( req );
        m_pixmapRequestsMutex.unlock();
        delete req;
        if ( m_closingLoop )
            m_closingLoop->exit();
        return;
    }

#ifndef NDEBUG
    if ( !m_generator->canGeneratePixmap() )
        qCDebug(OkularCoreDebug) << ""requestDone with generator not in READY state."";
#endif

    if ( !req->shouldAbortRender() )
    {
        // [MEM] 1.1 find and remove a previous entry for the same page and id
        QLinkedList< AllocatedPixmap * >::iterator aIt = m_allocatedPixmaps.begin();
        QLinkedList< AllocatedPixmap * >::iterator aEnd = m_allocatedPixmaps.end();
        for ( ; aIt != aEnd; ++aIt )
            if ( (*aIt)->page == req->pageNumber() && (*aIt)->observer == req->observer() )
            {
                AllocatedPixmap * p = *aIt;
                m_allocatedPixmaps.erase( aIt );
                m_allocatedPixmapsTotalMemory -= p->memory;
                delete p;
                break;
            }

        DocumentObserver *observer = req->observer();
        if ( m_observers.contains(observer) )
        {
            // [MEM] 1.2 append memory allocation descriptor to the FIFO
            qulonglong memoryBytes = 0;
            const TilesManager *tm = req->d->tilesManager();
            if ( tm )
                memoryBytes = tm->totalMemory();
            else
                memoryBytes = 4 * req->width() * req->height();

            AllocatedPixmap * memoryPage = new AllocatedPixmap( req->observer(), req->pageNumber(), memoryBytes );
            m_allocatedPixmaps.append( memoryPage );
            m_allocatedPixmapsTotalMemory += memoryBytes;

            // 2. notify an observer that its pixmap changed
            observer->notifyPageChanged( req->pageNumber(), DocumentObserver::Pixmap );
        }
#ifndef NDEBUG
        else
            qCWarning(OkularCoreDebug) << ""Receiving a done request for the defunct observer"" << observer;
#endif
    }

    // 3. delete request
    m_pixmapRequestsMutex.lock();
    m_executingPixmapRequests.removeAll( req );
    m_pixmapRequestsMutex.unlock();
    delete req;

    // 4. start a new generation if some is pending
    m_pixmapRequestsMutex.lock();
    bool hasPixmaps = !m_pixmapRequestsStack.isEmpty();
    m_pixmapRequestsMutex.unlock();
    if ( hasPixmaps )
        sendGeneratorPixmapRequest();
}

void DocumentPrivate::setPageBoundingBox( int page, const NormalizedRect& boundingBox )
{
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    if ( kp->boundingBox() == boundingBox )
        return;
    kp->setBoundingBox( boundingBox );

    // notify observers about the change
    foreachObserverD( notifyPageChanged( page, DocumentObserver::BoundingBox ) );

    // TODO: For generators that generate the bbox by pixmap scanning, if the first generated pixmap is very small, the bounding box will forever be inaccurate.
    // TODO: Crop computation should also consider annotations, actions, etc. to make sure they're not cropped away.
    // TODO: Help compute bounding box for generators that create a QPixmap without a QImage, like text and plucker.
    // TODO: Don't compute the bounding box if no one needs it (e.g., Trim Borders is off).

}

void DocumentPrivate::calculateMaxTextPages()
{
    int multipliers = qMax(1, qRound(getTotalMemory() / 536870912.0)); // 512 MB
    switch (SettingsCore::memoryLevel())
    {
        case SettingsCore::EnumMemoryLevel::Low:
            m_maxAllocatedTextPages = multipliers * 2;
        break;

        case SettingsCore::EnumMemoryLevel::Normal:
            m_maxAllocatedTextPages = multipliers * 50;
        break;

        case SettingsCore::EnumMemoryLevel::Aggressive:
            m_maxAllocatedTextPages = multipliers * 250;
        break;

        case SettingsCore::EnumMemoryLevel::Greedy:
            m_maxAllocatedTextPages = multipliers * 1250;
        break;
    }
}

void DocumentPrivate::textGenerationDone( Page *page )
{
    if ( !m_pageController ) return;

    // 1. If we reached the cache limit, delete the first text page from the fifo
    if (m_allocatedTextPagesFifo.size() == m_maxAllocatedTextPages)
    {
        int pageToKick = m_allocatedTextPagesFifo.takeFirst();
        if (pageToKick != page->number()) // this should never happen but better be safe than sorry
        {
            m_pagesVector.at(pageToKick)->setTextPage( nullptr ); // deletes the textpage
        }
    }

    // 2. Add the page to the fifo of generated text pages
    m_allocatedTextPagesFifo.append( page->number() );
}

void Document::setRotation( int r )
{
    d->setRotationInternal( r, true );
}

void DocumentPrivate::setRotationInternal( int r, bool notify )
{
    Rotation rotation = (Rotation)r;
    if ( !m_generator || ( m_rotation == rotation ) )
	return;

    // tell the pages to rotate
    QVector< Okular::Page * >::const_iterator pIt = m_pagesVector.constBegin();
    QVector< Okular::Page * >::const_iterator pEnd = m_pagesVector.constEnd();
    for ( ; pIt != pEnd; ++pIt )
        (*pIt)->d->rotateAt( rotation );
    if ( notify )
    {
        // notify the generator that the current rotation has changed
        m_generator->rotationChanged( rotation, m_rotation );
    }
    // set the new rotation
    m_rotation = rotation;

    if ( notify )
    {
        foreachObserverD( notifySetup( m_pagesVector, DocumentObserver::NewLayoutForPages ) );
        foreachObserverD( notifyContentsCleared( DocumentObserver::Pixmap | DocumentObserver::Highlights | DocumentObserver::Annotations ) );
    }
    qCDebug(OkularCoreDebug) << ""Rotated:"" << r;
}

void Document::setPageSize( const PageSize &size )
{
    if ( !d->m_generator || !d->m_generator->hasFeature( Generator::PageSizes ) )
        return;

    if ( d->m_pageSizes.isEmpty() )
        d->m_pageSizes = d->m_generator->pageSizes();
    int sizeid = d->m_pageSizes.indexOf( size );
    if ( sizeid == -1 )
        return;

    // tell the pages to change size
    QVector< Okular::Page * >::const_iterator pIt = d->m_pagesVector.constBegin();
    QVector< Okular::Page * >::const_iterator pEnd = d->m_pagesVector.constEnd();
    for ( ; pIt != pEnd; ++pIt )
        (*pIt)->d->changeSize( size );
    // clear 'memory allocation' descriptors
    qDeleteAll( d->m_allocatedPixmaps );
    d->m_allocatedPixmaps.clear();
    d->m_allocatedPixmapsTotalMemory = 0;
    // notify the generator that the current page size has changed
    d->m_generator->pageSizeChanged( size, d->m_pageSize );
    // set the new page size
    d->m_pageSize = size;

    foreachObserver( notifySetup( d->m_pagesVector, DocumentObserver::NewLayoutForPages ) );
    foreachObserver( notifyContentsCleared( DocumentObserver::Pixmap | DocumentObserver::Highlights ) );
    qCDebug(OkularCoreDebug) << ""New PageSize id:"" << sizeid;
}


/** DocumentViewport **/

DocumentViewport::DocumentViewport( int n )
    : pageNumber( n )
{
    // default settings
    rePos.enabled = false;
    rePos.normalizedX = 0.5;
    rePos.normalizedY = 0.0;
    rePos.pos = Center;
    autoFit.enabled = false;
    autoFit.width = false;
    autoFit.height = false;
}

DocumentViewport::DocumentViewport( const QString & xmlDesc )
    : pageNumber( -1 )
{
    // default settings (maybe overridden below)
    rePos.enabled = false;
    rePos.normalizedX = 0.5;
    rePos.normalizedY = 0.0;
    rePos.pos = Center;
    autoFit.enabled = false;
    autoFit.width = false;
    autoFit.height = false;

    // check for string presence
    if ( xmlDesc.isEmpty() )
        return;

    // decode the string
    bool ok;
    int field = 0;
    QString token = xmlDesc.section( QLatin1Char(';'), field, field );
    while ( !token.isEmpty() )
    {
        // decode the current token
        if ( field == 0 )
        {
            pageNumber = token.toInt( &ok );
            if ( !ok )
                return;
        }
        else if ( token.startsWith( QLatin1String(""C1"") ) )
        {
            rePos.enabled = true;
            rePos.normalizedX = token.section( QLatin1Char(':'), 1, 1 ).toDouble();
            rePos.normalizedY = token.section( QLatin1Char(':'), 2, 2 ).toDouble();
            rePos.pos = Center;
        }
        else if ( token.startsWith( QLatin1String(""C2"") ) )
        {
            rePos.enabled = true;
            rePos.normalizedX = token.section( QLatin1Char(':'), 1, 1 ).toDouble();
            rePos.normalizedY = token.section( QLatin1Char(':'), 2, 2 ).toDouble();
            if (token.section( QLatin1Char(':'), 3, 3 ).toInt() == 1) rePos.pos = Center;
            else rePos.pos = TopLeft;
        }
        else if ( token.startsWith( QLatin1String(""AF1"") ) )
        {
            autoFit.enabled = true;
            autoFit.width = token.section( QLatin1Char(':'), 1, 1 ) == QLatin1String(""T"");
            autoFit.height = token.section( QLatin1Char(':'), 2, 2 ) == QLatin1String(""T"");
        }
        // proceed tokenizing string
        field++;
        token = xmlDesc.section( QLatin1Char(';'), field, field );
    }
}

QString DocumentViewport::toString() const
{
    // start string with page number
    QString s = QString::number( pageNumber );
    // if has center coordinates, save them on string
    if ( rePos.enabled )
        s += QStringLiteral( "";C2:"" ) + QString::number( rePos.normalizedX ) +
             QLatin1Char(':') + QString::number( rePos.normalizedY ) +
             QLatin1Char(':') + QString::number( rePos.pos );
    // if has autofit enabled, save its state on string
    if ( autoFit.enabled )
        s += QStringLiteral( "";AF1:"" ) + (autoFit.width ? QLatin1Char('T') : QLatin1Char('F')) +
             QLatin1Char(':') + (autoFit.height ? QLatin1Char('T') : QLatin1Char('F'));
    return s;
}

bool DocumentViewport::isValid() const
{
    return pageNumber >= 0;
}

bool DocumentViewport::operator==( const DocumentViewport & vp ) const
{
    bool equal = ( pageNumber == vp.pageNumber ) &&
                 ( rePos.enabled == vp.rePos.enabled ) &&
                 ( autoFit.enabled == vp.autoFit.enabled );
    if ( !equal )
        return false;
    if ( rePos.enabled &&
         (( rePos.normalizedX != vp.rePos.normalizedX) ||
         ( rePos.normalizedY != vp.rePos.normalizedY ) || rePos.pos != vp.rePos.pos) )
        return false;
    if ( autoFit.enabled &&
         (( autoFit.width != vp.autoFit.width ) ||
         ( autoFit.height != vp.autoFit.height )) )
        return false;
    return true;
}

bool DocumentViewport::operator<( const DocumentViewport & vp ) const
{
    // TODO: Check autoFit and Position

    if ( pageNumber != vp.pageNumber )
        return pageNumber < vp.pageNumber;

    if ( !rePos.enabled && vp.rePos.enabled )
        return true;

    if ( !vp.rePos.enabled )
        return false;

    if ( rePos.normalizedY != vp.rePos.normalizedY )
        return rePos.normalizedY < vp.rePos.normalizedY;

    return rePos.normalizedX < vp.rePos.normalizedX;
}


/** DocumentInfo **/

DocumentInfo::DocumentInfo() : d(new DocumentInfoPrivate())
{
}

DocumentInfo::DocumentInfo(const DocumentInfo &info) : d(new DocumentInfoPrivate())
{
    *this = info;
}

DocumentInfo& DocumentInfo::operator=(const DocumentInfo &info)
{
    d->values = info.d->values;
    d->titles = info.d->titles;
    return *this;
}

DocumentInfo::~DocumentInfo()
{
    delete d;
}

void DocumentInfo::set( const QString &key, const QString &value, const QString &title )
{
    d->values[ key ] = value;
    d->titles[ key ] = title;
}

void DocumentInfo::set( Key key, const QString &value )
{
    d->values[ getKeyString( key ) ] = value;
}

QStringList DocumentInfo::keys() const
{
    return d->values.keys();
}

QString DocumentInfo::get( Key key ) const
{
    return get( getKeyString( key ) );
}

QString DocumentInfo::get( const QString &key ) const
{
    return d->values[ key ];
}

QString DocumentInfo::getKeyString( Key key ) //const
{
    switch ( key ) {
        case Title:
            return QStringLiteral(""title"");
            break;
        case Subject:
            return QStringLiteral(""subject"");
            break;
        case Description:
            return QStringLiteral(""description"");
            break;
        case Author:
            return QStringLiteral(""author"");
            break;
        case Creator:
            return QStringLiteral(""creator"");
            break;
        case Producer:
            return QStringLiteral(""producer"");
            break;
        case Copyright:
            return QStringLiteral(""copyright"");
            break;
        case Pages:
            return QStringLiteral(""pages"");
            break;
        case CreationDate:
            return QStringLiteral(""creationDate"");
            break;
        case ModificationDate:
            return QStringLiteral(""modificationDate"");
            break;
        case MimeType:
            return QStringLiteral(""mimeType"");
            break;
        case Category:
            return QStringLiteral(""category"");
            break;
        case Keywords:
            return QStringLiteral(""keywords"");
            break;
        case FilePath:
            return QStringLiteral(""filePath"");
            break;
        case DocumentSize:
            return QStringLiteral(""documentSize"");
            break;
        case PagesSize:
            return QStringLiteral(""pageSize"");
            break;
        default:
            qCWarning(OkularCoreDebug) << ""Unknown"" << key;
            return QString();
            break;
    }
}

DocumentInfo::Key DocumentInfo::getKeyFromString( const QString &key ) //const
{
    if (key == QLatin1String(""title"")) return Title;
    else if (key == QLatin1String(""subject"")) return Subject;
    else if (key == QLatin1String(""description"")) return Description;
    else if (key == QLatin1String(""author"")) return Author;
    else if (key == QLatin1String(""creator"")) return Creator;
    else if (key == QLatin1String(""producer"")) return Producer;
    else if (key == QLatin1String(""copyright"")) return Copyright;
    else if (key == QLatin1String(""pages"")) return Pages;
    else if (key == QLatin1String(""creationDate"")) return CreationDate;
    else if (key == QLatin1String(""modificationDate"")) return ModificationDate;
    else if (key == QLatin1String(""mimeType"")) return MimeType;
    else if (key == QLatin1String(""category"")) return Category;
    else if (key == QLatin1String(""keywords"")) return Keywords;
    else if (key == QLatin1String(""filePath"")) return FilePath;
    else if (key == QLatin1String(""documentSize"")) return DocumentSize;
    else if (key == QLatin1String(""pageSize"")) return PagesSize;
    else return Invalid;
}

QString DocumentInfo::getKeyTitle( Key key ) //const
{
    switch ( key ) {
        case Title:
            return i18n( ""Title"" );
            break;
        case Subject:
            return i18n( ""Subject"" );
            break;
        case Description:
            return i18n( ""Description"" );
            break;
        case Author:
            return i18n( ""Author"" );
            break;
        case Creator:
            return i18n( ""Creator"" );
            break;
        case Producer:
            return i18n( ""Producer"" );
            break;
        case Copyright:
            return i18n( ""Copyright"" );
            break;
        case Pages:
            return i18n( ""Pages"" );
            break;
        case CreationDate:
            return i18n( ""Created"" );
            break;
        case ModificationDate:
            return i18n( ""Modified"" );
            break;
        case MimeType:
            return i18n( ""Mime Type"" );
            break;
        case Category:
            return i18n( ""Category"" );
            break;
        case Keywords:
            return i18n( ""Keywords"" );
            break;
        case FilePath:
            return i18n( ""File Path"" );
            break;
        case DocumentSize:
            return i18n( ""File Size"" );
            break;
        case PagesSize:
            return i18n(""Page Size"");
            break;
        default:
            return QString();
            break;
    }
}

QString DocumentInfo::getKeyTitle( const QString &key ) const
{
    QString title = getKeyTitle ( getKeyFromString( key ) );
    if ( title.isEmpty() )
        title = d->titles[ key ];
    return title;
}



/** DocumentSynopsis **/

DocumentSynopsis::DocumentSynopsis()
  : QDomDocument( QStringLiteral(""DocumentSynopsis"") )
{
    // void implementation, only subclassed for naming
}

DocumentSynopsis::DocumentSynopsis( const QDomDocument &document )
  : QDomDocument( document )
{
}

/** EmbeddedFile **/

EmbeddedFile::EmbeddedFile()
{
}

EmbeddedFile::~EmbeddedFile()
{
}

VisiblePageRect::VisiblePageRect( int page, const NormalizedRect &rectangle )
    : pageNumber( page ), rect( rectangle )
{
}

#undef foreachObserver
#undef foreachObserverD

#include ""moc_document.cpp""

/* kate: replace-tabs on; indent-width 4; */
","/***************************************************************************
 *   Copyright (C) 2004-2005 by Enrico Ros <eros.kde@email.it>             *
 *   Copyright (C) 2004-2008 by Albert Astals Cid <aacid@kde.org>          *
 *   Copyright (C) 2017, 2018 Klarälvdalens Datakonsult AB, a KDAB Group         *
 *                      company, info@kdab.com. Work sponsored by the      *
 *                      LiMux project of the city of Munich                *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 ***************************************************************************/

#include ""document.h""
#include ""document_p.h""
#include ""documentcommands_p.h""

#include <limits.h>
#include <memory>
#ifdef Q_OS_WIN
#define _WIN32_WINNT 0x0500
#include <windows.h>
#elif defined(Q_OS_FREEBSD)
#include <sys/types.h>
#include <sys/sysctl.h>
#include <vm/vm_param.h>
#endif

// qt/kde/system includes
#include <QtCore/QtAlgorithms>
#include <QtCore/QDir>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>
#include <QtCore/QMap>
#include <QtCore/qtemporaryfile.h>
#include <QtCore/QTextStream>
#include <QtCore/QTimer>
#include <QtWidgets/QApplication>
#include <QtWidgets/QLabel>
#include <QtPrintSupport/QPrinter>
#include <QtPrintSupport/QPrintDialog>
#include <QStack>
#include <QUndoCommand>
#include <QMimeDatabase>
#include <QDesktopServices>
#include <QPageSize>
#include <QStandardPaths>

#include <kauthorized.h>
#include <kconfigdialog.h>
#include <kmacroexpander.h>
#include <kmessagebox.h>
#include <kmimetypetrader.h>
#include <kprocess.h>
#include <KRun>
#include <kshell.h>
#include <kzip.h>
#include <KIO/Global>
#include <KFormat>
#include <KLocalizedString>
#include <KPluginMetaData>
#include <Kdelibs4Migration>

// local includes
#include ""action.h""
#include ""annotations.h""
#include ""annotations_p.h""
#include ""audioplayer.h""
#include ""audioplayer_p.h""
#include ""bookmarkmanager.h""
#include ""chooseenginedialog_p.h""
#include ""debug_p.h""
#include ""generator_p.h""
#include ""interfaces/configinterface.h""
#include ""interfaces/guiinterface.h""
#include ""interfaces/printinterface.h""
#include ""interfaces/saveinterface.h""
#include ""observer.h""
#include ""misc.h""
#include ""page.h""
#include ""page_p.h""
#include ""pagecontroller_p.h""
#include ""scripter.h""
#include ""script/event_p.h""
#include ""settings_core.h""
#include ""sourcereference.h""
#include ""sourcereference_p.h""
#include ""texteditors_p.h""
#include ""tile.h""
#include ""tilesmanager_p.h""
#include ""utils_p.h""
#include ""view.h""
#include ""view_p.h""
#include ""form.h""
#include ""utils.h""

#include <memory>

#include <config-okular.h>

#if HAVE_MALLOC_TRIM
#include ""malloc.h""
#endif

using namespace Okular;

struct AllocatedPixmap
{
    // owner of the page
    DocumentObserver *observer;
    int page;
    qulonglong memory;
    // public constructor: initialize data
    AllocatedPixmap( DocumentObserver *o, int p, qulonglong m ) : observer( o ), page( p ), memory( m ) {}
};

struct ArchiveData
{
    ArchiveData()
    {
    }

    QString originalFileName;
    QTemporaryFile document;
    QTemporaryFile metadataFile;
};

struct RunningSearch
{
    // store search properties
    int continueOnPage;
    RegularAreaRect continueOnMatch;
    QSet< int > highlightedPages;

    // fields related to previous searches (used for 'continueSearch')
    QString cachedString;
    Document::SearchType cachedType;
    Qt::CaseSensitivity cachedCaseSensitivity;
    bool cachedViewportMove : 1;
    bool isCurrentlySearching : 1;
    QColor cachedColor;
    int pagesDone;
};

#define foreachObserver( cmd ) {\
    QSet< DocumentObserver * >::const_iterator it=d->m_observers.constBegin(), end=d->m_observers.constEnd();\
    for ( ; it != end ; ++ it ) { (*it)-> cmd ; } }

#define foreachObserverD( cmd ) {\
    QSet< DocumentObserver * >::const_iterator it = m_observers.constBegin(), end = m_observers.constEnd();\
    for ( ; it != end ; ++ it ) { (*it)-> cmd ; } }

#define OKULAR_HISTORY_MAXSTEPS 100
#define OKULAR_HISTORY_SAVEDSTEPS 10

/***** Document ******/

QString DocumentPrivate::pagesSizeString() const
{
    if (m_generator)
    {
        if (m_generator->pagesSizeMetric() != Generator::None)
        {
            QSizeF size = m_parent->allPagesSize();
            if (size.isValid()) return localizedSize(size);
            else return QString();
        }
        else return QString();
    }
    else return QString();
}

QString DocumentPrivate::namePaperSize(double inchesWidth, double inchesHeight) const
{
    const QPrinter::Orientation orientation = inchesWidth > inchesHeight ? QPrinter::Landscape : QPrinter::Portrait;

    const QSize pointsSize(inchesWidth *72.0, inchesHeight*72.0);
    const QPageSize::PageSizeId paperSize = QPageSize::id(pointsSize, QPageSize::FuzzyOrientationMatch);

    const QString paperName = QPageSize::name(paperSize);

    if (orientation == QPrinter::Portrait) {
        return i18nc(""paper type and orientation (eg: Portrait A4)"", ""Portrait %1"", paperName);
    } else {
        return i18nc(""paper type and orientation (eg: Portrait A4)"", ""Landscape %1"", paperName);
    }
}

QString DocumentPrivate::localizedSize(const QSizeF &size) const
{
    double inchesWidth = 0, inchesHeight = 0;
    switch (m_generator->pagesSizeMetric())
    {
        case Generator::Points:
            inchesWidth = size.width() / 72.0;
            inchesHeight = size.height() / 72.0;
        break;

        case Generator::Pixels:
        {
            const QSizeF dpi = m_generator->dpi();
            inchesWidth = size.width() / dpi.width();
            inchesHeight = size.height() / dpi.height();
        }
        break;

        case Generator::None:
        break;
    }
    if (QLocale::system().measurementSystem() == QLocale::ImperialSystem)
    {
        return i18nc(""%1 is width, %2 is height, %3 is paper size name"", ""%1 x %2 in (%3)"", inchesWidth, inchesHeight, namePaperSize(inchesWidth, inchesHeight));
    }
    else
    {
        return i18nc(""%1 is width, %2 is height, %3 is paper size name"", ""%1 x %2 mm (%3)"", QString::number(inchesWidth * 25.4, 'd', 0), QString::number(inchesHeight * 25.4, 'd', 0), namePaperSize(inchesWidth, inchesHeight));
    }
}

qulonglong DocumentPrivate::calculateMemoryToFree()
{
    // [MEM] choose memory parameters based on configuration profile
    qulonglong clipValue = 0;
    qulonglong memoryToFree = 0;

    switch ( SettingsCore::memoryLevel() )
    {
        case SettingsCore::EnumMemoryLevel::Low:
            memoryToFree = m_allocatedPixmapsTotalMemory;
            break;

        case SettingsCore::EnumMemoryLevel::Normal:
        {
            qulonglong thirdTotalMemory = getTotalMemory() / 3;
            qulonglong freeMemory = getFreeMemory();
            if (m_allocatedPixmapsTotalMemory > thirdTotalMemory) memoryToFree = m_allocatedPixmapsTotalMemory - thirdTotalMemory;
            if (m_allocatedPixmapsTotalMemory > freeMemory) clipValue = (m_allocatedPixmapsTotalMemory - freeMemory) / 2;
        }
        break;

        case SettingsCore::EnumMemoryLevel::Aggressive:
        {
            qulonglong freeMemory = getFreeMemory();
            if (m_allocatedPixmapsTotalMemory > freeMemory) clipValue = (m_allocatedPixmapsTotalMemory - freeMemory) / 2;
        }
        break;
        case SettingsCore::EnumMemoryLevel::Greedy:
        {
            qulonglong freeSwap;
            qulonglong freeMemory = getFreeMemory( &freeSwap );
            const qulonglong memoryLimit = qMin( qMax( freeMemory, getTotalMemory()/2 ), freeMemory+freeSwap );
            if (m_allocatedPixmapsTotalMemory > memoryLimit) clipValue = (m_allocatedPixmapsTotalMemory - memoryLimit) / 2;
        }
        break;
    }

    if ( clipValue > memoryToFree )
        memoryToFree = clipValue;

    return memoryToFree;
}

void DocumentPrivate::cleanupPixmapMemory()
{
    cleanupPixmapMemory( calculateMemoryToFree() );
}

void DocumentPrivate::cleanupPixmapMemory( qulonglong memoryToFree )
{
    if ( memoryToFree < 1 )
        return;

    const int currentViewportPage = (*m_viewportIterator).pageNumber;

    // Create a QMap of visible rects, indexed by page number
    QMap< int, VisiblePageRect * > visibleRects;
    QVector< Okular::VisiblePageRect * >::const_iterator vIt = m_pageRects.constBegin(), vEnd = m_pageRects.constEnd();
    for ( ; vIt != vEnd; ++vIt )
        visibleRects.insert( (*vIt)->pageNumber, (*vIt) );

    // Free memory starting from pages that are farthest from the current one
    int pagesFreed = 0;
    while ( memoryToFree > 0 )
    {
        AllocatedPixmap * p = searchLowestPriorityPixmap( true, true );
        if ( !p ) // No pixmap to remove
            break;

        qCDebug(OkularCoreDebug).nospace() << ""Evicting cache pixmap observer="" << p->observer << "" page="" << p->page;

        // m_allocatedPixmapsTotalMemory can't underflow because we always add or remove
        // the memory used by the AllocatedPixmap so at most it can reach zero
        m_allocatedPixmapsTotalMemory -= p->memory;
        // Make sure memoryToFree does not underflow
        if ( p->memory > memoryToFree )
            memoryToFree = 0;
        else
            memoryToFree -= p->memory;
        pagesFreed++;
        // delete pixmap
        m_pagesVector.at( p->page )->deletePixmap( p->observer );
        // delete allocation descriptor
        delete p;
    }

    // If we're still on low memory, try to free individual tiles

    // Store pages that weren't completely removed

    QLinkedList< AllocatedPixmap * > pixmapsToKeep;
    while (memoryToFree > 0)
    {
        int clean_hits = 0;
        foreach (DocumentObserver *observer, m_observers)
        {
            AllocatedPixmap * p = searchLowestPriorityPixmap( false, true, observer );
            if ( !p ) // No pixmap to remove
                continue;

            clean_hits++;

            TilesManager *tilesManager = m_pagesVector.at( p->page )->d->tilesManager( observer );
            if ( tilesManager && tilesManager->totalMemory() > 0 )
            {
                qulonglong memoryDiff = p->memory;
                NormalizedRect visibleRect;
                if ( visibleRects.contains( p->page ) )
                    visibleRect = visibleRects[ p->page ]->rect;

                // Free non visible tiles
                tilesManager->cleanupPixmapMemory( memoryToFree, visibleRect, currentViewportPage );

                p->memory = tilesManager->totalMemory();
                memoryDiff -= p->memory;
                memoryToFree = (memoryDiff < memoryToFree) ? (memoryToFree - memoryDiff) : 0;
                m_allocatedPixmapsTotalMemory -= memoryDiff;

                if ( p->memory > 0 )
                    pixmapsToKeep.append( p );
                else
                    delete p;
            }
            else
                pixmapsToKeep.append( p );
        }

        if (clean_hits == 0) break;
    }

    m_allocatedPixmaps += pixmapsToKeep;
    //p--rintf(""freeMemory A:[%d -%d = %d] \n"", m_allocatedPixmaps.count() + pagesFreed, pagesFreed, m_allocatedPixmaps.count() );
}

/* Returns the next pixmap to evict from cache, or NULL if no suitable pixmap
 * if found. If unloadableOnly is set, only unloadable pixmaps are returned. If
 * thenRemoveIt is set, the pixmap is removed from m_allocatedPixmaps before
 * returning it
 */
AllocatedPixmap * DocumentPrivate::searchLowestPriorityPixmap( bool unloadableOnly, bool thenRemoveIt, DocumentObserver *observer )
{
    QLinkedList< AllocatedPixmap * >::iterator pIt = m_allocatedPixmaps.begin();
    QLinkedList< AllocatedPixmap * >::iterator pEnd = m_allocatedPixmaps.end();
    QLinkedList< AllocatedPixmap * >::iterator farthestPixmap = pEnd;
    const int currentViewportPage = (*m_viewportIterator).pageNumber;

    /* Find the pixmap that is farthest from the current viewport */
    int maxDistance = -1;
    while ( pIt != pEnd )
    {
        const AllocatedPixmap * p = *pIt;
        // Filter by observer
        if ( observer == nullptr || p->observer == observer )
        {
            const int distance = qAbs( p->page - currentViewportPage );
            if ( maxDistance < distance && ( !unloadableOnly || p->observer->canUnloadPixmap( p->page ) ) )
            {
                maxDistance = distance;
                farthestPixmap = pIt;
            }
        }
        ++pIt;
    }

    /* No pixmap to remove */
    if ( farthestPixmap == pEnd )
        return nullptr;

    AllocatedPixmap * selectedPixmap = *farthestPixmap;
    if ( thenRemoveIt )
        m_allocatedPixmaps.erase( farthestPixmap );
    return selectedPixmap;
}

qulonglong DocumentPrivate::getTotalMemory()
{
    static qulonglong cachedValue = 0;
    if ( cachedValue )
        return cachedValue;

#if defined(Q_OS_LINUX)
    // if /proc/meminfo doesn't exist, return 128MB
    QFile memFile( QStringLiteral(""/proc/meminfo"") );
    if ( !memFile.open( QIODevice::ReadOnly ) )
        return (cachedValue = 134217728);

    QTextStream readStream( &memFile );
    while ( true )
    {
        QString entry = readStream.readLine();
        if ( entry.isNull() ) break;
        if ( entry.startsWith( QLatin1String(""MemTotal:"") ) )
            return (cachedValue = (Q_UINT64_C(1024) * entry.section( QLatin1Char ( ' ' ), -2, -2 ).toULongLong()));
    }
#elif defined(Q_OS_FREEBSD)
    qulonglong physmem;
    int mib[] = {CTL_HW, HW_PHYSMEM};
    size_t len = sizeof( physmem );
    if ( sysctl( mib, 2, &physmem, &len, NULL, 0 ) == 0 )
        return (cachedValue = physmem);
#elif defined(Q_OS_WIN)
    MEMORYSTATUSEX stat;
    stat.dwLength = sizeof(stat);
    GlobalMemoryStatusEx (&stat);

    return ( cachedValue = stat.ullTotalPhys );
#endif
    return (cachedValue = 134217728);
}

qulonglong DocumentPrivate::getFreeMemory( qulonglong *freeSwap )
{
    static QTime lastUpdate = QTime::currentTime().addSecs(-3);
    static qulonglong cachedValue = 0;
    static qulonglong cachedFreeSwap = 0;

    if ( qAbs( lastUpdate.secsTo( QTime::currentTime() ) ) <= 2 )
    {
        if (freeSwap)
            *freeSwap = cachedFreeSwap;
        return cachedValue;
    }

    /* Initialize the returned free swap value to 0. It is overwritten if the
     * actual value is available */
    if (freeSwap)
        *freeSwap = 0;

#if defined(Q_OS_LINUX)
    // if /proc/meminfo doesn't exist, return MEMORY FULL
    QFile memFile( QStringLiteral(""/proc/meminfo"") );
    if ( !memFile.open( QIODevice::ReadOnly ) )
        return 0;

    // read /proc/meminfo and sum up the contents of 'MemFree', 'Buffers'
    // and 'Cached' fields. consider swapped memory as used memory.
    qulonglong memoryFree = 0;
    QString entry;
    QTextStream readStream( &memFile );
    static const int nElems = 5;
    QString names[nElems] = { QStringLiteral(""MemFree:""), QStringLiteral(""Buffers:""), QStringLiteral(""Cached:""), QStringLiteral(""SwapFree:""), QStringLiteral(""SwapTotal:"") };
    qulonglong values[nElems] = { 0, 0, 0, 0, 0 };
    bool foundValues[nElems] = { false, false, false, false, false };
    while ( true )
    {
        entry = readStream.readLine();
        if ( entry.isNull() ) break;
        for ( int i = 0; i < nElems; ++i )
        {
            if ( entry.startsWith( names[i] ) )
            {
                values[i] = entry.section( QLatin1Char ( ' ' ), -2, -2 ).toULongLong( &foundValues[i] );
            }
        }
    }
    memFile.close();
    bool found = true;
    for ( int i = 0; found && i < nElems; ++i )
        found = found && foundValues[i];
    if ( found )
    {
        /* MemFree + Buffers + Cached - SwapUsed =
         * = MemFree + Buffers + Cached - (SwapTotal - SwapFree) =
         * = MemFree + Buffers + Cached + SwapFree - SwapTotal */
        memoryFree = values[0] + values[1] + values[2] + values[3];
        if ( values[4] > memoryFree )
            memoryFree = 0;
        else
            memoryFree -= values[4];
    }
    else
    {
        return 0;
    }

    lastUpdate = QTime::currentTime();

    if (freeSwap)
        *freeSwap = ( cachedFreeSwap = (Q_UINT64_C(1024) * values[3]) );
    return ( cachedValue = (Q_UINT64_C(1024) * memoryFree) );
#elif defined(Q_OS_FREEBSD)
    qulonglong cache, inact, free, psize;
    size_t cachelen, inactlen, freelen, psizelen;
    cachelen = sizeof( cache );
    inactlen = sizeof( inact );
    freelen = sizeof( free );
    psizelen = sizeof( psize );
    // sum up inactive, cached and free memory
    if ( sysctlbyname( ""vm.stats.vm.v_cache_count"", &cache, &cachelen, NULL, 0 ) == 0 &&
            sysctlbyname( ""vm.stats.vm.v_inactive_count"", &inact, &inactlen, NULL, 0 ) == 0 &&
            sysctlbyname( ""vm.stats.vm.v_free_count"", &free, &freelen, NULL, 0 ) == 0 &&
            sysctlbyname( ""vm.stats.vm.v_page_size"", &psize, &psizelen, NULL, 0 ) == 0 )
    {
        lastUpdate = QTime::currentTime();
        return (cachedValue = (cache + inact + free) * psize);
    }
    else
    {
        return 0;
    }
#elif defined(Q_OS_WIN)
    MEMORYSTATUSEX stat;
    stat.dwLength = sizeof(stat);
    GlobalMemoryStatusEx (&stat);

    lastUpdate = QTime::currentTime();

    if (freeSwap)
        *freeSwap = ( cachedFreeSwap = stat.ullAvailPageFile );
    return ( cachedValue = stat.ullAvailPhys );
#else
    // tell the memory is full.. will act as in LOW profile
    return 0;
#endif
}

bool DocumentPrivate::loadDocumentInfo( LoadDocumentInfoFlags loadWhat )
// note: load data and stores it internally (document or pages). observers
// are still uninitialized at this point so don't access them
{
    //qCDebug(OkularCoreDebug).nospace() << ""Using '"" << d->m_xmlFileName << ""' as document info file."";
    if ( m_xmlFileName.isEmpty() )
        return false;

    QFile infoFile( m_xmlFileName );
    return loadDocumentInfo( infoFile, loadWhat );
}

bool DocumentPrivate::loadDocumentInfo( QFile &infoFile, LoadDocumentInfoFlags loadWhat )
{
    if ( !infoFile.exists() || !infoFile.open( QIODevice::ReadOnly ) )
        return false;

    // Load DOM from XML file
    QDomDocument doc( QStringLiteral(""documentInfo"") );
    if ( !doc.setContent( &infoFile ) )
    {
        qCDebug(OkularCoreDebug) << ""Can't load XML pair! Check for broken xml."";
        infoFile.close();
        return false;
    }
    infoFile.close();

    QDomElement root = doc.documentElement();

    if ( root.tagName() != QLatin1String(""documentInfo"") )
        return false;

    QUrl documentUrl( root.attribute( ""url"" ) );
    bool loadedAnything = false; // set if something gets actually loaded

    // Parse the DOM tree
    QDomNode topLevelNode = root.firstChild();
    while ( topLevelNode.isElement() )
    {
        QString catName = topLevelNode.toElement().tagName();

        // Restore page attributes (bookmark, annotations, ...) from the DOM
        if ( catName == QLatin1String(""pageList"") && ( loadWhat & LoadPageInfo ) )
        {
            QDomNode pageNode = topLevelNode.firstChild();
            while ( pageNode.isElement() )
            {
                QDomElement pageElement = pageNode.toElement();
                if ( pageElement.hasAttribute( QStringLiteral(""number"") ) )
                {
                    // get page number (node's attribute)
                    bool ok;
                    int pageNumber = pageElement.attribute( QStringLiteral(""number"") ).toInt( &ok );

                    // pass the domElement to the right page, to read config data from
                    if ( ok && pageNumber >= 0 && pageNumber < (int)m_pagesVector.count() )
                    {
                        if ( m_pagesVector[ pageNumber ]->d->restoreLocalContents( pageElement ) )
                            loadedAnything = true;
                    }
                }
                pageNode = pageNode.nextSibling();
            }
        }

        // Restore 'general info' from the DOM
        else if ( catName == QLatin1String(""generalInfo"") && ( loadWhat & LoadGeneralInfo ) )
        {
            QDomNode infoNode = topLevelNode.firstChild();
            while ( infoNode.isElement() )
            {
                QDomElement infoElement = infoNode.toElement();

                // restore viewports history
                if ( infoElement.tagName() == QLatin1String(""history"") )
                {
                    // clear history
                    m_viewportHistory.clear();
                    // append old viewports
                    QDomNode historyNode = infoNode.firstChild();
                    while ( historyNode.isElement() )
                    {
                        QDomElement historyElement = historyNode.toElement();
                        if ( historyElement.hasAttribute( QStringLiteral(""viewport"") ) )
                        {
                            QString vpString = historyElement.attribute( QStringLiteral(""viewport"") );
                            m_viewportIterator = m_viewportHistory.insert( m_viewportHistory.end(),
                                    DocumentViewport( vpString ) );
                            loadedAnything = true;
                        }
                        historyNode = historyNode.nextSibling();
                    }
                    // consistancy check
                    if ( m_viewportHistory.isEmpty() )
                        m_viewportIterator = m_viewportHistory.insert( m_viewportHistory.end(), DocumentViewport() );
                }
                else if ( infoElement.tagName() == QLatin1String(""rotation"") )
                {
                    QString str = infoElement.text();
                    bool ok = true;
                    int newrotation = !str.isEmpty() ? ( str.toInt( &ok ) % 4 ) : 0;
                    if ( ok && newrotation != 0 )
                    {
                        setRotationInternal( newrotation, false );
                        loadedAnything = true;
                    }
                }
                else if ( infoElement.tagName() == QLatin1String(""views"") )
                {
                    QDomNode viewNode = infoNode.firstChild();
                    while ( viewNode.isElement() )
                    {
                        QDomElement viewElement = viewNode.toElement();
                        if ( viewElement.tagName() == QLatin1String(""view"") )
                        {
                            const QString viewName = viewElement.attribute( QStringLiteral(""name"") );
                            Q_FOREACH ( View * view, m_views )
                            {
                                if ( view->name() == viewName )
                                {
                                    loadViewsInfo( view, viewElement );
                                    loadedAnything = true;
                                    break;
                                }
                            }
                        }
                        viewNode = viewNode.nextSibling();
                    }
                }
                infoNode = infoNode.nextSibling();
            }
        }

        topLevelNode = topLevelNode.nextSibling();
    } // </documentInfo>

    return loadedAnything;
}

void DocumentPrivate::loadViewsInfo( View *view, const QDomElement &e )
{
    QDomNode viewNode = e.firstChild();
    while ( viewNode.isElement() )
    {
        QDomElement viewElement = viewNode.toElement();

        if ( viewElement.tagName() == QLatin1String(""zoom"") )
        {
            const QString valueString = viewElement.attribute( QStringLiteral(""value"") );
            bool newzoom_ok = true;
            const double newzoom = !valueString.isEmpty() ? valueString.toDouble( &newzoom_ok ) : 1.0;
            if ( newzoom_ok && newzoom != 0
                 && view->supportsCapability( View::Zoom )
                 && ( view->capabilityFlags( View::Zoom ) & ( View::CapabilityRead | View::CapabilitySerializable ) ) )
            {
                view->setCapability( View::Zoom, newzoom );
            }
            const QString modeString = viewElement.attribute( QStringLiteral(""mode"") );
            bool newmode_ok = true;
            const int newmode = !modeString.isEmpty() ? modeString.toInt( &newmode_ok ) : 2;
            if ( newmode_ok
                 && view->supportsCapability( View::ZoomModality )
                 && ( view->capabilityFlags( View::ZoomModality ) & ( View::CapabilityRead | View::CapabilitySerializable ) ) )
            {
                view->setCapability( View::ZoomModality, newmode );
            }
        }

        viewNode = viewNode.nextSibling();
    }
}

void DocumentPrivate::saveViewsInfo( View *view, QDomElement &e ) const
{
    if ( view->supportsCapability( View::Zoom )
         && ( view->capabilityFlags( View::Zoom ) & ( View::CapabilityRead | View::CapabilitySerializable ) )
         && view->supportsCapability( View::ZoomModality )
         && ( view->capabilityFlags( View::ZoomModality ) & ( View::CapabilityRead | View::CapabilitySerializable ) ) )
    {
        QDomElement zoomEl = e.ownerDocument().createElement( QStringLiteral(""zoom"") );
        e.appendChild( zoomEl );
        bool ok = true;
        const double zoom = view->capability( View::Zoom ).toDouble( &ok );
        if ( ok && zoom != 0 )
        {
            zoomEl.setAttribute( QStringLiteral(""value""), QString::number(zoom) );
        }
        const int mode = view->capability( View::ZoomModality ).toInt( &ok );
        if ( ok )
        {
            zoomEl.setAttribute( QStringLiteral(""mode""), mode );
        }
    }
}

QUrl DocumentPrivate::giveAbsoluteUrl( const QString & fileName ) const
{
    if ( !QDir::isRelativePath( fileName ) )
        return QUrl::fromLocalFile(fileName);

    if ( !m_url.isValid() )
        return QUrl();

    return QUrl(KIO::upUrl(m_url).toString() + fileName);
}

bool DocumentPrivate::openRelativeFile( const QString & fileName )
{
    QUrl url = giveAbsoluteUrl( fileName );
    if ( url.isEmpty() )
        return false;

    qCDebug(OkularCoreDebug).nospace() << ""openRelativeFile: '"" << url << ""'"";

    emit m_parent->openUrl( url );
    return true;
}

Generator * DocumentPrivate::loadGeneratorLibrary( const KPluginMetaData &service )
{
    KPluginLoader loader( service.fileName() );
    qCDebug(OkularCoreDebug) << service.fileName();
    KPluginFactory *factory = loader.factory();
    if ( !factory )
    {
        qCWarning(OkularCoreDebug).nospace() << ""Invalid plugin factory for "" << service.fileName() << "":"" << loader.errorString();
        return nullptr;
    }

    Generator * plugin = factory->create<Okular::Generator>();

    GeneratorInfo info( plugin, service );
    m_loadedGenerators.insert( service.pluginId(), info );
    return plugin;
}

void DocumentPrivate::loadAllGeneratorLibraries()
{
    if ( m_generatorsLoaded )
        return;

    loadServiceList( availableGenerators() );

    m_generatorsLoaded = true;
}

void DocumentPrivate::loadServiceList( const QVector<KPluginMetaData>& offers )
{
    int count = offers.count();
    if ( count <= 0 )
        return;

    for ( int i = 0; i < count; ++i )
    {
        QString id = offers.at(i).pluginId();
        // don't load already loaded generators
        QHash< QString, GeneratorInfo >::const_iterator genIt = m_loadedGenerators.constFind( id );
        if ( !m_loadedGenerators.isEmpty() && genIt != m_loadedGenerators.constEnd() )
            continue;

        Generator * g = loadGeneratorLibrary( offers.at(i) );
        (void)g;
    }
}

void DocumentPrivate::unloadGenerator( const GeneratorInfo& info )
{
    delete info.generator;
}

void DocumentPrivate::cacheExportFormats()
{
    if ( m_exportCached )
        return;

    const ExportFormat::List formats = m_generator->exportFormats();
    for ( int i = 0; i < formats.count(); ++i )
    {
        if ( formats.at( i ).mimeType().name() == QLatin1String( ""text/plain"" ) )
            m_exportToText = formats.at( i );
        else
            m_exportFormats.append( formats.at( i ) );
    }

    m_exportCached = true;
}

ConfigInterface* DocumentPrivate::generatorConfig( GeneratorInfo& info )
{
    if ( info.configChecked )
        return info.config;

    info.config = qobject_cast< Okular::ConfigInterface * >( info.generator );
    info.configChecked = true;
    return info.config;
}

SaveInterface* DocumentPrivate::generatorSave( GeneratorInfo& info )
{
    if ( info.saveChecked )
        return info.save;

    info.save = qobject_cast< Okular::SaveInterface * >( info.generator );
    info.saveChecked = true;
    return info.save;
}

Document::OpenResult DocumentPrivate::openDocumentInternal( const KPluginMetaData& offer, bool isstdin, const QString& docFile, const QByteArray& filedata, const QString& password )
{
    QString propName = offer.pluginId();
    QHash< QString, GeneratorInfo >::const_iterator genIt = m_loadedGenerators.constFind( propName );
    m_walletGenerator = nullptr;
    if ( genIt != m_loadedGenerators.constEnd() )
    {
        m_generator = genIt.value().generator;
    }
    else
    {
        m_generator = loadGeneratorLibrary( offer );
        if ( !m_generator )
            return Document::OpenError;
        genIt = m_loadedGenerators.constFind( propName );
        Q_ASSERT( genIt != m_loadedGenerators.constEnd() );
    }
    Q_ASSERT_X( m_generator, ""Document::load()"", ""null generator?!"" );

    m_generator->d_func()->m_document = this;

    // connect error reporting signals
    QObject::connect( m_generator, &Generator::error, m_parent, &Document::error );
    QObject::connect( m_generator, &Generator::warning, m_parent, &Document::warning );
    QObject::connect( m_generator, &Generator::notice, m_parent, &Document::notice );

    QApplication::setOverrideCursor( Qt::WaitCursor );

    const QSizeF dpi = Utils::realDpi(m_widget);
    qCDebug(OkularCoreDebug) << ""Output DPI:"" << dpi;
    m_generator->setDPI(dpi);

    Document::OpenResult openResult = Document::OpenError;
    if ( !isstdin )
    {
        openResult = m_generator->loadDocumentWithPassword( docFile, m_pagesVector, password );
    }
    else if ( !filedata.isEmpty() )
    {
        if ( m_generator->hasFeature( Generator::ReadRawData ) )
        {
            openResult = m_generator->loadDocumentFromDataWithPassword( filedata, m_pagesVector, password );
        }
        else
        {
            m_tempFile = new QTemporaryFile();
            if ( !m_tempFile->open() )
            {
                delete m_tempFile;
                m_tempFile = nullptr;
            }
            else
            {
                m_tempFile->write( filedata );
                QString tmpFileName = m_tempFile->fileName();
                m_tempFile->close();
                openResult = m_generator->loadDocumentWithPassword( tmpFileName, m_pagesVector, password );
            }
        }
    }

    QApplication::restoreOverrideCursor();
    if ( openResult != Document::OpenSuccess || m_pagesVector.size() <= 0 )
    {
        m_generator->d_func()->m_document = nullptr;
        QObject::disconnect( m_generator, nullptr, m_parent, nullptr );
        // TODO this is a bit of a hack, since basically means that
        // you can only call walletDataForFile after calling openDocument
        // but since in reality it's what happens I've decided not to refactor/break API
        // One solution is just kill walletDataForFile and make OpenResult be an object
        // where the wallet data is also returned when OpenNeedsPassword
        m_walletGenerator = m_generator;
        m_generator = nullptr;

        qDeleteAll( m_pagesVector );
        m_pagesVector.clear();
        delete m_tempFile;
        m_tempFile = nullptr;

        // TODO: emit a message telling the document is empty
        if ( openResult == Document::OpenSuccess )
            openResult = Document::OpenError;
    }

    return openResult;
}

bool DocumentPrivate::savePageDocumentInfo( QTemporaryFile *infoFile, int what ) const
{
    if ( infoFile->open() )
    {
        // 1. Create DOM
        QDomDocument doc( QStringLiteral(""documentInfo"") );
        QDomProcessingInstruction xmlPi = doc.createProcessingInstruction(
                QStringLiteral( ""xml"" ), QStringLiteral( ""version=\""1.0\"" encoding=\""utf-8\"""" ) );
        doc.appendChild( xmlPi );
        QDomElement root = doc.createElement( QStringLiteral(""documentInfo"") );
        doc.appendChild( root );

        // 2.1. Save page attributes (bookmark state, annotations, ... ) to DOM
        QDomElement pageList = doc.createElement( QStringLiteral(""pageList"") );
        root.appendChild( pageList );
        // <page list><page number='x'>.... </page> save pages that hold data
        QVector< Page * >::const_iterator pIt = m_pagesVector.constBegin(), pEnd = m_pagesVector.constEnd();
        for ( ; pIt != pEnd; ++pIt )
            (*pIt)->d->saveLocalContents( pageList, doc, PageItems( what ) );

        // 3. Save DOM to XML file
        QString xml = doc.toString();
        QTextStream os( infoFile );
        os.setCodec( ""UTF-8"" );
        os << xml;
        return true;
    }
    return false;
}

DocumentViewport DocumentPrivate::nextDocumentViewport() const
{
    DocumentViewport ret = m_nextDocumentViewport;
    if ( !m_nextDocumentDestination.isEmpty() && m_generator )
    {
        DocumentViewport vp( m_parent->metaData( QStringLiteral(""NamedViewport""), m_nextDocumentDestination ).toString() );
        if ( vp.isValid() )
        {
            ret = vp;
        }
    }
    return ret;
}

void DocumentPrivate::performAddPageAnnotation( int page, Annotation * annotation )
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );
    AnnotationProxy *proxy = iface ? iface->annotationProxy() : nullptr;

    // find out the page to attach annotation
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    // the annotation belongs already to a page
    if ( annotation->d_ptr->m_page )
        return;

    // add annotation to the page
    kp->addAnnotation( annotation );

    // tell the annotation proxy
    if ( proxy && proxy->supports(AnnotationProxy::Addition) )
        proxy->notifyAddition( annotation, page );

    // notify observers about the change
    notifyAnnotationChanges( page );

    if ( annotation->flags() & Annotation::ExternallyDrawn )
    {
        // Redraw everything, including ExternallyDrawn annotations
        refreshPixmaps( page );
    }
}

void DocumentPrivate::performRemovePageAnnotation( int page, Annotation * annotation )
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );
    AnnotationProxy *proxy = iface ? iface->annotationProxy() : nullptr;
    bool isExternallyDrawn;

    // find out the page
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    if ( annotation->flags() & Annotation::ExternallyDrawn )
        isExternallyDrawn = true;
    else
        isExternallyDrawn = false;

    // try to remove the annotation
    if ( m_parent->canRemovePageAnnotation( annotation ) )
    {
        // tell the annotation proxy
        if ( proxy && proxy->supports(AnnotationProxy::Removal) )
            proxy->notifyRemoval( annotation, page );

        kp->removeAnnotation( annotation ); // Also destroys the object

        // in case of success, notify observers about the change
        notifyAnnotationChanges( page );

        if ( isExternallyDrawn )
        {
            // Redraw everything, including ExternallyDrawn annotations
            refreshPixmaps( page );
        }
    }
}

void DocumentPrivate::performModifyPageAnnotation( int page, Annotation * annotation, bool appearanceChanged )
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );
    AnnotationProxy *proxy = iface ? iface->annotationProxy() : nullptr;

    // find out the page
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    // tell the annotation proxy
    if ( proxy && proxy->supports(AnnotationProxy::Modification) )
    {
        proxy->notifyModification( annotation, page, appearanceChanged );
    }

    // notify observers about the change
    notifyAnnotationChanges( page );
    if ( appearanceChanged && (annotation->flags() & Annotation::ExternallyDrawn) )
    {
        /* When an annotation is being moved, the generator will not render it.
         * Therefore there's no need to refresh pixmaps after the first time */
        if ( annotation->flags() & (Annotation::BeingMoved | Annotation::BeingResized) )
        {
            if ( m_annotationBeingModified )
                return;
            else // First time: take note
                m_annotationBeingModified = true;
        }
        else
        {
            m_annotationBeingModified = false;
        }

        // Redraw everything, including ExternallyDrawn annotations
        qCDebug(OkularCoreDebug) << ""Refreshing Pixmaps"";
        refreshPixmaps( page );
    }
}

void DocumentPrivate::performSetAnnotationContents( const QString & newContents, Annotation *annot, int pageNumber )
{
    bool appearanceChanged = false;

    // Check if appearanceChanged should be true
    switch ( annot->subType() )
    {
        // If it's an in-place TextAnnotation, set the inplace text
        case Okular::Annotation::AText:
        {
            Okular::TextAnnotation * txtann = static_cast< Okular::TextAnnotation * >( annot );
            if ( txtann->textType() == Okular::TextAnnotation::InPlace )
            {
                appearanceChanged = true;
            }
            break;
        }
        // If it's a LineAnnotation, check if caption text is visible
        case Okular::Annotation::ALine:
        {
            Okular::LineAnnotation * lineann = static_cast< Okular::LineAnnotation * >( annot );
            if ( lineann->showCaption() )
                appearanceChanged = true;
            break;
        }
        default:
            break;
    }

    // Set contents
    annot->setContents( newContents );

    // Tell the document the annotation has been modified
    performModifyPageAnnotation( pageNumber,  annot, appearanceChanged );
}

void DocumentPrivate::recalculateForms()
{
    const QVariant fco = m_parent->metaData(QLatin1String(""FormCalculateOrder""));
    const QVector<int> formCalculateOrder = fco.value<QVector<int>>();
    foreach(int formId, formCalculateOrder) {
        for ( uint pageIdx = 0; pageIdx  < m_parent->pages(); pageIdx++ )
        {
            const Page *p = m_parent->page( pageIdx );
            if (p)
            {
                bool pageNeedsRefresh = false;
                foreach( FormField *form, p->formFields() )
                {
                    if ( form->id() == formId ) {
                        Action *action = form->additionalAction( FormField::CalculateField );
                        if (action)
                        {
                            FormFieldText *fft = dynamic_cast< FormFieldText * >( form );
                            std::shared_ptr<Event> event;
                            QString oldVal;
                            if ( fft )
                            {
                                // Pepare text calculate event
                                event = Event::createFormCalculateEvent( fft, m_pagesVector[pageIdx] );
                                if ( !m_scripter )
                                    m_scripter = new Scripter( this );
                                m_scripter->setEvent( event.get() );
                                // The value maybe changed in javascript so save it first.
                                oldVal = fft->text();
                            }

                            m_parent->processAction( action );
                            if ( event && fft )
                            {
                                // Update text field from calculate
                                m_scripter->setEvent( nullptr );
                                const QString newVal = event->value().toString();
                                if ( newVal != oldVal )
                                {
                                    fft->setText( newVal );
                                    emit m_parent->refreshFormWidget( fft );
                                    pageNeedsRefresh = true;
                                }
                            }
                        }
                        else
                        {
                            qWarning() << ""Form that is part of calculate order doesn't have a calculate action"";
                        }
                    }
                }
                if ( pageNeedsRefresh )
                {
                    refreshPixmaps( p->number() );
                }
            }
        }
    }
}

void DocumentPrivate::saveDocumentInfo() const
{
    if ( m_xmlFileName.isEmpty() )
        return;

    QFile infoFile( m_xmlFileName );
    qCDebug(OkularCoreDebug) << ""About to save document info to"" << m_xmlFileName;
    if (!infoFile.open( QIODevice::WriteOnly | QIODevice::Truncate))
    {
        qCWarning(OkularCoreDebug) << ""Failed to open docdata file"" << m_xmlFileName;
        return;
    }
    // 1. Create DOM
    QDomDocument doc( QStringLiteral(""documentInfo"") );
    QDomProcessingInstruction xmlPi = doc.createProcessingInstruction(
            QStringLiteral( ""xml"" ), QStringLiteral( ""version=\""1.0\"" encoding=\""utf-8\"""" ) );
    doc.appendChild( xmlPi );
    QDomElement root = doc.createElement( QStringLiteral(""documentInfo"") );
    root.setAttribute( QStringLiteral(""url""), m_url.toDisplayString(QUrl::PreferLocalFile) );
    doc.appendChild( root );

    // 2.1. Save page attributes (bookmark state, annotations, ... ) to DOM
    //  -> do this if there are not-yet-migrated annots or forms in docdata/
    if ( m_docdataMigrationNeeded )
    {
        QDomElement pageList = doc.createElement( ""pageList"" );
        root.appendChild( pageList );
        // OriginalAnnotationPageItems and OriginalFormFieldPageItems tell to
        // store the same unmodified annotation list and form contents that we
        // read when we opened the file and ignore any change made by the user.
        // Since we don't store annotations and forms in docdata/ any more, this is
        // necessary to preserve annotations/forms that previous Okular version
        // had stored there.
        const PageItems saveWhat = AllPageItems | OriginalAnnotationPageItems | OriginalFormFieldPageItems;
        // <page list><page number='x'>.... </page> save pages that hold data
        QVector< Page * >::const_iterator pIt = m_pagesVector.constBegin(), pEnd = m_pagesVector.constEnd();
        for ( ; pIt != pEnd; ++pIt )
            (*pIt)->d->saveLocalContents( pageList, doc, saveWhat );
    }

    // 2.2. Save document info (current viewport, history, ... ) to DOM
    QDomElement generalInfo = doc.createElement( QStringLiteral(""generalInfo"") );
    root.appendChild( generalInfo );
    // create rotation node
    if ( m_rotation != Rotation0 )
    {
        QDomElement rotationNode = doc.createElement( QStringLiteral(""rotation"") );
        generalInfo.appendChild( rotationNode );
        rotationNode.appendChild( doc.createTextNode( QString::number( (int)m_rotation ) ) );
    }
    // <general info><history> ... </history> save history up to OKULAR_HISTORY_SAVEDSTEPS viewports
    QLinkedList< DocumentViewport >::const_iterator backIterator = m_viewportIterator;
    if ( backIterator != m_viewportHistory.constEnd() )
    {
        // go back up to OKULAR_HISTORY_SAVEDSTEPS steps from the current viewportIterator
        int backSteps = OKULAR_HISTORY_SAVEDSTEPS;
        while ( backSteps-- && backIterator != m_viewportHistory.constBegin() )
            --backIterator;

        // create history root node
        QDomElement historyNode = doc.createElement( QStringLiteral(""history"") );
        generalInfo.appendChild( historyNode );

        // add old[backIterator] and present[viewportIterator] items
        QLinkedList< DocumentViewport >::const_iterator endIt = m_viewportIterator;
        ++endIt;
        while ( backIterator != endIt )
        {
            QString name = (backIterator == m_viewportIterator) ? QStringLiteral (""current"") : QStringLiteral (""oldPage"");
            QDomElement historyEntry = doc.createElement( name );
            historyEntry.setAttribute( QStringLiteral(""viewport""), (*backIterator).toString() );
            historyNode.appendChild( historyEntry );
            ++backIterator;
        }
    }
    // create views root node
    QDomElement viewsNode = doc.createElement( QStringLiteral(""views"") );
    generalInfo.appendChild( viewsNode );
    Q_FOREACH ( View * view, m_views )
    {
        QDomElement viewEntry = doc.createElement( QStringLiteral(""view"") );
        viewEntry.setAttribute( QStringLiteral(""name""), view->name() );
        viewsNode.appendChild( viewEntry );
        saveViewsInfo( view, viewEntry );
    }

    // 3. Save DOM to XML file
    QString xml = doc.toString();
    QTextStream os( &infoFile );
    os.setCodec( ""UTF-8"" );
    os << xml;
    infoFile.close();
}

void DocumentPrivate::slotTimedMemoryCheck()
{
    // [MEM] clean memory (for 'free mem dependant' profiles only)
    if ( SettingsCore::memoryLevel() != SettingsCore::EnumMemoryLevel::Low &&
         m_allocatedPixmapsTotalMemory > 1024*1024 )
        cleanupPixmapMemory();
}

void DocumentPrivate::sendGeneratorPixmapRequest()
{
    /* If the pixmap cache will have to be cleaned in order to make room for the
     * next request, get the distance from the current viewport of the page
     * whose pixmap will be removed. We will ignore preload requests for pages
     * that are at the same distance or farther */
    const qulonglong memoryToFree = calculateMemoryToFree();
    const int currentViewportPage = (*m_viewportIterator).pageNumber;
    int maxDistance = INT_MAX; // Default: No maximum
    if ( memoryToFree )
    {
        AllocatedPixmap *pixmapToReplace = searchLowestPriorityPixmap( true );
        if ( pixmapToReplace )
            maxDistance = qAbs( pixmapToReplace->page - currentViewportPage );
    }

    // find a request
    PixmapRequest * request = nullptr;
    m_pixmapRequestsMutex.lock();
    while ( !m_pixmapRequestsStack.isEmpty() && !request )
    {
        PixmapRequest * r = m_pixmapRequestsStack.last();
        if (!r)
        {
            m_pixmapRequestsStack.pop_back();
            continue;
        }

        QRect requestRect = r->isTile() ? r->normalizedRect().geometry( r->width(), r->height() ) : QRect( 0, 0, r->width(), r->height() );
        TilesManager *tilesManager = r->d->tilesManager();

        // If it's a preload but the generator is not threaded no point in trying to preload
        if ( r->preload() && !m_generator->hasFeature( Generator::Threaded ) )
        {
            m_pixmapRequestsStack.pop_back();
            delete r;
        }
        // request only if page isn't already present and request has valid id
        else if ( ( !r->d->mForce && r->page()->hasPixmap( r->observer(), r->width(), r->height(), r->normalizedRect() ) ) || !m_observers.contains(r->observer()) )
        {
            m_pixmapRequestsStack.pop_back();
            delete r;
        }
        else if ( !r->d->mForce && r->preload() && qAbs( r->pageNumber() - currentViewportPage ) >= maxDistance )
        {
            m_pixmapRequestsStack.pop_back();
            //qCDebug(OkularCoreDebug) << ""Ignoring request that doesn't fit in cache"";
            delete r;
        }
        // Ignore requests for pixmaps that are already being generated
        else if ( tilesManager && tilesManager->isRequesting( r->normalizedRect(), r->width(), r->height() ) )
        {
            m_pixmapRequestsStack.pop_back();
            delete r;
        }
        // If the requested area is above 8000000 pixels, switch on the tile manager
        else if ( !tilesManager && m_generator->hasFeature( Generator::TiledRendering ) && (long)r->width() * (long)r->height() > 8000000L )
        {
            // if the image is too big. start using tiles
            qCDebug(OkularCoreDebug).nospace() << ""Start using tiles on page "" << r->pageNumber()
                << "" ("" << r->width() << ""x"" << r->height() << "" px);"";

            // fill the tiles manager with the last rendered pixmap
            const QPixmap *pixmap = r->page()->_o_nearestPixmap( r->observer(), r->width(), r->height() );
            if ( pixmap )
            {
                tilesManager = new TilesManager( r->pageNumber(), pixmap->width(), pixmap->height(), r->page()->rotation() );
                tilesManager->setPixmap( pixmap, NormalizedRect( 0, 0, 1, 1 ), true /*isPartialPixmap*/ );
                tilesManager->setSize( r->width(), r->height() );
            }
            else
            {
                // create new tiles manager
                tilesManager = new TilesManager( r->pageNumber(), r->width(), r->height(), r->page()->rotation() );
            }
            tilesManager->setRequest( r->normalizedRect(), r->width(), r->height() );
            r->page()->deletePixmap( r->observer() );
            r->page()->d->setTilesManager( r->observer(), tilesManager );
            r->setTile( true );

            // Change normalizedRect to the smallest rect that contains all
            // visible tiles.
            if ( !r->normalizedRect().isNull() )
            {
                NormalizedRect tilesRect;
                const QList<Tile> tiles = tilesManager->tilesAt( r->normalizedRect(), TilesManager::TerminalTile );
                QList<Tile>::const_iterator tIt = tiles.constBegin(), tEnd = tiles.constEnd();
                while ( tIt != tEnd )
                {
                    Tile tile = *tIt;
                    if ( tilesRect.isNull() )
                        tilesRect = tile.rect();
                    else
                        tilesRect |= tile.rect();

                    ++tIt;
                }

                r->setNormalizedRect( tilesRect );
                request = r;
            }
            else
            {
                // Discard request if normalizedRect is null. This happens in
                // preload requests issued by PageView if the requested page is
                // not visible and the user has just switched from a non-tiled
                // zoom level to a tiled one
                m_pixmapRequestsStack.pop_back();
                delete r;
            }
        }
        // If the requested area is below 6000000 pixels, switch off the tile manager
        else if ( tilesManager && (long)r->width() * (long)r->height() < 6000000L )
        {
            qCDebug(OkularCoreDebug).nospace() << ""Stop using tiles on page "" << r->pageNumber()
                << "" ("" << r->width() << ""x"" << r->height() << "" px);"";

            // page is too small. stop using tiles.
            r->page()->deletePixmap( r->observer() );
            r->setTile( false );

            request = r;
        }
        else if ( (long)requestRect.width() * (long)requestRect.height() > 200000000L && (SettingsCore::memoryLevel() != SettingsCore::EnumMemoryLevel::Greedy ) )
        {
            m_pixmapRequestsStack.pop_back();
            if ( !m_warnedOutOfMemory )
            {
                qCWarning(OkularCoreDebug).nospace() << ""Running out of memory on page "" << r->pageNumber()
                    << "" ("" << r->width() << ""x"" << r->height() << "" px);"";
                qCWarning(OkularCoreDebug) << ""this message will be reported only once."";
                m_warnedOutOfMemory = true;
            }
            delete r;
        }
        else
        {
            request = r;
        }
    }

    // if no request found (or already generated), return
    if ( !request )
    {
        m_pixmapRequestsMutex.unlock();
        return;
    }

    // [MEM] preventive memory freeing
    qulonglong pixmapBytes = 0;
    TilesManager * tm = request->d->tilesManager();
    if ( tm )
        pixmapBytes = tm->totalMemory();
    else
        pixmapBytes = 4 * request->width() * request->height();

    if ( pixmapBytes > (1024 * 1024) )
        cleanupPixmapMemory( memoryToFree /* previously calculated value */ );

    // submit the request to the generator
    if ( m_generator->canGeneratePixmap() )
    {
        QRect requestRect = !request->isTile() ? QRect(0, 0, request->width(), request->height() ) : request->normalizedRect().geometry( request->width(), request->height() );
        qCDebug(OkularCoreDebug).nospace() << ""sending request observer="" << request->observer() << "" "" <<requestRect.width() << ""x"" << requestRect.height() << ""@"" << request->pageNumber() << "" async == "" << request->asynchronous() << "" isTile == "" << request->isTile();
        m_pixmapRequestsStack.removeAll ( request );

        if ( tm )
            tm->setRequest( request->normalizedRect(), request->width(), request->height() );

        if ( (int)m_rotation % 2 )
            request->d->swap();

        if ( m_rotation != Rotation0 && !request->normalizedRect().isNull() )
            request->setNormalizedRect( TilesManager::fromRotatedRect(
                        request->normalizedRect(), m_rotation ) );

        // If set elsewhere we already know we want it to be partial
        if ( !request->partialUpdatesWanted() )
        {
            request->setPartialUpdatesWanted( request->asynchronous() && !request->page()->hasPixmap( request->observer() ) );
        }

        // we always have to unlock _before_ the generatePixmap() because
        // a sync generation would end with requestDone() -> deadlock, and
        // we can not really know if the generator can do async requests
        m_executingPixmapRequests.push_back( request );
        m_pixmapRequestsMutex.unlock();
        m_generator->generatePixmap( request );
    }
    else
    {
        m_pixmapRequestsMutex.unlock();
        // pino (7/4/2006): set the polling interval from 10 to 30
        QTimer::singleShot( 30, m_parent, SLOT(sendGeneratorPixmapRequest()) );
    }
}

void DocumentPrivate::rotationFinished( int page, Okular::Page *okularPage )
{
    Okular::Page *wantedPage = m_pagesVector.value( page, 0 );
    if ( !wantedPage || wantedPage != okularPage )
        return;

    foreach(DocumentObserver *o, m_observers)
        o->notifyPageChanged( page, DocumentObserver::Pixmap | DocumentObserver::Annotations );
}

void DocumentPrivate::slotFontReadingProgress( int page )
{
    emit m_parent->fontReadingProgress( page );

    if ( page >= (int)m_parent->pages() - 1 )
    {
        emit m_parent->fontReadingEnded();
        m_fontThread = nullptr;
        m_fontsCached = true;
    }
}

void DocumentPrivate::fontReadingGotFont( const Okular::FontInfo& font )
{
    // Try to avoid duplicate fonts
    if (m_fontsCache.indexOf(font) == -1) {
        m_fontsCache.append( font );

        emit m_parent->gotFont( font );
    }
}

void DocumentPrivate::slotGeneratorConfigChanged( const QString& )
{
    if ( !m_generator )
        return;

    // reparse generator config and if something changed clear Pages
    bool configchanged = false;
    QHash< QString, GeneratorInfo >::iterator it = m_loadedGenerators.begin(), itEnd = m_loadedGenerators.end();
    for ( ; it != itEnd; ++it )
    {
        Okular::ConfigInterface * iface = generatorConfig( it.value() );
        if ( iface )
        {
            bool it_changed = iface->reparseConfig();
            if ( it_changed && ( m_generator == it.value().generator ) )
                configchanged = true;
        }
    }
    if ( configchanged )
    {
        // invalidate pixmaps
        QVector<Page*>::const_iterator it = m_pagesVector.constBegin(), end = m_pagesVector.constEnd();
        for ( ; it != end; ++it ) {
            (*it)->deletePixmaps();
        }

        // [MEM] remove allocation descriptors
        qDeleteAll( m_allocatedPixmaps );
        m_allocatedPixmaps.clear();
        m_allocatedPixmapsTotalMemory = 0;

        // send reload signals to observers
        foreachObserverD( notifyContentsCleared( DocumentObserver::Pixmap ) );
    }

    // free memory if in 'low' profile
    if ( SettingsCore::memoryLevel() == SettingsCore::EnumMemoryLevel::Low &&
         !m_allocatedPixmaps.isEmpty() && !m_pagesVector.isEmpty() )
        cleanupPixmapMemory();
}

void DocumentPrivate::refreshPixmaps( int pageNumber )
{
    Page* page = m_pagesVector.value( pageNumber, 0 );
    if ( !page )
        return;

    QMap< DocumentObserver*, PagePrivate::PixmapObject >::ConstIterator it = page->d->m_pixmaps.constBegin(), itEnd = page->d->m_pixmaps.constEnd();
    QVector< Okular::PixmapRequest * > pixmapsToRequest;
    for ( ; it != itEnd; ++it )
    {
        const QSize size = (*it).m_pixmap->size();
        PixmapRequest * p = new PixmapRequest( it.key(), pageNumber, size.width() / qApp->devicePixelRatio(), size.height() / qApp->devicePixelRatio(), 1, PixmapRequest::Asynchronous );
        p->d->mForce = true;
        pixmapsToRequest << p;
    }

    // Need to do this ↑↓ in two steps since requestPixmaps can end up calling cancelRenderingBecauseOf
    // which changes m_pixmaps and thus breaks the loop above
    for ( PixmapRequest *pr : qAsConst( pixmapsToRequest ) )
    {
        QLinkedList< Okular::PixmapRequest * > requestedPixmaps;
        requestedPixmaps.push_back( pr );
        m_parent->requestPixmaps( requestedPixmaps, Okular::Document::NoOption );
    }

    foreach (DocumentObserver *observer, m_observers)
    {
        QLinkedList< Okular::PixmapRequest * > requestedPixmaps;

        TilesManager *tilesManager = page->d->tilesManager( observer );
        if ( tilesManager )
        {
            tilesManager->markDirty();

            PixmapRequest * p = new PixmapRequest( observer, pageNumber, tilesManager->width() / qApp->devicePixelRatio(), tilesManager->height() / qApp->devicePixelRatio(), 1, PixmapRequest::Asynchronous );

            NormalizedRect tilesRect;

            // Get the visible page rect
            NormalizedRect visibleRect;
            QVector< Okular::VisiblePageRect * >::const_iterator vIt = m_pageRects.constBegin(), vEnd = m_pageRects.constEnd();
            for ( ; vIt != vEnd; ++vIt )
            {
                if ( (*vIt)->pageNumber == pageNumber )
                {
                    visibleRect = (*vIt)->rect;
                    break;
                }
            }

            if ( !visibleRect.isNull() )
            {
                p->setNormalizedRect( visibleRect );
                p->setTile( true );
                p->d->mForce = true;
                requestedPixmaps.push_back( p );
            }
            else
            {
                delete p;
            }
        }

        m_parent->requestPixmaps( requestedPixmaps, Okular::Document::NoOption );
    }

}

void DocumentPrivate::_o_configChanged()
{
    // free text pages if needed
    calculateMaxTextPages();
    while (m_allocatedTextPagesFifo.count() > m_maxAllocatedTextPages)
    {
        int pageToKick = m_allocatedTextPagesFifo.takeFirst();
        m_pagesVector.at(pageToKick)->setTextPage( nullptr ); // deletes the textpage
    }
}

void DocumentPrivate::doContinueDirectionMatchSearch(void *doContinueDirectionMatchSearchStruct)
{
    DoContinueDirectionMatchSearchStruct *searchStruct = static_cast<DoContinueDirectionMatchSearchStruct *>(doContinueDirectionMatchSearchStruct);
    RunningSearch *search = m_searches.value(searchStruct->searchID);

    if ((m_searchCancelled && !searchStruct->match) || !search)
    {
        // if the user cancelled but he just got a match, give him the match!
        QApplication::restoreOverrideCursor();

        if (search) search->isCurrentlySearching = false;

        emit m_parent->searchFinished( searchStruct->searchID, Document::SearchCancelled );
        delete searchStruct->pagesToNotify;
        delete searchStruct;
        return;
    }

    const bool forward = search->cachedType == Document::NextMatch;
    bool doContinue = false;
    // if no match found, loop through the whole doc, starting from currentPage
    if ( !searchStruct->match )
    {
        const int pageCount = m_pagesVector.count();
        if (search->pagesDone < pageCount)
        {
            doContinue = true;
            if ( searchStruct->currentPage >= pageCount )
            {
                searchStruct->currentPage = 0;
                emit m_parent->notice(i18n(""Continuing search from beginning""), 3000);
            }
            else if ( searchStruct->currentPage < 0 )
            {
                searchStruct->currentPage = pageCount - 1;
                emit m_parent->notice(i18n(""Continuing search from bottom""), 3000);
            }
        }
    }

    if (doContinue)
    {
        // get page
        Page * page = m_pagesVector[ searchStruct->currentPage ];
        // request search page if needed
        if ( !page->hasTextPage() )
            m_parent->requestTextPage( page->number() );

        // if found a match on the current page, end the loop
        searchStruct->match = page->findText( searchStruct->searchID, search->cachedString, forward ? FromTop : FromBottom, search->cachedCaseSensitivity );
        if ( !searchStruct->match )
        {
            if (forward) searchStruct->currentPage++;
            else searchStruct->currentPage--;
            search->pagesDone++;
        }
        else
        {
            search->pagesDone = 1;
        }

        // Both of the previous if branches need to call doContinueDirectionMatchSearch
        QMetaObject::invokeMethod(m_parent, ""doContinueDirectionMatchSearch"", Qt::QueuedConnection, Q_ARG(void *, searchStruct));
    }
    else
    {
        doProcessSearchMatch( searchStruct->match, search, searchStruct->pagesToNotify, searchStruct->currentPage, searchStruct->searchID, search->cachedViewportMove, search->cachedColor );
        delete searchStruct;
    }
}

void DocumentPrivate::doProcessSearchMatch( RegularAreaRect *match, RunningSearch *search, QSet< int > *pagesToNotify, int currentPage, int searchID, bool moveViewport, const QColor & color )
{
    // reset cursor to previous shape
    QApplication::restoreOverrideCursor();

    bool foundAMatch = false;

    search->isCurrentlySearching = false;

    // if a match has been found..
    if ( match )
    {
        // update the RunningSearch structure adding this match..
        foundAMatch = true;
        search->continueOnPage = currentPage;
        search->continueOnMatch = *match;
        search->highlightedPages.insert( currentPage );
        // ..add highlight to the page..
        m_pagesVector[ currentPage ]->d->setHighlight( searchID, match, color );

        // ..queue page for notifying changes..
        pagesToNotify->insert( currentPage );

        // Create a normalized rectangle around the search match that includes a 5% buffer on all sides.
        const Okular::NormalizedRect matchRectWithBuffer = Okular::NormalizedRect( match->first().left - 0.05,
                                                                                   match->first().top - 0.05,
                                                                                   match->first().right + 0.05,
                                                                                   match->first().bottom + 0.05 );

        const bool matchRectFullyVisible = isNormalizedRectangleFullyVisible( matchRectWithBuffer, currentPage );

        // ..move the viewport to show the first of the searched word sequence centered
        if ( moveViewport && !matchRectFullyVisible )
        {
            DocumentViewport searchViewport( currentPage );
            searchViewport.rePos.enabled = true;
            searchViewport.rePos.normalizedX = (match->first().left + match->first().right) / 2.0;
            searchViewport.rePos.normalizedY = (match->first().top + match->first().bottom) / 2.0;
            m_parent->setViewport( searchViewport, nullptr, true );
        }
        delete match;
    }

    // notify observers about highlights changes
    foreach(int pageNumber, *pagesToNotify)
        foreach(DocumentObserver *observer, m_observers)
            observer->notifyPageChanged( pageNumber, DocumentObserver::Highlights );

    if (foundAMatch) emit m_parent->searchFinished( searchID, Document::MatchFound );
    else emit m_parent->searchFinished( searchID, Document::NoMatchFound );

    delete pagesToNotify;
}

void DocumentPrivate::doContinueAllDocumentSearch(void *pagesToNotifySet, void *pageMatchesMap, int currentPage, int searchID)
{
    QMap< Page *, QVector<RegularAreaRect *> > *pageMatches = static_cast< QMap< Page *, QVector<RegularAreaRect *> > * >(pageMatchesMap);
    QSet< int > *pagesToNotify = static_cast< QSet< int > * >( pagesToNotifySet );
    RunningSearch *search = m_searches.value(searchID);

    if (m_searchCancelled || !search)
    {
        typedef QVector<RegularAreaRect *> MatchesVector;

        QApplication::restoreOverrideCursor();

        if (search) search->isCurrentlySearching = false;

        emit m_parent->searchFinished( searchID, Document::SearchCancelled );
        foreach(const MatchesVector &mv, *pageMatches) qDeleteAll(mv);
        delete pageMatches;
        delete pagesToNotify;
        return;
    }

    if (currentPage < m_pagesVector.count())
    {
        // get page (from the first to the last)
        Page *page = m_pagesVector.at(currentPage);
        int pageNumber = page->number(); // redundant? is it == currentPage ?

        // request search page if needed
        if ( !page->hasTextPage() )
            m_parent->requestTextPage( pageNumber );

        // loop on a page adding highlights for all found items
        RegularAreaRect * lastMatch = nullptr;
        while ( 1 )
        {
            if ( lastMatch )
                lastMatch = page->findText( searchID, search->cachedString, NextResult, search->cachedCaseSensitivity, lastMatch );
            else
                lastMatch = page->findText( searchID, search->cachedString, FromTop, search->cachedCaseSensitivity );

            if ( !lastMatch )
                break;

            // add highligh rect to the matches map
            (*pageMatches)[page].append(lastMatch);
        }
        delete lastMatch;

        QMetaObject::invokeMethod(m_parent, ""doContinueAllDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotifySet), Q_ARG(void *, pageMatches), Q_ARG(int, currentPage + 1), Q_ARG(int, searchID));
    }
    else
    {
        // reset cursor to previous shape
        QApplication::restoreOverrideCursor();

        search->isCurrentlySearching = false;
        bool foundAMatch = pageMatches->count() != 0;
        QMap< Page *, QVector<RegularAreaRect *> >::const_iterator it, itEnd;
        it = pageMatches->constBegin();
        itEnd = pageMatches->constEnd();
        for ( ; it != itEnd; ++it)
        {
            foreach(RegularAreaRect *match, it.value())
            {
                it.key()->d->setHighlight( searchID, match, search->cachedColor );
                delete match;
            }
            search->highlightedPages.insert( it.key()->number() );
            pagesToNotify->insert( it.key()->number() );
        }

        foreach(DocumentObserver *observer, m_observers)
            observer->notifySetup( m_pagesVector, 0 );

        // notify observers about highlights changes
        foreach(int pageNumber, *pagesToNotify)
            foreach(DocumentObserver *observer, m_observers)
                observer->notifyPageChanged( pageNumber, DocumentObserver::Highlights );

        if (foundAMatch) emit m_parent->searchFinished(searchID, Document::MatchFound );
        else emit m_parent->searchFinished( searchID, Document::NoMatchFound );

        delete pageMatches;
        delete pagesToNotify;
    }
}

void DocumentPrivate::doContinueGooglesDocumentSearch(void *pagesToNotifySet, void *pageMatchesMap, int currentPage, int searchID, const QStringList & words)
{
    typedef QPair<RegularAreaRect *, QColor> MatchColor;
    QMap< Page *, QVector<MatchColor> > *pageMatches = static_cast< QMap< Page *, QVector<MatchColor> > * >(pageMatchesMap);
    QSet< int > *pagesToNotify = static_cast< QSet< int > * >( pagesToNotifySet );
    RunningSearch *search = m_searches.value(searchID);

    if (m_searchCancelled || !search)
    {
        typedef QVector<MatchColor> MatchesVector;

        QApplication::restoreOverrideCursor();

        if (search) search->isCurrentlySearching = false;

        emit m_parent->searchFinished( searchID, Document::SearchCancelled );

        foreach(const MatchesVector &mv, *pageMatches)
        {
            foreach(const MatchColor &mc, mv) delete mc.first;
        }
        delete pageMatches;
        delete pagesToNotify;
        return;
    }

    const int wordCount = words.count();
    const int hueStep = (wordCount > 1) ? (60 / (wordCount - 1)) : 60;
    int baseHue, baseSat, baseVal;
    search->cachedColor.getHsv( &baseHue, &baseSat, &baseVal );

    if (currentPage < m_pagesVector.count())
    {
        // get page (from the first to the last)
        Page *page = m_pagesVector.at(currentPage);
        int pageNumber = page->number(); // redundant? is it == currentPage ?

        // request search page if needed
        if ( !page->hasTextPage() )
            m_parent->requestTextPage( pageNumber );

        // loop on a page adding highlights for all found items
        bool allMatched = wordCount > 0,
             anyMatched = false;
        for ( int w = 0; w < wordCount; w++ )
        {
            const QString &word = words[ w ];
            int newHue = baseHue - w * hueStep;
            if ( newHue < 0 )
                newHue += 360;
            QColor wordColor = QColor::fromHsv( newHue, baseSat, baseVal );
            RegularAreaRect * lastMatch = nullptr;
            // add all highlights for current word
            bool wordMatched = false;
            while ( 1 )
            {
                if ( lastMatch )
                    lastMatch = page->findText( searchID, word, NextResult, search->cachedCaseSensitivity, lastMatch );
                else
                    lastMatch = page->findText( searchID, word, FromTop, search->cachedCaseSensitivity);

                if ( !lastMatch )
                    break;

                // add highligh rect to the matches map
                (*pageMatches)[page].append(MatchColor(lastMatch, wordColor));
                wordMatched = true;
            }
            allMatched = allMatched && wordMatched;
            anyMatched = anyMatched || wordMatched;
        }

        // if not all words are present in page, remove partial highlights
        const bool matchAll = search->cachedType == Document::GoogleAll;
        if ( !allMatched && matchAll )
        {
            QVector<MatchColor> &matches = (*pageMatches)[page];
            foreach(const MatchColor &mc, matches) delete mc.first;
            pageMatches->remove(page);
        }

        QMetaObject::invokeMethod(m_parent, ""doContinueGooglesDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotifySet), Q_ARG(void *, pageMatches), Q_ARG(int, currentPage + 1), Q_ARG(int, searchID), Q_ARG(QStringList, words));
    }
    else
    {
        // reset cursor to previous shape
        QApplication::restoreOverrideCursor();

        search->isCurrentlySearching = false;
        bool foundAMatch = pageMatches->count() != 0;
        QMap< Page *, QVector<MatchColor> >::const_iterator it, itEnd;
        it = pageMatches->constBegin();
        itEnd = pageMatches->constEnd();
        for ( ; it != itEnd; ++it)
        {
            foreach(const MatchColor &mc, it.value())
            {
                it.key()->d->setHighlight( searchID, mc.first, mc.second );
                delete mc.first;
            }
            search->highlightedPages.insert( it.key()->number() );
            pagesToNotify->insert( it.key()->number() );
        }

        // send page lists to update observers (since some filter on bookmarks)
        foreach(DocumentObserver *observer, m_observers)
            observer->notifySetup( m_pagesVector, 0 );

        // notify observers about highlights changes
        foreach(int pageNumber, *pagesToNotify)
            foreach(DocumentObserver *observer, m_observers)
                observer->notifyPageChanged( pageNumber, DocumentObserver::Highlights );

        if (foundAMatch) emit m_parent->searchFinished( searchID, Document::MatchFound );
        else emit m_parent->searchFinished( searchID, Document::NoMatchFound );

        delete pageMatches;
        delete pagesToNotify;
    }
}

QVariant DocumentPrivate::documentMetaData( const Generator::DocumentMetaDataKey key, const QVariant &option ) const
{
    switch ( key )
    {
        case Generator::PaperColorMetaData:
        {
            bool giveDefault = option.toBool();
            QColor color;
            if ( ( SettingsCore::renderMode() == SettingsCore::EnumRenderMode::Paper )
                && SettingsCore::changeColors() )
            {
                color = SettingsCore::paperColor();
            }
            else if ( giveDefault )
            {
                color = Qt::white;
            }
            return color;
        }
        break;

        case Generator::TextAntialiasMetaData:
            switch ( SettingsCore::textAntialias() )
            {
                case SettingsCore::EnumTextAntialias::Enabled:
                    return true;
                    break;
#if 0
                case Settings::EnumTextAntialias::UseKDESettings:
                    // TODO: read the KDE configuration
                    return true;
                    break;
#endif
                case SettingsCore::EnumTextAntialias::Disabled:
                    return false;
                    break;
            }
        break;

        case Generator::GraphicsAntialiasMetaData:
            switch ( SettingsCore::graphicsAntialias() )
            {
                case SettingsCore::EnumGraphicsAntialias::Enabled:
                    return true;
                    break;
                case SettingsCore::EnumGraphicsAntialias::Disabled:
                    return false;
                    break;
            }
        break;

        case Generator::TextHintingMetaData:
            switch ( SettingsCore::textHinting() )
            {
                case SettingsCore::EnumTextHinting::Enabled:
                    return true;
                    break;
                case SettingsCore::EnumTextHinting::Disabled:
                    return false;
                    break;
            }
        break;
    }
    return QVariant();
}

bool DocumentPrivate::isNormalizedRectangleFullyVisible( const Okular::NormalizedRect & rectOfInterest, int rectPage )
{
    bool rectFullyVisible = false;
    const QVector<Okular::VisiblePageRect *> & visibleRects = m_parent->visiblePageRects();
    QVector<Okular::VisiblePageRect *>::const_iterator vEnd = visibleRects.end();
    QVector<Okular::VisiblePageRect *>::const_iterator vIt = visibleRects.begin();

    for ( ; ( vIt != vEnd ) && !rectFullyVisible; ++vIt )
    {
        if ( (*vIt)->pageNumber == rectPage &&
            (*vIt)->rect.contains( rectOfInterest.left, rectOfInterest.top ) &&
            (*vIt)->rect.contains( rectOfInterest.right, rectOfInterest.bottom ) )
        {
            rectFullyVisible = true;
        }
    }
    return rectFullyVisible;
}

struct pdfsyncpoint
{
    QString file;
    qlonglong x;
    qlonglong y;
    int row;
    int column;
    int page;
};

void DocumentPrivate::loadSyncFile( const QString & filePath )
{
    QFile f( filePath + QLatin1String( ""sync"" ) );
    if ( !f.open( QIODevice::ReadOnly ) )
        return;

    QTextStream ts( &f );
    // first row: core name of the pdf output
    const QString coreName = ts.readLine();
    // second row: version string, in the form 'Version %u'
    QString versionstr = ts.readLine();
    QRegExp versionre( QStringLiteral(""Version (\\d+)"") );
    versionre.setCaseSensitivity( Qt::CaseInsensitive );
    if ( !versionre.exactMatch( versionstr ) )
        return;

    QHash<int, pdfsyncpoint> points;
    QStack<QString> fileStack;
    int currentpage = -1;
    const QLatin1String texStr( "".tex"" );
    const QChar spaceChar = QChar::fromLatin1( ' ' );

    fileStack.push( coreName + texStr );

    const QSizeF dpi = m_generator->dpi();

    QString line;
    while ( !ts.atEnd() )
    {
        line = ts.readLine();
        const QStringList tokens = line.split( spaceChar, QString::SkipEmptyParts );
        const int tokenSize = tokens.count();
        if ( tokenSize < 1 )
            continue;
        if ( tokens.first() == QLatin1String( ""l"" ) && tokenSize >= 3 )
        {
            int id = tokens.at( 1 ).toInt();
            QHash<int, pdfsyncpoint>::const_iterator it = points.constFind( id );
            if ( it == points.constEnd() )
            {
                pdfsyncpoint pt;
                pt.x = 0;
                pt.y = 0;
                pt.row = tokens.at( 2 ).toInt();
                pt.column = 0; // TODO
                pt.page = -1;
                pt.file = fileStack.top();
                points[ id ] = pt;
            }
        }
        else if ( tokens.first() == QLatin1String( ""s"" ) && tokenSize >= 2 )
        {
            currentpage = tokens.at( 1 ).toInt() - 1;
        }
        else if ( tokens.first() == QLatin1String( ""p*"" ) && tokenSize >= 4 )
        {
            // TODO
            qCDebug(OkularCoreDebug) << ""PdfSync: 'p*' line ignored"";
        }
        else if ( tokens.first() == QLatin1String( ""p"" ) && tokenSize >= 4 )
        {
            int id = tokens.at( 1 ).toInt();
            QHash<int, pdfsyncpoint>::iterator it = points.find( id );
            if ( it != points.end() )
            {
                it->x = tokens.at( 2 ).toInt();
                it->y = tokens.at( 3 ).toInt();
                it->page = currentpage;
            }
        }
        else if ( line.startsWith( QLatin1Char( '(' ) ) && tokenSize == 1 )
        {
            QString newfile = line;
            // chop the leading '('
            newfile.remove( 0, 1 );
            if ( !newfile.endsWith( texStr ) )
            {
                newfile += texStr;
            }
            fileStack.push( newfile );
        }
        else if ( line == QLatin1String( "")"" ) )
        {
            if ( !fileStack.isEmpty() )
            {
                fileStack.pop();
            }
            else
               qCDebug(OkularCoreDebug) << ""PdfSync: going one level down too much"";
        }
        else
            qCDebug(OkularCoreDebug).nospace() << ""PdfSync: unknown line format: '"" << line << ""'"";

    }

    QVector< QLinkedList< Okular::SourceRefObjectRect * > > refRects( m_pagesVector.size() );
    foreach ( const pdfsyncpoint& pt, points )
    {
        // drop pdfsync points not completely valid
        if ( pt.page < 0 || pt.page >= m_pagesVector.size() )
            continue;

        // magic numbers for TeX's RSU's (Ridiculously Small Units) conversion to pixels
        Okular::NormalizedPoint p(
            ( pt.x * dpi.width() ) / ( 72.27 * 65536.0 * m_pagesVector[pt.page]->width() ),
            ( pt.y * dpi.height() ) / ( 72.27 * 65536.0 * m_pagesVector[pt.page]->height() )
            );
        QString file = pt.file;
        Okular::SourceReference * sourceRef = new Okular::SourceReference( file, pt.row, pt.column );
        refRects[ pt.page ].append( new Okular::SourceRefObjectRect( p, sourceRef ) );
    }
    for ( int i = 0; i < refRects.size(); ++i )
        if ( !refRects.at(i).isEmpty() )
            m_pagesVector[i]->setSourceReferences( refRects.at(i) );
}

void DocumentPrivate::clearAndWaitForRequests()
{
    m_pixmapRequestsMutex.lock();
    QLinkedList< PixmapRequest * >::const_iterator sIt = m_pixmapRequestsStack.constBegin();
    QLinkedList< PixmapRequest * >::const_iterator sEnd = m_pixmapRequestsStack.constEnd();
    for ( ; sIt != sEnd; ++sIt )
        delete *sIt;
    m_pixmapRequestsStack.clear();
    m_pixmapRequestsMutex.unlock();

    QEventLoop loop;
    bool startEventLoop = false;
    do
    {
        m_pixmapRequestsMutex.lock();
        startEventLoop = !m_executingPixmapRequests.isEmpty();

        if ( m_generator->hasFeature( Generator::SupportsCancelling ) )
        {
            for ( PixmapRequest *executingRequest : qAsConst( m_executingPixmapRequests ) )
                executingRequest->d->mShouldAbortRender = 1;

            if ( m_generator->d_ptr->mTextPageGenerationThread )
                m_generator->d_ptr->mTextPageGenerationThread->abortExtraction();
        }

        m_pixmapRequestsMutex.unlock();
        if ( startEventLoop )
        {
            m_closingLoop = &loop;
            loop.exec();
            m_closingLoop = nullptr;
        }
    }
    while ( startEventLoop );
}

Document::Document( QWidget *widget )
    : QObject( nullptr ), d( new DocumentPrivate( this ) )
{
    d->m_widget = widget;
    d->m_bookmarkManager = new BookmarkManager( d );
    d->m_viewportIterator = d->m_viewportHistory.insert( d->m_viewportHistory.end(), DocumentViewport() );
    d->m_undoStack = new QUndoStack(this);

    connect( SettingsCore::self(), SIGNAL(configChanged()), this, SLOT(_o_configChanged()) );
    connect(d->m_undoStack, &QUndoStack::canUndoChanged, this, &Document::canUndoChanged);
    connect(d->m_undoStack, &QUndoStack::canRedoChanged, this, &Document::canRedoChanged);
    connect(d->m_undoStack, &QUndoStack::cleanChanged, this, &Document::undoHistoryCleanChanged);

    qRegisterMetaType<Okular::FontInfo>();
}

Document::~Document()
{
    // delete generator, pages, and related stuff
    closeDocument();

    QSet< View * >::const_iterator viewIt = d->m_views.constBegin(), viewEnd = d->m_views.constEnd();
    for ( ; viewIt != viewEnd; ++viewIt )
    {
        View *v = *viewIt;
        v->d_func()->document = nullptr;
    }

    // delete the bookmark manager
    delete d->m_bookmarkManager;

    // delete the loaded generators
    QHash< QString, GeneratorInfo >::const_iterator it = d->m_loadedGenerators.constBegin(), itEnd = d->m_loadedGenerators.constEnd();
    for ( ; it != itEnd; ++it )
        d->unloadGenerator( it.value() );
    d->m_loadedGenerators.clear();

    // delete the private structure
    delete d;
}

QString DocumentPrivate::docDataFileName(const QUrl &url, qint64 document_size)
{

    QString fn = url.fileName();
    fn = QString::number( document_size ) + QLatin1Char('.') + fn + QStringLiteral("".xml"");
    QString docdataDir = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation)
            + QStringLiteral(""/okular/docdata"");
    // make sure that the okular/docdata/ directory exists (probably this used to be handled by KStandardDirs)
    if (!QFileInfo::exists(docdataDir))
    {
        qCDebug(OkularCoreDebug) << ""creating docdata folder"" << docdataDir;
        QDir().mkpath(docdataDir);
    }
    QString newokularfile = docdataDir + QLatin1Char('/') + fn;
    // we don't want to accidentally migrate old files when running unit tests
    if (!QFile::exists( newokularfile ) && !QStandardPaths::isTestModeEnabled())
    {
        // see if an KDE4 file still exists
        static Kdelibs4Migration k4migration;
        QString oldfile = k4migration.locateLocal(""data"", QStringLiteral(""okular/docdata/"") + fn);
        if (oldfile.isEmpty())
        {
            oldfile =  k4migration.locateLocal(""data"",  QStringLiteral(""kpdf/"") + fn);
        }
        if ( !oldfile.isEmpty() && QFile::exists( oldfile ) )
        {
            // ### copy or move?
            if ( !QFile::copy( oldfile, newokularfile ) )
                return QString();
        }
    }
    return newokularfile;
}

QVector<KPluginMetaData> DocumentPrivate::availableGenerators()
{
    static QVector<KPluginMetaData> result;
    if (result.isEmpty())
    {
        result = KPluginLoader::findPlugins( QLatin1String ( ""okular/generators"" ) );
    }
    return result;
}

KPluginMetaData DocumentPrivate::generatorForMimeType(const QMimeType& type, QWidget* widget, const QVector<KPluginMetaData> &triedOffers)
{
    // First try to find an exact match, and then look for more general ones (e. g. the plain text one)
    // Ideally we would rank these by ""closeness"", but that might be overdoing it

    const QVector<KPluginMetaData> available = availableGenerators();
    QVector<KPluginMetaData> offers;
    QVector<KPluginMetaData> exactMatches;

    QMimeDatabase mimeDatabase;

    for (const KPluginMetaData& md : available)
    {
        if (triedOffers.contains(md))
            continue;

        foreach (const QString& supported, md.mimeTypes())
        {
            QMimeType mimeType = mimeDatabase.mimeTypeForName(supported);
            if (mimeType == type && !exactMatches.contains(md)) {
                exactMatches << md;
            }

            if (type.inherits(supported) && !offers.contains(md))
            {
                offers << md;
            }
        }
    }

    if (!exactMatches.isEmpty()) {
        offers = exactMatches;
    }

    if (offers.isEmpty())
    {
        return KPluginMetaData();
    }
    int hRank=0;
    // best ranked offer search
    int offercount = offers.size();
    if (offercount > 1)
    {
        // sort the offers: the offers with an higher priority come before
        auto cmp = [](const KPluginMetaData& s1, const KPluginMetaData& s2)
        {
            const QString property = QStringLiteral(""X-KDE-Priority"");
            return s1.rawData()[property].toInt() > s2.rawData()[property].toInt();
        };
        std::stable_sort(offers.begin(), offers.end(), cmp);

        if (SettingsCore::chooseGenerators())
        {
            QStringList list;
            for (int i = 0; i < offercount; ++i)
            {
                list << offers.at(i).pluginId();
            }
            ChooseEngineDialog choose(list, type, widget);

            if (choose.exec() == QDialog::Rejected)
                return KPluginMetaData();

            hRank = choose.selectedGenerator();
        }
    }
    Q_ASSERT(hRank < offers.size());
    return offers.at(hRank);
}

Document::OpenResult Document::openDocument(const QString & docFile, const QUrl &url, const QMimeType &_mime, const QString & password )
{
    QMimeDatabase db;
    QMimeType mime = _mime;
    QByteArray filedata;
    int fd = -1;
    if (url.scheme() == QLatin1String(""fd""))
    {
        bool ok;
        fd = url.path().mid(1).toInt(&ok);
        if (!ok)
        {
            return OpenError;
        }
    }
    else if (url.fileName() == QLatin1String( ""-"" ))
    {
        fd = 0;
    }
    bool triedMimeFromFileContent = false;
    if ( fd < 0 )
    {
        if ( !mime.isValid() )
            return OpenError;

        d->m_url = url;
        d->m_docFileName = docFile;

        if ( !d->updateMetadataXmlNameAndDocSize() )
            return OpenError;
    }
    else
    {
        QFile qstdin;
        const bool ret = qstdin.open( fd, QIODevice::ReadOnly, QFileDevice::AutoCloseHandle );
        if (!ret) {
            qWarning() << ""failed to read"" << url << filedata;
            return OpenError;
        }

        filedata = qstdin.readAll();
        mime = db.mimeTypeForData( filedata );
        if ( !mime.isValid() || mime.isDefault() )
            return OpenError;
        d->m_docSize = filedata.size();
        triedMimeFromFileContent = true;
    }

    const bool fromFileDescriptor = fd >= 0;

    // 0. load Generator
    // request only valid non-disabled plugins suitable for the mimetype
    KPluginMetaData offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget);
    if ( !offer.isValid() && !triedMimeFromFileContent )
    {
        QMimeType newmime = db.mimeTypeForFile(docFile, QMimeDatabase::MatchExtension);
        triedMimeFromFileContent = true;
        if ( newmime != mime )
        {
            mime = newmime;
            offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget);
        }
        if ( !offer.isValid() )
        {
            // There's still no offers, do a final mime search based on the filename
            // We need this because sometimes (e.g. when downloading from a webserver) the mimetype we
            // use is the one fed by the server, that may be wrong
            newmime = db.mimeTypeForUrl( url );

            if ( !newmime.isDefault() && newmime != mime )
            {
                mime = newmime;
                offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget);
            }
        }
    }
    if (!offer.isValid())
    {
        emit error( i18n( ""Can not find a plugin which is able to handle the document being passed."" ), -1 );
        qCWarning(OkularCoreDebug).nospace() << ""No plugin for mimetype '"" << mime.name() << ""'."";
        return OpenError;
    }

    // 1. load Document
    OpenResult openResult = d->openDocumentInternal( offer, fromFileDescriptor, docFile, filedata, password );
    if ( openResult == OpenError )
    {
        QVector<KPluginMetaData> triedOffers;
        triedOffers << offer;
        offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);

        while ( offer.isValid() )
        {
            openResult = d->openDocumentInternal( offer, fromFileDescriptor, docFile, filedata, password );

            if ( openResult == OpenError )
            {
                triedOffers << offer;
                offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);
            }
            else break;
        }

        if (openResult == OpenError && !triedMimeFromFileContent )
        {
            QMimeType newmime = db.mimeTypeForFile(docFile, QMimeDatabase::MatchExtension);
            triedMimeFromFileContent = true;
            if ( newmime != mime )
            {
                mime = newmime;
                offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);
                while ( offer.isValid() )
                {
                    openResult = d->openDocumentInternal( offer, fromFileDescriptor, docFile, filedata, password );

                    if ( openResult == OpenError )
                    {
                        triedOffers << offer;
                        offer = DocumentPrivate::generatorForMimeType(mime, d->m_widget, triedOffers);
                    }
                    else break;
                }
            }
        }

        if ( openResult == OpenSuccess )
        {
            // Clear errors, since we're trying various generators, maybe one of them errored out
            // but we finally succeeded
            // TODO one can still see the error message animating out but since this is a very rare
            //      condition we can leave this for future work
            emit error( QString(), -1 );
        }
    }
    if ( openResult != OpenSuccess )
    {
        return openResult;
    }

    // no need to check for the existence of a synctex file, no parser will be
    // created if none exists
    d->m_synctex_scanner = synctex_scanner_new_with_output_file( QFile::encodeName( docFile ).constData(), nullptr, 1);
    if ( !d->m_synctex_scanner && QFile::exists(docFile + QLatin1String( ""sync"" ) ) )
    {
        d->loadSyncFile(docFile);
    }

    d->m_generatorName = offer.pluginId();
    d->m_pageController = new PageController();
    connect( d->m_pageController, SIGNAL(rotationFinished(int,Okular::Page*)),
             this, SLOT(rotationFinished(int,Okular::Page*)) );

    foreach ( Page * p, d->m_pagesVector )
        p->d->m_doc = d;

    d->m_metadataLoadingCompleted = false;
    d->m_docdataMigrationNeeded = false;

    // 2. load Additional Data (bookmarks, local annotations and metadata) about the document
    if ( d->m_archiveData )
    {
        // QTemporaryFile is weird and will return false in exists if fileName wasn't called before
        d->m_archiveData->metadataFile.fileName();
        d->loadDocumentInfo( d->m_archiveData->metadataFile, LoadPageInfo );
        d->loadDocumentInfo( LoadGeneralInfo );
    }
    else
    {
        if ( d->loadDocumentInfo( LoadPageInfo ) )
            d->m_docdataMigrationNeeded = true;
        d->loadDocumentInfo( LoadGeneralInfo );
    }

    d->m_metadataLoadingCompleted = true;
    d->m_bookmarkManager->setUrl( d->m_url );

    // 3. setup observers inernal lists and data
    foreachObserver( notifySetup( d->m_pagesVector, DocumentObserver::DocumentChanged | DocumentObserver::UrlChanged ) );

    // 4. set initial page (restoring the page saved in xml if loaded)
    DocumentViewport loadedViewport = (*d->m_viewportIterator);
    if ( loadedViewport.isValid() )
    {
        (*d->m_viewportIterator) = DocumentViewport();
        if ( loadedViewport.pageNumber >= (int)d->m_pagesVector.size() )
            loadedViewport.pageNumber = d->m_pagesVector.size() - 1;
    }
    else
        loadedViewport.pageNumber = 0;
    setViewport( loadedViewport );

    // start bookmark saver timer
    if ( !d->m_saveBookmarksTimer )
    {
        d->m_saveBookmarksTimer = new QTimer( this );
        connect( d->m_saveBookmarksTimer, SIGNAL(timeout()), this, SLOT(saveDocumentInfo()) );
    }
    d->m_saveBookmarksTimer->start( 5 * 60 * 1000 );

    // start memory check timer
    if ( !d->m_memCheckTimer )
    {
        d->m_memCheckTimer = new QTimer( this );
        connect( d->m_memCheckTimer, SIGNAL(timeout()), this, SLOT(slotTimedMemoryCheck()) );
    }
    d->m_memCheckTimer->start( 2000 );

    const DocumentViewport nextViewport = d->nextDocumentViewport();
    if ( nextViewport.isValid() )
    {
        setViewport( nextViewport );
        d->m_nextDocumentViewport = DocumentViewport();
        d->m_nextDocumentDestination = QString();
    }

    AudioPlayer::instance()->d->m_currentDocument = fromFileDescriptor ? QUrl() : d->m_url;

    const QStringList docScripts = d->m_generator->metaData( QStringLiteral(""DocumentScripts""), QStringLiteral ( ""JavaScript"" ) ).toStringList();
    if ( !docScripts.isEmpty() )
    {
        d->m_scripter = new Scripter( d );
        Q_FOREACH ( const QString &docscript, docScripts )
        {
            d->m_scripter->execute( JavaScript, docscript );
        }
    }

    return OpenSuccess;
}

bool DocumentPrivate::updateMetadataXmlNameAndDocSize()
{
    // m_docFileName is always local so we can use QFileInfo on it
    QFileInfo fileReadTest( m_docFileName );
    if ( !fileReadTest.isFile() && !fileReadTest.isReadable() )
        return false;

    m_docSize = fileReadTest.size();

    // determine the related ""xml document-info"" filename
    if ( m_url.isLocalFile() )
    {
        const QString filePath = docDataFileName( m_url, m_docSize );
        qCDebug(OkularCoreDebug) << ""Metadata file is now:"" << filePath;
        m_xmlFileName = filePath;
    }
    else
    {
        qCDebug(OkularCoreDebug) << ""Metadata file: disabled"";
        m_xmlFileName = QString();
    }

    return true;
}


KXMLGUIClient* Document::guiClient()
{
    if ( d->m_generator )
    {
        Okular::GuiInterface * iface = qobject_cast< Okular::GuiInterface * >( d->m_generator );
        if ( iface )
            return iface->guiClient();
    }
    return nullptr;
}

void Document::closeDocument()
{
    // check if there's anything to close...
    if ( !d->m_generator )
        return;

    delete d->m_pageController;
    d->m_pageController = nullptr;

    delete d->m_scripter;
    d->m_scripter = nullptr;

     // remove requests left in queue
    d->clearAndWaitForRequests();

    if ( d->m_fontThread )
    {
        disconnect( d->m_fontThread, nullptr, this, nullptr );
        d->m_fontThread->stopExtraction();
        d->m_fontThread->wait();
        d->m_fontThread = nullptr;
    }

    // stop any audio playback
    AudioPlayer::instance()->stopPlaybacks();

    // close the current document and save document info if a document is still opened
    if ( d->m_generator && d->m_pagesVector.size() > 0 )
    {
        d->saveDocumentInfo();
        d->m_generator->closeDocument();
    }

    if ( d->m_synctex_scanner )
    {
        synctex_scanner_free( d->m_synctex_scanner );
        d->m_synctex_scanner = nullptr;
    }

    // stop timers
    if ( d->m_memCheckTimer )
        d->m_memCheckTimer->stop();
    if ( d->m_saveBookmarksTimer )
        d->m_saveBookmarksTimer->stop();

    if ( d->m_generator )
    {
        // disconnect the generator from this document ...
        d->m_generator->d_func()->m_document = nullptr;
        // .. and this document from the generator signals
        disconnect( d->m_generator, nullptr, this, nullptr );

        QHash< QString, GeneratorInfo >::const_iterator genIt = d->m_loadedGenerators.constFind( d->m_generatorName );
        Q_ASSERT( genIt != d->m_loadedGenerators.constEnd() );
    }
    d->m_generator = nullptr;
    d->m_generatorName = QString();
    d->m_url = QUrl();
    d->m_walletGenerator = nullptr;
    d->m_docFileName = QString();
    d->m_xmlFileName = QString();
    delete d->m_tempFile;
    d->m_tempFile = nullptr;
    delete d->m_archiveData;
    d->m_archiveData = nullptr;
    d->m_docSize = -1;
    d->m_exportCached = false;
    d->m_exportFormats.clear();
    d->m_exportToText = ExportFormat();
    d->m_fontsCached = false;
    d->m_fontsCache.clear();
    d->m_rotation = Rotation0;

    // send an empty list to observers (to free their data)
    foreachObserver( notifySetup( QVector< Page * >(), DocumentObserver::DocumentChanged | DocumentObserver::UrlChanged ) );

    // delete pages and clear 'd->m_pagesVector' container
    QVector< Page * >::const_iterator pIt = d->m_pagesVector.constBegin();
    QVector< Page * >::const_iterator pEnd = d->m_pagesVector.constEnd();
    for ( ; pIt != pEnd; ++pIt )
        delete *pIt;
    d->m_pagesVector.clear();

    // clear 'memory allocation' descriptors
    qDeleteAll( d->m_allocatedPixmaps );
    d->m_allocatedPixmaps.clear();

    // clear 'running searches' descriptors
    QMap< int, RunningSearch * >::const_iterator rIt = d->m_searches.constBegin();
    QMap< int, RunningSearch * >::const_iterator rEnd = d->m_searches.constEnd();
    for ( ; rIt != rEnd; ++rIt )
        delete *rIt;
    d->m_searches.clear();

    // clear the visible areas and notify the observers
    QVector< VisiblePageRect * >::const_iterator vIt = d->m_pageRects.constBegin();
    QVector< VisiblePageRect * >::const_iterator vEnd = d->m_pageRects.constEnd();
    for ( ; vIt != vEnd; ++vIt )
        delete *vIt;
    d->m_pageRects.clear();
    foreachObserver( notifyVisibleRectsChanged() );

    // reset internal variables

    d->m_viewportHistory.clear();
    d->m_viewportHistory.append( DocumentViewport() );
    d->m_viewportIterator = d->m_viewportHistory.begin();
    d->m_allocatedPixmapsTotalMemory = 0;
    d->m_allocatedTextPagesFifo.clear();
    d->m_pageSize = PageSize();
    d->m_pageSizes.clear();

    d->m_documentInfo = DocumentInfo();
    d->m_documentInfoAskedKeys.clear();

    AudioPlayer::instance()->d->m_currentDocument = QUrl();

    d->m_undoStack->clear();
    d->m_docdataMigrationNeeded = false;

#if HAVE_MALLOC_TRIM
    // trim unused memory, glibc should do this but it seems it does not
    // this can greatly decrease the [perceived] memory consumption of okular
    // see: https://sourceware.org/bugzilla/show_bug.cgi?id=14827
    malloc_trim(0);
#endif
}

void Document::addObserver( DocumentObserver * pObserver )
{
    Q_ASSERT( !d->m_observers.contains( pObserver ) );
    d->m_observers << pObserver;

    // if the observer is added while a document is already opened, tell it
    if ( !d->m_pagesVector.isEmpty() )
    {
        pObserver->notifySetup( d->m_pagesVector, DocumentObserver::DocumentChanged | DocumentObserver::UrlChanged );
        pObserver->notifyViewportChanged( false /*disables smoothMove*/ );
    }
}

void Document::removeObserver( DocumentObserver * pObserver )
{
    // remove observer from the set. it won't receive notifications anymore
    if ( d->m_observers.contains( pObserver ) )
    {
        // free observer's pixmap data
        QVector<Page*>::const_iterator it = d->m_pagesVector.constBegin(), end = d->m_pagesVector.constEnd();
        for ( ; it != end; ++it )
            (*it)->deletePixmap( pObserver );

        // [MEM] free observer's allocation descriptors
        QLinkedList< AllocatedPixmap * >::iterator aIt = d->m_allocatedPixmaps.begin();
        QLinkedList< AllocatedPixmap * >::iterator aEnd = d->m_allocatedPixmaps.end();
        while ( aIt != aEnd )
        {
            AllocatedPixmap * p = *aIt;
            if ( p->observer == pObserver )
            {
                aIt = d->m_allocatedPixmaps.erase( aIt );
                delete p;
            }
            else
                ++aIt;
        }

        for ( PixmapRequest *executingRequest : qAsConst( d->m_executingPixmapRequests ) )
        {
            if ( executingRequest->observer() == pObserver ) {
                d->cancelRenderingBecauseOf( executingRequest, nullptr );
            }
        }

        // remove observer entry from the set
        d->m_observers.remove( pObserver );
    }
}

void Document::reparseConfig()
{
    // reparse generator config and if something changed clear Pages
    bool configchanged = false;
    if ( d->m_generator )
    {
        Okular::ConfigInterface * iface = qobject_cast< Okular::ConfigInterface * >( d->m_generator );
        if ( iface )
            configchanged = iface->reparseConfig();
    }
    if ( configchanged )
    {
        // invalidate pixmaps
        QVector<Page*>::const_iterator it = d->m_pagesVector.constBegin(), end = d->m_pagesVector.constEnd();
        for ( ; it != end; ++it ) {
            (*it)->deletePixmaps();
        }

        // [MEM] remove allocation descriptors
        qDeleteAll( d->m_allocatedPixmaps );
        d->m_allocatedPixmaps.clear();
        d->m_allocatedPixmapsTotalMemory = 0;

        // send reload signals to observers
        foreachObserver( notifyContentsCleared( DocumentObserver::Pixmap ) );
    }

    // free memory if in 'low' profile
    if ( SettingsCore::memoryLevel() == SettingsCore::EnumMemoryLevel::Low &&
         !d->m_allocatedPixmaps.isEmpty() && !d->m_pagesVector.isEmpty() )
        d->cleanupPixmapMemory();
}


bool Document::isOpened() const
{
    return d->m_generator;
}

bool Document::canConfigurePrinter( ) const
{
    if ( d->m_generator )
    {
        Okular::PrintInterface * iface = qobject_cast< Okular::PrintInterface * >( d->m_generator );
        return iface ? true : false;
    }
    else
        return 0;
}

DocumentInfo Document::documentInfo() const
{
    QSet<DocumentInfo::Key> keys;
    for (Okular::DocumentInfo::Key ks = Okular::DocumentInfo::Title;
                                   ks < Okular::DocumentInfo::Invalid;
                                   ks = Okular::DocumentInfo::Key( ks+1 ) )
    {
        keys << ks;
    }

    return documentInfo( keys );
}

DocumentInfo Document::documentInfo( const QSet<DocumentInfo::Key> &keys ) const
{
    DocumentInfo result = d->m_documentInfo;
    const QSet<DocumentInfo::Key> missingKeys = keys - d->m_documentInfoAskedKeys;

    if ( d->m_generator && !missingKeys.isEmpty() )
    {
        DocumentInfo info = d->m_generator->generateDocumentInfo( missingKeys );

        if ( missingKeys.contains( DocumentInfo::FilePath ) )
        {
            info.set( DocumentInfo::FilePath, currentDocument().toDisplayString() );
        }

        if ( d->m_docSize != -1 && missingKeys.contains( DocumentInfo::DocumentSize ) )
        {
            const QString sizeString = KFormat().formatByteSize( d->m_docSize );
            info.set( DocumentInfo::DocumentSize, sizeString );
        }
        if ( missingKeys.contains( DocumentInfo::PagesSize ) )
        {
            const QString pagesSize = d->pagesSizeString();
            if ( !pagesSize.isEmpty() )
            {
                info.set( DocumentInfo::PagesSize, pagesSize );
            }
        }

        if ( missingKeys.contains( DocumentInfo::Pages ) && info.get( DocumentInfo::Pages ).isEmpty() ) {
            info.set( DocumentInfo::Pages, QString::number( this->pages() ) );
        }

        d->m_documentInfo.d->values.unite(info.d->values);
        d->m_documentInfo.d->titles.unite(info.d->titles);
        result.d->values.unite(info.d->values);
        result.d->titles.unite(info.d->titles);
    }
    d->m_documentInfoAskedKeys += keys;

    return result;
}

const DocumentSynopsis * Document::documentSynopsis() const
{
    return d->m_generator ? d->m_generator->generateDocumentSynopsis() : nullptr;
}

void Document::startFontReading()
{
    if ( !d->m_generator || !d->m_generator->hasFeature( Generator::FontInfo ) || d->m_fontThread )
        return;

    if ( d->m_fontsCached )
    {
        // in case we have cached fonts, simulate a reading
        // this way the API is the same, and users no need to care about the
        // internal caching
        for ( int i = 0; i < d->m_fontsCache.count(); ++i )
        {
            emit gotFont( d->m_fontsCache.at( i ) );
            emit fontReadingProgress( i / pages() );
        }
        emit fontReadingEnded();
        return;
    }

    d->m_fontThread = new FontExtractionThread( d->m_generator, pages() );
    connect( d->m_fontThread, SIGNAL(gotFont(Okular::FontInfo)), this, SLOT(fontReadingGotFont(Okular::FontInfo)) );
    connect( d->m_fontThread.data(), SIGNAL(progress(int)), this, SLOT(slotFontReadingProgress(int)) );

    d->m_fontThread->startExtraction( /*d->m_generator->hasFeature( Generator::Threaded )*/true );
}

void Document::stopFontReading()
{
    if ( !d->m_fontThread )
        return;

    disconnect( d->m_fontThread, nullptr, this, nullptr );
    d->m_fontThread->stopExtraction();
    d->m_fontThread = nullptr;
    d->m_fontsCache.clear();
}

bool Document::canProvideFontInformation() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::FontInfo ) : false;
}

const QList<EmbeddedFile*> *Document::embeddedFiles() const
{
    return d->m_generator ? d->m_generator->embeddedFiles() : nullptr;
}

const Page * Document::page( int n ) const
{
    return ( n >= 0 && n < d->m_pagesVector.count() ) ? d->m_pagesVector.at(n) : nullptr;
}

const DocumentViewport & Document::viewport() const
{
    return (*d->m_viewportIterator);
}

const QVector< VisiblePageRect * > & Document::visiblePageRects() const
{
    return d->m_pageRects;
}

void Document::setVisiblePageRects( const QVector< VisiblePageRect * > & visiblePageRects, DocumentObserver *excludeObserver )
{
    QVector< VisiblePageRect * >::const_iterator vIt = d->m_pageRects.constBegin();
    QVector< VisiblePageRect * >::const_iterator vEnd = d->m_pageRects.constEnd();
    for ( ; vIt != vEnd; ++vIt )
        delete *vIt;
    d->m_pageRects = visiblePageRects;
    // notify change to all other (different from id) observers
    foreach(DocumentObserver *o, d->m_observers)
        if ( o != excludeObserver )
            o->notifyVisibleRectsChanged();
}

uint Document::currentPage() const
{
    return (*d->m_viewportIterator).pageNumber;
}

uint Document::pages() const
{
    return d->m_pagesVector.size();
}

QUrl Document::currentDocument() const
{
    return d->m_url;
}

bool Document::isAllowed( Permission action ) const
{
    if ( action == Okular::AllowNotes && ( d->m_docdataMigrationNeeded || !d->m_annotationEditingEnabled ) )
        return false;
    if ( action == Okular::AllowFillForms && d->m_docdataMigrationNeeded )
        return false;

#if !OKULAR_FORCE_DRM
    if ( KAuthorized::authorize( QStringLiteral(""skip_drm"") ) && !SettingsCore::obeyDRM() )
        return true;
#endif

    return d->m_generator ? d->m_generator->isAllowed( action ) : false;
}

bool Document::supportsSearching() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::TextExtraction ) : false;
}

bool Document::supportsPageSizes() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::PageSizes ) : false;
}

bool Document::supportsTiles() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::TiledRendering ) : false;
}

PageSize::List Document::pageSizes() const
{
    if ( d->m_generator )
    {
        if ( d->m_pageSizes.isEmpty() )
            d->m_pageSizes = d->m_generator->pageSizes();
        return d->m_pageSizes;
    }
    return PageSize::List();
}

bool Document::canExportToText() const
{
    if ( !d->m_generator )
        return false;

    d->cacheExportFormats();
    return !d->m_exportToText.isNull();
}

bool Document::exportToText( const QString& fileName ) const
{
    if ( !d->m_generator )
        return false;

    d->cacheExportFormats();
    if ( d->m_exportToText.isNull() )
        return false;

    return d->m_generator->exportTo( fileName, d->m_exportToText );
}

ExportFormat::List Document::exportFormats() const
{
    if ( !d->m_generator )
        return ExportFormat::List();

    d->cacheExportFormats();
    return d->m_exportFormats;
}

bool Document::exportTo( const QString& fileName, const ExportFormat& format ) const
{
    return d->m_generator ? d->m_generator->exportTo( fileName, format ) : false;
}

bool Document::historyAtBegin() const
{
    return d->m_viewportIterator == d->m_viewportHistory.begin();
}

bool Document::historyAtEnd() const
{
    return d->m_viewportIterator == --(d->m_viewportHistory.end());
}

QVariant Document::metaData( const QString & key, const QVariant & option ) const
{
    // if option starts with ""src:"" assume that we are handling a
    // source reference
    if ( key == QLatin1String(""NamedViewport"")
         && option.toString().startsWith( QLatin1String(""src:""), Qt::CaseInsensitive )
         && d->m_synctex_scanner)
    {
        const QString reference = option.toString();

        // The reference is of form ""src:1111Filename"", where ""1111""
        // points to line number 1111 in the file ""Filename"".
        // Extract the file name and the numeral part from the reference string.
        // This will fail if Filename starts with a digit.
        QString name, lineString;
        // Remove ""src:"". Presence of substring has been checked before this
        // function is called.
        name = reference.mid( 4 );
        // split
        int nameLength = name.length();
        int i = 0;
        for( i = 0; i < nameLength; ++i )
        {
            if ( !name[i].isDigit() ) break;
        }
        lineString = name.left( i );
        name = name.mid( i );
        // Remove spaces.
        name = name.trimmed();
        lineString = lineString.trimmed();
        // Convert line to integer.
        bool ok;
        int line = lineString.toInt( &ok );
        if (!ok) line = -1;

        // Use column == -1 for now.
        if( synctex_display_query( d->m_synctex_scanner, QFile::encodeName(name).constData(), line, -1, 0 ) > 0 )
        {
            synctex_node_p node;
            // For now use the first hit. Could possibly be made smarter
            // in case there are multiple hits.
            while( ( node = synctex_scanner_next_result( d->m_synctex_scanner ) ) )
            {
                Okular::DocumentViewport viewport;

                // TeX pages start at 1.
                viewport.pageNumber = synctex_node_page( node ) - 1;

                if ( viewport.pageNumber >= 0 )
                {
                    const QSizeF dpi = d->m_generator->dpi();

                    // TeX small points ...
                    double px = (synctex_node_visible_h( node ) * dpi.width()) / 72.27;
                    double py = (synctex_node_visible_v( node ) * dpi.height()) / 72.27;
                    viewport.rePos.normalizedX = px / page(viewport.pageNumber)->width();
                    viewport.rePos.normalizedY = ( py + 0.5 ) / page(viewport.pageNumber)->height();
                    viewport.rePos.enabled = true;
                    viewport.rePos.pos = Okular::DocumentViewport::Center;

                    return viewport.toString();
                }
            }
        }
    }
    return d->m_generator ? d->m_generator->metaData( key, option ) : QVariant();
}

Rotation Document::rotation() const
{
    return d->m_rotation;
}

QSizeF Document::allPagesSize() const
{
    bool allPagesSameSize = true;
    QSizeF size;
    for (int i = 0; allPagesSameSize && i < d->m_pagesVector.count(); ++i)
    {
        const Page *p = d->m_pagesVector.at(i);
        if (i == 0) size = QSizeF(p->width(), p->height());
        else
        {
            allPagesSameSize = (size == QSizeF(p->width(), p->height()));
        }
    }
    if (allPagesSameSize) return size;
    else return QSizeF();
}

QString Document::pageSizeString(int page) const
{
    if (d->m_generator)
    {
        if (d->m_generator->pagesSizeMetric() != Generator::None)
        {
            const Page *p = d->m_pagesVector.at( page );
            return d->localizedSize(QSizeF(p->width(), p->height()));
        }
    }
    return QString();
}

static bool shouldCancelRenderingBecauseOf( const PixmapRequest & executingRequest, const PixmapRequest & otherRequest )
{
    // New request has higher priority -> cancel
    if ( executingRequest.priority() > otherRequest.priority() )
        return true;

    // New request has lower priority -> don't cancel
    if ( executingRequest.priority() < otherRequest.priority() )
        return false;

    // New request has same priority and is from a different observer -> don't cancel
    // AFAIK this never happens since all observers have different priorities
    if ( executingRequest.observer() != otherRequest.observer() )
        return false;

    // Same priority and observer, different page number -> don't cancel
    // may still end up cancelled later in the parent caller if none of the requests
    // is of the executingRequest page and RemoveAllPrevious is specified
    if ( executingRequest.pageNumber() != otherRequest.pageNumber() )
        return false;

    // Same priority, observer, page, different size -> cancel
    if ( executingRequest.width() != otherRequest.width() )
        return true;

    // Same priority, observer, page, different size -> cancel
    if ( executingRequest.height() != otherRequest.height() )
        return true;

    // Same priority, observer, page, different tiling -> cancel
    if ( executingRequest.isTile() != otherRequest.isTile() )
        return true;

    // Same priority, observer, page, different tiling -> cancel
    if ( executingRequest.isTile() )
    {
        const NormalizedRect bothRequestsRect = executingRequest.normalizedRect() | otherRequest.normalizedRect();
        if ( !( bothRequestsRect == executingRequest.normalizedRect() ) )
            return true;
    }

    return false;
}

bool DocumentPrivate::cancelRenderingBecauseOf( PixmapRequest *executingRequest, PixmapRequest *newRequest )
{
    // No point in aborting the rendering already finished, let it go through
    if ( !executingRequest->d->mResultImage.isNull() )
        return false;

    if ( newRequest && newRequest->asynchronous() && executingRequest->partialUpdatesWanted() ) {
        newRequest->setPartialUpdatesWanted( true );
    }

    TilesManager *tm = executingRequest->d->tilesManager();
    if ( tm )
    {
        tm->setPixmap( nullptr, executingRequest->normalizedRect(), true /*isPartialPixmap*/ );
        tm->setRequest( NormalizedRect(), 0, 0 );
    }
    PagePrivate::PixmapObject object = executingRequest->page()->d->m_pixmaps.take( executingRequest->observer() );
    delete object.m_pixmap;

    if ( executingRequest->d->mShouldAbortRender != 0)
        return false;

    executingRequest->d->mShouldAbortRender = 1;

    if ( m_generator->d_ptr->mTextPageGenerationThread && m_generator->d_ptr->mTextPageGenerationThread->page() == executingRequest->page() )
    {
        m_generator->d_ptr->mTextPageGenerationThread->abortExtraction();
    }

    return true;
}

void Document::requestPixmaps( const QLinkedList< PixmapRequest * > & requests )
{
    requestPixmaps( requests, RemoveAllPrevious );
}

void Document::requestPixmaps( const QLinkedList< PixmapRequest * > & requests, PixmapRequestFlags reqOptions )
{
    if ( requests.isEmpty() )
        return;

    if ( !d->m_pageController )
    {
        // delete requests..
        QLinkedList< PixmapRequest * >::const_iterator rIt = requests.constBegin(), rEnd = requests.constEnd();
        for ( ; rIt != rEnd; ++rIt )
            delete *rIt;
        // ..and return
        return;
    }

    QSet< DocumentObserver * > observersPixmapCleared;

    // 1. [CLEAN STACK] remove previous requests of requesterID
    DocumentObserver *requesterObserver = requests.first()->observer();
    QSet< int > requestedPages;
    {
        QLinkedList< PixmapRequest * >::const_iterator rIt = requests.constBegin(), rEnd = requests.constEnd();
        for ( ; rIt != rEnd; ++rIt )
        {
            Q_ASSERT( (*rIt)->observer() == requesterObserver );
            requestedPages.insert( (*rIt)->pageNumber() );
        }
    }
    const bool removeAllPrevious = reqOptions & RemoveAllPrevious;
    d->m_pixmapRequestsMutex.lock();
    QLinkedList< PixmapRequest * >::iterator sIt = d->m_pixmapRequestsStack.begin(), sEnd = d->m_pixmapRequestsStack.end();
    while ( sIt != sEnd )
    {
        if ( (*sIt)->observer() == requesterObserver
             && ( removeAllPrevious || requestedPages.contains( (*sIt)->pageNumber() ) ) )
        {
            // delete request and remove it from stack
            delete *sIt;
            sIt = d->m_pixmapRequestsStack.erase( sIt );
        }
        else
            ++sIt;
    }

    // 1.B [PREPROCESS REQUESTS] tweak some values of the requests
    for ( PixmapRequest *request : requests )
    {
        // set the 'page field' (see PixmapRequest) and check if it is valid
        qCDebug(OkularCoreDebug).nospace() << ""request observer="" << request->observer() << "" "" <<request->width() << ""x"" << request->height() << ""@"" << request->pageNumber();
        if ( d->m_pagesVector.value( request->pageNumber() ) == 0 )
        {
            // skip requests referencing an invalid page (must not happen)
            delete request;
            continue;
        }

        request->d->mPage = d->m_pagesVector.value( request->pageNumber() );

        if ( request->isTile() )
        {
            // Change the current request rect so that only invalid tiles are
            // requested. Also make sure the rect is tile-aligned.
            NormalizedRect tilesRect;
            const QList<Tile> tiles = request->d->tilesManager()->tilesAt( request->normalizedRect(), TilesManager::TerminalTile );
            QList<Tile>::const_iterator tIt = tiles.constBegin(), tEnd = tiles.constEnd();
            while ( tIt != tEnd )
            {
                const Tile &tile = *tIt;
                if ( !tile.isValid() )
                {
                    if ( tilesRect.isNull() )
                        tilesRect = tile.rect();
                    else
                        tilesRect |= tile.rect();
                }

                tIt++;
            }

            request->setNormalizedRect( tilesRect );
        }

        if ( !request->asynchronous() )
            request->d->mPriority = 0;
    }

    // 1.C [CANCEL REQUESTS] cancel those requests that are running and should be cancelled because of the new requests coming in
    if ( d->m_generator->hasFeature( Generator::SupportsCancelling ) )
    {
        for ( PixmapRequest *executingRequest : qAsConst( d->m_executingPixmapRequests ) )
        {
            bool newRequestsContainExecutingRequestPage = false;
            bool requestCancelled = false;
            for ( PixmapRequest *newRequest : requests )
            {
                if ( newRequest->pageNumber() == executingRequest->pageNumber() && requesterObserver == executingRequest->observer())
                {
                    newRequestsContainExecutingRequestPage = true;
                }

                if ( shouldCancelRenderingBecauseOf( *executingRequest, *newRequest ) )
                {
                    requestCancelled = d->cancelRenderingBecauseOf( executingRequest, newRequest );
                }
            }

            // If we were told to remove all the previous requests and the executing request page is not part of the new requests, cancel it
            if ( !requestCancelled && removeAllPrevious && requesterObserver == executingRequest->observer() && !newRequestsContainExecutingRequestPage )
            {
                requestCancelled = d->cancelRenderingBecauseOf( executingRequest, nullptr );
            }

            if ( requestCancelled )
            {
                observersPixmapCleared << executingRequest->observer();
            }
        }
    }

    // 2. [ADD TO STACK] add requests to stack
    for ( PixmapRequest *request : requests )
    {
        // add request to the 'stack' at the right place
        if ( !request->priority() )
            // add priority zero requests to the top of the stack
            d->m_pixmapRequestsStack.append( request );
        else
        {
            // insert in stack sorted by priority
            sIt = d->m_pixmapRequestsStack.begin();
            sEnd = d->m_pixmapRequestsStack.end();
            while ( sIt != sEnd && (*sIt)->priority() > request->priority() )
                ++sIt;
            d->m_pixmapRequestsStack.insert( sIt, request );
        }
    }
    d->m_pixmapRequestsMutex.unlock();

    // 3. [START FIRST GENERATION] if <NO>generator is ready, start a new generation,
    // or else (if gen is running) it will be started when the new contents will
    //come from generator (in requestDone())</NO>
    // all handling of requests put into sendGeneratorPixmapRequest
    //    if ( generator->canRequestPixmap() )
        d->sendGeneratorPixmapRequest();

    for ( DocumentObserver *o : qAsConst( observersPixmapCleared ) )
        o->notifyContentsCleared( Okular::DocumentObserver::Pixmap );
}

void Document::requestTextPage( uint page )
{
    Page * kp = d->m_pagesVector[ page ];
    if ( !d->m_generator || !kp )
        return;

    // Memory management for TextPages

    d->m_generator->generateTextPage( kp );
}

void DocumentPrivate::notifyAnnotationChanges( int page )
{
    foreachObserverD( notifyPageChanged( page, DocumentObserver::Annotations ) );
}

void DocumentPrivate::notifyFormChanges( int /*page*/ )
{
    recalculateForms();
}

void Document::addPageAnnotation( int page, Annotation * annotation )
{
    // Transform annotation's base boundary rectangle into unrotated coordinates
    Page *p = d->m_pagesVector[page];
    QTransform t = p->d->rotationMatrix();
    annotation->d_ptr->baseTransform(t.inverted());
    QUndoCommand *uc = new AddAnnotationCommand(this->d, annotation, page);
    d->m_undoStack->push(uc);
}

bool Document::canModifyPageAnnotation( const Annotation * annotation ) const
{
    if ( !annotation || ( annotation->flags() & Annotation::DenyWrite ) )
        return false;

    if ( !isAllowed(Okular::AllowNotes) )
        return false;

    if ( ( annotation->flags() & Annotation::External ) && !d->canModifyExternalAnnotations() )
        return false;

    switch ( annotation->subType() )
    {
        case Annotation::AText:
        case Annotation::ALine:
        case Annotation::AGeom:
        case Annotation::AHighlight:
        case Annotation::AStamp:
        case Annotation::AInk:
            return true;
        default:
            return false;
    }
}

void Document::prepareToModifyAnnotationProperties( Annotation * annotation )
{
    Q_ASSERT(d->m_prevPropsOfAnnotBeingModified.isNull());
    if (!d->m_prevPropsOfAnnotBeingModified.isNull())
    {
        qCCritical(OkularCoreDebug) << ""Error: Document::prepareToModifyAnnotationProperties has already been called since last call to Document::modifyPageAnnotationProperties"";
        return;
    }
    d->m_prevPropsOfAnnotBeingModified = annotation->getAnnotationPropertiesDomNode();
}

void Document::modifyPageAnnotationProperties( int page, Annotation * annotation )
{
    Q_ASSERT(!d->m_prevPropsOfAnnotBeingModified.isNull());
    if (d->m_prevPropsOfAnnotBeingModified.isNull())
    {
        qCCritical(OkularCoreDebug) << ""Error: Document::prepareToModifyAnnotationProperties must be called before Annotation is modified"";
        return;
    }
    QDomNode prevProps = d->m_prevPropsOfAnnotBeingModified;
    QUndoCommand *uc = new Okular::ModifyAnnotationPropertiesCommand( d,
                                                                      annotation,
                                                                      page,
                                                                      prevProps,
                                                                      annotation->getAnnotationPropertiesDomNode() );
    d->m_undoStack->push( uc );
    d->m_prevPropsOfAnnotBeingModified.clear();
}

void Document::translatePageAnnotation(int page, Annotation* annotation, const NormalizedPoint & delta )
{
    int complete = (annotation->flags() & Okular::Annotation::BeingMoved) == 0;
    QUndoCommand *uc = new Okular::TranslateAnnotationCommand( d, annotation, page, delta, complete );
    d->m_undoStack->push(uc);
}

void Document::adjustPageAnnotation( int page, Annotation *annotation, const Okular::NormalizedPoint & delta1, const Okular::NormalizedPoint & delta2 )
{
    const bool complete = (annotation->flags() & Okular::Annotation::BeingResized) == 0;
    QUndoCommand *uc = new Okular::AdjustAnnotationCommand( d, annotation, page, delta1, delta2, complete );
    d->m_undoStack->push(uc);
}

void Document::editPageAnnotationContents( int page, Annotation* annotation,
                                           const QString & newContents,
                                           int newCursorPos,
                                           int prevCursorPos,
                                           int prevAnchorPos
                                         )
{
    QString prevContents = annotation->contents();
    QUndoCommand *uc = new EditAnnotationContentsCommand( d, annotation, page, newContents, newCursorPos,
                                                            prevContents, prevCursorPos, prevAnchorPos );
    d->m_undoStack->push( uc );
}

bool Document::canRemovePageAnnotation( const Annotation * annotation ) const
{
    if ( !annotation || ( annotation->flags() & Annotation::DenyDelete ) )
        return false;

    if ( ( annotation->flags() & Annotation::External ) && !d->canRemoveExternalAnnotations() )
        return false;

    switch ( annotation->subType() )
    {
        case Annotation::AText:
        case Annotation::ALine:
        case Annotation::AGeom:
        case Annotation::AHighlight:
        case Annotation::AStamp:
        case Annotation::AInk:
        case Annotation::ACaret:
            return true;
        default:
            return false;
    }
}

void Document::removePageAnnotation( int page, Annotation * annotation )
{
    QUndoCommand *uc = new RemoveAnnotationCommand(this->d, annotation, page);
    d->m_undoStack->push(uc);
}

void Document::removePageAnnotations( int page, const QList<Annotation*> &annotations )
{
    d->m_undoStack->beginMacro(i18nc(""remove a collection of annotations from the page"", ""remove annotations""));
    foreach(Annotation* annotation, annotations)
    {
        QUndoCommand *uc = new RemoveAnnotationCommand(this->d, annotation, page);
        d->m_undoStack->push(uc);
    }
    d->m_undoStack->endMacro();
}

bool DocumentPrivate::canAddAnnotationsNatively() const
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );

    if ( iface && iface->supportsOption(Okular::SaveInterface::SaveChanges) &&
         iface->annotationProxy() && iface->annotationProxy()->supports(AnnotationProxy::Addition) )
        return true;

    return false;
}

bool DocumentPrivate::canModifyExternalAnnotations() const
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );

    if ( iface && iface->supportsOption(Okular::SaveInterface::SaveChanges) &&
         iface->annotationProxy() && iface->annotationProxy()->supports(AnnotationProxy::Modification) )
        return true;

    return false;
}

bool DocumentPrivate::canRemoveExternalAnnotations() const
{
    Okular::SaveInterface * iface = qobject_cast< Okular::SaveInterface * >( m_generator );

    if ( iface && iface->supportsOption(Okular::SaveInterface::SaveChanges) &&
         iface->annotationProxy() && iface->annotationProxy()->supports(AnnotationProxy::Removal) )
        return true;

    return false;
}

void Document::setPageTextSelection( int page, RegularAreaRect * rect, const QColor & color )
{
    Page * kp = d->m_pagesVector[ page ];
    if ( !d->m_generator || !kp )
        return;

    // add or remove the selection basing whether rect is null or not
    if ( rect )
        kp->d->setTextSelections( rect, color );
    else
        kp->d->deleteTextSelections();

    // notify observers about the change
    foreachObserver( notifyPageChanged( page, DocumentObserver::TextSelection ) );
}

bool Document::canUndo() const
{
    return d->m_undoStack->canUndo();
}

bool Document::canRedo() const
{
    return d->m_undoStack->canRedo();
}

/* REFERENCE IMPLEMENTATION: better calling setViewport from other code
void Document::setNextPage()
{
    // advance page and set viewport on observers
    if ( (*d->m_viewportIterator).pageNumber < (int)d->m_pagesVector.count() - 1 )
        setViewport( DocumentViewport( (*d->m_viewportIterator).pageNumber + 1 ) );
}

void Document::setPrevPage()
{
    // go to previous page and set viewport on observers
    if ( (*d->m_viewportIterator).pageNumber > 0 )
        setViewport( DocumentViewport( (*d->m_viewportIterator).pageNumber - 1 ) );
}
*/
void Document::setViewportPage( int page, DocumentObserver *excludeObserver, bool smoothMove )
{
    // clamp page in range [0 ... numPages-1]
    if ( page < 0 )
        page = 0;
    else if ( page > (int)d->m_pagesVector.count() )
        page = d->m_pagesVector.count() - 1;

    // make a viewport from the page and broadcast it
    setViewport( DocumentViewport( page ), excludeObserver, smoothMove );
}

void Document::setViewport( const DocumentViewport & viewport, DocumentObserver *excludeObserver, bool smoothMove )
{
    if ( !viewport.isValid() )
    {
        qCDebug(OkularCoreDebug) << ""invalid viewport:"" << viewport.toString();
        return;
    }
    if ( viewport.pageNumber >= int(d->m_pagesVector.count()) )
    {
        //qCDebug(OkularCoreDebug) << ""viewport out of document:"" << viewport.toString();
        return;
    }

    // if already broadcasted, don't redo it
    DocumentViewport & oldViewport = *d->m_viewportIterator;
    // disabled by enrico on 2005-03-18 (less debug output)
    //if ( viewport == oldViewport )
    //    qCDebug(OkularCoreDebug) << ""setViewport with the same viewport."";

    const int oldPageNumber = oldViewport.pageNumber;

    // set internal viewport taking care of history
    if ( oldViewport.pageNumber == viewport.pageNumber || !oldViewport.isValid() )
    {
        // if page is unchanged save the viewport at current position in queue
        oldViewport = viewport;
    }
    else
    {
        // remove elements after viewportIterator in queue
        d->m_viewportHistory.erase( ++d->m_viewportIterator, d->m_viewportHistory.end() );

        // keep the list to a reasonable size by removing head when needed
        if ( d->m_viewportHistory.count() >= OKULAR_HISTORY_MAXSTEPS )
            d->m_viewportHistory.pop_front();

        // add the item at the end of the queue
        d->m_viewportIterator = d->m_viewportHistory.insert( d->m_viewportHistory.end(), viewport );
    }

    const int currentViewportPage = (*d->m_viewportIterator).pageNumber;

    const bool currentPageChanged = (oldPageNumber != currentViewportPage);

    // notify change to all other (different from id) observers
    foreach(DocumentObserver *o, d->m_observers)
    {
        if ( o != excludeObserver )
            o->notifyViewportChanged( smoothMove );

        if ( currentPageChanged )
            o->notifyCurrentPageChanged( oldPageNumber, currentViewportPage );
    }
}

void Document::setZoom(int factor, DocumentObserver *excludeObserver)
{
    // notify change to all other (different from id) observers
    foreach(DocumentObserver *o, d->m_observers)
        if (o != excludeObserver)
            o->notifyZoom( factor );
}

void Document::setPrevViewport()
// restore viewport from the history
{
    if ( d->m_viewportIterator != d->m_viewportHistory.begin() )
    {
        const int oldViewportPage = (*d->m_viewportIterator).pageNumber;

        // restore previous viewport and notify it to observers
        --d->m_viewportIterator;
        foreachObserver( notifyViewportChanged( true ) );

        const int currentViewportPage = (*d->m_viewportIterator).pageNumber;
        if (oldViewportPage != currentViewportPage)
            foreachObserver( notifyCurrentPageChanged( oldViewportPage, currentViewportPage ) );
    }
}

void Document::setNextViewport()
// restore next viewport from the history
{
    QLinkedList< DocumentViewport >::const_iterator nextIterator = d->m_viewportIterator;
    ++nextIterator;
    if ( nextIterator != d->m_viewportHistory.end() )
    {
        const int oldViewportPage = (*d->m_viewportIterator).pageNumber;

        // restore next viewport and notify it to observers
        ++d->m_viewportIterator;
        foreachObserver( notifyViewportChanged( true ) );

        const int currentViewportPage = (*d->m_viewportIterator).pageNumber;
        if (oldViewportPage != currentViewportPage)
            foreachObserver( notifyCurrentPageChanged( oldViewportPage, currentViewportPage ) );
    }
}

void Document::setNextDocumentViewport( const DocumentViewport & viewport )
{
    d->m_nextDocumentViewport = viewport;
}

void Document::setNextDocumentDestination( const QString &namedDestination )
{
    d->m_nextDocumentDestination = namedDestination;
}

void Document::searchText( int searchID, const QString & text, bool fromStart, Qt::CaseSensitivity caseSensitivity,
                               SearchType type, bool moveViewport, const QColor & color )
{
    d->m_searchCancelled = false;

    // safety checks: don't perform searches on empty or unsearchable docs
    if ( !d->m_generator || !d->m_generator->hasFeature( Generator::TextExtraction ) || d->m_pagesVector.isEmpty() )
    {
        emit searchFinished( searchID, NoMatchFound );
        return;
    }

    // if searchID search not recorded, create new descriptor and init params
    QMap< int, RunningSearch * >::iterator searchIt = d->m_searches.find( searchID );
    if ( searchIt == d->m_searches.end() )
    {
        RunningSearch * search = new RunningSearch();
        search->continueOnPage = -1;
        searchIt = d->m_searches.insert( searchID, search );
    }
    RunningSearch * s = *searchIt;

    // update search structure
    bool newText = text != s->cachedString;
    s->cachedString = text;
    s->cachedType = type;
    s->cachedCaseSensitivity = caseSensitivity;
    s->cachedViewportMove = moveViewport;
    s->cachedColor = color;
    s->isCurrentlySearching = true;

    // global data for search
    QSet< int > *pagesToNotify = new QSet< int >;

    // remove highlights from pages and queue them for notifying changes
    *pagesToNotify += s->highlightedPages;
    foreach(int pageNumber, s->highlightedPages)
        d->m_pagesVector.at(pageNumber)->d->deleteHighlights( searchID );
    s->highlightedPages.clear();

    // set hourglass cursor
    QApplication::setOverrideCursor( Qt::WaitCursor );

    // 1. ALLDOC - proces all document marking pages
    if ( type == AllDocument )
    {
        QMap< Page *, QVector<RegularAreaRect *> > *pageMatches = new QMap< Page *, QVector<RegularAreaRect *> >;

        // search and highlight 'text' (as a solid phrase) on all pages
        QMetaObject::invokeMethod(this, ""doContinueAllDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotify), Q_ARG(void *, pageMatches), Q_ARG(int, 0), Q_ARG(int, searchID));
    }
    // 2. NEXTMATCH - find next matching item (or start from top)
    // 3. PREVMATCH - find previous matching item (or start from bottom)
    else if ( type == NextMatch || type == PreviousMatch )
    {
        // find out from where to start/resume search from
        const bool forward = type == NextMatch;
        const int viewportPage = (*d->m_viewportIterator).pageNumber;
        const int fromStartSearchPage = forward ? 0 : d->m_pagesVector.count() - 1;
        int currentPage = fromStart ? fromStartSearchPage : ((s->continueOnPage != -1) ? s->continueOnPage : viewportPage);
        Page * lastPage = fromStart ? 0 : d->m_pagesVector[ currentPage ];
        int pagesDone = 0;

        // continue checking last TextPage first (if it is the current page)
        RegularAreaRect * match = nullptr;
        if ( lastPage && lastPage->number() == s->continueOnPage )
        {
            if ( newText )
                match = lastPage->findText( searchID, text, forward ? FromTop : FromBottom, caseSensitivity );
            else
                match = lastPage->findText( searchID, text, forward ? NextResult : PreviousResult, caseSensitivity, &s->continueOnMatch );
            if ( !match )
            {
                if (forward) currentPage++;
                else currentPage--;
                pagesDone++;
            }
        }

        s->pagesDone = pagesDone;

        DoContinueDirectionMatchSearchStruct *searchStruct = new DoContinueDirectionMatchSearchStruct();
        searchStruct->pagesToNotify = pagesToNotify;
        searchStruct->match = match;
        searchStruct->currentPage = currentPage;
        searchStruct->searchID = searchID;

        QMetaObject::invokeMethod(this, ""doContinueDirectionMatchSearch"", Qt::QueuedConnection, Q_ARG(void *, searchStruct));
    }
    // 4. GOOGLE* - process all document marking pages
    else if ( type == GoogleAll || type == GoogleAny )
    {
        QMap< Page *, QVector< QPair<RegularAreaRect *, QColor> > > *pageMatches = new QMap< Page *, QVector<QPair<RegularAreaRect *, QColor> > >;
        const QStringList words = text.split( QLatin1Char ( ' ' ), QString::SkipEmptyParts );

        // search and highlight every word in 'text' on all pages
        QMetaObject::invokeMethod(this, ""doContinueGooglesDocumentSearch"", Qt::QueuedConnection, Q_ARG(void *, pagesToNotify), Q_ARG(void *, pageMatches), Q_ARG(int, 0), Q_ARG(int, searchID), Q_ARG(QStringList, words));
    }
}

void Document::continueSearch( int searchID )
{
    // check if searchID is present in runningSearches
    QMap< int, RunningSearch * >::const_iterator it = d->m_searches.constFind( searchID );
    if ( it == d->m_searches.constEnd() )
    {
        emit searchFinished( searchID, NoMatchFound );
        return;
    }

    // start search with cached parameters from last search by searchID
    RunningSearch * p = *it;
    if ( !p->isCurrentlySearching )
        searchText( searchID, p->cachedString, false, p->cachedCaseSensitivity,
                    p->cachedType, p->cachedViewportMove, p->cachedColor );
}

void Document::continueSearch( int searchID, SearchType type )
{
    // check if searchID is present in runningSearches
    QMap< int, RunningSearch * >::const_iterator it = d->m_searches.constFind( searchID );
    if ( it == d->m_searches.constEnd() )
    {
        emit searchFinished( searchID, NoMatchFound );
        return;
    }

    // start search with cached parameters from last search by searchID
    RunningSearch * p = *it;
    if ( !p->isCurrentlySearching )
        searchText( searchID, p->cachedString, false, p->cachedCaseSensitivity,
                    type, p->cachedViewportMove, p->cachedColor );
}

void Document::resetSearch( int searchID )
{
    // if we are closing down, don't bother doing anything
    if ( !d->m_generator )
        return;

    // check if searchID is present in runningSearches
    QMap< int, RunningSearch * >::iterator searchIt = d->m_searches.find( searchID );
    if ( searchIt == d->m_searches.end() )
        return;

    // get previous parameters for search
    RunningSearch * s = *searchIt;

    // unhighlight pages and inform observers about that
    foreach(int pageNumber, s->highlightedPages)
    {
        d->m_pagesVector.at(pageNumber)->d->deleteHighlights( searchID );
        foreachObserver( notifyPageChanged( pageNumber, DocumentObserver::Highlights ) );
    }

    // send the setup signal too (to update views that filter on matches)
    foreachObserver( notifySetup( d->m_pagesVector, 0 ) );

    // remove serch from the runningSearches list and delete it
    d->m_searches.erase( searchIt );
    delete s;
}

void Document::cancelSearch()
{
    d->m_searchCancelled = true;
}

void Document::undo()
{
    d->m_undoStack->undo();
}

void Document::redo()
{
    d->m_undoStack->redo();
}

void Document::editFormText( int pageNumber,
                             Okular::FormFieldText* form,
                             const QString & newContents,
                             int newCursorPos,
                             int prevCursorPos,
                             int prevAnchorPos )
{
    QUndoCommand *uc = new EditFormTextCommand( this->d, form, pageNumber, newContents, newCursorPos, form->text(), prevCursorPos, prevAnchorPos );
    d->m_undoStack->push( uc );
}

void Document::editFormList( int pageNumber,
                             FormFieldChoice* form,
                             const QList< int > & newChoices )
{
    const QList< int > prevChoices = form->currentChoices();
    QUndoCommand *uc = new EditFormListCommand( this->d, form, pageNumber, newChoices, prevChoices );
    d->m_undoStack->push( uc );
}

void Document::editFormCombo( int pageNumber,
                              FormFieldChoice* form,
                              const QString & newText,
                              int newCursorPos,
                              int prevCursorPos,
                              int prevAnchorPos )
{

    QString prevText;
    if ( form->currentChoices().isEmpty() )
    {
        prevText = form->editChoice();
    }
    else
    {
        prevText = form->choices()[form->currentChoices().constFirst()];
    }

    QUndoCommand *uc = new EditFormComboCommand( this->d, form, pageNumber, newText, newCursorPos, prevText, prevCursorPos, prevAnchorPos );
    d->m_undoStack->push( uc );
}

void Document::editFormButtons( int pageNumber, const QList< FormFieldButton* >& formButtons, const QList< bool >& newButtonStates )
{
    QUndoCommand *uc = new EditFormButtonsCommand( this->d, pageNumber, formButtons, newButtonStates );
    d->m_undoStack->push( uc );
}

void Document::reloadDocument() const
{
    const int numOfPages = pages();
    for( int i = currentPage(); i >= 0; i -- )
        d->refreshPixmaps( i );
    for( int i = currentPage() + 1; i < numOfPages; i ++ )
        d->refreshPixmaps( i );
}

BookmarkManager * Document::bookmarkManager() const
{
    return d->m_bookmarkManager;
}

QList<int> Document::bookmarkedPageList() const
{
    QList<int> list;
    uint docPages = pages();

    //pages are 0-indexed internally, but 1-indexed externally
    for ( uint i = 0; i < docPages; i++ )
    {
        if ( bookmarkManager()->isBookmarked( i ) )
        {
            list << i + 1;
        }
    }
    return list;
}

QString Document::bookmarkedPageRange() const
{
    // Code formerly in Part::slotPrint()
    // range detecting
    QString range;
    uint docPages = pages();
    int startId = -1;
    int endId = -1;

    for ( uint i = 0; i < docPages; ++i )
    {
        if ( bookmarkManager()->isBookmarked( i ) )
        {
            if ( startId < 0 )
                startId = i;
            if ( endId < 0 )
                endId = startId;
            else
                ++endId;
        }
        else if ( startId >= 0 && endId >= 0 )
        {
            if ( !range.isEmpty() )
                range += QLatin1Char ( ',' );

            if ( endId - startId > 0 )
                range += QStringLiteral( ""%1-%2"" ).arg( startId + 1 ).arg( endId + 1 );
            else
                range += QString::number( startId + 1 );
            startId = -1;
            endId = -1;
        }
    }
    if ( startId >= 0 && endId >= 0 )
    {
        if ( !range.isEmpty() )
            range += QLatin1Char ( ',' );

        if ( endId - startId > 0 )
            range += QStringLiteral( ""%1-%2"" ).arg( startId + 1 ).arg( endId + 1 );
        else
            range += QString::number( startId + 1 );
    }
    return range;
}

void Document::processAction( const Action * action )
{
    if ( !action )
        return;

    switch( action->actionType() )
    {
        case Action::Goto: {
            const GotoAction * go = static_cast< const GotoAction * >( action );
            d->m_nextDocumentViewport = go->destViewport();
            d->m_nextDocumentDestination = go->destinationName();

            // Explanation of why d->m_nextDocumentViewport is needed:
            // all openRelativeFile does is launch a signal telling we
            // want to open another URL, the problem is that when the file is
            // non local, the loading is done assynchronously so you can't
            // do a setViewport after the if as it was because you are doing the setViewport
            // on the old file and when the new arrives there is no setViewport for it and
            // it does not show anything

            // first open filename if link is pointing outside this document
            if ( go->isExternal() && !d->openRelativeFile( go->fileName() ) )
            {
                qCWarning(OkularCoreDebug).nospace() << ""Action: Error opening '"" << go->fileName() << ""'."";
                break;
            }
            else
            {
                const DocumentViewport nextViewport = d->nextDocumentViewport();
                // skip local links that point to nowhere (broken ones)
                if ( !nextViewport.isValid() )
                    break;

                setViewport( nextViewport, nullptr, true );
                d->m_nextDocumentViewport = DocumentViewport();
                d->m_nextDocumentDestination = QString();
            }

            } break;

        case Action::Execute: {
            const ExecuteAction * exe  = static_cast< const ExecuteAction * >( action );
            const QString fileName = exe->fileName();
            if ( fileName.endsWith( QLatin1String("".pdf""), Qt::CaseInsensitive ) )
            {
                d->openRelativeFile( fileName );
                break;
            }

            // Albert: the only pdf i have that has that kind of link don't define
            // an application and use the fileName as the file to open
            QUrl url = d->giveAbsoluteUrl( fileName );
            QMimeDatabase db;
            QMimeType mime = db.mimeTypeForUrl( url );
            // Check executables
            if ( KRun::isExecutableFile( url, mime.name() ) )
            {
                // Don't have any pdf that uses this code path, just a guess on how it should work
                if ( !exe->parameters().isEmpty() )
                {
                    url = d->giveAbsoluteUrl( exe->parameters() );
                    mime = db.mimeTypeForUrl( url );

                    if ( KRun::isExecutableFile( url, mime.name() ) )
                    {
                        // this case is a link pointing to an executable with a parameter
                        // that also is an executable, possibly a hand-crafted pdf
                        KMessageBox::information( d->m_widget, i18n(""The document is trying to execute an external application and, for your safety, Okular does not allow that."") );
                        break;
                    }
                }
                else
                {
                    // this case is a link pointing to an executable with no parameters
                    // core developers find unacceptable executing it even after asking the user
                    KMessageBox::information( d->m_widget, i18n(""The document is trying to execute an external application and, for your safety, Okular does not allow that."") );
                    break;
                }
            }

            KService::Ptr ptr = KMimeTypeTrader::self()->preferredService( mime.name(), QStringLiteral(""Application"") );
            if ( ptr )
            {
                QList<QUrl> lst;
                lst.append( url );
                KRun::runService( *ptr, lst, nullptr );
            }
            else
                KMessageBox::information( d->m_widget, i18n( ""No application found for opening file of mimetype %1."", mime.name() ) );
            } break;

        case Action::DocAction: {
            const DocumentAction * docaction = static_cast< const DocumentAction * >( action );
            switch( docaction->documentActionType() )
            {
                case DocumentAction::PageFirst:
                    setViewportPage( 0 );
                    break;
                case DocumentAction::PagePrev:
                    if ( (*d->m_viewportIterator).pageNumber > 0 )
                        setViewportPage( (*d->m_viewportIterator).pageNumber - 1 );
                    break;
                case DocumentAction::PageNext:
                    if ( (*d->m_viewportIterator).pageNumber < (int)d->m_pagesVector.count() - 1 )
                        setViewportPage( (*d->m_viewportIterator).pageNumber + 1 );
                    break;
                case DocumentAction::PageLast:
                    setViewportPage( d->m_pagesVector.count() - 1 );
                    break;
                case DocumentAction::HistoryBack:
                    setPrevViewport();
                    break;
                case DocumentAction::HistoryForward:
                    setNextViewport();
                    break;
                case DocumentAction::Quit:
                    emit quit();
                    break;
                case DocumentAction::Presentation:
                    emit linkPresentation();
                    break;
                case DocumentAction::EndPresentation:
                    emit linkEndPresentation();
                    break;
                case DocumentAction::Find:
                    emit linkFind();
                    break;
                case DocumentAction::GoToPage:
                    emit linkGoToPage();
                    break;
                case DocumentAction::Close:
                    emit close();
                    break;
            }
            } break;

        case Action::Browse: {
            const BrowseAction * browse = static_cast< const BrowseAction * >( action );
            QString lilySource;
            int lilyRow = 0, lilyCol = 0;
            // if the url is a mailto one, invoke mailer
            if ( browse->url().scheme() == QLatin1String(""mailto"") )
            {
                QDesktopServices::openUrl( browse->url() );
            }
            else if ( extractLilyPondSourceReference( browse->url(), &lilySource, &lilyRow, &lilyCol ) )
            {
                const SourceReference ref( lilySource, lilyRow, lilyCol );
                processSourceReference( &ref );
            }
            else
            {
                const QUrl url = browse->url();

                // fix for #100366, documents with relative links that are the form of http:foo.pdf
                if ((url.scheme() == ""http"") && url.host().isEmpty() && url.fileName().endsWith(""pdf""))
                {
                    d->openRelativeFile(url.fileName());
                    break;
                }

                // handle documents with relative path
                if ( d->m_url.isValid() )
                {
                    const QUrl realUrl = KIO::upUrl(d->m_url).resolved(url);
                    // KRun autodeletes
                    new KRun( realUrl, d->m_widget );
                }
            }
            } break;

        case Action::Sound: {
            const SoundAction * linksound = static_cast< const SoundAction * >( action );
            AudioPlayer::instance()->playSound( linksound->sound(), linksound );
            } break;

        case Action::Script: {
            const ScriptAction * linkscript = static_cast< const ScriptAction * >( action );
            if ( !d->m_scripter )
                d->m_scripter = new Scripter( d );
            d->m_scripter->execute( linkscript->scriptType(), linkscript->script() );
            } break;

        case Action::Movie:
            emit processMovieAction( static_cast< const MovieAction * >( action ) );
            break;
        case Action::Rendition: {
            const RenditionAction * linkrendition = static_cast< const RenditionAction * >( action );
            if ( !linkrendition->script().isEmpty() )
            {
                if ( !d->m_scripter )
                    d->m_scripter = new Scripter( d );
                d->m_scripter->execute( linkrendition->scriptType(), linkrendition->script() );
            }

            emit processRenditionAction( static_cast< const RenditionAction * >( action ) );
            } break;
        case Action::BackendOpaque: {
            d->m_generator->opaqueAction( static_cast< const BackendOpaqueAction * >( action ) );
            } break;

    }

    for ( const Action *a : action->nextActions() )
    {
        processAction( a );
    }
}

void Document::processSourceReference( const SourceReference * ref )
{
    if ( !ref )
        return;

    const QUrl url = d->giveAbsoluteUrl( ref->fileName() );
    if ( !url.isLocalFile() )
    {
        qCDebug(OkularCoreDebug) << url.url() << ""is not a local file."";
        return;
    }

    const QString absFileName = url.toLocalFile();
    if ( !QFile::exists( absFileName ) )
    {
        qCDebug(OkularCoreDebug) << ""No such file:"" << absFileName;
        return;
    }

    bool handled = false;
    emit sourceReferenceActivated(absFileName, ref->row(), ref->column(), &handled);
    if(handled) {
        return;
    }

    static QHash< int, QString > editors;
    // init the editors table if empty (on first run, usually)
    if ( editors.isEmpty() )
    {
        editors = buildEditorsMap();
    }

    QHash< int, QString >::const_iterator it = editors.constFind( SettingsCore::externalEditor() );
    QString p;
    if ( it != editors.constEnd() )
        p = *it;
    else
        p = SettingsCore::externalEditorCommand();
    // custom editor not yet configured
    if ( p.isEmpty() )
        return;

    // manually append the %f placeholder if not specified
    if ( p.indexOf( QLatin1String( ""%f"" ) ) == -1 )
        p.append( QLatin1String( "" %f"" ) );

    // replacing the placeholders
    QHash< QChar, QString > map;
    map.insert( QLatin1Char ( 'f' ), absFileName );
    map.insert( QLatin1Char ( 'c' ), QString::number( ref->column() ) );
    map.insert( QLatin1Char ( 'l' ), QString::number( ref->row() ) );
    const QString cmd = KMacroExpander::expandMacrosShellQuote( p, map );
    if ( cmd.isEmpty() )
        return;
    const QStringList args = KShell::splitArgs( cmd );
    if ( args.isEmpty() )
        return;

    KProcess::startDetached( args );
}

const SourceReference * Document::dynamicSourceReference( int pageNr, double absX, double absY )
{
    if  ( !d->m_synctex_scanner )
        return nullptr;

    const QSizeF dpi = d->m_generator->dpi();

    if (synctex_edit_query(d->m_synctex_scanner, pageNr + 1, absX * 72. / dpi.width(), absY * 72. / dpi.height()) > 0)
    {
        synctex_node_p node;
        // TODO what should we do if there is really more than one node?
        while (( node = synctex_scanner_next_result( d->m_synctex_scanner ) ))
        {
            int line = synctex_node_line(node);
            int col = synctex_node_column(node);
            // column extraction does not seem to be implemented in synctex so far. set the SourceReference default value.
            if ( col == -1 )
            {
                col = 0;
            }
            const char *name = synctex_scanner_get_name( d->m_synctex_scanner, synctex_node_tag( node ) );

            return new Okular::SourceReference( QFile::decodeName( name ), line, col );
        }
    }
    return nullptr;
}

Document::PrintingType Document::printingSupport() const
{
    if ( d->m_generator )
    {

        if ( d->m_generator->hasFeature( Generator::PrintNative ) )
        {
            return NativePrinting;
        }

#ifndef Q_OS_WIN
        if ( d->m_generator->hasFeature( Generator::PrintPostscript ) )
        {
            return PostscriptPrinting;
        }
#endif

    }

    return NoPrinting;
}

bool Document::supportsPrintToFile() const
{
    return d->m_generator ? d->m_generator->hasFeature( Generator::PrintToFile ) : false;
}

bool Document::print( QPrinter &printer )
{
    return d->m_generator ? d->m_generator->print( printer ) : false;
}

QString Document::printError() const
{
    Okular::Generator::PrintError err = Generator::UnknownPrintError;
    if ( d->m_generator )
    {
        QMetaObject::invokeMethod( d->m_generator, ""printError"", Qt::DirectConnection, Q_RETURN_ARG(Okular::Generator::PrintError, err) );
    }
    Q_ASSERT( err != Generator::NoPrintError );
    switch ( err )
    {
        case Generator::TemporaryFileOpenPrintError:
            return i18n( ""Could not open a temporary file"" );
        case Generator::FileConversionPrintError:
            return i18n( ""Print conversion failed"" );
        case Generator::PrintingProcessCrashPrintError:
            return i18n( ""Printing process crashed"" );
        case Generator::PrintingProcessStartPrintError:
            return i18n( ""Printing process could not start"" );
        case Generator::PrintToFilePrintError:
            return i18n( ""Printing to file failed"" );
        case Generator::InvalidPrinterStatePrintError:
            return i18n( ""Printer was in invalid state"" );
        case Generator::UnableToFindFilePrintError:
            return i18n( ""Unable to find file to print"" );
        case Generator::NoFileToPrintError:
            return i18n( ""There was no file to print"" );
        case Generator::NoBinaryToPrintError:
            return i18n( ""Could not find a suitable binary for printing. Make sure CUPS lpr binary is available"" );
        case Generator::InvalidPageSizePrintError:
            return i18n( ""The page print size is invalid"" );
        case Generator::NoPrintError:
            return QString();
        case Generator::UnknownPrintError:
            return QString();
    }

    return QString();
}

QWidget* Document::printConfigurationWidget() const
{
    if ( d->m_generator )
    {
        PrintInterface * iface = qobject_cast< Okular::PrintInterface * >( d->m_generator );
        return iface ? iface->printConfigurationWidget() : nullptr;
    }
    else
        return nullptr;
}

void Document::fillConfigDialog( KConfigDialog * dialog )
{
    if ( !dialog )
        return;

    // ensure that we have all the generators with settings loaded
    QVector<KPluginMetaData> offers = DocumentPrivate::configurableGenerators();
    d->loadServiceList( offers );

    // We want the generators to be sorted by name so let's fill in a QMap
    // this sorts by internal id which is not awesome, but at least the sorting
    // is stable between runs that before it wasn't
    QMap<QString, GeneratorInfo> sortedGenerators;
    QHash< QString, GeneratorInfo >::iterator it = d->m_loadedGenerators.begin();
    QHash< QString, GeneratorInfo >::iterator itEnd = d->m_loadedGenerators.end();
    for ( ; it != itEnd; ++it )
    {
        sortedGenerators.insert(it.key(), it.value());
    }

    bool pagesAdded = false;
    QMap< QString, GeneratorInfo >::iterator sit = sortedGenerators.begin();
    QMap< QString, GeneratorInfo >::iterator sitEnd = sortedGenerators.end();
    for ( ; sit != sitEnd; ++sit )
    {
        Okular::ConfigInterface * iface = d->generatorConfig( sit.value() );
        if ( iface )
        {
            iface->addPages( dialog );
            pagesAdded = true;
        }
    }
    if ( pagesAdded )
    {
        connect( dialog, SIGNAL(settingsChanged(QString)),
                 this, SLOT(slotGeneratorConfigChanged(QString)) );
    }
}


QVector<KPluginMetaData> DocumentPrivate::configurableGenerators()
{
    const QVector<KPluginMetaData> available = availableGenerators();
    QVector<KPluginMetaData> result;
    for (const KPluginMetaData& md : available)
    {
        if (md.rawData()[QStringLiteral(""X-KDE-okularHasInternalSettings"")].toBool())
        {
            result << md;
        }
    }
    return result;
}

KPluginMetaData Document::generatorInfo() const
{
    if (!d->m_generator)
        return KPluginMetaData();

    auto genIt = d->m_loadedGenerators.constFind(d->m_generatorName);
    Q_ASSERT(genIt != d->m_loadedGenerators.constEnd());
    return genIt.value().metadata;
}

int Document::configurableGenerators() const
{
    return DocumentPrivate::configurableGenerators().size();
}

QStringList Document::supportedMimeTypes() const
{
    // TODO: make it a static member of DocumentPrivate?
    QStringList result = d->m_supportedMimeTypes;
    if (result.isEmpty())
    {
        const QVector<KPluginMetaData> available = DocumentPrivate::availableGenerators();
        for (const KPluginMetaData& md : available)
        {
            result << md.mimeTypes();
        }

        // Remove duplicate mimetypes represented by different names
        QMimeDatabase mimeDatabase;
        QSet<QMimeType> uniqueMimetypes;
        for (const QString &mimeName : result) {
            uniqueMimetypes.insert(mimeDatabase.mimeTypeForName(mimeName));
        }
        result.clear();
        for (const QMimeType &mimeType : uniqueMimetypes) {
            result.append(mimeType.name());
        }

        // Add the Okular archive mimetype
        result << QStringLiteral(""application/vnd.kde.okular-archive"");

        // Sorting by mimetype name doesn't make a ton of sense,
        // but ensures that the list is ordered the same way every time
        qSort(result);

        d->m_supportedMimeTypes = result;
    }
    return result;
}

bool Document::canSwapBackingFile() const
{
    if ( !d->m_generator )
        return false;

    return d->m_generator->hasFeature( Generator::SwapBackingFile );
}

bool Document::swapBackingFile( const QString &newFileName, const QUrl &url )
{
    if ( !d->m_generator )
        return false;

    if ( !d->m_generator->hasFeature( Generator::SwapBackingFile ) )
        return false;

    // Save metadata about the file we're about to close
    d->saveDocumentInfo();

    d->clearAndWaitForRequests();

    qCDebug(OkularCoreDebug) << ""Swapping backing file to"" << newFileName;
    QVector< Page * > newPagesVector;
    Generator::SwapBackingFileResult result = d->m_generator->swapBackingFile( newFileName, newPagesVector );
    if (result != Generator::SwapBackingFileError)
    {
        QLinkedList< ObjectRect* > rectsToDelete;
        QLinkedList< Annotation* > annotationsToDelete;
        QSet< PagePrivate* > pagePrivatesToDelete;

        if (result == Generator::SwapBackingFileReloadInternalData)
        {
            // Here we need to replace everything that the old generator
            // had created with what the new one has without making it look like
            // we have actually closed and opened the file again

            // Simple sanity check
            if (newPagesVector.count() != d->m_pagesVector.count())
                return false;

            // Update the undo stack contents
            for (int i = 0; i < d->m_undoStack->count(); ++i)
            {
                // Trust me on the const_cast ^_^
                QUndoCommand *uc = const_cast<QUndoCommand *>( d->m_undoStack->command( i ) );
                if (OkularUndoCommand *ouc = dynamic_cast<OkularUndoCommand*>( uc ))
                {
                    const bool success = ouc->refreshInternalPageReferences( newPagesVector );
                    if ( !success )
                    {
                        qWarning() << ""Document::swapBackingFile: refreshInternalPageReferences failed"" << ouc;
                        return false;
                    }
                }
                else
                {
                    qWarning() << ""Document::swapBackingFile: Unhandled undo command"" << uc;
                    return false;
                }
            }

            for (int i = 0; i < d->m_pagesVector.count(); ++i)
            {
                // switch the PagePrivate* from newPage to oldPage
                // this way everyone still holding Page* doesn't get
                // disturbed by it
                Page *oldPage = d->m_pagesVector[i];
                Page *newPage = newPagesVector[i];
                newPage->d->adoptGeneratedContents(oldPage->d);

                pagePrivatesToDelete << oldPage->d;
                oldPage->d = newPage->d;
                oldPage->d->m_page = oldPage;
                oldPage->d->m_doc = d;
                newPage->d = nullptr;

                annotationsToDelete << oldPage->m_annotations;
                rectsToDelete << oldPage->m_rects;
                oldPage->m_annotations = newPage->m_annotations;
                oldPage->m_rects = newPage->m_rects;
            }
            qDeleteAll( newPagesVector );
        }

        d->m_url = url;
        d->m_docFileName = newFileName;
        d->updateMetadataXmlNameAndDocSize();
        d->m_bookmarkManager->setUrl( d->m_url );
        d->m_documentInfo = DocumentInfo();
        d->m_documentInfoAskedKeys.clear();

        if ( d->m_synctex_scanner )
        {
            synctex_scanner_free( d->m_synctex_scanner );
            d->m_synctex_scanner = synctex_scanner_new_with_output_file( QFile::encodeName( newFileName ).constData(), nullptr, 1);
            if ( !d->m_synctex_scanner && QFile::exists(newFileName + QLatin1String( ""sync"" ) ) )
            {
                d->loadSyncFile(newFileName);
            }
        }

        foreachObserver( notifySetup( d->m_pagesVector, DocumentObserver::UrlChanged ) );

        qDeleteAll( annotationsToDelete );
        qDeleteAll( rectsToDelete );
        qDeleteAll( pagePrivatesToDelete );

        return true;
    }
    else
    {
        return false;
    }
}

bool Document::swapBackingFileArchive( const QString &newFileName, const QUrl &url )
{
    qCDebug(OkularCoreDebug) << ""Swapping backing archive to"" << newFileName;

    ArchiveData *newArchive = DocumentPrivate::unpackDocumentArchive( newFileName );
    if ( !newArchive )
        return false;

    const QString tempFileName = newArchive->document.fileName();

    const bool success = swapBackingFile( tempFileName, url );

    if ( success )
    {
        delete d->m_archiveData;
        d->m_archiveData = newArchive;
    }

    return success;
}

void Document::setHistoryClean( bool clean )
{
    if ( clean )
        d->m_undoStack->setClean();
    // Since we only use the resetClean
    // in some cases and we're past the dependency freeze
    // if you happen to compile with an old Qt you will miss
    // some extra nicety when saving an okular file with annotations to png file
    // it's quite corner case compared to how important the whole save feature
    // is so you'll have to live without it
#if QT_VERSION > QT_VERSION_CHECK(5, 8, 0)
    else
        d->m_undoStack->resetClean();
#endif
}

bool Document::canSaveChanges() const
{
    if ( !d->m_generator )
        return false;
    Q_ASSERT( !d->m_generatorName.isEmpty() );

    QHash< QString, GeneratorInfo >::iterator genIt = d->m_loadedGenerators.find( d->m_generatorName );
    Q_ASSERT( genIt != d->m_loadedGenerators.end() );
    SaveInterface* saveIface = d->generatorSave( genIt.value() );
    if ( !saveIface )
        return false;

    return saveIface->supportsOption( SaveInterface::SaveChanges );
}

bool Document::canSaveChanges( SaveCapability cap ) const
{
    switch ( cap )
    {
        case SaveFormsCapability:
            /* Assume that if the generator supports saving, forms can be saved.
             * We have no means to actually query the generator at the moment
             * TODO: Add some method to query the generator in SaveInterface */
            return canSaveChanges();

        case SaveAnnotationsCapability:
            return d->canAddAnnotationsNatively();
    }

    return false;
}

bool Document::saveChanges( const QString &fileName )
{
    QString errorText;
    return saveChanges( fileName, &errorText );
}

bool Document::saveChanges( const QString &fileName, QString *errorText )
{
    if ( !d->m_generator || fileName.isEmpty() )
        return false;
    Q_ASSERT( !d->m_generatorName.isEmpty() );

    QHash< QString, GeneratorInfo >::iterator genIt = d->m_loadedGenerators.find( d->m_generatorName );
    Q_ASSERT( genIt != d->m_loadedGenerators.end() );
    SaveInterface* saveIface = d->generatorSave( genIt.value() );
    if ( !saveIface || !saveIface->supportsOption( SaveInterface::SaveChanges ) )
        return false;

    return saveIface->save( fileName, SaveInterface::SaveChanges, errorText );
}

void Document::registerView( View *view )
{
    if ( !view )
        return;

    Document *viewDoc = view->viewDocument();
    if ( viewDoc )
    {
        // check if already registered for this document
        if ( viewDoc == this )
            return;

        viewDoc->unregisterView( view );
    }

    d->m_views.insert( view );
    view->d_func()->document = d;
}

void Document::unregisterView( View *view )
{
    if ( !view )
        return;

    Document *viewDoc = view->viewDocument();
    if ( !viewDoc || viewDoc != this )
        return;

    view->d_func()->document = nullptr;
    d->m_views.remove( view );
}

QByteArray Document::fontData(const FontInfo &font) const
{
    QByteArray result;

    if (d->m_generator)
    {
        QMetaObject::invokeMethod(d->m_generator, ""requestFontData"", Qt::DirectConnection, Q_ARG(Okular::FontInfo, font), Q_ARG(QByteArray *, &result));
    }

    return result;
}

ArchiveData *DocumentPrivate::unpackDocumentArchive( const QString &archivePath )
{
    QMimeDatabase db;
    const QMimeType mime = db.mimeTypeForFile( archivePath, QMimeDatabase::MatchExtension );
    if ( !mime.inherits( QStringLiteral(""application/vnd.kde.okular-archive"") ) )
        return nullptr;

    KZip okularArchive( archivePath );
    if ( !okularArchive.open( QIODevice::ReadOnly ) )
        return nullptr;

    const KArchiveDirectory * mainDir = okularArchive.directory();

    // Check the archive doesn't have folders, we don't create them when saving the archive
    // and folders mean paths and paths mean path traversal issues
    for ( const QString &entry : mainDir->entries() )
    {
        if ( mainDir->entry( entry )->isDirectory() )
        {
            qWarning() << ""Warning: Found a directory inside"" << archivePath << "" - Okular does not create files like that so it is most probably forged."";
            return nullptr;
        }
    }

    const KArchiveEntry * mainEntry = mainDir->entry( QStringLiteral(""content.xml"") );
    if ( !mainEntry || !mainEntry->isFile() )
        return nullptr;

    std::unique_ptr< QIODevice > mainEntryDevice( static_cast< const KZipFileEntry * >( mainEntry )->createDevice() );
    QDomDocument doc;
    if ( !doc.setContent( mainEntryDevice.get() ) )
        return nullptr;
    mainEntryDevice.reset();

    QDomElement root = doc.documentElement();
   if ( root.tagName() != QLatin1String(""OkularArchive"") )
        return nullptr;

    QString documentFileName;
    QString metadataFileName;
    QDomElement el = root.firstChild().toElement();
    for ( ; !el.isNull(); el = el.nextSibling().toElement() )
    {
        if ( el.tagName() == QLatin1String(""Files"") )
        {
            QDomElement fileEl = el.firstChild().toElement();
            for ( ; !fileEl.isNull(); fileEl = fileEl.nextSibling().toElement() )
            {
                if ( fileEl.tagName() == QLatin1String(""DocumentFileName"") )
                    documentFileName = fileEl.text();
                else if ( fileEl.tagName() == QLatin1String(""MetadataFileName"") )
                    metadataFileName = fileEl.text();
            }
        }
    }
    if ( documentFileName.isEmpty() )
        return nullptr;

    const KArchiveEntry * docEntry = mainDir->entry( documentFileName );
    if ( !docEntry || !docEntry->isFile() )
        return nullptr;

    std::unique_ptr< ArchiveData > archiveData( new ArchiveData() );
    const int dotPos = documentFileName.indexOf( QLatin1Char('.') );
    if ( dotPos != -1 )
        archiveData->document.setFileTemplate(QDir::tempPath() + QLatin1String(""/okular_XXXXXX"") + documentFileName.mid(dotPos));
    if ( !archiveData->document.open() )
        return nullptr;

    archiveData->originalFileName = documentFileName;

    {
    std::unique_ptr< QIODevice > docEntryDevice( static_cast< const KZipFileEntry * >( docEntry )->createDevice() );
    copyQIODevice( docEntryDevice.get(), &archiveData->document );
    archiveData->document.close();
    }

    const KArchiveEntry * metadataEntry = mainDir->entry( metadataFileName );
    if ( metadataEntry && metadataEntry->isFile() )
    {
        std::unique_ptr< QIODevice > metadataEntryDevice( static_cast< const KZipFileEntry * >( metadataEntry )->createDevice() );
        archiveData->metadataFile.setFileTemplate(QDir::tempPath() + QLatin1String(""/okular_XXXXXX.xml""));
        if ( archiveData->metadataFile.open() )
        {
            copyQIODevice( metadataEntryDevice.get(), &archiveData->metadataFile );
            archiveData->metadataFile.close();
        }
    }

    return archiveData.release();
}

Document::OpenResult Document::openDocumentArchive( const QString & docFile, const QUrl & url, const QString & password )
{
    d->m_archiveData = DocumentPrivate::unpackDocumentArchive( docFile );
    if ( !d->m_archiveData )
        return OpenError;

    const QString tempFileName = d->m_archiveData->document.fileName();
    QMimeDatabase db;
    const QMimeType docMime = db.mimeTypeForFile( tempFileName, QMimeDatabase::MatchContent );
    const OpenResult ret = openDocument( tempFileName, url, docMime, password );

    if ( ret != OpenSuccess )
    {
        delete d->m_archiveData;
        d->m_archiveData = nullptr;
    }

    return ret;
}

bool Document::saveDocumentArchive( const QString &fileName )
{
    if ( !d->m_generator )
        return false;

    /* If we opened an archive, use the name of original file (eg foo.pdf)
     * instead of the archive's one (eg foo.okular) */
    QString docFileName = d->m_archiveData ? d->m_archiveData->originalFileName : d->m_url.fileName();
    if ( docFileName == QLatin1String( ""-"" ) )
        return false;

    QString docPath = d->m_docFileName;
    const QFileInfo fi( docPath );
    if ( fi.isSymLink() )
        docPath = fi.symLinkTarget();

    KZip okularArchive( fileName );
    if ( !okularArchive.open( QIODevice::WriteOnly ) )
        return false;

    const KUser user;
#ifndef Q_OS_WIN
    const KUserGroup userGroup( user.groupId() );
#else
    const KUserGroup userGroup( QString( """" ) );
#endif

    QDomDocument contentDoc( QStringLiteral(""OkularArchive"") );
    QDomProcessingInstruction xmlPi = contentDoc.createProcessingInstruction(
            QStringLiteral( ""xml"" ), QStringLiteral( ""version=\""1.0\"" encoding=\""utf-8\"""" ) );
    contentDoc.appendChild( xmlPi );
    QDomElement root = contentDoc.createElement( QStringLiteral(""OkularArchive"") );
    contentDoc.appendChild( root );

    QDomElement filesNode = contentDoc.createElement( QStringLiteral(""Files"") );
    root.appendChild( filesNode );

    QDomElement fileNameNode = contentDoc.createElement( QStringLiteral(""DocumentFileName"") );
    filesNode.appendChild( fileNameNode );
    fileNameNode.appendChild( contentDoc.createTextNode( docFileName ) );

    QDomElement metadataFileNameNode = contentDoc.createElement( QStringLiteral(""MetadataFileName"") );
    filesNode.appendChild( metadataFileNameNode );
    metadataFileNameNode.appendChild( contentDoc.createTextNode( QStringLiteral(""metadata.xml"") ) );

    // If the generator can save annotations natively, do it
    QTemporaryFile modifiedFile;
    bool annotationsSavedNatively = false;
    bool formsSavedNatively = false;
    if ( d->canAddAnnotationsNatively() || canSaveChanges( SaveFormsCapability ) )
    {
        if ( !modifiedFile.open() )
            return false;

        const QString modifiedFileName = modifiedFile.fileName();

        modifiedFile.close(); // We're only interested in the file name

        QString errorText;
        if ( saveChanges( modifiedFileName, &errorText ) )
        {
            docPath = modifiedFileName; // Save this instead of the original file
            annotationsSavedNatively = d->canAddAnnotationsNatively();
            formsSavedNatively = canSaveChanges( SaveFormsCapability );
        }
        else
        {
            qCWarning(OkularCoreDebug) << ""saveChanges failed: "" << errorText;
            qCDebug(OkularCoreDebug) << ""Falling back to saving a copy of the original file"";
        }
    }

    PageItems saveWhat = None;
    if ( !annotationsSavedNatively )
        saveWhat |= AnnotationPageItems;
    if ( !formsSavedNatively )
        saveWhat |= FormFieldPageItems;

    QTemporaryFile metadataFile;
    if ( !d->savePageDocumentInfo( &metadataFile, saveWhat ) )
        return false;

    const QByteArray contentDocXml = contentDoc.toByteArray();
    const mode_t perm = 0100644;
    okularArchive.writeFile( QStringLiteral(""content.xml""), contentDocXml, perm,
                              user.loginName(), userGroup.name() );


    okularArchive.addLocalFile( docPath, docFileName );
    okularArchive.addLocalFile( metadataFile.fileName(), QStringLiteral(""metadata.xml"") );

    if ( !okularArchive.close() )
        return false;

    return true;
}

bool Document::extractArchivedFile( const QString &destFileName )
{
    if ( !d->m_archiveData )
        return false;

    // Remove existing file, if present (QFile::copy doesn't overwrite by itself)
    QFile::remove( destFileName );

    return d->m_archiveData->document.copy( destFileName );
}

QPrinter::Orientation Document::orientation() const
{
    double width, height;
    int landscape, portrait;
    const Okular::Page *currentPage;

    // if some pages are landscape and others are not, the most common wins, as
    // QPrinter does not accept a per-page setting
    landscape = 0;
    portrait = 0;
    for (uint i = 0; i < pages(); i++)
    {
        currentPage = page(i);
        width = currentPage->width();
        height = currentPage->height();
        if (currentPage->orientation() == Okular::Rotation90 || currentPage->orientation() == Okular::Rotation270) qSwap(width, height);
        if (width > height) landscape++;
        else portrait++;
    }
    return (landscape > portrait) ? QPrinter::Landscape : QPrinter::Portrait;
}

void Document::setAnnotationEditingEnabled( bool enable )
{
    d->m_annotationEditingEnabled = enable;
    foreachObserver( notifySetup( d->m_pagesVector, 0 ) );
}

void Document::walletDataForFile( const QString &fileName, QString *walletName, QString *walletFolder, QString *walletKey ) const
{
    if (d->m_generator) {
        d->m_generator->walletDataForFile( fileName, walletName, walletFolder, walletKey );
    } else if (d->m_walletGenerator) {
        d->m_walletGenerator->walletDataForFile( fileName, walletName, walletFolder, walletKey );
    }
}

bool Document::isDocdataMigrationNeeded() const
{
    return d->m_docdataMigrationNeeded;
}

void Document::docdataMigrationDone()
{
    if (d->m_docdataMigrationNeeded)
    {
        d->m_docdataMigrationNeeded = false;
        foreachObserver( notifySetup( d->m_pagesVector, 0 ) );
    }
}

QAbstractItemModel * Document::layersModel() const
{
    return d->m_generator ? d->m_generator->layersModel() : nullptr;
}

void DocumentPrivate::requestDone( PixmapRequest * req )
{
    if ( !req )
        return;

    if ( !m_generator || m_closingLoop )
    {
        m_pixmapRequestsMutex.lock();
        m_executingPixmapRequests.removeAll( req );
        m_pixmapRequestsMutex.unlock();
        delete req;
        if ( m_closingLoop )
            m_closingLoop->exit();
        return;
    }

#ifndef NDEBUG
    if ( !m_generator->canGeneratePixmap() )
        qCDebug(OkularCoreDebug) << ""requestDone with generator not in READY state."";
#endif

    if ( !req->shouldAbortRender() )
    {
        // [MEM] 1.1 find and remove a previous entry for the same page and id
        QLinkedList< AllocatedPixmap * >::iterator aIt = m_allocatedPixmaps.begin();
        QLinkedList< AllocatedPixmap * >::iterator aEnd = m_allocatedPixmaps.end();
        for ( ; aIt != aEnd; ++aIt )
            if ( (*aIt)->page == req->pageNumber() && (*aIt)->observer == req->observer() )
            {
                AllocatedPixmap * p = *aIt;
                m_allocatedPixmaps.erase( aIt );
                m_allocatedPixmapsTotalMemory -= p->memory;
                delete p;
                break;
            }

        DocumentObserver *observer = req->observer();
        if ( m_observers.contains(observer) )
        {
            // [MEM] 1.2 append memory allocation descriptor to the FIFO
            qulonglong memoryBytes = 0;
            const TilesManager *tm = req->d->tilesManager();
            if ( tm )
                memoryBytes = tm->totalMemory();
            else
                memoryBytes = 4 * req->width() * req->height();

            AllocatedPixmap * memoryPage = new AllocatedPixmap( req->observer(), req->pageNumber(), memoryBytes );
            m_allocatedPixmaps.append( memoryPage );
            m_allocatedPixmapsTotalMemory += memoryBytes;

            // 2. notify an observer that its pixmap changed
            observer->notifyPageChanged( req->pageNumber(), DocumentObserver::Pixmap );
        }
#ifndef NDEBUG
        else
            qCWarning(OkularCoreDebug) << ""Receiving a done request for the defunct observer"" << observer;
#endif
    }

    // 3. delete request
    m_pixmapRequestsMutex.lock();
    m_executingPixmapRequests.removeAll( req );
    m_pixmapRequestsMutex.unlock();
    delete req;

    // 4. start a new generation if some is pending
    m_pixmapRequestsMutex.lock();
    bool hasPixmaps = !m_pixmapRequestsStack.isEmpty();
    m_pixmapRequestsMutex.unlock();
    if ( hasPixmaps )
        sendGeneratorPixmapRequest();
}

void DocumentPrivate::setPageBoundingBox( int page, const NormalizedRect& boundingBox )
{
    Page * kp = m_pagesVector[ page ];
    if ( !m_generator || !kp )
        return;

    if ( kp->boundingBox() == boundingBox )
        return;
    kp->setBoundingBox( boundingBox );

    // notify observers about the change
    foreachObserverD( notifyPageChanged( page, DocumentObserver::BoundingBox ) );

    // TODO: For generators that generate the bbox by pixmap scanning, if the first generated pixmap is very small, the bounding box will forever be inaccurate.
    // TODO: Crop computation should also consider annotations, actions, etc. to make sure they're not cropped away.
    // TODO: Help compute bounding box for generators that create a QPixmap without a QImage, like text and plucker.
    // TODO: Don't compute the bounding box if no one needs it (e.g., Trim Borders is off).

}

void DocumentPrivate::calculateMaxTextPages()
{
    int multipliers = qMax(1, qRound(getTotalMemory() / 536870912.0)); // 512 MB
    switch (SettingsCore::memoryLevel())
    {
        case SettingsCore::EnumMemoryLevel::Low:
            m_maxAllocatedTextPages = multipliers * 2;
        break;

        case SettingsCore::EnumMemoryLevel::Normal:
            m_maxAllocatedTextPages = multipliers * 50;
        break;

        case SettingsCore::EnumMemoryLevel::Aggressive:
            m_maxAllocatedTextPages = multipliers * 250;
        break;

        case SettingsCore::EnumMemoryLevel::Greedy:
            m_maxAllocatedTextPages = multipliers * 1250;
        break;
    }
}

void DocumentPrivate::textGenerationDone( Page *page )
{
    if ( !m_pageController ) return;

    // 1. If we reached the cache limit, delete the first text page from the fifo
    if (m_allocatedTextPagesFifo.size() == m_maxAllocatedTextPages)
    {
        int pageToKick = m_allocatedTextPagesFifo.takeFirst();
        if (pageToKick != page->number()) // this should never happen but better be safe than sorry
        {
            m_pagesVector.at(pageToKick)->setTextPage( nullptr ); // deletes the textpage
        }
    }

    // 2. Add the page to the fifo of generated text pages
    m_allocatedTextPagesFifo.append( page->number() );
}

void Document::setRotation( int r )
{
    d->setRotationInternal( r, true );
}

void DocumentPrivate::setRotationInternal( int r, bool notify )
{
    Rotation rotation = (Rotation)r;
    if ( !m_generator || ( m_rotation == rotation ) )
	return;

    // tell the pages to rotate
    QVector< Okular::Page * >::const_iterator pIt = m_pagesVector.constBegin();
    QVector< Okular::Page * >::const_iterator pEnd = m_pagesVector.constEnd();
    for ( ; pIt != pEnd; ++pIt )
        (*pIt)->d->rotateAt( rotation );
    if ( notify )
    {
        // notify the generator that the current rotation has changed
        m_generator->rotationChanged( rotation, m_rotation );
    }
    // set the new rotation
    m_rotation = rotation;

    if ( notify )
    {
        foreachObserverD( notifySetup( m_pagesVector, DocumentObserver::NewLayoutForPages ) );
        foreachObserverD( notifyContentsCleared( DocumentObserver::Pixmap | DocumentObserver::Highlights | DocumentObserver::Annotations ) );
    }
    qCDebug(OkularCoreDebug) << ""Rotated:"" << r;
}

void Document::setPageSize( const PageSize &size )
{
    if ( !d->m_generator || !d->m_generator->hasFeature( Generator::PageSizes ) )
        return;

    if ( d->m_pageSizes.isEmpty() )
        d->m_pageSizes = d->m_generator->pageSizes();
    int sizeid = d->m_pageSizes.indexOf( size );
    if ( sizeid == -1 )
        return;

    // tell the pages to change size
    QVector< Okular::Page * >::const_iterator pIt = d->m_pagesVector.constBegin();
    QVector< Okular::Page * >::const_iterator pEnd = d->m_pagesVector.constEnd();
    for ( ; pIt != pEnd; ++pIt )
        (*pIt)->d->changeSize( size );
    // clear 'memory allocation' descriptors
    qDeleteAll( d->m_allocatedPixmaps );
    d->m_allocatedPixmaps.clear();
    d->m_allocatedPixmapsTotalMemory = 0;
    // notify the generator that the current page size has changed
    d->m_generator->pageSizeChanged( size, d->m_pageSize );
    // set the new page size
    d->m_pageSize = size;

    foreachObserver( notifySetup( d->m_pagesVector, DocumentObserver::NewLayoutForPages ) );
    foreachObserver( notifyContentsCleared( DocumentObserver::Pixmap | DocumentObserver::Highlights ) );
    qCDebug(OkularCoreDebug) << ""New PageSize id:"" << sizeid;
}


/** DocumentViewport **/

DocumentViewport::DocumentViewport( int n )
    : pageNumber( n )
{
    // default settings
    rePos.enabled = false;
    rePos.normalizedX = 0.5;
    rePos.normalizedY = 0.0;
    rePos.pos = Center;
    autoFit.enabled = false;
    autoFit.width = false;
    autoFit.height = false;
}

DocumentViewport::DocumentViewport( const QString & xmlDesc )
    : pageNumber( -1 )
{
    // default settings (maybe overridden below)
    rePos.enabled = false;
    rePos.normalizedX = 0.5;
    rePos.normalizedY = 0.0;
    rePos.pos = Center;
    autoFit.enabled = false;
    autoFit.width = false;
    autoFit.height = false;

    // check for string presence
    if ( xmlDesc.isEmpty() )
        return;

    // decode the string
    bool ok;
    int field = 0;
    QString token = xmlDesc.section( QLatin1Char(';'), field, field );
    while ( !token.isEmpty() )
    {
        // decode the current token
        if ( field == 0 )
        {
            pageNumber = token.toInt( &ok );
            if ( !ok )
                return;
        }
        else if ( token.startsWith( QLatin1String(""C1"") ) )
        {
            rePos.enabled = true;
            rePos.normalizedX = token.section( QLatin1Char(':'), 1, 1 ).toDouble();
            rePos.normalizedY = token.section( QLatin1Char(':'), 2, 2 ).toDouble();
            rePos.pos = Center;
        }
        else if ( token.startsWith( QLatin1String(""C2"") ) )
        {
            rePos.enabled = true;
            rePos.normalizedX = token.section( QLatin1Char(':'), 1, 1 ).toDouble();
            rePos.normalizedY = token.section( QLatin1Char(':'), 2, 2 ).toDouble();
            if (token.section( QLatin1Char(':'), 3, 3 ).toInt() == 1) rePos.pos = Center;
            else rePos.pos = TopLeft;
        }
        else if ( token.startsWith( QLatin1String(""AF1"") ) )
        {
            autoFit.enabled = true;
            autoFit.width = token.section( QLatin1Char(':'), 1, 1 ) == QLatin1String(""T"");
            autoFit.height = token.section( QLatin1Char(':'), 2, 2 ) == QLatin1String(""T"");
        }
        // proceed tokenizing string
        field++;
        token = xmlDesc.section( QLatin1Char(';'), field, field );
    }
}

QString DocumentViewport::toString() const
{
    // start string with page number
    QString s = QString::number( pageNumber );
    // if has center coordinates, save them on string
    if ( rePos.enabled )
        s += QStringLiteral( "";C2:"" ) + QString::number( rePos.normalizedX ) +
             QLatin1Char(':') + QString::number( rePos.normalizedY ) +
             QLatin1Char(':') + QString::number( rePos.pos );
    // if has autofit enabled, save its state on string
    if ( autoFit.enabled )
        s += QStringLiteral( "";AF1:"" ) + (autoFit.width ? QLatin1Char('T') : QLatin1Char('F')) +
             QLatin1Char(':') + (autoFit.height ? QLatin1Char('T') : QLatin1Char('F'));
    return s;
}

bool DocumentViewport::isValid() const
{
    return pageNumber >= 0;
}

bool DocumentViewport::operator==( const DocumentViewport & vp ) const
{
    bool equal = ( pageNumber == vp.pageNumber ) &&
                 ( rePos.enabled == vp.rePos.enabled ) &&
                 ( autoFit.enabled == vp.autoFit.enabled );
    if ( !equal )
        return false;
    if ( rePos.enabled &&
         (( rePos.normalizedX != vp.rePos.normalizedX) ||
         ( rePos.normalizedY != vp.rePos.normalizedY ) || rePos.pos != vp.rePos.pos) )
        return false;
    if ( autoFit.enabled &&
         (( autoFit.width != vp.autoFit.width ) ||
         ( autoFit.height != vp.autoFit.height )) )
        return false;
    return true;
}

bool DocumentViewport::operator<( const DocumentViewport & vp ) const
{
    // TODO: Check autoFit and Position

    if ( pageNumber != vp.pageNumber )
        return pageNumber < vp.pageNumber;

    if ( !rePos.enabled && vp.rePos.enabled )
        return true;

    if ( !vp.rePos.enabled )
        return false;

    if ( rePos.normalizedY != vp.rePos.normalizedY )
        return rePos.normalizedY < vp.rePos.normalizedY;

    return rePos.normalizedX < vp.rePos.normalizedX;
}


/** DocumentInfo **/

DocumentInfo::DocumentInfo() : d(new DocumentInfoPrivate())
{
}

DocumentInfo::DocumentInfo(const DocumentInfo &info) : d(new DocumentInfoPrivate())
{
    *this = info;
}

DocumentInfo& DocumentInfo::operator=(const DocumentInfo &info)
{
    d->values = info.d->values;
    d->titles = info.d->titles;
    return *this;
}

DocumentInfo::~DocumentInfo()
{
    delete d;
}

void DocumentInfo::set( const QString &key, const QString &value, const QString &title )
{
    d->values[ key ] = value;
    d->titles[ key ] = title;
}

void DocumentInfo::set( Key key, const QString &value )
{
    d->values[ getKeyString( key ) ] = value;
}

QStringList DocumentInfo::keys() const
{
    return d->values.keys();
}

QString DocumentInfo::get( Key key ) const
{
    return get( getKeyString( key ) );
}

QString DocumentInfo::get( const QString &key ) const
{
    return d->values[ key ];
}

QString DocumentInfo::getKeyString( Key key ) //const
{
    switch ( key ) {
        case Title:
            return QStringLiteral(""title"");
            break;
        case Subject:
            return QStringLiteral(""subject"");
            break;
        case Description:
            return QStringLiteral(""description"");
            break;
        case Author:
            return QStringLiteral(""author"");
            break;
        case Creator:
            return QStringLiteral(""creator"");
            break;
        case Producer:
            return QStringLiteral(""producer"");
            break;
        case Copyright:
            return QStringLiteral(""copyright"");
            break;
        case Pages:
            return QStringLiteral(""pages"");
            break;
        case CreationDate:
            return QStringLiteral(""creationDate"");
            break;
        case ModificationDate:
            return QStringLiteral(""modificationDate"");
            break;
        case MimeType:
            return QStringLiteral(""mimeType"");
            break;
        case Category:
            return QStringLiteral(""category"");
            break;
        case Keywords:
            return QStringLiteral(""keywords"");
            break;
        case FilePath:
            return QStringLiteral(""filePath"");
            break;
        case DocumentSize:
            return QStringLiteral(""documentSize"");
            break;
        case PagesSize:
            return QStringLiteral(""pageSize"");
            break;
        default:
            qCWarning(OkularCoreDebug) << ""Unknown"" << key;
            return QString();
            break;
    }
}

DocumentInfo::Key DocumentInfo::getKeyFromString( const QString &key ) //const
{
    if (key == QLatin1String(""title"")) return Title;
    else if (key == QLatin1String(""subject"")) return Subject;
    else if (key == QLatin1String(""description"")) return Description;
    else if (key == QLatin1String(""author"")) return Author;
    else if (key == QLatin1String(""creator"")) return Creator;
    else if (key == QLatin1String(""producer"")) return Producer;
    else if (key == QLatin1String(""copyright"")) return Copyright;
    else if (key == QLatin1String(""pages"")) return Pages;
    else if (key == QLatin1String(""creationDate"")) return CreationDate;
    else if (key == QLatin1String(""modificationDate"")) return ModificationDate;
    else if (key == QLatin1String(""mimeType"")) return MimeType;
    else if (key == QLatin1String(""category"")) return Category;
    else if (key == QLatin1String(""keywords"")) return Keywords;
    else if (key == QLatin1String(""filePath"")) return FilePath;
    else if (key == QLatin1String(""documentSize"")) return DocumentSize;
    else if (key == QLatin1String(""pageSize"")) return PagesSize;
    else return Invalid;
}

QString DocumentInfo::getKeyTitle( Key key ) //const
{
    switch ( key ) {
        case Title:
            return i18n( ""Title"" );
            break;
        case Subject:
            return i18n( ""Subject"" );
            break;
        case Description:
            return i18n( ""Description"" );
            break;
        case Author:
            return i18n( ""Author"" );
            break;
        case Creator:
            return i18n( ""Creator"" );
            break;
        case Producer:
            return i18n( ""Producer"" );
            break;
        case Copyright:
            return i18n( ""Copyright"" );
            break;
        case Pages:
            return i18n( ""Pages"" );
            break;
        case CreationDate:
            return i18n( ""Created"" );
            break;
        case ModificationDate:
            return i18n( ""Modified"" );
            break;
        case MimeType:
            return i18n( ""Mime Type"" );
            break;
        case Category:
            return i18n( ""Category"" );
            break;
        case Keywords:
            return i18n( ""Keywords"" );
            break;
        case FilePath:
            return i18n( ""File Path"" );
            break;
        case DocumentSize:
            return i18n( ""File Size"" );
            break;
        case PagesSize:
            return i18n(""Page Size"");
            break;
        default:
            return QString();
            break;
    }
}

QString DocumentInfo::getKeyTitle( const QString &key ) const
{
    QString title = getKeyTitle ( getKeyFromString( key ) );
    if ( title.isEmpty() )
        title = d->titles[ key ];
    return title;
}



/** DocumentSynopsis **/

DocumentSynopsis::DocumentSynopsis()
  : QDomDocument( QStringLiteral(""DocumentSynopsis"") )
{
    // void implementation, only subclassed for naming
}

DocumentSynopsis::DocumentSynopsis( const QDomDocument &document )
  : QDomDocument( document )
{
}

/** EmbeddedFile **/

EmbeddedFile::EmbeddedFile()
{
}

EmbeddedFile::~EmbeddedFile()
{
}

VisiblePageRect::VisiblePageRect( int page, const NormalizedRect &rectangle )
    : pageNumber( page ), rect( rectangle )
{
}

#undef foreachObserver
#undef foreachObserverD

#include ""moc_document.cpp""

/* kate: replace-tabs on; indent-width 4; */
"
CVE-2013-6712,https://www.cvedetails.com/cve/CVE-2013-6712/,CWE-119,,DoS Overflow,2013-11-27,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The scan function in ext/date/lib/parse_iso_intervals.c in PHP through 5.5.6 does not properly restrict creation of DateInterval objects, which might allow remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted interval specification.",C,php,https://git.php.net/?p=php-src.git;a=commit;h=12fe4e90be7bfa2a763197079f68f5568a14e071,12fe4e90be7bfa2a763197079f68f5568a14e071,63f3ff7b5f89f50eb9df76c3d0860c04cc6e0f66,"@@ -1,4 +1,4 @@
-/* Generated by re2c 0.13.5 on Mon Dec  5 22:02:27 2011 */
+/* Generated by re2c 0.13.5 on Wed Nov 27 11:10:58 2013 */
 #line 1 ""ext/date/lib/parse_iso_intervals.re""
 /*
    +----------------------------------------------------------------------+
@@ -415,7 +415,7 @@ yy6:
                                        break;
                        }
                        ptr++;
-               } while (*ptr);
+               } while (!s->errors->error_count && *ptr);
                s->have_period = 1;
                TIMELIB_DEINIT;
                return TIMELIB_PERIOD;",https://git.php.net/?p=php-src.git;a=blob;f=ext/date/lib/parse_iso_intervals.c;h=bd1ad05ddd4e6d61c72b513bde3318b016b70b3b;hb=bd1ad05ddd4e6d61c72b513bde3318b016b70b3b,https://git.php.net/?p=php-src.git;a=blob;f=ext/date/lib/parse_iso_intervals.c;h=480ea38d9174657085c333c135d8a7993b40f2a3;hb=480ea38d9174657085c333c135d8a7993b40f2a3," /* Generated by re2c 0.13.5 on Mon Dec  5 22:02:27 2011 */
 #line 1 ""ext/date/lib/parse_iso_intervals.re""
 /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
    | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
    | available through the world-wide-web at the following url:           |
    | http://www.php.net/license/3_01.txt                                  |
    | If you did not receive a copy of the PHP license and are unable to   |
    | obtain it through the world-wide-web, please send a note to          |
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Authors: Derick Rethans <derick@derickrethans.nl>                    |
    +----------------------------------------------------------------------+
  */
 
 /* $Id$ */
 
 #include ""timelib.h""
 
 #include <stdio.h>
 #include <ctype.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #if defined(_MSC_VER)
 # define strtoll(s, f, b) _atoi64(s)
 #elif !defined(HAVE_STRTOLL)
 # if defined(HAVE_ATOLL)
 #  define strtoll(s, f, b) atoll(s)
 # else
 #  define strtoll(s, f, b) strtol(s, f, b)
 # endif
 #endif
 
 #define TIMELIB_UNSET   -99999
 
 #define TIMELIB_SECOND  1
 #define TIMELIB_MINUTE  2
 #define TIMELIB_HOUR    3
 #define TIMELIB_DAY     4
 #define TIMELIB_MONTH   5
 #define TIMELIB_YEAR    6
 
 #define EOI      257
 
 #define TIMELIB_PERIOD  260
 #define TIMELIB_ISO_DATE 261
 #define TIMELIB_ERROR   999
 
 typedef unsigned char uchar;
 
 #define   BSIZE    8192
 
 #define   YYCTYPE      uchar
 #define   YYCURSOR     cursor
 #define   YYLIMIT      s->lim
 #define   YYMARKER     s->ptr
 #define   YYFILL(n)    return EOI;
 
 #define   RET(i)       {s->cur = cursor; return i;}
 
 #define timelib_string_free free
 
 #define TIMELIB_INIT  s->cur = cursor; str = timelib_string(s); ptr = str
 #define TIMELIB_DEINIT timelib_string_free(str)
 
 #ifdef DEBUG_PARSER
 #define DEBUG_OUTPUT(s) printf(""%s\n"", s);
 #define YYDEBUG(s,c) { if (s != -1) { printf(""state: %d "", s); printf(""[%c]\n"", c); } }
 #else
 #define DEBUG_OUTPUT(s)
 #define YYDEBUG(s,c)
 #endif
 
 #include ""timelib_structs.h""
 
 typedef struct Scanner {
         int           fd;
         uchar        *lim, *str, *ptr, *cur, *tok, *pos;
         unsigned int  line, len;
         struct timelib_error_container *errors;
 
         struct timelib_time     *begin;
         struct timelib_time     *end;
         struct timelib_rel_time *period;
         int                      recurrences;
 
         int have_period;
         int have_recurrences;
         int have_date;
         int have_begin_date;
         int have_end_date;
 } Scanner;
 
 #define HOUR(a) (int)(a * 60)
 
 static void add_warning(Scanner *s, char *error)
 {
         s->errors->warning_count++;
         s->errors->warning_messages = realloc(s->errors->warning_messages, s->errors->warning_count * sizeof(timelib_error_message));
         s->errors->warning_messages[s->errors->warning_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].message = strdup(error);
 }
 
 static void add_error(Scanner *s, char *error)
 {
         s->errors->error_count++;
         s->errors->error_messages = realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));
         s->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->error_messages[s->errors->error_count - 1].message = strdup(error);
 }
 
 static char *timelib_string(Scanner *s)
 {
         char *tmp = calloc(1, s->cur - s->tok + 1);
         memcpy(tmp, s->tok, s->cur - s->tok);
 
         return tmp;
 }
 
 static timelib_sll timelib_get_nr(char **ptr, int max_length)
 {
         char *begin, *end, *str;
         timelib_sll tmp_nr = TIMELIB_UNSET;
         int len = 0;
 
         while ((**ptr < '0') || (**ptr > '9')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
         begin = *ptr;
         while ((**ptr >= '0') && (**ptr <= '9') && len < max_length) {
                 ++*ptr;
                 ++len;
         }
         end = *ptr;
         str = calloc(1, end - begin + 1);
         memcpy(str, begin, end - begin);
         tmp_nr = strtoll(str, NULL, 10);
         free(str);
         return tmp_nr;
 }
 
 static timelib_ull timelib_get_unsigned_nr(char **ptr, int max_length)
 {
         timelib_ull dir = 1;
 
         while (((**ptr < '0') || (**ptr > '9')) && (**ptr != '+') && (**ptr != '-')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
 
         while (**ptr == '+' || **ptr == '-')
         {
                 if (**ptr == '-') {
                         dir *= -1;
                 }
                 ++*ptr;
         }
         return dir * timelib_get_nr(ptr, max_length);
 }
 
 static long timelib_parse_tz_cor(char **ptr)
 {
         char *begin = *ptr, *end;
         long  tmp;
 
         while (isdigit(**ptr) || **ptr == ':') {
                 ++*ptr;
         }
         end = *ptr;
         switch (end - begin) {
                 case 1:
                 case 2:
                         return HOUR(strtol(begin, NULL, 10));
                         break;
                 case 3:
                 case 4:
                         if (begin[1] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 2, NULL, 10);
                                 return tmp;
                         } else if (begin[2] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                                 return tmp;
                         } else {
                                 tmp = strtol(begin, NULL, 10);
                                 return HOUR(tmp / 100) + tmp % 100;
                         }
                 case 5:
                         tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                         return tmp;
         }
         return 0;
 }
 
 static void timelib_eat_spaces(char **ptr)
 {
         while (**ptr == ' ' || **ptr == '\t') {
                 ++*ptr;
         }
 }
 
 static void timelib_eat_until_separator(char **ptr)
 {
         while (strchr("" \t.,:;/-0123456789"", **ptr) == NULL) {
                 ++*ptr;
         }
 }
 
 static long timelib_get_zone(char **ptr, int *dst, timelib_time *t, int *tz_not_found, const timelib_tzdb *tzdb)
 {
         long retval = 0;
 
         *tz_not_found = 0;
 
         while (**ptr == ' ' || **ptr == '\t' || **ptr == '(') {
                 ++*ptr;
         }
         if ((*ptr)[0] == 'G' && (*ptr)[1] == 'M' && (*ptr)[2] == 'T' && ((*ptr)[3] == '+' || (*ptr)[3] == '-')) {
                 *ptr += 3;
         }
         if (**ptr == '+') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = -1 * timelib_parse_tz_cor(ptr);
         } else if (**ptr == '-') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = timelib_parse_tz_cor(ptr);
         }
         while (**ptr == ')') {
                 ++*ptr;
         }
         return retval;
 }
 
 #define timelib_split_free(arg) {       \
         int i;                         \
         for (i = 0; i < arg.c; i++) {  \
                 free(arg.v[i]);            \
         }                              \
         if (arg.v) {                   \
                 free(arg.v);               \
         }                              \
 }
 
 /* date parser's scan function too large for VC6 - VC7.x
    drop the optimization solves the problem */
 #ifdef PHP_WIN32
 #pragma optimize( """", off )
 #endif
 static int scan(Scanner *s)
 {
         uchar *cursor = s->cur;
         char *str, *ptr = NULL;
                 
 std:
         s->tok = cursor;
         s->len = 0;
 #line 311 ""ext/date/lib/parse_iso_intervals.re""
 
 
 
 #line 291 ""ext/date/lib/parse_iso_intervals.c""
 {
         YYCTYPE yych;
         unsigned int yyaccept = 0;
         static const unsigned char yybm[] = {
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                 128, 128, 128, 128, 128, 128, 128, 128, 
                 128, 128,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
         };
 
         YYDEBUG(0, *YYCURSOR);
         if ((YYLIMIT - YYCURSOR) < 20) YYFILL(20);
         yych = *YYCURSOR;
         if (yych <= ',') {
                 if (yych <= '\n') {
                         if (yych <= 0x00) goto yy9;
                         if (yych <= 0x08) goto yy11;
                         if (yych <= '\t') goto yy7;
                         goto yy9;
                 } else {
                         if (yych == ' ') goto yy7;
                         if (yych <= '+') goto yy11;
                         goto yy7;
                 }
         } else {
                 if (yych <= 'O') {
                         if (yych <= '-') goto yy11;
                         if (yych <= '/') goto yy7;
                         if (yych <= '9') goto yy4;
                         goto yy11;
                 } else {
                         if (yych <= 'P') goto yy5;
                         if (yych != 'R') goto yy11;
                 }
         }
         YYDEBUG(2, *YYCURSOR);
         ++YYCURSOR;
         if ((yych = *YYCURSOR) <= '/') goto yy3;
         if (yych <= '9') goto yy98;
 yy3:
         YYDEBUG(3, *YYCURSOR);
 #line 424 ""ext/date/lib/parse_iso_intervals.re""
         {
                 add_error(s, ""Unexpected character"");
                 goto std;
         }
 #line 366 ""ext/date/lib/parse_iso_intervals.c""
 yy4:
         YYDEBUG(4, *YYCURSOR);
         yyaccept = 0;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy3;
         if (yych <= '9') goto yy59;
         goto yy3;
 yy5:
         YYDEBUG(5, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy12;
         if (yych == 'T') goto yy14;
 yy6:
         YYDEBUG(6, *YYCURSOR);
 #line 351 ""ext/date/lib/parse_iso_intervals.re""
         {
                 timelib_sll nr;
                 int         in_time = 0;
                 DEBUG_OUTPUT(""period"");
                 TIMELIB_INIT;
                 ptr++;
                 do {
                         if ( *ptr == 'T' ) {
                                 in_time = 1;
                                 ptr++;
                         }
                         if ( *ptr == '\0' ) {
                                 add_error(s, ""Missing expected time part"");
                                 break;
                         }
 
                         nr = timelib_get_unsigned_nr((char **) &ptr, 12);
                         switch (*ptr) {
                                 case 'Y': s->period->y = nr; break;
                                 case 'W': s->period->d = nr * 7; break;
                                 case 'D': s->period->d = nr; break;
                                 case 'H': s->period->h = nr; break;
                                 case 'S': s->period->s = nr; break;
                                 case 'M': 
                                         if (in_time) {
                                                 s->period->i = nr;
                                         } else {
                                                 s->period->m = nr; 
                                         }
                                         break;
                                 default:
                                         add_error(s, ""Undefined period specifier"");
                                         break;
                         }
                         ptr++;
                 } while (*ptr);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 #line 424 ""ext/date/lib/parse_iso_intervals.c""
 yy7:
         YYDEBUG(7, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(8, *YYCURSOR);
 #line 413 ""ext/date/lib/parse_iso_intervals.re""
         {
                 goto std;
         }
 #line 433 ""ext/date/lib/parse_iso_intervals.c""
 yy9:
         YYDEBUG(9, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(10, *YYCURSOR);
 #line 418 ""ext/date/lib/parse_iso_intervals.re""
         {
                 s->pos = cursor; s->line++;
                 goto std;
         }
 #line 443 ""ext/date/lib/parse_iso_intervals.c""
 yy11:
         YYDEBUG(11, *YYCURSOR);
         yych = *++YYCURSOR;
         goto yy3;
 yy12:
         YYDEBUG(12, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych >= '0') goto yy25;
                 } else {
                         if (yych == 'D') goto yy24;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych >= 'W') goto yy26;
                 } else {
                         if (yych == 'Y') goto yy28;
                 }
         }
 yy13:
         YYDEBUG(13, *YYCURSOR);
         YYCURSOR = YYMARKER;
         if (yyaccept <= 0) {
                 goto yy3;
         } else {
                 goto yy6;
         }
 yy14:
         YYDEBUG(14, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yybm[0+yych] & 128) {
                 goto yy15;
         }
         goto yy6;
 yy15:
         YYDEBUG(15, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
         yych = *YYCURSOR;
         YYDEBUG(16, *YYCURSOR);
         if (yybm[0+yych] & 128) {
                 goto yy15;
         }
         if (yych <= 'L') {
                 if (yych == 'H') goto yy19;
                 goto yy13;
         } else {
                 if (yych <= 'M') goto yy18;
                 if (yych != 'S') goto yy13;
         }
 yy17:
         YYDEBUG(17, *YYCURSOR);
         yych = *++YYCURSOR;
         goto yy6;
 yy18:
         YYDEBUG(18, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy22;
         goto yy6;
 yy19:
         YYDEBUG(19, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych >= ':') goto yy6;
 yy20:
         YYDEBUG(20, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
         yych = *YYCURSOR;
         YYDEBUG(21, *YYCURSOR);
         if (yych <= 'L') {
                 if (yych <= '/') goto yy13;
                 if (yych <= '9') goto yy20;
                 goto yy13;
         } else {
                 if (yych <= 'M') goto yy18;
                 if (yych == 'S') goto yy17;
                 goto yy13;
         }
 yy22:
         YYDEBUG(22, *YYCURSOR);
         ++YYCURSOR;
         if (YYLIMIT <= YYCURSOR) YYFILL(1);
         yych = *YYCURSOR;
         YYDEBUG(23, *YYCURSOR);
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy22;
         if (yych == 'S') goto yy17;
         goto yy13;
 yy24:
         YYDEBUG(24, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy25:
         YYDEBUG(25, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych <= '/') goto yy13;
                         goto yy35;
                 } else {
                         if (yych == 'D') goto yy24;
                         goto yy13;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych <= 'V') goto yy13;
                 } else {
                         if (yych == 'Y') goto yy28;
                         goto yy13;
                 }
         }
 yy26:
         YYDEBUG(26, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy33;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy27:
         YYDEBUG(27, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy31;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy28:
         YYDEBUG(28, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy29;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy29:
         YYDEBUG(29, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
         YYDEBUG(30, *YYCURSOR);
         if (yych <= 'D') {
                 if (yych <= '/') goto yy13;
                 if (yych <= '9') goto yy29;
                 if (yych <= 'C') goto yy13;
                 goto yy24;
         } else {
                 if (yych <= 'M') {
                         if (yych <= 'L') goto yy13;
                         goto yy27;
                 } else {
                         if (yych == 'W') goto yy26;
                         goto yy13;
                 }
         }
 yy31:
         YYDEBUG(31, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
         YYDEBUG(32, *YYCURSOR);
         if (yych <= 'C') {
                 if (yych <= '/') goto yy13;
                 if (yych <= '9') goto yy31;
                 goto yy13;
         } else {
                 if (yych <= 'D') goto yy24;
                 if (yych == 'W') goto yy26;
                 goto yy13;
         }
 yy33:
         YYDEBUG(33, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
         YYDEBUG(34, *YYCURSOR);
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy33;
         if (yych == 'D') goto yy24;
         goto yy13;
 yy35:
         YYDEBUG(35, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych <= '/') goto yy13;
                 } else {
                         if (yych == 'D') goto yy24;
                         goto yy13;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych <= 'V') goto yy13;
                         goto yy26;
                 } else {
                         if (yych == 'Y') goto yy28;
                         goto yy13;
                 }
         }
         YYDEBUG(36, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != '-') goto yy39;
         YYDEBUG(37, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy40;
         if (yych <= '1') goto yy41;
         goto yy13;
 yy38:
         YYDEBUG(38, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
 yy39:
         YYDEBUG(39, *YYCURSOR);
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych <= '/') goto yy13;
                         goto yy38;
                 } else {
                         if (yych == 'D') goto yy24;
                         goto yy13;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych <= 'V') goto yy13;
                         goto yy26;
                 } else {
                         if (yych == 'Y') goto yy28;
                         goto yy13;
                 }
         }
 yy40:
         YYDEBUG(40, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy42;
         goto yy13;
 yy41:
         YYDEBUG(41, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '3') goto yy13;
 yy42:
         YYDEBUG(42, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != '-') goto yy13;
         YYDEBUG(43, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy44;
         if (yych <= '2') goto yy45;
         if (yych <= '3') goto yy46;
         goto yy13;
 yy44:
         YYDEBUG(44, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy47;
         goto yy13;
 yy45:
         YYDEBUG(45, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy47;
         goto yy13;
 yy46:
         YYDEBUG(46, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '2') goto yy13;
 yy47:
         YYDEBUG(47, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'T') goto yy13;
         YYDEBUG(48, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '1') goto yy49;
         if (yych <= '2') goto yy50;
         goto yy13;
 yy49:
         YYDEBUG(49, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy51;
         goto yy13;
 yy50:
         YYDEBUG(50, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '5') goto yy13;
 yy51:
         YYDEBUG(51, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(52, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(53, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(54, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(55, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(56, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(57, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(58, *YYCURSOR);
 #line 393 ""ext/date/lib/parse_iso_intervals.re""
         {
                 DEBUG_OUTPUT(""combinedrep"");
                 TIMELIB_INIT;
                 s->period->y = timelib_get_unsigned_nr((char **) &ptr, 4);
                 ptr++;
                 s->period->m = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->d = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->h = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->i = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->s = timelib_get_unsigned_nr((char **) &ptr, 2);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 #line 792 ""ext/date/lib/parse_iso_intervals.c""
 yy59:
         YYDEBUG(59, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(60, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(61, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') {
                 if (yych == '-') goto yy64;
                 goto yy13;
         } else {
                 if (yych <= '0') goto yy62;
                 if (yych <= '1') goto yy63;
                 goto yy13;
         }
 yy62:
         YYDEBUG(62, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy85;
         goto yy13;
 yy63:
         YYDEBUG(63, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '2') goto yy85;
         goto yy13;
 yy64:
         YYDEBUG(64, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy65;
         if (yych <= '1') goto yy66;
         goto yy13;
 yy65:
         YYDEBUG(65, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy67;
         goto yy13;
 yy66:
         YYDEBUG(66, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '3') goto yy13;
 yy67:
         YYDEBUG(67, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != '-') goto yy13;
         YYDEBUG(68, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy69;
         if (yych <= '2') goto yy70;
         if (yych <= '3') goto yy71;
         goto yy13;
 yy69:
         YYDEBUG(69, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy72;
         goto yy13;
 yy70:
         YYDEBUG(70, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy72;
         goto yy13;
 yy71:
         YYDEBUG(71, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '2') goto yy13;
 yy72:
         YYDEBUG(72, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'T') goto yy13;
         YYDEBUG(73, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '1') goto yy74;
         if (yych <= '2') goto yy75;
         goto yy13;
 yy74:
         YYDEBUG(74, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy76;
         goto yy13;
 yy75:
         YYDEBUG(75, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '5') goto yy13;
 yy76:
         YYDEBUG(76, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(77, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(78, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(79, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(80, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(81, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(82, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'Z') goto yy13;
 yy83:
         YYDEBUG(83, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(84, *YYCURSOR);
 #line 327 ""ext/date/lib/parse_iso_intervals.re""
         {
                 timelib_time *current;
 
                 if (s->have_date || s->have_period) {
                         current = s->end;
                         s->have_end_date = 1;
                 } else {
                         current = s->begin;
                         s->have_begin_date = 1;
                 }
                 DEBUG_OUTPUT(""datetimebasic | datetimeextended"");
                 TIMELIB_INIT;
                 current->y = timelib_get_nr((char **) &ptr, 4);
                 current->m = timelib_get_nr((char **) &ptr, 2);
                 current->d = timelib_get_nr((char **) &ptr, 2);
                 current->h = timelib_get_nr((char **) &ptr, 2);
                 current->i = timelib_get_nr((char **) &ptr, 2);
                 current->s = timelib_get_nr((char **) &ptr, 2);
                 s->have_date = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_ISO_DATE;
         }
 #line 944 ""ext/date/lib/parse_iso_intervals.c""
 yy85:
         YYDEBUG(85, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy86;
         if (yych <= '2') goto yy87;
         if (yych <= '3') goto yy88;
         goto yy13;
 yy86:
         YYDEBUG(86, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy89;
         goto yy13;
 yy87:
         YYDEBUG(87, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy89;
         goto yy13;
 yy88:
         YYDEBUG(88, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '2') goto yy13;
 yy89:
         YYDEBUG(89, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'T') goto yy13;
         YYDEBUG(90, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '1') goto yy91;
         if (yych <= '2') goto yy92;
         goto yy13;
 yy91:
         YYDEBUG(91, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy93;
         goto yy13;
 yy92:
         YYDEBUG(92, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '5') goto yy13;
 yy93:
         YYDEBUG(93, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(94, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(95, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(96, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(97, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych == 'Z') goto yy83;
         goto yy13;
 yy98:
         YYDEBUG(98, *YYCURSOR);
         ++YYCURSOR;
         if (YYLIMIT <= YYCURSOR) YYFILL(1);
         yych = *YYCURSOR;
         YYDEBUG(99, *YYCURSOR);
         if (yych <= '/') goto yy100;
         if (yych <= '9') goto yy98;
 yy100:
         YYDEBUG(100, *YYCURSOR);
 #line 316 ""ext/date/lib/parse_iso_intervals.re""
         {
                 DEBUG_OUTPUT(""recurrences"");
                 TIMELIB_INIT;
                 ptr++;
                 s->recurrences = timelib_get_unsigned_nr((char **) &ptr, 9);
                 TIMELIB_DEINIT;
                 s->have_recurrences = 1;
                 return TIMELIB_PERIOD;
         }
 #line 1032 ""ext/date/lib/parse_iso_intervals.c""
 }
 #line 428 ""ext/date/lib/parse_iso_intervals.re""
 
 }
 #ifdef PHP_WIN32
 #pragma optimize( """", on )
 #endif
 
 #define YYMAXFILL 20
 
 void timelib_strtointerval(char *s, int len, 
                            timelib_time **begin, timelib_time **end, 
                                                    timelib_rel_time **period, int *recurrences, 
                                                    struct timelib_error_container **errors)
 {
         Scanner in;
         int t;
         char *e = s + len - 1;
 
         memset(&in, 0, sizeof(in));
         in.errors = malloc(sizeof(struct timelib_error_container));
         in.errors->warning_count = 0;
         in.errors->warning_messages = NULL;
         in.errors->error_count = 0;
         in.errors->error_messages = NULL;
 
         if (len > 0) {
                 while (isspace(*s) && s < e) {
                         s++;
                 }
                 while (isspace(*e) && e > s) {
                         e--;
                 }
         }
         if (e - s < 0) {
                 add_error(&in, ""Empty string"");
                 if (errors) {
                         *errors = in.errors;
                 } else {
                         timelib_error_container_dtor(in.errors);
                 }
                 return;
         }
         e++;
 
         /* init cursor */
         in.str = malloc((e - s) + YYMAXFILL);
         memset(in.str, 0, (e - s) + YYMAXFILL);
         memcpy(in.str, s, (e - s));
         in.lim = in.str + (e - s) + YYMAXFILL;
         in.cur = in.str;
 
         /* init value containers */
         in.begin = timelib_time_ctor();
         in.begin->y = TIMELIB_UNSET;
         in.begin->d = TIMELIB_UNSET;
         in.begin->m = TIMELIB_UNSET;
         in.begin->h = TIMELIB_UNSET;
         in.begin->i = TIMELIB_UNSET;
         in.begin->s = TIMELIB_UNSET;
         in.begin->f = 0;
         in.begin->z = 0;
         in.begin->dst = 0;
         in.begin->is_localtime = 0;
         in.begin->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.end = timelib_time_ctor();
         in.end->y = TIMELIB_UNSET;
         in.end->d = TIMELIB_UNSET;
         in.end->m = TIMELIB_UNSET;
         in.end->h = TIMELIB_UNSET;
         in.end->i = TIMELIB_UNSET;
         in.end->s = TIMELIB_UNSET;
         in.end->f = 0;
         in.end->z = 0;
         in.end->dst = 0;
         in.end->is_localtime = 0;
         in.end->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.period = timelib_rel_time_ctor();
         in.period->y = 0;
         in.period->d = 0;
         in.period->m = 0;
         in.period->h = 0;
         in.period->i = 0;
         in.period->s = 0;
         in.period->weekday = 0;
         in.period->weekday_behavior = 0;
         in.period->first_last_day_of = 0;
         in.period->days = TIMELIB_UNSET;
 
         in.recurrences = 1;
 
         do {
                 t = scan(&in);
 #ifdef DEBUG_PARSER
                 printf(""%d\n"", t);
 #endif
         } while(t != EOI);
 
         free(in.str);
         if (errors) {
                 *errors = in.errors;
         } else {
                 timelib_error_container_dtor(in.errors);
         }
         if (in.have_begin_date) {
                 *begin = in.begin;
         } else {
                 timelib_time_dtor(in.begin);
         }
         if (in.have_end_date) {
                 *end   = in.end;
         } else {
                 timelib_time_dtor(in.end);
         }
         if (in.have_period) {
                 *period = in.period;
         } else {
                 timelib_rel_time_dtor(in.period);
         }
         if (in.have_recurrences) {
                 *recurrences = in.recurrences;
         }
 }
 
 
 /*
  * vim: syntax=c
  */
"," /* Generated by re2c 0.13.5 on Wed Nov 27 11:10:58 2013 */
 #line 1 ""ext/date/lib/parse_iso_intervals.re""
 /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
    | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
    | available through the world-wide-web at the following url:           |
    | http://www.php.net/license/3_01.txt                                  |
    | If you did not receive a copy of the PHP license and are unable to   |
    | obtain it through the world-wide-web, please send a note to          |
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Authors: Derick Rethans <derick@derickrethans.nl>                    |
    +----------------------------------------------------------------------+
  */
 
 /* $Id$ */
 
 #include ""timelib.h""
 
 #include <stdio.h>
 #include <ctype.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #if defined(_MSC_VER)
 # define strtoll(s, f, b) _atoi64(s)
 #elif !defined(HAVE_STRTOLL)
 # if defined(HAVE_ATOLL)
 #  define strtoll(s, f, b) atoll(s)
 # else
 #  define strtoll(s, f, b) strtol(s, f, b)
 # endif
 #endif
 
 #define TIMELIB_UNSET   -99999
 
 #define TIMELIB_SECOND  1
 #define TIMELIB_MINUTE  2
 #define TIMELIB_HOUR    3
 #define TIMELIB_DAY     4
 #define TIMELIB_MONTH   5
 #define TIMELIB_YEAR    6
 
 #define EOI      257
 
 #define TIMELIB_PERIOD  260
 #define TIMELIB_ISO_DATE 261
 #define TIMELIB_ERROR   999
 
 typedef unsigned char uchar;
 
 #define   BSIZE    8192
 
 #define   YYCTYPE      uchar
 #define   YYCURSOR     cursor
 #define   YYLIMIT      s->lim
 #define   YYMARKER     s->ptr
 #define   YYFILL(n)    return EOI;
 
 #define   RET(i)       {s->cur = cursor; return i;}
 
 #define timelib_string_free free
 
 #define TIMELIB_INIT  s->cur = cursor; str = timelib_string(s); ptr = str
 #define TIMELIB_DEINIT timelib_string_free(str)
 
 #ifdef DEBUG_PARSER
 #define DEBUG_OUTPUT(s) printf(""%s\n"", s);
 #define YYDEBUG(s,c) { if (s != -1) { printf(""state: %d "", s); printf(""[%c]\n"", c); } }
 #else
 #define DEBUG_OUTPUT(s)
 #define YYDEBUG(s,c)
 #endif
 
 #include ""timelib_structs.h""
 
 typedef struct Scanner {
         int           fd;
         uchar        *lim, *str, *ptr, *cur, *tok, *pos;
         unsigned int  line, len;
         struct timelib_error_container *errors;
 
         struct timelib_time     *begin;
         struct timelib_time     *end;
         struct timelib_rel_time *period;
         int                      recurrences;
 
         int have_period;
         int have_recurrences;
         int have_date;
         int have_begin_date;
         int have_end_date;
 } Scanner;
 
 #define HOUR(a) (int)(a * 60)
 
 static void add_warning(Scanner *s, char *error)
 {
         s->errors->warning_count++;
         s->errors->warning_messages = realloc(s->errors->warning_messages, s->errors->warning_count * sizeof(timelib_error_message));
         s->errors->warning_messages[s->errors->warning_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].message = strdup(error);
 }
 
 static void add_error(Scanner *s, char *error)
 {
         s->errors->error_count++;
         s->errors->error_messages = realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));
         s->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->error_messages[s->errors->error_count - 1].message = strdup(error);
 }
 
 static char *timelib_string(Scanner *s)
 {
         char *tmp = calloc(1, s->cur - s->tok + 1);
         memcpy(tmp, s->tok, s->cur - s->tok);
 
         return tmp;
 }
 
 static timelib_sll timelib_get_nr(char **ptr, int max_length)
 {
         char *begin, *end, *str;
         timelib_sll tmp_nr = TIMELIB_UNSET;
         int len = 0;
 
         while ((**ptr < '0') || (**ptr > '9')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
         begin = *ptr;
         while ((**ptr >= '0') && (**ptr <= '9') && len < max_length) {
                 ++*ptr;
                 ++len;
         }
         end = *ptr;
         str = calloc(1, end - begin + 1);
         memcpy(str, begin, end - begin);
         tmp_nr = strtoll(str, NULL, 10);
         free(str);
         return tmp_nr;
 }
 
 static timelib_ull timelib_get_unsigned_nr(char **ptr, int max_length)
 {
         timelib_ull dir = 1;
 
         while (((**ptr < '0') || (**ptr > '9')) && (**ptr != '+') && (**ptr != '-')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
 
         while (**ptr == '+' || **ptr == '-')
         {
                 if (**ptr == '-') {
                         dir *= -1;
                 }
                 ++*ptr;
         }
         return dir * timelib_get_nr(ptr, max_length);
 }
 
 static long timelib_parse_tz_cor(char **ptr)
 {
         char *begin = *ptr, *end;
         long  tmp;
 
         while (isdigit(**ptr) || **ptr == ':') {
                 ++*ptr;
         }
         end = *ptr;
         switch (end - begin) {
                 case 1:
                 case 2:
                         return HOUR(strtol(begin, NULL, 10));
                         break;
                 case 3:
                 case 4:
                         if (begin[1] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 2, NULL, 10);
                                 return tmp;
                         } else if (begin[2] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                                 return tmp;
                         } else {
                                 tmp = strtol(begin, NULL, 10);
                                 return HOUR(tmp / 100) + tmp % 100;
                         }
                 case 5:
                         tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                         return tmp;
         }
         return 0;
 }
 
 static void timelib_eat_spaces(char **ptr)
 {
         while (**ptr == ' ' || **ptr == '\t') {
                 ++*ptr;
         }
 }
 
 static void timelib_eat_until_separator(char **ptr)
 {
         while (strchr("" \t.,:;/-0123456789"", **ptr) == NULL) {
                 ++*ptr;
         }
 }
 
 static long timelib_get_zone(char **ptr, int *dst, timelib_time *t, int *tz_not_found, const timelib_tzdb *tzdb)
 {
         long retval = 0;
 
         *tz_not_found = 0;
 
         while (**ptr == ' ' || **ptr == '\t' || **ptr == '(') {
                 ++*ptr;
         }
         if ((*ptr)[0] == 'G' && (*ptr)[1] == 'M' && (*ptr)[2] == 'T' && ((*ptr)[3] == '+' || (*ptr)[3] == '-')) {
                 *ptr += 3;
         }
         if (**ptr == '+') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = -1 * timelib_parse_tz_cor(ptr);
         } else if (**ptr == '-') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = timelib_parse_tz_cor(ptr);
         }
         while (**ptr == ')') {
                 ++*ptr;
         }
         return retval;
 }
 
 #define timelib_split_free(arg) {       \
         int i;                         \
         for (i = 0; i < arg.c; i++) {  \
                 free(arg.v[i]);            \
         }                              \
         if (arg.v) {                   \
                 free(arg.v);               \
         }                              \
 }
 
 /* date parser's scan function too large for VC6 - VC7.x
    drop the optimization solves the problem */
 #ifdef PHP_WIN32
 #pragma optimize( """", off )
 #endif
 static int scan(Scanner *s)
 {
         uchar *cursor = s->cur;
         char *str, *ptr = NULL;
                 
 std:
         s->tok = cursor;
         s->len = 0;
 #line 311 ""ext/date/lib/parse_iso_intervals.re""
 
 
 
 #line 291 ""ext/date/lib/parse_iso_intervals.c""
 {
         YYCTYPE yych;
         unsigned int yyaccept = 0;
         static const unsigned char yybm[] = {
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                 128, 128, 128, 128, 128, 128, 128, 128, 
                 128, 128,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
                   0,   0,   0,   0,   0,   0,   0,   0, 
         };
 
         YYDEBUG(0, *YYCURSOR);
         if ((YYLIMIT - YYCURSOR) < 20) YYFILL(20);
         yych = *YYCURSOR;
         if (yych <= ',') {
                 if (yych <= '\n') {
                         if (yych <= 0x00) goto yy9;
                         if (yych <= 0x08) goto yy11;
                         if (yych <= '\t') goto yy7;
                         goto yy9;
                 } else {
                         if (yych == ' ') goto yy7;
                         if (yych <= '+') goto yy11;
                         goto yy7;
                 }
         } else {
                 if (yych <= 'O') {
                         if (yych <= '-') goto yy11;
                         if (yych <= '/') goto yy7;
                         if (yych <= '9') goto yy4;
                         goto yy11;
                 } else {
                         if (yych <= 'P') goto yy5;
                         if (yych != 'R') goto yy11;
                 }
         }
         YYDEBUG(2, *YYCURSOR);
         ++YYCURSOR;
         if ((yych = *YYCURSOR) <= '/') goto yy3;
         if (yych <= '9') goto yy98;
 yy3:
         YYDEBUG(3, *YYCURSOR);
 #line 424 ""ext/date/lib/parse_iso_intervals.re""
         {
                 add_error(s, ""Unexpected character"");
                 goto std;
         }
 #line 366 ""ext/date/lib/parse_iso_intervals.c""
 yy4:
         YYDEBUG(4, *YYCURSOR);
         yyaccept = 0;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy3;
         if (yych <= '9') goto yy59;
         goto yy3;
 yy5:
         YYDEBUG(5, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy12;
         if (yych == 'T') goto yy14;
 yy6:
         YYDEBUG(6, *YYCURSOR);
 #line 351 ""ext/date/lib/parse_iso_intervals.re""
         {
                 timelib_sll nr;
                 int         in_time = 0;
                 DEBUG_OUTPUT(""period"");
                 TIMELIB_INIT;
                 ptr++;
                 do {
                         if ( *ptr == 'T' ) {
                                 in_time = 1;
                                 ptr++;
                         }
                         if ( *ptr == '\0' ) {
                                 add_error(s, ""Missing expected time part"");
                                 break;
                         }
 
                         nr = timelib_get_unsigned_nr((char **) &ptr, 12);
                         switch (*ptr) {
                                 case 'Y': s->period->y = nr; break;
                                 case 'W': s->period->d = nr * 7; break;
                                 case 'D': s->period->d = nr; break;
                                 case 'H': s->period->h = nr; break;
                                 case 'S': s->period->s = nr; break;
                                 case 'M': 
                                         if (in_time) {
                                                 s->period->i = nr;
                                         } else {
                                                 s->period->m = nr; 
                                         }
                                         break;
                                 default:
                                         add_error(s, ""Undefined period specifier"");
                                         break;
                         }
                         ptr++;
                 } while (!s->errors->error_count && *ptr);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 #line 424 ""ext/date/lib/parse_iso_intervals.c""
 yy7:
         YYDEBUG(7, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(8, *YYCURSOR);
 #line 413 ""ext/date/lib/parse_iso_intervals.re""
         {
                 goto std;
         }
 #line 433 ""ext/date/lib/parse_iso_intervals.c""
 yy9:
         YYDEBUG(9, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(10, *YYCURSOR);
 #line 418 ""ext/date/lib/parse_iso_intervals.re""
         {
                 s->pos = cursor; s->line++;
                 goto std;
         }
 #line 443 ""ext/date/lib/parse_iso_intervals.c""
 yy11:
         YYDEBUG(11, *YYCURSOR);
         yych = *++YYCURSOR;
         goto yy3;
 yy12:
         YYDEBUG(12, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych >= '0') goto yy25;
                 } else {
                         if (yych == 'D') goto yy24;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych >= 'W') goto yy26;
                 } else {
                         if (yych == 'Y') goto yy28;
                 }
         }
 yy13:
         YYDEBUG(13, *YYCURSOR);
         YYCURSOR = YYMARKER;
         if (yyaccept <= 0) {
                 goto yy3;
         } else {
                 goto yy6;
         }
 yy14:
         YYDEBUG(14, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yybm[0+yych] & 128) {
                 goto yy15;
         }
         goto yy6;
 yy15:
         YYDEBUG(15, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
         yych = *YYCURSOR;
         YYDEBUG(16, *YYCURSOR);
         if (yybm[0+yych] & 128) {
                 goto yy15;
         }
         if (yych <= 'L') {
                 if (yych == 'H') goto yy19;
                 goto yy13;
         } else {
                 if (yych <= 'M') goto yy18;
                 if (yych != 'S') goto yy13;
         }
 yy17:
         YYDEBUG(17, *YYCURSOR);
         yych = *++YYCURSOR;
         goto yy6;
 yy18:
         YYDEBUG(18, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy22;
         goto yy6;
 yy19:
         YYDEBUG(19, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych >= ':') goto yy6;
 yy20:
         YYDEBUG(20, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
         yych = *YYCURSOR;
         YYDEBUG(21, *YYCURSOR);
         if (yych <= 'L') {
                 if (yych <= '/') goto yy13;
                 if (yych <= '9') goto yy20;
                 goto yy13;
         } else {
                 if (yych <= 'M') goto yy18;
                 if (yych == 'S') goto yy17;
                 goto yy13;
         }
 yy22:
         YYDEBUG(22, *YYCURSOR);
         ++YYCURSOR;
         if (YYLIMIT <= YYCURSOR) YYFILL(1);
         yych = *YYCURSOR;
         YYDEBUG(23, *YYCURSOR);
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy22;
         if (yych == 'S') goto yy17;
         goto yy13;
 yy24:
         YYDEBUG(24, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy25:
         YYDEBUG(25, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych <= '/') goto yy13;
                         goto yy35;
                 } else {
                         if (yych == 'D') goto yy24;
                         goto yy13;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych <= 'V') goto yy13;
                 } else {
                         if (yych == 'Y') goto yy28;
                         goto yy13;
                 }
         }
 yy26:
         YYDEBUG(26, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy33;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy27:
         YYDEBUG(27, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy31;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy28:
         YYDEBUG(28, *YYCURSOR);
         yyaccept = 1;
         yych = *(YYMARKER = ++YYCURSOR);
         if (yych <= '/') goto yy6;
         if (yych <= '9') goto yy29;
         if (yych == 'T') goto yy14;
         goto yy6;
 yy29:
         YYDEBUG(29, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
         YYDEBUG(30, *YYCURSOR);
         if (yych <= 'D') {
                 if (yych <= '/') goto yy13;
                 if (yych <= '9') goto yy29;
                 if (yych <= 'C') goto yy13;
                 goto yy24;
         } else {
                 if (yych <= 'M') {
                         if (yych <= 'L') goto yy13;
                         goto yy27;
                 } else {
                         if (yych == 'W') goto yy26;
                         goto yy13;
                 }
         }
 yy31:
         YYDEBUG(31, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
         YYDEBUG(32, *YYCURSOR);
         if (yych <= 'C') {
                 if (yych <= '/') goto yy13;
                 if (yych <= '9') goto yy31;
                 goto yy13;
         } else {
                 if (yych <= 'D') goto yy24;
                 if (yych == 'W') goto yy26;
                 goto yy13;
         }
 yy33:
         YYDEBUG(33, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
         YYDEBUG(34, *YYCURSOR);
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy33;
         if (yych == 'D') goto yy24;
         goto yy13;
 yy35:
         YYDEBUG(35, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych <= '/') goto yy13;
                 } else {
                         if (yych == 'D') goto yy24;
                         goto yy13;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych <= 'V') goto yy13;
                         goto yy26;
                 } else {
                         if (yych == 'Y') goto yy28;
                         goto yy13;
                 }
         }
         YYDEBUG(36, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != '-') goto yy39;
         YYDEBUG(37, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy40;
         if (yych <= '1') goto yy41;
         goto yy13;
 yy38:
         YYDEBUG(38, *YYCURSOR);
         ++YYCURSOR;
         if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
         yych = *YYCURSOR;
 yy39:
         YYDEBUG(39, *YYCURSOR);
         if (yych <= 'L') {
                 if (yych <= '9') {
                         if (yych <= '/') goto yy13;
                         goto yy38;
                 } else {
                         if (yych == 'D') goto yy24;
                         goto yy13;
                 }
         } else {
                 if (yych <= 'W') {
                         if (yych <= 'M') goto yy27;
                         if (yych <= 'V') goto yy13;
                         goto yy26;
                 } else {
                         if (yych == 'Y') goto yy28;
                         goto yy13;
                 }
         }
 yy40:
         YYDEBUG(40, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy42;
         goto yy13;
 yy41:
         YYDEBUG(41, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '3') goto yy13;
 yy42:
         YYDEBUG(42, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != '-') goto yy13;
         YYDEBUG(43, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy44;
         if (yych <= '2') goto yy45;
         if (yych <= '3') goto yy46;
         goto yy13;
 yy44:
         YYDEBUG(44, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy47;
         goto yy13;
 yy45:
         YYDEBUG(45, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy47;
         goto yy13;
 yy46:
         YYDEBUG(46, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '2') goto yy13;
 yy47:
         YYDEBUG(47, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'T') goto yy13;
         YYDEBUG(48, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '1') goto yy49;
         if (yych <= '2') goto yy50;
         goto yy13;
 yy49:
         YYDEBUG(49, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy51;
         goto yy13;
 yy50:
         YYDEBUG(50, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '5') goto yy13;
 yy51:
         YYDEBUG(51, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(52, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(53, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(54, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(55, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(56, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(57, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(58, *YYCURSOR);
 #line 393 ""ext/date/lib/parse_iso_intervals.re""
         {
                 DEBUG_OUTPUT(""combinedrep"");
                 TIMELIB_INIT;
                 s->period->y = timelib_get_unsigned_nr((char **) &ptr, 4);
                 ptr++;
                 s->period->m = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->d = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->h = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->i = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->s = timelib_get_unsigned_nr((char **) &ptr, 2);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 #line 792 ""ext/date/lib/parse_iso_intervals.c""
 yy59:
         YYDEBUG(59, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(60, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(61, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') {
                 if (yych == '-') goto yy64;
                 goto yy13;
         } else {
                 if (yych <= '0') goto yy62;
                 if (yych <= '1') goto yy63;
                 goto yy13;
         }
 yy62:
         YYDEBUG(62, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy85;
         goto yy13;
 yy63:
         YYDEBUG(63, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '2') goto yy85;
         goto yy13;
 yy64:
         YYDEBUG(64, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy65;
         if (yych <= '1') goto yy66;
         goto yy13;
 yy65:
         YYDEBUG(65, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy67;
         goto yy13;
 yy66:
         YYDEBUG(66, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '3') goto yy13;
 yy67:
         YYDEBUG(67, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != '-') goto yy13;
         YYDEBUG(68, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy69;
         if (yych <= '2') goto yy70;
         if (yych <= '3') goto yy71;
         goto yy13;
 yy69:
         YYDEBUG(69, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy72;
         goto yy13;
 yy70:
         YYDEBUG(70, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy72;
         goto yy13;
 yy71:
         YYDEBUG(71, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '2') goto yy13;
 yy72:
         YYDEBUG(72, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'T') goto yy13;
         YYDEBUG(73, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '1') goto yy74;
         if (yych <= '2') goto yy75;
         goto yy13;
 yy74:
         YYDEBUG(74, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy76;
         goto yy13;
 yy75:
         YYDEBUG(75, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '5') goto yy13;
 yy76:
         YYDEBUG(76, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(77, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(78, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(79, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != ':') goto yy13;
         YYDEBUG(80, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(81, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(82, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'Z') goto yy13;
 yy83:
         YYDEBUG(83, *YYCURSOR);
         ++YYCURSOR;
         YYDEBUG(84, *YYCURSOR);
 #line 327 ""ext/date/lib/parse_iso_intervals.re""
         {
                 timelib_time *current;
 
                 if (s->have_date || s->have_period) {
                         current = s->end;
                         s->have_end_date = 1;
                 } else {
                         current = s->begin;
                         s->have_begin_date = 1;
                 }
                 DEBUG_OUTPUT(""datetimebasic | datetimeextended"");
                 TIMELIB_INIT;
                 current->y = timelib_get_nr((char **) &ptr, 4);
                 current->m = timelib_get_nr((char **) &ptr, 2);
                 current->d = timelib_get_nr((char **) &ptr, 2);
                 current->h = timelib_get_nr((char **) &ptr, 2);
                 current->i = timelib_get_nr((char **) &ptr, 2);
                 current->s = timelib_get_nr((char **) &ptr, 2);
                 s->have_date = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_ISO_DATE;
         }
 #line 944 ""ext/date/lib/parse_iso_intervals.c""
 yy85:
         YYDEBUG(85, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '0') goto yy86;
         if (yych <= '2') goto yy87;
         if (yych <= '3') goto yy88;
         goto yy13;
 yy86:
         YYDEBUG(86, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '0') goto yy13;
         if (yych <= '9') goto yy89;
         goto yy13;
 yy87:
         YYDEBUG(87, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy89;
         goto yy13;
 yy88:
         YYDEBUG(88, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '2') goto yy13;
 yy89:
         YYDEBUG(89, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych != 'T') goto yy13;
         YYDEBUG(90, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '1') goto yy91;
         if (yych <= '2') goto yy92;
         goto yy13;
 yy91:
         YYDEBUG(91, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych <= '9') goto yy93;
         goto yy13;
 yy92:
         YYDEBUG(92, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '5') goto yy13;
 yy93:
         YYDEBUG(93, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(94, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(95, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= '6') goto yy13;
         YYDEBUG(96, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych <= '/') goto yy13;
         if (yych >= ':') goto yy13;
         YYDEBUG(97, *YYCURSOR);
         yych = *++YYCURSOR;
         if (yych == 'Z') goto yy83;
         goto yy13;
 yy98:
         YYDEBUG(98, *YYCURSOR);
         ++YYCURSOR;
         if (YYLIMIT <= YYCURSOR) YYFILL(1);
         yych = *YYCURSOR;
         YYDEBUG(99, *YYCURSOR);
         if (yych <= '/') goto yy100;
         if (yych <= '9') goto yy98;
 yy100:
         YYDEBUG(100, *YYCURSOR);
 #line 316 ""ext/date/lib/parse_iso_intervals.re""
         {
                 DEBUG_OUTPUT(""recurrences"");
                 TIMELIB_INIT;
                 ptr++;
                 s->recurrences = timelib_get_unsigned_nr((char **) &ptr, 9);
                 TIMELIB_DEINIT;
                 s->have_recurrences = 1;
                 return TIMELIB_PERIOD;
         }
 #line 1032 ""ext/date/lib/parse_iso_intervals.c""
 }
 #line 428 ""ext/date/lib/parse_iso_intervals.re""
 
 }
 #ifdef PHP_WIN32
 #pragma optimize( """", on )
 #endif
 
 #define YYMAXFILL 20
 
 void timelib_strtointerval(char *s, int len, 
                            timelib_time **begin, timelib_time **end, 
                                                    timelib_rel_time **period, int *recurrences, 
                                                    struct timelib_error_container **errors)
 {
         Scanner in;
         int t;
         char *e = s + len - 1;
 
         memset(&in, 0, sizeof(in));
         in.errors = malloc(sizeof(struct timelib_error_container));
         in.errors->warning_count = 0;
         in.errors->warning_messages = NULL;
         in.errors->error_count = 0;
         in.errors->error_messages = NULL;
 
         if (len > 0) {
                 while (isspace(*s) && s < e) {
                         s++;
                 }
                 while (isspace(*e) && e > s) {
                         e--;
                 }
         }
         if (e - s < 0) {
                 add_error(&in, ""Empty string"");
                 if (errors) {
                         *errors = in.errors;
                 } else {
                         timelib_error_container_dtor(in.errors);
                 }
                 return;
         }
         e++;
 
         /* init cursor */
         in.str = malloc((e - s) + YYMAXFILL);
         memset(in.str, 0, (e - s) + YYMAXFILL);
         memcpy(in.str, s, (e - s));
         in.lim = in.str + (e - s) + YYMAXFILL;
         in.cur = in.str;
 
         /* init value containers */
         in.begin = timelib_time_ctor();
         in.begin->y = TIMELIB_UNSET;
         in.begin->d = TIMELIB_UNSET;
         in.begin->m = TIMELIB_UNSET;
         in.begin->h = TIMELIB_UNSET;
         in.begin->i = TIMELIB_UNSET;
         in.begin->s = TIMELIB_UNSET;
         in.begin->f = 0;
         in.begin->z = 0;
         in.begin->dst = 0;
         in.begin->is_localtime = 0;
         in.begin->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.end = timelib_time_ctor();
         in.end->y = TIMELIB_UNSET;
         in.end->d = TIMELIB_UNSET;
         in.end->m = TIMELIB_UNSET;
         in.end->h = TIMELIB_UNSET;
         in.end->i = TIMELIB_UNSET;
         in.end->s = TIMELIB_UNSET;
         in.end->f = 0;
         in.end->z = 0;
         in.end->dst = 0;
         in.end->is_localtime = 0;
         in.end->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.period = timelib_rel_time_ctor();
         in.period->y = 0;
         in.period->d = 0;
         in.period->m = 0;
         in.period->h = 0;
         in.period->i = 0;
         in.period->s = 0;
         in.period->weekday = 0;
         in.period->weekday_behavior = 0;
         in.period->first_last_day_of = 0;
         in.period->days = TIMELIB_UNSET;
 
         in.recurrences = 1;
 
         do {
                 t = scan(&in);
 #ifdef DEBUG_PARSER
                 printf(""%d\n"", t);
 #endif
         } while(t != EOI);
 
         free(in.str);
         if (errors) {
                 *errors = in.errors;
         } else {
                 timelib_error_container_dtor(in.errors);
         }
         if (in.have_begin_date) {
                 *begin = in.begin;
         } else {
                 timelib_time_dtor(in.begin);
         }
         if (in.have_end_date) {
                 *end   = in.end;
         } else {
                 timelib_time_dtor(in.end);
         }
         if (in.have_period) {
                 *period = in.period;
         } else {
                 timelib_rel_time_dtor(in.period);
         }
         if (in.have_recurrences) {
                 *recurrences = in.recurrences;
         }
 }
 
 
 /*
  * vim: syntax=c
  */
"
CVE-2013-6712,https://www.cvedetails.com/cve/CVE-2013-6712/,CWE-119,,DoS Overflow,2013-11-27,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The scan function in ext/date/lib/parse_iso_intervals.c in PHP through 5.5.6 does not properly restrict creation of DateInterval objects, which might allow remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted interval specification.",Re,php,https://git.php.net/?p=php-src.git;a=commit;h=12fe4e90be7bfa2a763197079f68f5568a14e071,12fe4e90be7bfa2a763197079f68f5568a14e071,63f3ff7b5f89f50eb9df76c3d0860c04cc6e0f66,"@@ -383,7 +383,7 @@ isoweek          = year4 ""-""? ""W"" weekofyear;
                                        break;
                        }
                        ptr++;
-               } while (*ptr);
+               } while (!s->errors->error_count && *ptr);
                s->have_period = 1;
                TIMELIB_DEINIT;
                return TIMELIB_PERIOD;",https://git.php.net/?p=php-src.git;a=blob;f=ext/date/lib/parse_iso_intervals.re;h=56aa34d8e005e7ec36ec4471c3d7308cf2308a04;hb=56aa34d8e005e7ec36ec4471c3d7308cf2308a04,https://git.php.net/?p=php-src.git;a=blob;f=ext/date/lib/parse_iso_intervals.re;h=c5e9f677ba22431074f3948887ae8394b4949b94;hb=c5e9f677ba22431074f3948887ae8394b4949b94," /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
    | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
    | available through the world-wide-web at the following url:           |
    | http://www.php.net/license/3_01.txt                                  |
    | If you did not receive a copy of the PHP license and are unable to   |
    | obtain it through the world-wide-web, please send a note to          |
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Authors: Derick Rethans <derick@derickrethans.nl>                    |
    +----------------------------------------------------------------------+
  */
 
 /* $Id$ */
 
 #include ""timelib.h""
 
 #include <stdio.h>
 #include <ctype.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #if defined(_MSC_VER)
 # define strtoll(s, f, b) _atoi64(s)
 #elif !defined(HAVE_STRTOLL)
 # if defined(HAVE_ATOLL)
 #  define strtoll(s, f, b) atoll(s)
 # else
 #  define strtoll(s, f, b) strtol(s, f, b)
 # endif
 #endif
 
 #define TIMELIB_UNSET   -99999
 
 #define TIMELIB_SECOND  1
 #define TIMELIB_MINUTE  2
 #define TIMELIB_HOUR    3
 #define TIMELIB_DAY     4
 #define TIMELIB_MONTH   5
 #define TIMELIB_YEAR    6
 
 #define EOI      257
 
 #define TIMELIB_PERIOD  260
 #define TIMELIB_ISO_DATE 261
 #define TIMELIB_ERROR   999
 
 typedef unsigned char uchar;
 
 #define   BSIZE    8192
 
 #define   YYCTYPE      uchar
 #define   YYCURSOR     cursor
 #define   YYLIMIT      s->lim
 #define   YYMARKER     s->ptr
 #define   YYFILL(n)    return EOI;
 
 #define   RET(i)       {s->cur = cursor; return i;}
 
 #define timelib_string_free free
 
 #define TIMELIB_INIT  s->cur = cursor; str = timelib_string(s); ptr = str
 #define TIMELIB_DEINIT timelib_string_free(str)
 
 #ifdef DEBUG_PARSER
 #define DEBUG_OUTPUT(s) printf(""%s\n"", s);
 #define YYDEBUG(s,c) { if (s != -1) { printf(""state: %d "", s); printf(""[%c]\n"", c); } }
 #else
 #define DEBUG_OUTPUT(s)
 #define YYDEBUG(s,c)
 #endif
 
 #include ""timelib_structs.h""
 
 typedef struct Scanner {
         int           fd;
         uchar        *lim, *str, *ptr, *cur, *tok, *pos;
         unsigned int  line, len;
         struct timelib_error_container *errors;
 
         struct timelib_time     *begin;
         struct timelib_time     *end;
         struct timelib_rel_time *period;
         int                      recurrences;
 
         int have_period;
         int have_recurrences;
         int have_date;
         int have_begin_date;
         int have_end_date;
 } Scanner;
 
 #define HOUR(a) (int)(a * 60)
 
 static void add_warning(Scanner *s, char *error)
 {
         s->errors->warning_count++;
         s->errors->warning_messages = realloc(s->errors->warning_messages, s->errors->warning_count * sizeof(timelib_error_message));
         s->errors->warning_messages[s->errors->warning_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].message = strdup(error);
 }
 
 static void add_error(Scanner *s, char *error)
 {
         s->errors->error_count++;
         s->errors->error_messages = realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));
         s->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->error_messages[s->errors->error_count - 1].message = strdup(error);
 }
 
 static char *timelib_string(Scanner *s)
 {
         char *tmp = calloc(1, s->cur - s->tok + 1);
         memcpy(tmp, s->tok, s->cur - s->tok);
 
         return tmp;
 }
 
 static timelib_sll timelib_get_nr(char **ptr, int max_length)
 {
         char *begin, *end, *str;
         timelib_sll tmp_nr = TIMELIB_UNSET;
         int len = 0;
 
         while ((**ptr < '0') || (**ptr > '9')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
         begin = *ptr;
         while ((**ptr >= '0') && (**ptr <= '9') && len < max_length) {
                 ++*ptr;
                 ++len;
         }
         end = *ptr;
         str = calloc(1, end - begin + 1);
         memcpy(str, begin, end - begin);
         tmp_nr = strtoll(str, NULL, 10);
         free(str);
         return tmp_nr;
 }
 
 static timelib_ull timelib_get_unsigned_nr(char **ptr, int max_length)
 {
         timelib_ull dir = 1;
 
         while (((**ptr < '0') || (**ptr > '9')) && (**ptr != '+') && (**ptr != '-')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
 
         while (**ptr == '+' || **ptr == '-')
         {
                 if (**ptr == '-') {
                         dir *= -1;
                 }
                 ++*ptr;
         }
         return dir * timelib_get_nr(ptr, max_length);
 }
 
 static long timelib_parse_tz_cor(char **ptr)
 {
         char *begin = *ptr, *end;
         long  tmp;
 
         while (isdigit(**ptr) || **ptr == ':') {
                 ++*ptr;
         }
         end = *ptr;
         switch (end - begin) {
                 case 1:
                 case 2:
                         return HOUR(strtol(begin, NULL, 10));
                         break;
                 case 3:
                 case 4:
                         if (begin[1] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 2, NULL, 10);
                                 return tmp;
                         } else if (begin[2] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                                 return tmp;
                         } else {
                                 tmp = strtol(begin, NULL, 10);
                                 return HOUR(tmp / 100) + tmp % 100;
                         }
                 case 5:
                         tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                         return tmp;
         }
         return 0;
 }
 
 static void timelib_eat_spaces(char **ptr)
 {
         while (**ptr == ' ' || **ptr == '\t') {
                 ++*ptr;
         }
 }
 
 static void timelib_eat_until_separator(char **ptr)
 {
         while (strchr("" \t.,:;/-0123456789"", **ptr) == NULL) {
                 ++*ptr;
         }
 }
 
 static long timelib_get_zone(char **ptr, int *dst, timelib_time *t, int *tz_not_found, const timelib_tzdb *tzdb)
 {
         long retval = 0;
 
         *tz_not_found = 0;
 
         while (**ptr == ' ' || **ptr == '\t' || **ptr == '(') {
                 ++*ptr;
         }
         if ((*ptr)[0] == 'G' && (*ptr)[1] == 'M' && (*ptr)[2] == 'T' && ((*ptr)[3] == '+' || (*ptr)[3] == '-')) {
                 *ptr += 3;
         }
         if (**ptr == '+') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = -1 * timelib_parse_tz_cor(ptr);
         } else if (**ptr == '-') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = timelib_parse_tz_cor(ptr);
         }
         while (**ptr == ')') {
                 ++*ptr;
         }
         return retval;
 }
 
 #define timelib_split_free(arg) {       \
         int i;                         \
         for (i = 0; i < arg.c; i++) {  \
                 free(arg.v[i]);            \
         }                              \
         if (arg.v) {                   \
                 free(arg.v);               \
         }                              \
 }
 
 /* date parser's scan function too large for VC6 - VC7.x
    drop the optimization solves the problem */
 #ifdef PHP_WIN32
 #pragma optimize( """", off )
 #endif
 static int scan(Scanner *s)
 {
         uchar *cursor = s->cur;
         char *str, *ptr = NULL;
                 
 std:
         s->tok = cursor;
         s->len = 0;
 /*!re2c
 
 /* */
 any = [\000-\377];
 number = [0-9]+;
 
 hour24lz = [01][0-9] | ""2""[0-4];
 minutelz = [0-5][0-9];
 monthlz = ""0"" [1-9] | ""1"" [0-2];
 monthlzz = ""0"" [0-9] | ""1"" [0-2];
 daylz   = ""0"" [1-9] | [1-2][0-9] | ""3"" [01];
 daylzz  = ""0"" [0-9] | [1-2][0-9] | ""3"" [01];
 secondlz = minutelz;
 year4 = [0-9]{4};
 weekofyear = ""0""[1-9] | [1-4][0-9] | ""5""[0-3];
 
 space = [ \t]+;
 datetimebasic  = year4 monthlz daylz ""T"" hour24lz minutelz secondlz ""Z"";
 datetimeextended  = year4 ""-"" monthlz ""-"" daylz ""T"" hour24lz ':' minutelz ':' secondlz ""Z"";
 period   = ""P"" (number ""Y"")? (number ""M"")? (number ""W"")? (number ""D"")? (""T"" (number ""H"")? (number ""M"")? (number ""S"")?)?;
 combinedrep = ""P"" year4 ""-"" monthlzz ""-"" daylzz ""T"" hour24lz ':' minutelz ':' secondlz;
 
 recurrences = ""R"" number;
 
 isoweekday       = year4 ""-""? ""W"" weekofyear ""-""? [0-7];
 isoweek          = year4 ""-""? ""W"" weekofyear;
 
 */
 
 /*!re2c
         /* so that vim highlights correctly */
         recurrences
         {
                 DEBUG_OUTPUT(""recurrences"");
                 TIMELIB_INIT;
                 ptr++;
                 s->recurrences = timelib_get_unsigned_nr((char **) &ptr, 9);
                 TIMELIB_DEINIT;
                 s->have_recurrences = 1;
                 return TIMELIB_PERIOD;
         }
 
         datetimebasic| datetimeextended
         {
                 timelib_time *current;
 
                 if (s->have_date || s->have_period) {
                         current = s->end;
                         s->have_end_date = 1;
                 } else {
                         current = s->begin;
                         s->have_begin_date = 1;
                 }
                 DEBUG_OUTPUT(""datetimebasic | datetimeextended"");
                 TIMELIB_INIT;
                 current->y = timelib_get_nr((char **) &ptr, 4);
                 current->m = timelib_get_nr((char **) &ptr, 2);
                 current->d = timelib_get_nr((char **) &ptr, 2);
                 current->h = timelib_get_nr((char **) &ptr, 2);
                 current->i = timelib_get_nr((char **) &ptr, 2);
                 current->s = timelib_get_nr((char **) &ptr, 2);
                 s->have_date = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_ISO_DATE;
         }
 
         period
         {
                 timelib_sll nr;
                 int         in_time = 0;
                 DEBUG_OUTPUT(""period"");
                 TIMELIB_INIT;
                 ptr++;
                 do {
                         if ( *ptr == 'T' ) {
                                 in_time = 1;
                                 ptr++;
                         }
                         if ( *ptr == '\0' ) {
                                 add_error(s, ""Missing expected time part"");
                                 break;
                         }
 
                         nr = timelib_get_unsigned_nr((char **) &ptr, 12);
                         switch (*ptr) {
                                 case 'Y': s->period->y = nr; break;
                                 case 'W': s->period->d = nr * 7; break;
                                 case 'D': s->period->d = nr; break;
                                 case 'H': s->period->h = nr; break;
                                 case 'S': s->period->s = nr; break;
                                 case 'M': 
                                         if (in_time) {
                                                 s->period->i = nr;
                                         } else {
                                                 s->period->m = nr; 
                                         }
                                         break;
                                 default:
                                         add_error(s, ""Undefined period specifier"");
                                         break;
                         }
                         ptr++;
                 } while (*ptr);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 
         combinedrep
         {
                 DEBUG_OUTPUT(""combinedrep"");
                 TIMELIB_INIT;
                 s->period->y = timelib_get_unsigned_nr((char **) &ptr, 4);
                 ptr++;
                 s->period->m = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->d = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->h = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->i = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->s = timelib_get_unsigned_nr((char **) &ptr, 2);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 
         [ .,\t/]
         {
                 goto std;
         }
 
         ""\000""|""\n""
         {
                 s->pos = cursor; s->line++;
                 goto std;
         }
 
         any
         {
                 add_error(s, ""Unexpected character"");
                 goto std;
         }
 */
 }
 #ifdef PHP_WIN32
 #pragma optimize( """", on )
 #endif
 
 /*!max:re2c */
 
 void timelib_strtointerval(char *s, int len, 
                            timelib_time **begin, timelib_time **end, 
                                                    timelib_rel_time **period, int *recurrences, 
                                                    struct timelib_error_container **errors)
 {
         Scanner in;
         int t;
         char *e = s + len - 1;
 
         memset(&in, 0, sizeof(in));
         in.errors = malloc(sizeof(struct timelib_error_container));
         in.errors->warning_count = 0;
         in.errors->warning_messages = NULL;
         in.errors->error_count = 0;
         in.errors->error_messages = NULL;
 
         if (len > 0) {
                 while (isspace(*s) && s < e) {
                         s++;
                 }
                 while (isspace(*e) && e > s) {
                         e--;
                 }
         }
         if (e - s < 0) {
                 add_error(&in, ""Empty string"");
                 if (errors) {
                         *errors = in.errors;
                 } else {
                         timelib_error_container_dtor(in.errors);
                 }
                 return;
         }
         e++;
 
         /* init cursor */
         in.str = malloc((e - s) + YYMAXFILL);
         memset(in.str, 0, (e - s) + YYMAXFILL);
         memcpy(in.str, s, (e - s));
         in.lim = in.str + (e - s) + YYMAXFILL;
         in.cur = in.str;
 
         /* init value containers */
         in.begin = timelib_time_ctor();
         in.begin->y = TIMELIB_UNSET;
         in.begin->d = TIMELIB_UNSET;
         in.begin->m = TIMELIB_UNSET;
         in.begin->h = TIMELIB_UNSET;
         in.begin->i = TIMELIB_UNSET;
         in.begin->s = TIMELIB_UNSET;
         in.begin->f = 0;
         in.begin->z = 0;
         in.begin->dst = 0;
         in.begin->is_localtime = 0;
         in.begin->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.end = timelib_time_ctor();
         in.end->y = TIMELIB_UNSET;
         in.end->d = TIMELIB_UNSET;
         in.end->m = TIMELIB_UNSET;
         in.end->h = TIMELIB_UNSET;
         in.end->i = TIMELIB_UNSET;
         in.end->s = TIMELIB_UNSET;
         in.end->f = 0;
         in.end->z = 0;
         in.end->dst = 0;
         in.end->is_localtime = 0;
         in.end->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.period = timelib_rel_time_ctor();
         in.period->y = 0;
         in.period->d = 0;
         in.period->m = 0;
         in.period->h = 0;
         in.period->i = 0;
         in.period->s = 0;
         in.period->weekday = 0;
         in.period->weekday_behavior = 0;
         in.period->first_last_day_of = 0;
         in.period->days = TIMELIB_UNSET;
 
         in.recurrences = 1;
 
         do {
                 t = scan(&in);
 #ifdef DEBUG_PARSER
                 printf(""%d\n"", t);
 #endif
         } while(t != EOI);
 
         free(in.str);
         if (errors) {
                 *errors = in.errors;
         } else {
                 timelib_error_container_dtor(in.errors);
         }
         if (in.have_begin_date) {
                 *begin = in.begin;
         } else {
                 timelib_time_dtor(in.begin);
         }
         if (in.have_end_date) {
                 *end   = in.end;
         } else {
                 timelib_time_dtor(in.end);
         }
         if (in.have_period) {
                 *period = in.period;
         } else {
                 timelib_rel_time_dtor(in.period);
         }
         if (in.have_recurrences) {
                 *recurrences = in.recurrences;
         }
 }
 
 
 /*
  * vim: syntax=c
  */
"," /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
    | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
    | available through the world-wide-web at the following url:           |
    | http://www.php.net/license/3_01.txt                                  |
    | If you did not receive a copy of the PHP license and are unable to   |
    | obtain it through the world-wide-web, please send a note to          |
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Authors: Derick Rethans <derick@derickrethans.nl>                    |
    +----------------------------------------------------------------------+
  */
 
 /* $Id$ */
 
 #include ""timelib.h""
 
 #include <stdio.h>
 #include <ctype.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #if defined(_MSC_VER)
 # define strtoll(s, f, b) _atoi64(s)
 #elif !defined(HAVE_STRTOLL)
 # if defined(HAVE_ATOLL)
 #  define strtoll(s, f, b) atoll(s)
 # else
 #  define strtoll(s, f, b) strtol(s, f, b)
 # endif
 #endif
 
 #define TIMELIB_UNSET   -99999
 
 #define TIMELIB_SECOND  1
 #define TIMELIB_MINUTE  2
 #define TIMELIB_HOUR    3
 #define TIMELIB_DAY     4
 #define TIMELIB_MONTH   5
 #define TIMELIB_YEAR    6
 
 #define EOI      257
 
 #define TIMELIB_PERIOD  260
 #define TIMELIB_ISO_DATE 261
 #define TIMELIB_ERROR   999
 
 typedef unsigned char uchar;
 
 #define   BSIZE    8192
 
 #define   YYCTYPE      uchar
 #define   YYCURSOR     cursor
 #define   YYLIMIT      s->lim
 #define   YYMARKER     s->ptr
 #define   YYFILL(n)    return EOI;
 
 #define   RET(i)       {s->cur = cursor; return i;}
 
 #define timelib_string_free free
 
 #define TIMELIB_INIT  s->cur = cursor; str = timelib_string(s); ptr = str
 #define TIMELIB_DEINIT timelib_string_free(str)
 
 #ifdef DEBUG_PARSER
 #define DEBUG_OUTPUT(s) printf(""%s\n"", s);
 #define YYDEBUG(s,c) { if (s != -1) { printf(""state: %d "", s); printf(""[%c]\n"", c); } }
 #else
 #define DEBUG_OUTPUT(s)
 #define YYDEBUG(s,c)
 #endif
 
 #include ""timelib_structs.h""
 
 typedef struct Scanner {
         int           fd;
         uchar        *lim, *str, *ptr, *cur, *tok, *pos;
         unsigned int  line, len;
         struct timelib_error_container *errors;
 
         struct timelib_time     *begin;
         struct timelib_time     *end;
         struct timelib_rel_time *period;
         int                      recurrences;
 
         int have_period;
         int have_recurrences;
         int have_date;
         int have_begin_date;
         int have_end_date;
 } Scanner;
 
 #define HOUR(a) (int)(a * 60)
 
 static void add_warning(Scanner *s, char *error)
 {
         s->errors->warning_count++;
         s->errors->warning_messages = realloc(s->errors->warning_messages, s->errors->warning_count * sizeof(timelib_error_message));
         s->errors->warning_messages[s->errors->warning_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->warning_messages[s->errors->warning_count - 1].message = strdup(error);
 }
 
 static void add_error(Scanner *s, char *error)
 {
         s->errors->error_count++;
         s->errors->error_messages = realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));
         s->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;
         s->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;
         s->errors->error_messages[s->errors->error_count - 1].message = strdup(error);
 }
 
 static char *timelib_string(Scanner *s)
 {
         char *tmp = calloc(1, s->cur - s->tok + 1);
         memcpy(tmp, s->tok, s->cur - s->tok);
 
         return tmp;
 }
 
 static timelib_sll timelib_get_nr(char **ptr, int max_length)
 {
         char *begin, *end, *str;
         timelib_sll tmp_nr = TIMELIB_UNSET;
         int len = 0;
 
         while ((**ptr < '0') || (**ptr > '9')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
         begin = *ptr;
         while ((**ptr >= '0') && (**ptr <= '9') && len < max_length) {
                 ++*ptr;
                 ++len;
         }
         end = *ptr;
         str = calloc(1, end - begin + 1);
         memcpy(str, begin, end - begin);
         tmp_nr = strtoll(str, NULL, 10);
         free(str);
         return tmp_nr;
 }
 
 static timelib_ull timelib_get_unsigned_nr(char **ptr, int max_length)
 {
         timelib_ull dir = 1;
 
         while (((**ptr < '0') || (**ptr > '9')) && (**ptr != '+') && (**ptr != '-')) {
                 if (**ptr == '\0') {
                         return TIMELIB_UNSET;
                 }
                 ++*ptr;
         }
 
         while (**ptr == '+' || **ptr == '-')
         {
                 if (**ptr == '-') {
                         dir *= -1;
                 }
                 ++*ptr;
         }
         return dir * timelib_get_nr(ptr, max_length);
 }
 
 static long timelib_parse_tz_cor(char **ptr)
 {
         char *begin = *ptr, *end;
         long  tmp;
 
         while (isdigit(**ptr) || **ptr == ':') {
                 ++*ptr;
         }
         end = *ptr;
         switch (end - begin) {
                 case 1:
                 case 2:
                         return HOUR(strtol(begin, NULL, 10));
                         break;
                 case 3:
                 case 4:
                         if (begin[1] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 2, NULL, 10);
                                 return tmp;
                         } else if (begin[2] == ':') {
                                 tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                                 return tmp;
                         } else {
                                 tmp = strtol(begin, NULL, 10);
                                 return HOUR(tmp / 100) + tmp % 100;
                         }
                 case 5:
                         tmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);
                         return tmp;
         }
         return 0;
 }
 
 static void timelib_eat_spaces(char **ptr)
 {
         while (**ptr == ' ' || **ptr == '\t') {
                 ++*ptr;
         }
 }
 
 static void timelib_eat_until_separator(char **ptr)
 {
         while (strchr("" \t.,:;/-0123456789"", **ptr) == NULL) {
                 ++*ptr;
         }
 }
 
 static long timelib_get_zone(char **ptr, int *dst, timelib_time *t, int *tz_not_found, const timelib_tzdb *tzdb)
 {
         long retval = 0;
 
         *tz_not_found = 0;
 
         while (**ptr == ' ' || **ptr == '\t' || **ptr == '(') {
                 ++*ptr;
         }
         if ((*ptr)[0] == 'G' && (*ptr)[1] == 'M' && (*ptr)[2] == 'T' && ((*ptr)[3] == '+' || (*ptr)[3] == '-')) {
                 *ptr += 3;
         }
         if (**ptr == '+') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = -1 * timelib_parse_tz_cor(ptr);
         } else if (**ptr == '-') {
                 ++*ptr;
                 t->is_localtime = 1;
                 t->zone_type = TIMELIB_ZONETYPE_OFFSET;
                 *tz_not_found = 0;
                 t->dst = 0;
 
                 retval = timelib_parse_tz_cor(ptr);
         }
         while (**ptr == ')') {
                 ++*ptr;
         }
         return retval;
 }
 
 #define timelib_split_free(arg) {       \
         int i;                         \
         for (i = 0; i < arg.c; i++) {  \
                 free(arg.v[i]);            \
         }                              \
         if (arg.v) {                   \
                 free(arg.v);               \
         }                              \
 }
 
 /* date parser's scan function too large for VC6 - VC7.x
    drop the optimization solves the problem */
 #ifdef PHP_WIN32
 #pragma optimize( """", off )
 #endif
 static int scan(Scanner *s)
 {
         uchar *cursor = s->cur;
         char *str, *ptr = NULL;
                 
 std:
         s->tok = cursor;
         s->len = 0;
 /*!re2c
 
 /* */
 any = [\000-\377];
 number = [0-9]+;
 
 hour24lz = [01][0-9] | ""2""[0-4];
 minutelz = [0-5][0-9];
 monthlz = ""0"" [1-9] | ""1"" [0-2];
 monthlzz = ""0"" [0-9] | ""1"" [0-2];
 daylz   = ""0"" [1-9] | [1-2][0-9] | ""3"" [01];
 daylzz  = ""0"" [0-9] | [1-2][0-9] | ""3"" [01];
 secondlz = minutelz;
 year4 = [0-9]{4};
 weekofyear = ""0""[1-9] | [1-4][0-9] | ""5""[0-3];
 
 space = [ \t]+;
 datetimebasic  = year4 monthlz daylz ""T"" hour24lz minutelz secondlz ""Z"";
 datetimeextended  = year4 ""-"" monthlz ""-"" daylz ""T"" hour24lz ':' minutelz ':' secondlz ""Z"";
 period   = ""P"" (number ""Y"")? (number ""M"")? (number ""W"")? (number ""D"")? (""T"" (number ""H"")? (number ""M"")? (number ""S"")?)?;
 combinedrep = ""P"" year4 ""-"" monthlzz ""-"" daylzz ""T"" hour24lz ':' minutelz ':' secondlz;
 
 recurrences = ""R"" number;
 
 isoweekday       = year4 ""-""? ""W"" weekofyear ""-""? [0-7];
 isoweek          = year4 ""-""? ""W"" weekofyear;
 
 */
 
 /*!re2c
         /* so that vim highlights correctly */
         recurrences
         {
                 DEBUG_OUTPUT(""recurrences"");
                 TIMELIB_INIT;
                 ptr++;
                 s->recurrences = timelib_get_unsigned_nr((char **) &ptr, 9);
                 TIMELIB_DEINIT;
                 s->have_recurrences = 1;
                 return TIMELIB_PERIOD;
         }
 
         datetimebasic| datetimeextended
         {
                 timelib_time *current;
 
                 if (s->have_date || s->have_period) {
                         current = s->end;
                         s->have_end_date = 1;
                 } else {
                         current = s->begin;
                         s->have_begin_date = 1;
                 }
                 DEBUG_OUTPUT(""datetimebasic | datetimeextended"");
                 TIMELIB_INIT;
                 current->y = timelib_get_nr((char **) &ptr, 4);
                 current->m = timelib_get_nr((char **) &ptr, 2);
                 current->d = timelib_get_nr((char **) &ptr, 2);
                 current->h = timelib_get_nr((char **) &ptr, 2);
                 current->i = timelib_get_nr((char **) &ptr, 2);
                 current->s = timelib_get_nr((char **) &ptr, 2);
                 s->have_date = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_ISO_DATE;
         }
 
         period
         {
                 timelib_sll nr;
                 int         in_time = 0;
                 DEBUG_OUTPUT(""period"");
                 TIMELIB_INIT;
                 ptr++;
                 do {
                         if ( *ptr == 'T' ) {
                                 in_time = 1;
                                 ptr++;
                         }
                         if ( *ptr == '\0' ) {
                                 add_error(s, ""Missing expected time part"");
                                 break;
                         }
 
                         nr = timelib_get_unsigned_nr((char **) &ptr, 12);
                         switch (*ptr) {
                                 case 'Y': s->period->y = nr; break;
                                 case 'W': s->period->d = nr * 7; break;
                                 case 'D': s->period->d = nr; break;
                                 case 'H': s->period->h = nr; break;
                                 case 'S': s->period->s = nr; break;
                                 case 'M': 
                                         if (in_time) {
                                                 s->period->i = nr;
                                         } else {
                                                 s->period->m = nr; 
                                         }
                                         break;
                                 default:
                                         add_error(s, ""Undefined period specifier"");
                                         break;
                         }
                         ptr++;
                 } while (!s->errors->error_count && *ptr);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 
         combinedrep
         {
                 DEBUG_OUTPUT(""combinedrep"");
                 TIMELIB_INIT;
                 s->period->y = timelib_get_unsigned_nr((char **) &ptr, 4);
                 ptr++;
                 s->period->m = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->d = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->h = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->i = timelib_get_unsigned_nr((char **) &ptr, 2);
                 ptr++;
                 s->period->s = timelib_get_unsigned_nr((char **) &ptr, 2);
                 s->have_period = 1;
                 TIMELIB_DEINIT;
                 return TIMELIB_PERIOD;
         }
 
         [ .,\t/]
         {
                 goto std;
         }
 
         ""\000""|""\n""
         {
                 s->pos = cursor; s->line++;
                 goto std;
         }
 
         any
         {
                 add_error(s, ""Unexpected character"");
                 goto std;
         }
 */
 }
 #ifdef PHP_WIN32
 #pragma optimize( """", on )
 #endif
 
 /*!max:re2c */
 
 void timelib_strtointerval(char *s, int len, 
                            timelib_time **begin, timelib_time **end, 
                                                    timelib_rel_time **period, int *recurrences, 
                                                    struct timelib_error_container **errors)
 {
         Scanner in;
         int t;
         char *e = s + len - 1;
 
         memset(&in, 0, sizeof(in));
         in.errors = malloc(sizeof(struct timelib_error_container));
         in.errors->warning_count = 0;
         in.errors->warning_messages = NULL;
         in.errors->error_count = 0;
         in.errors->error_messages = NULL;
 
         if (len > 0) {
                 while (isspace(*s) && s < e) {
                         s++;
                 }
                 while (isspace(*e) && e > s) {
                         e--;
                 }
         }
         if (e - s < 0) {
                 add_error(&in, ""Empty string"");
                 if (errors) {
                         *errors = in.errors;
                 } else {
                         timelib_error_container_dtor(in.errors);
                 }
                 return;
         }
         e++;
 
         /* init cursor */
         in.str = malloc((e - s) + YYMAXFILL);
         memset(in.str, 0, (e - s) + YYMAXFILL);
         memcpy(in.str, s, (e - s));
         in.lim = in.str + (e - s) + YYMAXFILL;
         in.cur = in.str;
 
         /* init value containers */
         in.begin = timelib_time_ctor();
         in.begin->y = TIMELIB_UNSET;
         in.begin->d = TIMELIB_UNSET;
         in.begin->m = TIMELIB_UNSET;
         in.begin->h = TIMELIB_UNSET;
         in.begin->i = TIMELIB_UNSET;
         in.begin->s = TIMELIB_UNSET;
         in.begin->f = 0;
         in.begin->z = 0;
         in.begin->dst = 0;
         in.begin->is_localtime = 0;
         in.begin->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.end = timelib_time_ctor();
         in.end->y = TIMELIB_UNSET;
         in.end->d = TIMELIB_UNSET;
         in.end->m = TIMELIB_UNSET;
         in.end->h = TIMELIB_UNSET;
         in.end->i = TIMELIB_UNSET;
         in.end->s = TIMELIB_UNSET;
         in.end->f = 0;
         in.end->z = 0;
         in.end->dst = 0;
         in.end->is_localtime = 0;
         in.end->zone_type = TIMELIB_ZONETYPE_OFFSET;
 
         in.period = timelib_rel_time_ctor();
         in.period->y = 0;
         in.period->d = 0;
         in.period->m = 0;
         in.period->h = 0;
         in.period->i = 0;
         in.period->s = 0;
         in.period->weekday = 0;
         in.period->weekday_behavior = 0;
         in.period->first_last_day_of = 0;
         in.period->days = TIMELIB_UNSET;
 
         in.recurrences = 1;
 
         do {
                 t = scan(&in);
 #ifdef DEBUG_PARSER
                 printf(""%d\n"", t);
 #endif
         } while(t != EOI);
 
         free(in.str);
         if (errors) {
                 *errors = in.errors;
         } else {
                 timelib_error_container_dtor(in.errors);
         }
         if (in.have_begin_date) {
                 *begin = in.begin;
         } else {
                 timelib_time_dtor(in.begin);
         }
         if (in.have_end_date) {
                 *end   = in.end;
         } else {
                 timelib_time_dtor(in.end);
         }
         if (in.have_period) {
                 *period = in.period;
         } else {
                 timelib_rel_time_dtor(in.period);
         }
         if (in.have_recurrences) {
                 *recurrences = in.recurrences;
         }
 }
 
 
 /*
  * vim: syntax=c
  */
"
CVE-2009-4261,https://www.cvedetails.com/cve/CVE-2009-4261/,CWE-22,,Exec Code +Priv Dir. Trav.,2009-12-21,2018-10-10,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple directory traversal vulnerabilities in the iallocator framework in Ganeti 1.2.4 through 1.2.8, 2.0.0 through 2.0.4, and 2.1.0 before 2.1.0~rc2 allow (1) remote attackers to execute arbitrary programs via a crafted external script name supplied through the HTTP remote API (RAPI) and allow (2) local users to execute arbitrary programs and gain privileges via a crafted external script name supplied through a gnt-* command, related to ""path sanitization errors.""",Python,ganeti,http://git.ganeti.org/?p=ganeti.git;a=commit;h=f95c81bf21c177f7e6a2c53ea0613034326329bd,f95c81bf21c177f7e6a2c53ea0613034326329bd,4fe80ef2ed1cda3a6357274eccafe5c1f21a5283,"@@ -1658,10 +1658,11 @@ def OSFromDisk(name, base_dir=None):
   """"""
   if base_dir is None:
     os_dir = utils.FindFile(name, constants.OS_SEARCH_PATH, os.path.isdir)
-    if os_dir is None:
-      raise errors.InvalidOS(name, None, ""OS dir not found in search path"")
   else:
-    os_dir = os.path.sep.join([base_dir, name])
+    os_dir = utils.FindFile(name, [base_dir], os.path.isdir)
+
+  if os_dir is None:
+    raise errors.InvalidOS(name, None, ""OS dir not found in search path"")
 
   api_versions = _OSOndiskVersion(name, os_dir)",http://git.ganeti.org/?p=ganeti.git;a=blob;f=lib/backend.py;h=44e45f63ad164c56164804f9ed8e8025263f3b94;hb=44e45f63ad164c56164804f9ed8e8025263f3b94,http://git.ganeti.org/?p=ganeti.git;a=blob;f=lib/backend.py;h=30984b38feaf31e2f3fa9d673c1c3180f04c2418;hb=30984b38feaf31e2f3fa9d673c1c3180f04c2418,"#
#
# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
""""""Functions used by the node daemon

@var _ALLOWED_UPLOAD_FILES: denotes which files are accepted in
     the L{UploadFile} function

""""""
import
import
.
import
import
import
import
import
import
import
import
import
import
import
from
import
from
import
from
import
from
import
from
import
from
import
from
import
from
import
def
_GetConfig
():
""""""Simple wrapper to return a SimpleStore.

  @rtype: L{ssconf.SimpleStore}
  @return: a SimpleStore instance

  """"""
return
.
SimpleStore
()
def
_GetSshRunner
(
):
""""""Simple wrapper to return an SshRunner.

  @type cluster_name: str
  @param cluster_name: the cluster name, which is needed
      by the SshRunner constructor
  @rtype: L{ssh.SshRunner}
  @return: an SshRunner instance

  """"""
return
.
SshRunner
(
)
def
_Decompress
(
):
""""""Unpacks data compressed by the RPC client.

  @type data: list or tuple
  @param data: Data sent by RPC client
  @rtype: str
  @return: Decompressed data

  """"""
assert
isinstance
(
, (
list
,
tuple
))
assert
len
(
) ==
2
(
,
) =
if
==
.
:
return
elif
==
.
:
return
.
decompress
(
.
b64decode
(
))
else
:
raise
AssertionError
(
""Unknown data encoding""
)
def
_CleanDirectory
(
,
=
None
):
""""""Removes all regular files in a directory.

  @type path: str
  @param path: the directory to clean
  @type exclude: list
  @param exclude: list of files to be excluded, defaults
      to the empty list

  """"""
if not
.
.
isdir
(
):
return
if
is None
:
= []
else
:
# Normalize excluded paths
= [
.
.
normpath
(
)
for
in
]
for
in
.
ListVisibleFiles
(
):
=
.
.
normpath
(
.
.
join
(
,
))
if
in
:
continue
if
.
.
isfile
(
)
and not
.
.
islink
(
):
.
RemoveFile
(
)
def
_BuildUploadFileList
():
""""""Build the list of allowed upload files.

  This is abstracted so that it's built only once at module import time.

  """"""
return
frozenset
([
.
,
.
,
.
,
.
,
])
=
_BuildUploadFileList
()
def
JobQueuePurge
():
""""""Removes job queue files and archived jobs.

  @rtype: None

  """"""
_CleanDirectory
(
.
,
=[
.
])
_CleanDirectory
(
.
)
def
GetMasterInfo
():
""""""Returns master information.

  This is an utility function to compute master information, either
  for consumption here or from the node daemon.

  @rtype: tuple
  @return: (master_netdev, master_ip, master_name) if we have a good
      configuration, otherwise (None, None, None)

  """"""
try
:
=
_GetConfig
()
=
.
GetMasterNetdev
()
=
.
GetMasterIP
()
=
.
GetMasterNode
()
except
.
:
.
exception
(
""Cluster configuration incomplete""
)
return
(
None
,
None
,
None
)
return
(
,
,
)
def
StartMaster
(
,
):
""""""Activate local node as master node.

  The function will always try activate the IP address of the master
  (unless someone else has it). It will also start the master daemons,
  based on the start_daemons parameter.

  @type start_daemons: boolean
  @param start_daemons: whther to also start the master
      daemons (ganeti-masterd and ganeti-rapi)
  @type no_voting: boolean
  @param no_voting: whether to start ganeti-masterd without a node vote
      (if start_daemons is True), but still non-interactively
  @rtype: None

  """"""
=
True
,
,
=
GetMasterInfo
()
if not
:
return False
if
.
TcpPing
(
,
.
):
if
.
OwnIpAddress
(
):
# we already have the ip:
.
debug
(
""Already started""
)
else
:
.
error
(
""Someone else has the master ip, not activating""
)
=
False
else
:
=
.
RunCmd
([
""ip""
,
""address""
,
""add""
,
""%s/32""
%
,
""dev""
,
,
""label""
,
""%s:0""
%
])
if
.
:
.
error
(
""Can't activate master IP: %s""
,
.
)
=
False
=
.
RunCmd
([
""arping""
,
""-q""
,
""-U""
,
""-c 3""
,
""-I""
,
,
""-s""
,
,
])
# we'll ignore the exit code of arping
# and now start the master and rapi daemons
if
:
= {
'ganeti-masterd'
: [],
'ganeti-rapi'
: [],
}
if
:
[
'ganeti-masterd'
].
append
(
'--no-voting'
)
[
'ganeti-masterd'
].
append
(
'--yes-do-it'
)
for
in
:
= [
]
.
extend
(
[
])
=
.
RunCmd
(
)
if
.
:
.
error
(
""Can't start daemon %s: %s""
,
,
.
)
=
False
return
def
StopMaster
(
):
""""""Deactivate this node as master.

  The function will always try to deactivate the IP address of the
  master. It will also stop the master daemons depending on the
  stop_daemons parameter.

  @type stop_daemons: boolean
  @param stop_daemons: whether to also stop the master daemons
      (ganeti-masterd and ganeti-rapi)
  @rtype: None

  """"""
,
,
=
GetMasterInfo
()
if not
:
return False
=
.
RunCmd
([
""ip""
,
""address""
,
""del""
,
""%s/32""
%
,
""dev""
,
])
if
.
:
.
error
(
""Can't remove the master IP, error: %s""
,
.
)
# but otherwise ignore the failure
if
:
# stop/kill the rapi and the master daemon
for
in
.
,
.
:
.
KillProcess
(
.
ReadPidFile
(
.
DaemonPidFileName
(
)))
return True
def
AddNode
(
,
,
,
,
,
):
""""""Joins this node to the cluster.

  This does the following:
      - updates the hostkeys of the machine (rsa and dsa)
      - adds the ssh private key to the user
      - adds the ssh public key to the users' authorized_keys file

  @type dsa: str
  @param dsa: the DSA private key to write
  @type dsapub: str
  @param dsapub: the DSA public key to write
  @type rsa: str
  @param rsa: the RSA private key to write
  @type rsapub: str
  @param rsapub: the RSA public key to write
  @type sshkey: str
  @param sshkey: the SSH private key to write
  @type sshpub: str
  @param sshpub: the SSH public key to write
  @rtype: boolean
  @return: the success of the operation

  """"""
=  [(
.
,
,
0600
),
(
.
,
,
0644
),
(
.
,
,
0600
),
(
.
,
,
0644
)]
for
,
,
in
:
.
WriteFile
(
,
=
,
=
)
try
:
,
,
=
.
GetUserFiles
(
.
,
=
True
)
except
.
,
:
=
""Error while processing user ssh files""
.
exception
(
)
return
(
False
,
""%s: %s""
% (
,
))
for
,
in
[(
,
), (
,
)]:
.
WriteFile
(
,
=
,
=
0600
)
.
AddAuthorizedKey
(
,
)
.
RunCmd
([
.
,
""restart""
])
return
(
True
,
""Node added successfully""
)
def
LeaveCluster
():
""""""Cleans up and remove the current node.

  This function cleans up and prepares the current node to be removed
  from the cluster.

  If processing is successful, then it raises an
  L{errors.QuitGanetiException} which is used as a special case to
  shutdown the node daemon.

  """"""
_CleanDirectory
(
.
)
JobQueuePurge
()
try
:
,
,
=
.
GetUserFiles
(
.
)
except
.
:
.
exception
(
""Error while processing ssh files""
)
return
=
open
(
,
'r'
)
try
:
.
RemoveAuthorizedKey
(
,
.
read
(
8192
))
finally
:
.
close
()
.
RemoveFile
(
)
.
RemoveFile
(
)
# Return a reassuring string to the caller, and quit
raise
.
QuitGanetiException
(
False
,
'Shutdown scheduled'
)
def
GetNodeInfo
(
,
):
""""""Gives back a hash with different information about the node.

  @type vgname: C{string}
  @param vgname: the name of the volume group to ask for disk space information
  @type hypervisor_type: C{str}
  @param hypervisor_type: the name of the hypervisor to ask for
      memory information
  @rtype: C{dict}
  @return: dictionary with the following keys:
      - vg_size is the size of the configured volume group in MiB
      - vg_free is the free size of the volume group in MiB
      - memory_dom0 is the memory allocated for domain0 in MiB
      - memory_free is the currently available (free) ram in MiB
      - memory_total is the total number of ram in MiB

  """"""
= {}
=
_GetVGInfo
(
)
[
'vg_size'
] =
[
'vg_size'
]
[
'vg_free'
] =
[
'vg_free'
]
=
.
GetHypervisor
(
)
=
.
GetNodeInfo
()
if
is not None
:
.
update
(
)
=
open
(
""/proc/sys/kernel/random/boot_id""
,
'r'
)
try
:
[
""bootid""
] =
.
read
(
128
).
rstrip
(
""
\n
""
)
finally
:
.
close
()
return
def
VerifyNode
(
,
):
""""""Verify the status of the local node.

  Based on the input L{what} parameter, various checks are done on the
  local node.

  If the I{filelist} key is present, this list of
  files is checksummed and the file/checksum pairs are returned.

  If the I{nodelist} key is present, we check that we have
  connectivity via ssh with the target nodes (and check the hostname
  report).

  If the I{node-net-test} key is present, we check that we have
  connectivity to the given nodes via both primary IP and, if
  applicable, secondary IPs.

  @type what: C{dict}
  @param what: a dictionary of things to check:
      - filelist: list of files for which to compute checksums
      - nodelist: list of nodes we should check ssh communication with
      - node-net-test: list of nodes we should check node daemon port
        connectivity with
      - hypervisor: list with hypervisors to run the verify for
  @rtype: dict
  @return: a dictionary with the same keys as the input dict, and
      values representing the result of the checks

  """"""
= {}
if
.
in
:
[
.
] =
= {}
for
in
[
.
]:
[
] =
.
GetHypervisor
(
).
Verify
()
if
.
in
:
[
.
] =
.
FingerprintFiles
(
[
.
])
if
.
in
:
[
.
] =
= {}
.
shuffle
(
[
.
])
for
in
[
.
]:
,
=
_GetSshRunner
(
).
VerifyNodeHostname
(
)
if not
:
[
] =
if
.
in
:
[
.
] =
= {}
=
.
HostInfo
().
=
=
None
for
,
,
in
[
.
]:
if
==
:
=
=
break
if not
:
[
] = (
""Can't find my own primary/secondary IP""
"" in the node list""
)
else
:
=
.
GetNodeDaemonPort
()
for
,
,
in
[
.
]:
= []
if not
.
TcpPing
(
,
,
=
):
.
append
(
""primary""
)
if
!=
:
if not
.
TcpPing
(
,
,
=
):
.
append
(
""secondary""
)
if
:
[
] = (
""failure using the %s interface(s)""
%
"" and ""
.
join
(
))
if
.
in
:
[
.
] =
GetVolumeList
(
[
.
])
if
.
in
:
[
.
] =
GetInstanceList
(
[
.
])
if
.
in
:
[
.
] =
ListVolumeGroups
()
if
.
in
:
[
.
] = (
.
,
.
)
if
.
in
:
=
.
GetHypervisor
(
[
.
])
[
.
] =
.
GetNodeInfo
()
if
.
in
:
try
:
=
.
.
GetUsedDevs
().
keys
()
except
.
,
:
.
warning
(
""Can't get used minors list""
,
=
True
)
=
str
(
)
[
.
] =
return
def
GetVolumeList
(
):
""""""Compute list of logical volumes and their size.

  @type vg_name: str
  @param vg_name: the volume group whose LVs we should list
  @rtype: dict
  @return:
      dictionary of all partions (key) with value being a tuple of
      their size (in MiB), inactive and online status::

        {'test1': ('20.06', True, True)}

      in case of errors, a string is returned with the error
      details.

  """"""
= {}
=
'|'
=
.
RunCmd
([
""lvs""
,
""--noheadings""
,
""--units=m""
,
""--nosuffix""
,
""--separator=%s""
%
,
""-olv_name,lv_size,lv_attr""
,
])
if
.
:
.
error
(
""Failed to list logical volumes, lvs output: %s""
,
.
)
return
.
=
.
compile
(
""^ *([^|]+)\|([0-9.]+)\|([^|]{6})\|?$""
)
for
in
.
.
splitlines
():
=
.
strip
()
=
.
match
(
)
if not
:
.
error
(
""Invalid line returned from lvs output: '%s'""
,
)
continue
,
,
=
.
groups
()
=
[
4
] ==
'-'
=
[
5
] ==
'o'
[
] = (
,
,
)
return
def
ListVolumeGroups
():
""""""List the volume groups and their size.

  @rtype: dict
  @return: dictionary with keys volume name and values the
      size of the volume

  """"""
return
.
ListVolumeGroups
()
def
NodeVolumes
():
""""""List all volumes on this node.

  @rtype: list
  @return:
    A list of dictionaries, each having four keys:
      - name: the logical volume name,
      - size: the size of the logical volume
      - dev: the physical device on which the LV lives
      - vg: the volume group to which it belongs

    In case of errors, we return an empty list and log the
    error.

    Note that since a logical volume can live on multiple physical
    volumes, the resulting list might include a logical volume
    multiple times.

  """"""
=
.
RunCmd
([
""lvs""
,
""--noheadings""
,
""--units=m""
,
""--nosuffix""
,
""--separator=|""
,
""--options=lv_name,lv_size,devices,vg_name""
])
if
.
:
.
error
(
""Failed to list logical volumes, lvs output: %s""
,
.
)
return
[]
def
parse_dev
(
):
if
'('
in
:
return
.
split
(
'('
)[
0
]
else
:
return
def
map_line
(
):
return
{
'name'
:
[
0
].
strip
(),
'size'
:
[
1
].
strip
(),
'dev'
:
parse_dev
(
[
2
].
strip
()),
'vg'
:
[
3
].
strip
(),
}
return
[
map_line
(
.
split
(
'|'
))
for
in
.
.
splitlines
()
if
.
count
(
'|'
) >=
3
]
def
BridgesExist
(
):
""""""Check if a list of bridges exist on the current node.

  @rtype: boolean
  @return: C{True} if all of them exist, C{False} otherwise

  """"""
for
in
:
if not
.
BridgeExists
(
):
return False
return True
def
GetInstanceList
(
):
""""""Provides a list of instances.

  @type hypervisor_list: list
  @param hypervisor_list: the list of hypervisors to query information

  @rtype: list
  @return: a list of all running instances on the current node
    - instance1.example.com
    - instance2.example.com

  """"""
= []
for
in
:
try
:
=
.
GetHypervisor
(
).
ListInstances
()
.
extend
(
)
except
.
:
.
exception
(
""Error enumerating instances for hypevisor %s""
,
)
raise
return
def
GetInstanceInfo
(
,
):
""""""Gives back the information about an instance as a dictionary.

  @type instance: string
  @param instance: the instance name
  @type hname: string
  @param hname: the hypervisor type of the instance

  @rtype: dict
  @return: dictionary with the following keys:
      - memory: memory size of instance (int)
      - state: xen state of instance (string)
      - time: cpu time of instance (float)

  """"""
= {}
=
.
GetHypervisor
(
).
GetInstanceInfo
(
)
if
is not None
:
[
'memory'
] =
[
2
]
[
'state'
] =
[
4
]
[
'time'
] =
[
5
]
return
def
GetInstanceMigratable
(
):
""""""Gives whether an instance can be migrated.

  @type instance: L{objects.Instance}
  @param instance: object representing the instance to be checked.

  @rtype: tuple
  @return: tuple of (result, description) where:
      - result: whether the instance can be migrated or not
      - description: a description of the issue, if relevant

  """"""
=
.
GetHypervisor
(
.
)
if
.
not in
.
ListInstances
():
return
(
False
,
'not running'
)
for
in
range
(
len
(
.
)):
=
_GetBlockDevSymlinkPath
(
.
,
)
if not
.
.
islink
(
):
return
(
False
,
'not restarted since ganeti 1.2.5'
)
return
(
True
,
''
)
def
GetAllInstancesInfo
(
):
""""""Gather data about all instances.

  This is the equivalent of L{GetInstanceInfo}, except that it
  computes data for all instances at once, thus being faster if one
  needs data about more than one instance.

  @type hypervisor_list: list
  @param hypervisor_list: list of hypervisors to query for instance data

  @rtype: dict
  @return: dictionary of instance: data, with data having the following keys:
      - memory: memory size of instance (int)
      - state: xen state of instance (string)
      - time: cpu time of instance (float)
      - vcpus: the number of vcpus

  """"""
= {}
for
in
:
=
.
GetHypervisor
(
).
GetAllInstancesInfo
()
if
:
for
,
,
,
,
,
in
:
= {
'memory'
:
,
'vcpus'
:
,
'state'
:
,
'time'
:
,
}
if
in
:
# we only check static parameters, like memory and vcpus,
# and not state and time which can change between the
# invocations of the different hypervisors
for
in
'memory'
,
'vcpus'
:
if
[
] !=
[
][
]:
raise
.
HypervisorError
(
""Instance %s is running twice""
"" with different parameters""
%
)
[
] =
return
def
InstanceOsAdd
(
):
""""""Add an OS to an instance.

  @type instance: L{objects.Instance}
  @param instance: Instance whose OS is to be installed
  @rtype: boolean
  @return: the success of the operation

  """"""
try
:
=
OSFromDisk
(
.
)
except
.
,
:
,
,
=
.
if
is None
:
return
(
False
,
""Can't find OS '%s': %s""
% (
,
))
else
:
return
(
False
,
""Error parsing OS '%s' in directory %s: %s""
%
(
,
,
))
=
OSEnvironment
(
)
=
""%s/add-%s-%s-%d.log""
% (
.
,
.
,
.
,
int
(
.
time
()))
=
.
RunCmd
([
.
],
=
,
=
.
,
=
,)
if
.
:
.
error
(
""os create command '%s' returned error: %s, logfile: %s,""
"" output: %s""
,
.
,
.
,
,
.
)
= [
.
SafeEncode
(
)
for
in
.
TailFile
(
,
=
20
)]
return
(
False
,
""OS create script failed (%s), last lines in the""
"" log file:
\n
%s""
% (
.
,
""
\n
""
.
join
(
)))
return
(
True
,
""Successfully installed""
)
def
RunRenameInstance
(
,
):
""""""Run the OS rename script for an instance.

  @type instance: L{objects.Instance}
  @param instance: Instance whose OS is to be installed
  @type old_name: string
  @param old_name: previous instance name
  @rtype: boolean
  @return: the success of the operation

  """"""
=
OSFromDisk
(
.
)
=
OSEnvironment
(
)
[
'OLD_INSTANCE_NAME'
] =
=
""%s/rename-%s-%s-%s-%d.log""
% (
.
,
.
,
,
.
,
int
(
.
time
()))
=
.
RunCmd
([
.
],
=
,
=
.
,
=
)
if
.
:
.
error
(
""os create command '%s' returned error: %s output: %s""
,
.
,
.
,
.
)
= [
.
SafeEncode
(
)
for
in
.
TailFile
(
,
=
20
)]
return
(
False
,
""OS rename script failed (%s), last lines in the""
"" log file:
\n
%s""
% (
.
,
""
\n
""
.
join
(
)))
return
(
True
,
""Rename successful""
)
def
_GetVGInfo
(
):
""""""Get information about the volume group.

  @type vg_name: str
  @param vg_name: the volume group which we query
  @rtype: dict
  @return:
    A dictionary with the following keys:
      - C{vg_size} is the total size of the volume group in MiB
      - C{vg_free} is the free size of the volume group in MiB
      - C{pv_count} are the number of physical disks in that VG

    If an error occurs during gathering of data, we return the same dict
    with keys all set to None.

  """"""
=
dict
.
fromkeys
([
""vg_size""
,
""vg_free""
,
""pv_count""
])
=
.
RunCmd
([
""vgs""
,
""-ovg_size,vg_free,pv_count""
,
""--noheadings""
,
""--nosuffix""
,
""--units=m""
,
""--separator=:""
,
])
if
.
:
.
error
(
""volume group %s not present""
,
)
return
=
.
.
strip
().
rstrip
(
':'
).
split
(
':'
)
if
len
(
) ==
3
:
try
:
= {
""vg_size""
:
int
(
round
(
float
(
[
0
]),
0
)),
""vg_free""
:
int
(
round
(
float
(
[
1
]),
0
)),
""pv_count""
:
int
(
[
2
]),
}
except
ValueError
,
:
.
exception
(
""Fail to parse vgs output""
)
else
:
.
error
(
""vgs output has the wrong number of fields (expected""
"" three): %s""
,
str
(
))
return
def
_GetBlockDevSymlinkPath
(
,
):
return
.
.
join
(
.
,
""%s:%d""
% (
,
))
def
_SymlinkBlockDev
(
,
,
):
""""""Set up symlinks to a instance's block device.

  This is an auxiliary function run when an instance is start (on the primary
  node) or when an instance is migrated (on the target node).


  @param instance_name: the name of the target instance
  @param device_path: path of the physical block device, on the node
  @param idx: the disk index
  @return: absolute path to the disk's symlink

  """"""
=
_GetBlockDevSymlinkPath
(
,
)
try
:
.
symlink
(
,
)
except
OSError
,
:
if
.
==
.
:
if
(
not
.
.
islink
(
)
or
.
readlink
(
) !=
):
.
remove
(
)
.
symlink
(
,
)
else
:
raise
return
def
_RemoveBlockDevLinks
(
,
):
""""""Remove the block device symlinks belonging to the given instance.

  """"""
for
,
in
enumerate
(
):
=
_GetBlockDevSymlinkPath
(
,
)
if
.
.
islink
(
):
try
:
.
remove
(
)
except
OSError
:
.
exception
(
""Can't remove symlink '%s'""
,
)
def
_GatherAndLinkBlockDevs
(
):
""""""Set up an instance's block device(s).

  This is run on the primary node at instance startup. The block
  devices must be already assembled.

  @type instance: L{objects.Instance}
  @param instance: the instance whose disks we shoul assemble
  @rtype: list
  @return: list of (disk_object, device_path)

  """"""
= []
for
,
in
enumerate
(
.
):
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Block device '%s' is not set up.""
%
str
(
))
.
Open
()
try
:
=
_SymlinkBlockDev
(
.
,
.
,
)
except
OSError
,
:
raise
.
BlockDeviceError
(
""Cannot create block device symlink: %s""
%
.
)
.
append
((
,
))
return
def
StartInstance
(
):
""""""Start an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance object
  @rtype: boolean
  @return: whether the startup was successful or not

  """"""
=
GetInstanceList
([
.
])
if
.
in
:
return
(
True
,
""Already running""
)
try
:
=
_GatherAndLinkBlockDevs
(
)
=
.
GetHypervisor
(
.
)
.
StartInstance
(
,
)
except
.
,
:
.
exception
(
""Failed to start instance""
)
return
(
False
,
""Block device error: %s""
%
str
(
))
except
.
,
:
.
exception
(
""Failed to start instance""
)
_RemoveBlockDevLinks
(
.
,
.
)
return
(
False
,
""Hypervisor error: %s""
%
str
(
))
return
(
True
,
""Instance started successfully""
)
def
InstanceShutdown
(
):
""""""Shut an instance down.

  @note: this functions uses polling with a hardcoded timeout.

  @type instance: L{objects.Instance}
  @param instance: the instance object
  @rtype: boolean
  @return: whether the startup was successful or not

  """"""
=
.
=
GetInstanceList
([
])
if
.
not in
:
return
(
True
,
""Instance already stopped""
)
=
.
GetHypervisor
(
)
try
:
.
StopInstance
(
)
except
.
,
:
=
""Failed to stop instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
# test every 10secs for 2min
.
sleep
(
1
)
for
in
range
(
11
):
if
.
not in
GetInstanceList
([
]):
break
.
sleep
(
10
)
else
:
# the shutdown did not succeed
.
error
(
""Shutdown of '%s' unsuccessful, using destroy""
,
.
)
try
:
.
StopInstance
(
,
=
True
)
except
.
,
:
=
""Failed to force stop instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
.
sleep
(
1
)
if
.
in
GetInstanceList
([
]):
= (
""Could not shutdown instance %s even by destroy""
%
.
)
.
error
(
)
return
(
False
,
)
_RemoveBlockDevLinks
(
.
,
.
)
return
(
True
,
""Instance has been shutdown successfully""
)
def
InstanceReboot
(
,
):
""""""Reboot an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance object to reboot
  @type reboot_type: str
  @param reboot_type: the type of reboot, one the following
    constants:
      - L{constants.INSTANCE_REBOOT_SOFT}: only reboot the
        instance OS, do not recreate the VM
      - L{constants.INSTANCE_REBOOT_HARD}: tear down and
        restart the VM (at the hypervisor level)
      - the other reboot type (L{constants.INSTANCE_REBOOT_FULL}) is
        not accepted here, since that mode is handled differently, in
        cmdlib, and translates into full stop and start of the
        instance (instead of a call_instance_reboot RPC)
  @rtype: boolean
  @return: the success of the operation

  """"""
=
GetInstanceList
([
.
])
if
.
not in
:
=
""Cannot reboot instance %s that is not running""
%
.
.
error
(
)
return
(
False
,
)
=
.
GetHypervisor
(
.
)
if
==
.
:
try
:
.
RebootInstance
(
)
except
.
,
:
=
""Failed to soft reboot instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
elif
==
.
:
try
:
=
InstanceShutdown
(
)
if not
[
0
]:
return
return
StartInstance
(
)
except
.
,
:
=
""Failed to hard reboot instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
else
:
return
(
False
,
""Invalid reboot_type received: %s""
% (
,))
return
(
True
,
""Reboot successful""
)
def
MigrationInfo
(
):
""""""Gather information about an instance to be migrated.

  @type instance: L{objects.Instance}
  @param instance: the instance definition

  """"""
=
.
GetHypervisor
(
.
)
try
:
=
.
MigrationInfo
(
)
except
.
,
:
=
""Failed to fetch migration information""
.
exception
(
)
return
(
False
,
'%s: %s'
% (
,
))
return
(
True
,
)
def
AcceptInstance
(
,
,
):
""""""Prepare the node to accept an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance definition
  @type info: string/data (opaque)
  @param info: migration information, from the source node
  @type target: string
  @param target: target host (usually ip), on this node

  """"""
=
.
GetHypervisor
(
.
)
try
:
.
AcceptInstance
(
,
,
)
except
.
,
:
=
""Failed to accept instance""
.
exception
(
)
return
(
False
,
'%s: %s'
% (
,
))
return
(
True
,
""Accept successful""
)
def
FinalizeMigration
(
,
,
):
""""""Finalize any preparation to accept an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance definition
  @type info: string/data (opaque)
  @param info: migration information, from the source node
  @type success: boolean
  @param success: whether the migration was a success or a failure

  """"""
=
.
GetHypervisor
(
.
)
try
:
.
FinalizeMigration
(
,
,
)
except
.
,
:
=
""Failed to finalize migration""
.
exception
(
)
return
(
False
,
'%s: %s'
% (
,
))
return
(
True
,
""Migration Finalized""
)
def
MigrateInstance
(
,
,
):
""""""Migrates an instance to another node.

  @type instance: L{objects.Instance}
  @param instance: the instance definition
  @type target: string
  @param target: the target node name
  @type live: boolean
  @param live: whether the migration should be done live or not (the
      interpretation of this parameter is left to the hypervisor)
  @rtype: tuple
  @return: a tuple of (success, msg) where:
      - succes is a boolean denoting the success/failure of the operation
      - msg is a string with details in case of failure

  """"""
=
.
GetHypervisor
(
.
)
try
:
.
MigrateInstance
(
.
,
,
)
except
.
,
:
=
""Failed to migrate instance""
.
exception
(
)
return
(
False
,
""%s: %s""
% (
,
))
return
(
True
,
""Migration successful""
)
def
BlockdevCreate
(
,
,
,
,
):
""""""Creates a block device for an instance.

  @type disk: L{objects.Disk}
  @param disk: the object describing the disk we should create
  @type size: int
  @param size: the size of the physical underlying device, in MiB
  @type owner: str
  @param owner: the name of the instance for which disk is created,
      used for device cache data
  @type on_primary: boolean
  @param on_primary:  indicates if it is the primary node or not
  @type info: string
  @param info: string that will be sent to the physical device
      creation, used for example to set (LVM) tags on LVs

  @return: the new unique_id of the device (this can sometime be
      computed only after creation), or None. On secondary nodes,
      it's not required to return anything.

  """"""
= []
if
.
:
for
in
.
:
try
:
=
_RecursiveAssembleBD
(
,
,
)
except
.
,
:
=
""Can't assemble device %s: %s""
% (
,
)
.
error
(
)
return False
,
if
or
.
AssembleOnSecondary
():
# we need the children open in case the device itself has to
# be assembled
try
:
.
Open
()
except
.
,
:
=
""Can't make child '%s' read-write: %s""
% (
,
)
.
error
(
)
return False
,
.
append
(
)
try
:
=
.
Create
(
.
,
.
,
,
.
)
except
.
,
:
return False
,
""Can't create block device: %s""
%
str
(
)
if
or
.
AssembleOnSecondary
():
try
:
.
Assemble
()
except
.
,
:
= (
""Can't assemble device after creation, very""
"" unusual event: %s""
%
str
(
))
.
error
(
)
return False
,
.
SetSyncSpeed
(
.
)
if
or
.
OpenOnSecondary
():
try
:
.
Open
(
=
True
)
except
.
,
:
= (
""Can't make device r/w after creation, very""
"" unusual event: %s""
%
str
(
))
.
error
(
)
return False
,
.
UpdateCache
(
.
,
,
,
.
)
.
SetInfo
(
)
=
.
return True
,
def
BlockdevRemove
(
):
""""""Remove a block device.

  @note: This is intended to be called recursively.

  @type disk: L{objects.Disk}
  @param disk: the disk object we should remove
  @rtype: boolean
  @return: the success of the operation

  """"""
= []
=
True
try
:
=
_RecursiveFindBD
(
)
except
.
,
:
# probably can't attach
.
info
(
""Can't attach to device %s in remove""
,
)
=
None
if
is not None
:
=
.
try
:
.
Remove
()
except
.
,
:
.
append
(
str
(
))
=
False
if
:
.
RemoveCache
(
)
if
.
:
for
in
.
:
,
=
BlockdevRemove
(
)
=
and
if
:
# not an empty message
.
append
(
)
return
(
,
""; ""
.
join
(
))
def
_RecursiveAssembleBD
(
,
,
):
""""""Activate a block device for an instance.

  This is run on the primary and secondary nodes for an instance.

  @note: this function is called recursively.

  @type disk: L{objects.Disk}
  @param disk: the disk we try to assemble
  @type owner: str
  @param owner: the name of the instance which owns the disk
  @type as_primary: boolean
  @param as_primary: if we should make the block device
      read/write

  @return: the assembled device or None (in case no device
      was assembled)
  @raise errors.BlockDeviceError: in case there is an error
      during the activation of the children or the device
      itself

  """"""
= []
if
.
:
=
.
ChildrenNeeded
()
if
== -
1
:
=
0
# max number of Nones allowed
else
:
=
len
(
.
) -
# max number of Nones
for
in
.
:
try
:
=
_RecursiveAssembleBD
(
,
,
)
except
.
,
:
if
.
count
(
None
) >=
:
raise
=
None
.
error
(
""Error in child activation (but continuing): %s""
,
str
(
))
.
append
(
)
if
or
.
AssembleOnSecondary
():
=
.
Assemble
(
.
,
.
,
,
.
)
.
SetSyncSpeed
(
.
)
=
if
or
.
OpenOnSecondary
():
.
Open
()
.
UpdateCache
(
.
,
,
,
.
)
else
:
=
True
return
def
BlockdevAssemble
(
,
,
):
""""""Activate a block device for an instance.

  This is a wrapper over _RecursiveAssembleBD.

  @rtype: str or boolean
  @return: a C{/dev/...} path for primary nodes, and
      C{True} for secondary nodes

  """"""
=
True
=
""no error information""
try
:
=
_RecursiveAssembleBD
(
,
,
)
if
isinstance
(
,
.
):
=
.
except
.
,
:
=
""Error while assembling disk: %s""
%
str
(
)
=
False
return
(
,
)
def
BlockdevShutdown
(
):
""""""Shut down a block device.

  First, if the device is assembled (Attach() is successful), then
  the device is shutdown. Then the children of the device are
  shutdown.

  This function is called recursively. Note that we don't cache the
  children or such, as oppossed to assemble, shutdown of different
  devices doesn't require that the upper device was active.

  @type disk: L{objects.Disk}
  @param disk: the description of the disk we should
      shutdown
  @rtype: boolean
  @return: the success of the operation

  """"""
= []
=
True
=
_RecursiveFindBD
(
)
if
is not None
:
=
.
try
:
.
Shutdown
()
.
RemoveCache
(
)
except
.
,
:
.
append
(
str
(
))
=
False
if
.
:
for
in
.
:
,
=
BlockdevShutdown
(
)
=
and
if
:
# not an empty message
.
append
(
)
return
(
,
""; ""
.
join
(
))
def
BlockdevAddchildren
(
,
):
""""""Extend a mirrored block device.

  @type parent_cdev: L{objects.Disk}
  @param parent_cdev: the disk to which we should add children
  @type new_cdevs: list of L{objects.Disk}
  @param new_cdevs: the list of children which we should add
  @rtype: boolean
  @return: the success of the operation

  """"""
=
_RecursiveFindBD
(
)
if
is None
:
.
error
(
""Can't find parent device""
)
return False
= [
_RecursiveFindBD
(
)
for
in
]
if
.
count
(
None
) >
0
:
.
error
(
""Can't find new device(s) to add: %s:%s""
,
,
)
return False
.
AddChildren
(
)
return True
def
BlockdevRemovechildren
(
,
):
""""""Shrink a mirrored block device.

  @type parent_cdev: L{objects.Disk}
  @param parent_cdev: the disk from which we should remove children
  @type new_cdevs: list of L{objects.Disk}
  @param new_cdevs: the list of children which we should remove
  @rtype: boolean
  @return: the success of the operation

  """"""
=
_RecursiveFindBD
(
)
if
is None
:
.
error
(
""Can't find parent in remove children: %s""
,
)
return False
= []
for
in
:
=
.
StaticDevPath
()
if
is None
:
=
_RecursiveFindBD
(
)
if
is None
:
.
error
(
""Can't find dynamic device %s while removing children""
,
)
return False
else
:
.
append
(
.
)
else
:
.
append
(
)
.
RemoveChildren
(
)
return True
def
BlockdevGetmirrorstatus
(
):
""""""Get the mirroring status of a list of devices.

  @type disks: list of L{objects.Disk}
  @param disks: the list of disks which we should query
  @rtype: disk
  @return:
      a list of (mirror_done, estimated_time) tuples, which
      are the result of L{bdev.BlockDev.CombinedSyncStatus}
  @raise errors.BlockDeviceError: if any of the disks cannot be
      found

  """"""
= []
for
in
:
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Can't find device %s""
%
str
(
))
.
append
(
.
CombinedSyncStatus
())
return
def
_RecursiveFindBD
(
):
""""""Check if a device is activated.

  If so, return information about the real device.

  @type disk: L{objects.Disk}
  @param disk: the disk object we need to find

  @return: None if the device can't be found,
      otherwise the device instance

  """"""
= []
if
.
:
for
in
.
:
.
append
(
_RecursiveFindBD
(
))
return
.
FindDevice
(
.
,
.
,
,
.
)
def
BlockdevFind
(
):
""""""Check if a device is activated.

  If it is, return information about the real device.

  @type disk: L{objects.Disk}
  @param disk: the disk to find
  @rtype: None or tuple
  @return: None if the disk cannot be found, otherwise a
      tuple (device_path, major, minor, sync_percent,
      estimated_time, is_degraded)

  """"""
try
:
=
_RecursiveFindBD
(
)
except
.
,
:
return
(
False
,
str
(
))
if
is None
:
return
(
True
,
None
)
return
(
True
, (
.
,
.
,
.
) +
.
GetSyncStatus
())
def
BlockdevGetsize
(
):
""""""Computes the size of the given disks.

  If a disk is not found, returns None instead.

  @type disks: list of L{objects.Disk}
  @param disks: the list of disk to compute the size for
  @rtype: list
  @return: list with elements None if the disk cannot be found,
      otherwise the size

  """"""
= []
for
in
:
try
:
=
_RecursiveFindBD
(
)
except
.
,
:
.
append
(
None
)
continue
if
is None
:
.
append
(
None
)
else
:
.
append
(
.
GetActualSize
())
return
def
UploadFile
(
,
,
,
,
,
,
):
""""""Write a file to the filesystem.

  This allows the master to overwrite(!) a file. It will only perform
  the operation if the file belongs to a list of configuration files.

  @type file_name: str
  @param file_name: the target file name
  @type data: str
  @param data: the new contents of the file
  @type mode: int
  @param mode: the mode to give the file (can be None)
  @type uid: int
  @param uid: the owner of the file (can be -1 for default)
  @type gid: int
  @param gid: the group of the file (can be -1 for default)
  @type atime: float
  @param atime: the atime to set on the file (can be None)
  @type mtime: float
  @param mtime: the mtime to set on the file (can be None)
  @rtype: boolean
  @return: the success of the operation; errors are logged
      in the node daemon log

  """"""
if not
.
.
isabs
(
):
.
error
(
""Filename passed to UploadFile is not absolute: '%s'""
,
)
return False
if
not in
:
.
error
(
""Filename passed to UploadFile not in allowed""
"" upload targets: '%s'""
,
)
return False
=
_Decompress
(
)
.
WriteFile
(
,
=
,
=
,
=
,
=
,
=
,
=
)
return True
def
WriteSsconfFiles
(
):
""""""Update all ssconf files.

  Wrapper around the SimpleStore.WriteFiles.

  """"""
.
SimpleStore
().
WriteFiles
(
)
def
_ErrnoOrStr
(
):
""""""Format an EnvironmentError exception.

  If the L{err} argument has an errno attribute, it will be looked up
  and converted into a textual C{E...} description. Otherwise the
  string representation of the error will be returned.

  @type err: L{EnvironmentError}
  @param err: the exception to format

  """"""
if
hasattr
(
,
'errno'
):
=
.
[
.
]
else
:
=
str
(
)
return
def
_OSOndiskVersion
(
,
):
""""""Compute and return the API version of a given OS.

  This function will try to read the API version of the OS given by
  the 'name' parameter and residing in the 'os_dir' directory.

  @type name: str
  @param name: the OS name we should look for
  @type os_dir: str
  @param os_dir: the directory inwhich we should look for the OS
  @rtype: int or None
  @return:
      Either an integer denoting the version or None in the
      case when this is not a valid OS name.
  @raise errors.InvalidOS: if the OS cannot be found

  """"""
=
.
.
.
join
([
,
""ganeti_api_version""
])
try
:
=
.
stat
(
)
except
EnvironmentError
,
:
raise
.
InvalidOS
(
,
,
""'ganeti_api_version' file not""
"" found (%s)""
%
_ErrnoOrStr
(
))
if not
.
S_ISREG
(
.
S_IFMT
(
.
)):
raise
.
InvalidOS
(
,
,
""'ganeti_api_version' file is not""
"" a regular file""
)
try
:
=
open
(
)
try
:
=
.
readlines
()
finally
:
.
close
()
except
EnvironmentError
,
:
raise
.
InvalidOS
(
,
,
""error while reading the""
"" API version (%s)""
%
_ErrnoOrStr
(
))
= [
.
strip
()
for
in
]
try
:
= [
int
(
)
for
in
]
except
(
TypeError
,
ValueError
),
:
raise
.
InvalidOS
(
,
,
""API version is not integer (%s)""
%
str
(
))
return
def
DiagnoseOS
(
=
None
):
""""""Compute the validity for all OSes.

  @type top_dirs: list
  @param top_dirs: the list of directories in which to
      search (if not given defaults to
      L{constants.OS_SEARCH_PATH})
  @rtype: list of L{objects.OS}
  @return: an OS object for each name in all the given
      directories

  """"""
if
is None
:
=
.
= []
for
in
:
if
.
.
isdir
(
):
try
:
=
.
ListVisibleFiles
(
)
except
EnvironmentError
,
:
.
exception
(
""Can't list the OS directory %s""
,
)
break
for
in
:
try
:
=
OSFromDisk
(
,
=
)
.
append
(
)
except
.
,
:
.
append
(
.
.
FromInvalidOS
(
))
return
def
OSFromDisk
(
,
=
None
):
""""""Create an OS instance from disk.

  This function will return an OS instance if the given name is a
  valid OS name. Otherwise, it will raise an appropriate
  L{errors.InvalidOS} exception, detailing why this is not a valid OS.

  @type base_dir: string
  @keyword base_dir: Base directory containing OS installations.
                     Defaults to a search in all the OS_SEARCH_PATH dirs.
  @rtype: L{objects.OS}
  @return: the OS instance if we find a valid one
  @raise errors.InvalidOS: if we don't find a valid OS

  """"""
if
is None
:
=
.
FindFile
(
,
.
,
.
.
)
if
is None
:
raise
.
InvalidOS
(
,
None
,
""OS dir not found in search path""
)
else
:
=
.
.
.
join
([
,
])
=
_OSOndiskVersion
(
,
)
if
.
not in
:
raise
.
InvalidOS
(
,
,
""API version mismatch""
"" (found %s want %s)""
% (
,
.
))
# OS Scripts dictionary, we will populate it with the actual script names
=
dict
.
fromkeys
(
.
)
for
in
:
[
] =
.
.
.
join
([
,
])
try
:
=
.
stat
(
[
])
except
EnvironmentError
,
:
raise
.
InvalidOS
(
,
,
""'%s' script missing (%s)""
%
(
,
_ErrnoOrStr
(
)))
if
.
S_IMODE
(
.
) &
.
!=
.
:
raise
.
InvalidOS
(
,
,
""'%s' script not executable""
%
)
if not
.
S_ISREG
(
.
S_IFMT
(
.
)):
raise
.
InvalidOS
(
,
,
""'%s' is not a regular file""
%
)
return
.
OS
(
=
,
=
,
=
.
,
=
[
.
],
=
[
.
],
=
[
.
],
=
[
.
],
=
)
def
OSEnvironment
(
,
=
0
):
""""""Calculate the environment for an os script.

  @type instance: L{objects.Instance}
  @param instance: target instance for the os script run
  @type debug: integer
  @param debug: debug level (0 or 1, for OS Api 10)
  @rtype: dict
  @return: dict of environment variables
  @raise errors.BlockDeviceError: if the block device
      cannot be found

  """"""
= {}
[
'OS_API_VERSION'
] =
'%d'
%
.
[
'INSTANCE_NAME'
] =
.
[
'INSTANCE_OS'
] =
.
[
'HYPERVISOR'
] =
.
[
'DISK_COUNT'
] =
'%d'
%
len
(
.
)
[
'NIC_COUNT'
] =
'%d'
%
len
(
.
)
[
'DEBUG_LEVEL'
] =
'%d'
%
for
,
in
enumerate
(
.
):
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Block device '%s' is not set up""
%
str
(
))
.
Open
()
[
'DISK_%d_PATH'
%
] =
.
[
'DISK_%d_ACCESS'
%
] =
.
if
.
in
.
:
[
'DISK_%d_FRONTEND_TYPE'
%
] =
.
[
.
]
if
.
in
.
:
[
'DISK_%d_BACKEND_TYPE'
%
] =
'block'
elif
.
==
.
:
[
'DISK_%d_BACKEND_TYPE'
%
] =
'file:%s'
%
.
[
0
]
for
,
in
enumerate
(
.
):
[
'NIC_%d_MAC'
%
] =
.
if
.
:
[
'NIC_%d_IP'
%
] =
.
[
'NIC_%d_BRIDGE'
%
] =
.
if
.
in
.
:
[
'NIC_%d_FRONTEND_TYPE'
%
] =
.
[
.
]
for
,
in
[(
.
,
""BE""
), (
.
,
""HV""
)]:
for
,
in
.
items
():
[
""INSTANCE_%s_%s""
% (
,
)] =
str
(
)
return
def
BlockdevGrow
(
,
):
""""""Grow a stack of block devices.

  This function is called recursively, with the childrens being the
  first ones to resize.

  @type disk: L{objects.Disk}
  @param disk: the disk to be grown
  @rtype: (status, result)
  @return: a tuple with the status of the operation
      (True/False), and the errors message if status
      is False

  """"""
=
_RecursiveFindBD
(
)
if
is None
:
return False
,
""Cannot find block device %s""
% (
,)
try
:
.
Grow
(
)
except
.
,
:
return False
,
str
(
)
return True
,
None
def
BlockdevSnapshot
(
):
""""""Create a snapshot copy of a block device.

  This function is called recursively, and the snapshot is actually created
  just for the leaf lvm backend device.

  @type disk: L{objects.Disk}
  @param disk: the disk to be snapshotted
  @rtype: string
  @return: snapshot disk path

  """"""
if
.
:
if
len
(
.
) ==
1
:
# only one child, let's recurse on it
return
BlockdevSnapshot
(
.
[
0
])
else
:
# more than one child, choose one that matches
for
in
.
:
if
.
==
.
:
# return implies breaking the loop
return
BlockdevSnapshot
(
)
elif
.
==
.
:
=
_RecursiveFindBD
(
)
if
is not None
:
# let's stay on the safe side and ask for the full size, for now
return
.
Snapshot
(
.
)
else
:
return None
else
:
raise
.
ProgrammerError
(
""Cannot snapshot non-lvm block device""
"" '%s' of type '%s'""
%
(
.
,
.
))
def
ExportSnapshot
(
,
,
,
,
):
""""""Export a block device snapshot to a remote node.

  @type disk: L{objects.Disk}
  @param disk: the description of the disk to export
  @type dest_node: str
  @param dest_node: the destination node to export to
  @type instance: L{objects.Instance}
  @param instance: the instance object to whom the disk belongs
  @type cluster_name: str
  @param cluster_name: the cluster name, needed for SSH hostalias
  @type idx: int
  @param idx: the index of the disk in the instance's disk list,
      used to export to the OS scripts environment
  @rtype: boolean
  @return: the success of the operation

  """"""
=
OSEnvironment
(
)
=
OSFromDisk
(
.
)
=
.
=
""%s/exp-%s-%s-%s.log""
% (
.
,
.
,
.
,
int
(
.
time
()))
if not
.
.
exists
(
.
):
.
mkdir
(
.
,
0750
)
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Block device '%s' is not set up""
%
str
(
))
.
Open
()
[
'EXPORT_DEVICE'
] =
.
[
'EXPORT_INDEX'
] =
str
(
)
=
.
.
join
(
.
,
.
+
"".new""
)
=
.
[
1
]
# the target command is built out of three individual commands,
# which are joined by pipes; we check each individual command for
# valid parameters
=
.
BuildShellCmd
(
""set -e; set -o pipefail; cd %s; %s 2>%s""
,
.
,
,
)
=
""gzip""
=
.
BuildShellCmd
(
""mkdir -p %s && cat > %s/%s""
,
,
,
)
=
_GetSshRunner
(
).
BuildCmd
(
,
.
,
)
# all commands have been checked, so we're safe to combine them
=
'|'
.
join
([
,
,
.
ShellQuoteArgs
(
)])
=
.
RunCmd
([
""bash""
,
""-c""
,
],
=
)
if
.
:
.
error
(
""os snapshot export command '%s' returned error: %s""
"" output: %s""
,
,
.
,
.
)
return False
return True
def
FinalizeExport
(
,
):
""""""Write out the export configuration information.

  @type instance: L{objects.Instance}
  @param instance: the instance which we export, used for
      saving configuration
  @type snap_disks: list of L{objects.Disk}
  @param snap_disks: list of snapshot block devices, which
      will be used to get the actual name of the dump file

  @rtype: boolean
  @return: the success of the operation

  """"""
=
.
.
join
(
.
,
.
+
"".new""
)
=
.
.
join
(
.
,
.
)
=
.
SerializableConfigParser
()
.
add_section
(
.
)
.
set
(
.
,
'version'
,
'0'
)
.
set
(
.
,
'timestamp'
,
'%d'
%
int
(
.
time
()))
.
set
(
.
,
'source'
,
.
)
.
set
(
.
,
'os'
,
.
)
.
set
(
.
,
'compression'
,
'gzip'
)
.
add_section
(
.
)
.
set
(
.
,
'name'
,
.
)
.
set
(
.
,
'memory'
,
'%d'
%
.
[
.
])
.
set
(
.
,
'vcpus'
,
'%d'
%
.
[
.
])
.
set
(
.
,
'disk_template'
,
.
)
=
0
for
,
in
enumerate
(
.
):
+=
1
.
set
(
.
,
'nic%d_mac'
%
,
'%s'
%
.
)
.
set
(
.
,
'nic%d_ip'
%
,
'%s'
%
.
)
.
set
(
.
,
'nic%d_bridge'
%
,
'%s'
%
.
)
# TODO: redundant: on load can read nics until it doesn't exist
.
set
(
.
,
'nic_count'
,
'%d'
%
)
=
0
for
,
in
enumerate
(
):
if
:
+=
1
.
set
(
.
,
'disk%d_ivname'
%
,
(
'%s'
%
.
))
.
set
(
.
,
'disk%d_dump'
%
,
(
'%s'
%
.
[
1
]))
.
set
(
.
,
'disk%d_size'
%
,
(
'%d'
%
.
))
.
set
(
.
,
'disk_count'
,
'%d'
%
)
.
WriteFile
(
.
.
join
(
,
.
),
=
.
Dumps
())
.
rmtree
(
,
True
)
.
move
(
,
)
return True
def
ExportInfo
(
):
""""""Get export configuration information.

  @type dest: str
  @param dest: directory containing the export

  @rtype: L{objects.SerializableConfigParser}
  @return: a serializable config file containing the
      export info

  """"""
=
.
.
join
(
,
.
)
=
.
SerializableConfigParser
()
.
read
(
)
if
(
not
.
has_section
(
.
)
or
not
.
has_section
(
.
)):
return None
return
def
ImportOSIntoInstance
(
,
,
,
):
""""""Import an os image into an instance.

  @type instance: L{objects.Instance}
  @param instance: instance to import the disks into
  @type src_node: string
  @param src_node: source node for the disk images
  @type src_images: list of string
  @param src_images: absolute paths of the disk images
  @rtype: list of boolean
  @return: each boolean represent the success of importing the n-th disk

  """"""
=
OSEnvironment
(
)
=
OSFromDisk
(
.
)
=
.
=
""%s/import-%s-%s-%s.log""
% (
.
,
.
,
.
,
int
(
.
time
()))
if not
.
.
exists
(
.
):
.
mkdir
(
.
,
0750
)
=
""gunzip""
=
.
BuildShellCmd
(
""(cd %s; %s >%s 2>&1)""
,
.
,
,
)
= []
for
,
in
enumerate
(
):
if
:
=
.
BuildShellCmd
(
'cat %s'
,
)
=
_GetSshRunner
(
).
BuildCmd
(
,
.
,
)
=
'|'
.
join
([
.
ShellQuoteArgs
(
),
,
])
[
'IMPORT_DEVICE'
] =
[
'DISK_%d_PATH'
%
]
[
'IMPORT_INDEX'
] =
str
(
)
=
.
RunCmd
(
,
=
)
if
.
:
.
error
(
""Disk import command '%s' returned error: %s""
"" output: %s""
,
,
.
,
.
)
.
append
(
False
)
else
:
.
append
(
True
)
else
:
.
append
(
True
)
return
def
ListExports
():
""""""Return a list of exports currently available on this machine.

  @rtype: list
  @return: list of the exports

  """"""
if
.
.
isdir
(
.
):
return
.
ListVisibleFiles
(
.
)
else
:
return
[]
def
RemoveExport
(
):
""""""Remove an existing export from the node.

  @type export: str
  @param export: the name of the export to remove
  @rtype: boolean
  @return: the success of the operation

  """"""
=
.
.
join
(
.
,
)
.
rmtree
(
)
# TODO: catch some of the relevant exceptions and provide a pretty
# error message if rmtree fails.
return True
def
BlockdevRename
(
):
""""""Rename a list of block devices.

  @type devlist: list of tuples
  @param devlist: list of tuples of the form  (disk,
      new_logical_id, new_physical_id); disk is an
      L{objects.Disk} object describing the current disk,
      and new logical_id/physical_id is the name we
      rename it to
  @rtype: boolean
  @return: True if all renames succeeded, False otherwise

  """"""
=
True
for
,
in
:
=
_RecursiveFindBD
(
)
if
is None
:
=
False
continue
try
:
=
.
.
Rename
(
)
=
.
if
!=
:
.
RemoveCache
(
)
# FIXME: we should add the new cache information here, like:
# DevCacheManager.UpdateCache(new_rpath, owner, ...)
# but we don't have the owner here - maybe parse from existing
# cache? for now, we only lose lvm data when we rename, which
# is less critical than DRBD or MD
except
.
:
.
exception
(
""Can't rename device '%s' to '%s'""
,
,
)
=
False
return
def
_TransformFileStorageDir
(
):
""""""Checks whether given file_storage_dir is valid.

  Checks wheter the given file_storage_dir is within the cluster-wide
  default file_storage_dir stored in SimpleStore. Only paths under that
  directory are allowed.

  @type file_storage_dir: str
  @param file_storage_dir: the path to check

  @return: the normalized path if valid, None otherwise

  """"""
=
_GetConfig
()
=
.
.
normpath
(
)
=
.
GetFileStorageDir
()
if
(
not
.
.
commonprefix
([
,
]) ==
):
.
error
(
""file storage directory '%s' is not under base file""
"" storage directory '%s'""
,
,
)
return None
return
def
CreateFileStorageDir
(
):
""""""Create file storage directory.

  @type file_storage_dir: str
  @param file_storage_dir: directory to create

  @rtype: tuple
  @return: tuple with first element a boolean indicating wheter dir
      creation was successful or not

  """"""
=
_TransformFileStorageDir
(
)
=
True
,
if not
:
=
False
,
else
:
if
.
.
exists
(
):
if not
.
.
isdir
(
):
.
error
(
""'%s' is not a directory""
,
)
=
False
,
else
:
try
:
.
makedirs
(
,
0750
)
except
OSError
,
:
.
error
(
""Cannot create file storage directory '%s': %s""
,
,
)
=
False
,
return
def
RemoveFileStorageDir
(
):
""""""Remove file storage directory.

  Remove it only if it's empty. If not log an error and return.

  @type file_storage_dir: str
  @param file_storage_dir: the directory we should cleanup
  @rtype: tuple (success,)
  @return: tuple of one element, C{success}, denoting
      whether the operation was successful

  """"""
=
_TransformFileStorageDir
(
)
=
True
,
if not
:
=
False
,
else
:
if
.
.
exists
(
):
if not
.
.
isdir
(
):
.
error
(
""'%s' is not a directory""
,
)
=
False
,
# deletes dir only if empty, otherwise we want to return False
try
:
.
rmdir
(
)
except
OSError
:
.
exception
(
""Cannot remove file storage directory '%s'""
,
)
=
False
,
return
def
RenameFileStorageDir
(
,
):
""""""Rename the file storage directory.

  @type old_file_storage_dir: str
  @param old_file_storage_dir: the current path
  @type new_file_storage_dir: str
  @param new_file_storage_dir: the name we should rename to
  @rtype: tuple (success,)
  @return: tuple of one element, C{success}, denoting
      whether the operation was successful

  """"""
=
_TransformFileStorageDir
(
)
=
_TransformFileStorageDir
(
)
=
True
,
if not
or not
:
=
False
,
else
:
if not
.
.
exists
(
):
if
.
.
isdir
(
):
try
:
.
rename
(
,
)
except
OSError
:
.
exception
(
""Cannot rename '%s' to '%s'""
,
,
)
=
False
,
else
:
.
error
(
""'%s' is not a directory""
,
)
=
False
,
else
:
if
.
.
exists
(
):
.
error
(
""Cannot rename '%s' to '%s'. Both locations exist.""
,
,
)
=
False
,
return
def
_IsJobQueueFile
(
):
""""""Checks whether the given filename is in the queue directory.

  @type file_name: str
  @param file_name: the file name we should check
  @rtype: boolean
  @return: whether the file is under the queue directory

  """"""
=
.
.
normpath
(
.
)
= (
.
.
commonprefix
([
,
]) ==
)
if not
:
.
error
(
""'%s' is not a file in the queue directory""
,
)
return
def
JobQueueUpdate
(
,
):
""""""Updates a file in the queue directory.

  This is just a wrapper over L{utils.WriteFile}, with proper
  checking.

  @type file_name: str
  @param file_name: the job file name
  @type content: str
  @param content: the new job contents
  @rtype: boolean
  @return: the success of the operation

  """"""
if not
_IsJobQueueFile
(
):
return False
# Write and replace the file atomically
.
WriteFile
(
,
=
_Decompress
(
))
return True
def
JobQueueRename
(
,
):
""""""Renames a job queue file.

  This is just a wrapper over os.rename with proper checking.

  @type old: str
  @param old: the old (actual) file name
  @type new: str
  @param new: the desired file name
  @rtype: boolean
  @return: the success of the operation

  """"""
if not
(
_IsJobQueueFile
(
)
and
_IsJobQueueFile
(
)):
return False
.
RenameFile
(
,
,
=
True
)
return True
def
JobQueueSetDrainFlag
(
):
""""""Set the drain flag for the queue.

  This will set or unset the queue drain flag.

  @type drain_flag: boolean
  @param drain_flag: if True, will set the drain flag, otherwise reset it.
  @rtype: boolean
  @return: always True
  @warning: the function always returns True

  """"""
if
:
.
WriteFile
(
.
,
=
""""
,
=
True
)
else
:
.
RemoveFile
(
.
)
return True
def
BlockdevClose
(
,
):
""""""Closes the given block devices.

  This means they will be switched to secondary mode (in case of
  DRBD).

  @param instance_name: if the argument is not empty, the symlinks
      of this instance will be removed
  @type disks: list of L{objects.Disk}
  @param disks: the list of disks to be closed
  @rtype: tuple (success, message)
  @return: a tuple of success and message, where success
      indicates the succes of the operation, and message
      which will contain the error details in case we
      failed

  """"""
= []
for
in
:
=
_RecursiveFindBD
(
)
if
is None
:
return
(
False
,
""Can't find device %s""
%
)
.
append
(
)
= []
for
in
:
try
:
.
Close
()
except
.
,
:
.
append
(
str
(
))
if
:
return
(
False
,
""Can't make devices secondary: %s""
%
"",""
.
join
(
))
else
:
if
:
_RemoveBlockDevLinks
(
,
)
return
(
True
,
""All devices secondary""
)
def
ValidateHVParams
(
,
):
""""""Validates the given hypervisor parameters.

  @type hvname: string
  @param hvname: the hypervisor name
  @type hvparams: dict
  @param hvparams: the hypervisor parameters to be validated
  @rtype: tuple (success, message)
  @return: a tuple of success and message, where success
      indicates the succes of the operation, and message
      which will contain the error details in case we
      failed

  """"""
try
:
=
.
GetHypervisor
(
)
.
ValidateParameters
(
)
return
(
True
,
""Validation passed""
)
except
.
,
:
return
(
False
,
str
(
))
def
DemoteFromMC
():
""""""Demotes the current node from master candidate role.

  """"""
# try to ensure we're not the master by mistake
,
=
.
GetMasterAndMyself
()
if
==
:
return
(
False
,
""ssconf status shows I'm the master node, will not demote""
)
=
.
DaemonPidFileName
(
.
)
if
.
IsProcessAlive
(
.
ReadPidFile
(
)):
return
(
False
,
""The master daemon is running, will not demote""
)
try
:
if
.
.
isfile
(
.
):
.
CreateBackup
(
.
)
except
EnvironmentError
,
:
if
.
!=
.
:
return
(
False
,
""Error while backing up cluster file: %s""
%
str
(
))
.
RemoveFile
(
.
)
return
(
True
,
""Done""
)
def
_FindDisks
(
,
):
""""""Sets the physical ID on disks and returns the block devices.

  """"""
# set the correct physical ID
=
.
HostInfo
().
for
in
:
.
SetPhysicalID
(
,
)
= []
for
in
:
=
_RecursiveFindBD
(
)
if
is None
:
return
(
False
,
""Can't find device %s""
%
)
.
append
(
)
return
(
True
,
)
def
DrbdDisconnectNet
(
,
):
""""""Disconnects the network on a list of drbd devices.

  """"""
,
=
_FindDisks
(
,
)
if not
:
return
,
# disconnect disks
for
in
:
try
:
.
DisconnectNet
()
except
.
,
:
.
exception
(
""Failed to go into standalone mode""
)
return
(
False
,
""Can't change network configuration: %s""
%
str
(
))
return
(
True
,
""All disks are now disconnected""
)
def
DrbdAttachNet
(
,
,
,
):
""""""Attaches the network on a list of drbd devices.

  """"""
,
=
_FindDisks
(
,
)
if not
:
return
,
if
:
for
,
in
enumerate
(
):
try
:
_SymlinkBlockDev
(
,
.
,
)
except
EnvironmentError
,
:
return
(
False
,
""Can't create symlink: %s""
%
str
(
))
# reconnect disks, switch to new master configuration and if
# needed primary mode
for
in
:
try
:
.
AttachNet
(
)
except
.
,
:
return
(
False
,
""Can't change network configuration: %s""
%
str
(
))
# wait until the disks are connected; we need to retry the re-attach
# if the device becomes standalone, as this might happen if the one
# node disconnects and reconnects in a different mode before the
# other node reconnects; in this case, one or both of the nodes will
# decide it has wrong configuration and switch to standalone
=
2
*
60
=
0.100
# start with 100 miliseconds
=
.
time
() +
while
.
time
() <
:
=
True
for
in
:
=
.
GetProcStatus
()
if not
(
.
or
.
):
=
False
if
.
:
# peer had different config info and this node became
# standalone, even though this should not happen with the
# new staged way of changing disk configs
try
:
.
AttachNet
(
)
except
.
,
:
return
(
False
,
""Can't change network configuration: %s""
%
str
(
))
if
:
break
.
sleep
(
)
=
min
(
5
,
*
1.5
)
if not
:
return
(
False
,
""Timeout in disk reconnecting""
)
if
:
# change to primary mode
for
in
:
try
:
.
Open
()
except
.
,
:
return
(
False
,
""Can't change to primary mode: %s""
%
str
(
))
if
:
=
""multi-master and primary""
else
:
=
""single-master""
return
(
True
,
""Disks are now configured as %s""
%
)
def
DrbdWaitSync
(
,
):
""""""Wait until DRBDs have synchronized.

  """"""
,
=
_FindDisks
(
,
)
if not
:
return
,
=
100
=
True
=
False
for
in
:
=
.
GetProcStatus
()
if not
(
.
or
.
):
=
True
break
=
and
(
not
.
)
if
.
is not None
:
=
min
(
,
.
)
return
(
not
, (
,
))
class
HooksRunner
(
object
):
""""""Hook runner.

  This class is instantiated on the node side (ganeti-noded) and not
  on the master side.

  """"""
def
__init__
(
,
=
None
):
""""""Constructor for hooks runner.

    @type hooks_base_dir: str or None
    @param hooks_base_dir: if not None, this overrides the
        L{constants.HOOKS_BASE_DIR} (useful for unittests)

    """"""
if
is None
:
=
.
.
=
@
staticmethod
def
ExecHook
(
,
):
""""""Exec one hook script.

    @type script: str
    @param script: the full path to the script
    @type env: dict
    @param env: the environment with which to exec the script
    @rtype: tuple (success, message)
    @return: a tuple of success and message, where success
        indicates the succes of the operation, and message
        which will contain the error details in case we
        failed

    """"""
# exec the process using subprocess and log the output
=
None
try
:
=
open
(
""/dev/null""
,
""r""
)
=
.
Popen
([
],
=
,
=
.
,
=
.
,
=
True
,
=
False
,
=
""/""
,
=
)
=
""""
try
:
=
.
.
read
(
4096
)
.
.
close
()
except
EnvironmentError
,
:
+=
""Hook script error: %s""
%
str
(
)
while True
:
try
:
=
.
wait
()
break
except
EnvironmentError
,
:
if
.
==
.
:
continue
raise
finally
:
# try not to leak fds
for
in
(
, ):
if
is not None
:
try
:
.
close
()
except
EnvironmentError
,
:
# just log the error
#logging.exception(""Error while closing fd %s"", fd)
pass
return
==
0
,
.
SafeEncode
(
.
strip
())
def
RunHooks
(
,
,
,
):
""""""Run the scripts in the hooks directory.

    @type hpath: str
    @param hpath: the path to the hooks directory which
        holds the scripts
    @type phase: str
    @param phase: either L{constants.HOOKS_PHASE_PRE} or
        L{constants.HOOKS_PHASE_POST}
    @type env: dict
    @param env: dictionary with the environment for the hook
    @rtype: list
    @return: list of 3-element tuples:
      - script path
      - script result, either L{constants.HKR_SUCCESS} or
        L{constants.HKR_FAIL}
      - output of the script

    @raise errors.ProgrammerError: for invalid input
        parameters

    """"""
if
==
.
:
=
""pre""
elif
==
.
:
=
""post""
else
:
raise
.
ProgrammerError
(
""Unknown hooks phase: '%s'""
%
)
= []
=
""%s-%s.d""
% (
,
)
=
""%s/%s""
% (
.
,
)
try
:
=
.
ListVisibleFiles
(
)
except
OSError
:
# FIXME: must log output in case of failures
return
# we use the standard python sort order,
# so 00name is the recommended naming scheme
.
sort
()
for
in
:
=
.
.
join
(
,
)
if not
(
.
.
isfile
(
)
and
.
access
(
,
.
)
and
.
.
match
(
)
is not None
):
=
.
=
""""
else
:
,
=
.
ExecHook
(
,
)
if not
:
=
.
else
:
=
.
.
append
((
""%s/%s""
% (
,
),
,
))
return
class
IAllocatorRunner
(
object
):
""""""IAllocator runner.

  This class is instantiated on the node side (ganeti-noded) and not on
  the master side.

  """"""
def
Run
(
,
,
):
""""""Run an iallocator script.

    @type name: str
    @param name: the iallocator script name
    @type idata: str
    @param idata: the allocator input data

    @rtype: tuple
    @return: four element tuple of:
       - run status (one of the IARUN_ constants)
       - stdout
       - stderr
       - fail reason (as from L{utils.RunResult})

    """"""
=
.
FindFile
(
,
.
,
.
.
)
if
is None
:
return
(
.
,
None
,
None
,
None
)
,
=
.
mkstemp
(
=
""ganeti-iallocator.""
)
try
:
.
write
(
,
)
.
close
(
)
=
.
RunCmd
([
,
])
if
.
:
return
(
.
,
.
,
.
,
.
)
finally
:
.
unlink
(
)
return
(
.
,
.
,
.
,
None
)
class
DevCacheManager
(
object
):
""""""Simple class for managing a cache of block device information.

  """"""
=
""/dev/""
=
.
@
classmethod
def
_ConvertPath
(
,
):
""""""Converts a /dev/name path to the cache file name.

    This replaces slashes with underscores and strips the /dev
    prefix. It then returns the full path to the cache file.

    @type dev_path: str
    @param dev_path: the C{/dev/} path name
    @rtype: str
    @return: the converted path name

    """"""
if
.
startswith
(
.
):
=
[
len
(
.
):]
=
.
replace
(
""/""
,
""_""
)
=
""%s/bdev_%s""
% (
.
,
)
return
@
classmethod
def
UpdateCache
(
,
,
,
,
):
""""""Updates the cache information for a given device.

    @type dev_path: str
    @param dev_path: the pathname of the device
    @type owner: str
    @param owner: the owner (instance name) of the device
    @type on_primary: bool
    @param on_primary: whether this is the primary
        node nor not
    @type iv_name: str
    @param iv_name: the instance-visible name of the
        device, as in objects.Disk.iv_name

    @rtype: None

    """"""
if
is None
:
.
error
(
""DevCacheManager.UpdateCache got a None dev_path""
)
return
=
.
_ConvertPath
(
)
if
:
=
""primary""
else
:
=
""secondary""
if
is None
:
=
""not_visible""
=
""%s %s %s
\n
""
% (
str
(
),
,
)
try
:
.
WriteFile
(
,
=
)
except
EnvironmentError
:
.
exception
(
""Can't update bdev cache for %s""
,
)
@
classmethod
def
RemoveCache
(
,
):
""""""Remove data for a dev_path.

    This is just a wrapper over L{utils.RemoveFile} with a converted
    path name and logging.

    @type dev_path: str
    @param dev_path: the pathname of the device

    @rtype: None

    """"""
if
is None
:
.
error
(
""DevCacheManager.RemoveCache got a None dev_path""
)
return
=
.
_ConvertPath
(
)
try
:
.
RemoveFile
(
)
except
EnvironmentError
:
.
exception
(
""Can't update bdev cache for %s""
,
)
","#
#
# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
""""""Functions used by the node daemon

@var _ALLOWED_UPLOAD_FILES: denotes which files are accepted in
     the L{UploadFile} function

""""""
import
import
.
import
import
import
import
import
import
import
import
import
import
import
from
import
from
import
from
import
from
import
from
import
from
import
from
import
from
import
def
_GetConfig
():
""""""Simple wrapper to return a SimpleStore.

  @rtype: L{ssconf.SimpleStore}
  @return: a SimpleStore instance

  """"""
return
.
SimpleStore
()
def
_GetSshRunner
(
):
""""""Simple wrapper to return an SshRunner.

  @type cluster_name: str
  @param cluster_name: the cluster name, which is needed
      by the SshRunner constructor
  @rtype: L{ssh.SshRunner}
  @return: an SshRunner instance

  """"""
return
.
SshRunner
(
)
def
_Decompress
(
):
""""""Unpacks data compressed by the RPC client.

  @type data: list or tuple
  @param data: Data sent by RPC client
  @rtype: str
  @return: Decompressed data

  """"""
assert
isinstance
(
, (
list
,
tuple
))
assert
len
(
) ==
2
(
,
) =
if
==
.
:
return
elif
==
.
:
return
.
decompress
(
.
b64decode
(
))
else
:
raise
AssertionError
(
""Unknown data encoding""
)
def
_CleanDirectory
(
,
=
None
):
""""""Removes all regular files in a directory.

  @type path: str
  @param path: the directory to clean
  @type exclude: list
  @param exclude: list of files to be excluded, defaults
      to the empty list

  """"""
if not
.
.
isdir
(
):
return
if
is None
:
= []
else
:
# Normalize excluded paths
= [
.
.
normpath
(
)
for
in
]
for
in
.
ListVisibleFiles
(
):
=
.
.
normpath
(
.
.
join
(
,
))
if
in
:
continue
if
.
.
isfile
(
)
and not
.
.
islink
(
):
.
RemoveFile
(
)
def
_BuildUploadFileList
():
""""""Build the list of allowed upload files.

  This is abstracted so that it's built only once at module import time.

  """"""
return
frozenset
([
.
,
.
,
.
,
.
,
])
=
_BuildUploadFileList
()
def
JobQueuePurge
():
""""""Removes job queue files and archived jobs.

  @rtype: None

  """"""
_CleanDirectory
(
.
,
=[
.
])
_CleanDirectory
(
.
)
def
GetMasterInfo
():
""""""Returns master information.

  This is an utility function to compute master information, either
  for consumption here or from the node daemon.

  @rtype: tuple
  @return: (master_netdev, master_ip, master_name) if we have a good
      configuration, otherwise (None, None, None)

  """"""
try
:
=
_GetConfig
()
=
.
GetMasterNetdev
()
=
.
GetMasterIP
()
=
.
GetMasterNode
()
except
.
:
.
exception
(
""Cluster configuration incomplete""
)
return
(
None
,
None
,
None
)
return
(
,
,
)
def
StartMaster
(
,
):
""""""Activate local node as master node.

  The function will always try activate the IP address of the master
  (unless someone else has it). It will also start the master daemons,
  based on the start_daemons parameter.

  @type start_daemons: boolean
  @param start_daemons: whther to also start the master
      daemons (ganeti-masterd and ganeti-rapi)
  @type no_voting: boolean
  @param no_voting: whether to start ganeti-masterd without a node vote
      (if start_daemons is True), but still non-interactively
  @rtype: None

  """"""
=
True
,
,
=
GetMasterInfo
()
if not
:
return False
if
.
TcpPing
(
,
.
):
if
.
OwnIpAddress
(
):
# we already have the ip:
.
debug
(
""Already started""
)
else
:
.
error
(
""Someone else has the master ip, not activating""
)
=
False
else
:
=
.
RunCmd
([
""ip""
,
""address""
,
""add""
,
""%s/32""
%
,
""dev""
,
,
""label""
,
""%s:0""
%
])
if
.
:
.
error
(
""Can't activate master IP: %s""
,
.
)
=
False
=
.
RunCmd
([
""arping""
,
""-q""
,
""-U""
,
""-c 3""
,
""-I""
,
,
""-s""
,
,
])
# we'll ignore the exit code of arping
# and now start the master and rapi daemons
if
:
= {
'ganeti-masterd'
: [],
'ganeti-rapi'
: [],
}
if
:
[
'ganeti-masterd'
].
append
(
'--no-voting'
)
[
'ganeti-masterd'
].
append
(
'--yes-do-it'
)
for
in
:
= [
]
.
extend
(
[
])
=
.
RunCmd
(
)
if
.
:
.
error
(
""Can't start daemon %s: %s""
,
,
.
)
=
False
return
def
StopMaster
(
):
""""""Deactivate this node as master.

  The function will always try to deactivate the IP address of the
  master. It will also stop the master daemons depending on the
  stop_daemons parameter.

  @type stop_daemons: boolean
  @param stop_daemons: whether to also stop the master daemons
      (ganeti-masterd and ganeti-rapi)
  @rtype: None

  """"""
,
,
=
GetMasterInfo
()
if not
:
return False
=
.
RunCmd
([
""ip""
,
""address""
,
""del""
,
""%s/32""
%
,
""dev""
,
])
if
.
:
.
error
(
""Can't remove the master IP, error: %s""
,
.
)
# but otherwise ignore the failure
if
:
# stop/kill the rapi and the master daemon
for
in
.
,
.
:
.
KillProcess
(
.
ReadPidFile
(
.
DaemonPidFileName
(
)))
return True
def
AddNode
(
,
,
,
,
,
):
""""""Joins this node to the cluster.

  This does the following:
      - updates the hostkeys of the machine (rsa and dsa)
      - adds the ssh private key to the user
      - adds the ssh public key to the users' authorized_keys file

  @type dsa: str
  @param dsa: the DSA private key to write
  @type dsapub: str
  @param dsapub: the DSA public key to write
  @type rsa: str
  @param rsa: the RSA private key to write
  @type rsapub: str
  @param rsapub: the RSA public key to write
  @type sshkey: str
  @param sshkey: the SSH private key to write
  @type sshpub: str
  @param sshpub: the SSH public key to write
  @rtype: boolean
  @return: the success of the operation

  """"""
=  [(
.
,
,
0600
),
(
.
,
,
0644
),
(
.
,
,
0600
),
(
.
,
,
0644
)]
for
,
,
in
:
.
WriteFile
(
,
=
,
=
)
try
:
,
,
=
.
GetUserFiles
(
.
,
=
True
)
except
.
,
:
=
""Error while processing user ssh files""
.
exception
(
)
return
(
False
,
""%s: %s""
% (
,
))
for
,
in
[(
,
), (
,
)]:
.
WriteFile
(
,
=
,
=
0600
)
.
AddAuthorizedKey
(
,
)
.
RunCmd
([
.
,
""restart""
])
return
(
True
,
""Node added successfully""
)
def
LeaveCluster
():
""""""Cleans up and remove the current node.

  This function cleans up and prepares the current node to be removed
  from the cluster.

  If processing is successful, then it raises an
  L{errors.QuitGanetiException} which is used as a special case to
  shutdown the node daemon.

  """"""
_CleanDirectory
(
.
)
JobQueuePurge
()
try
:
,
,
=
.
GetUserFiles
(
.
)
except
.
:
.
exception
(
""Error while processing ssh files""
)
return
=
open
(
,
'r'
)
try
:
.
RemoveAuthorizedKey
(
,
.
read
(
8192
))
finally
:
.
close
()
.
RemoveFile
(
)
.
RemoveFile
(
)
# Return a reassuring string to the caller, and quit
raise
.
QuitGanetiException
(
False
,
'Shutdown scheduled'
)
def
GetNodeInfo
(
,
):
""""""Gives back a hash with different information about the node.

  @type vgname: C{string}
  @param vgname: the name of the volume group to ask for disk space information
  @type hypervisor_type: C{str}
  @param hypervisor_type: the name of the hypervisor to ask for
      memory information
  @rtype: C{dict}
  @return: dictionary with the following keys:
      - vg_size is the size of the configured volume group in MiB
      - vg_free is the free size of the volume group in MiB
      - memory_dom0 is the memory allocated for domain0 in MiB
      - memory_free is the currently available (free) ram in MiB
      - memory_total is the total number of ram in MiB

  """"""
= {}
=
_GetVGInfo
(
)
[
'vg_size'
] =
[
'vg_size'
]
[
'vg_free'
] =
[
'vg_free'
]
=
.
GetHypervisor
(
)
=
.
GetNodeInfo
()
if
is not None
:
.
update
(
)
=
open
(
""/proc/sys/kernel/random/boot_id""
,
'r'
)
try
:
[
""bootid""
] =
.
read
(
128
).
rstrip
(
""
\n
""
)
finally
:
.
close
()
return
def
VerifyNode
(
,
):
""""""Verify the status of the local node.

  Based on the input L{what} parameter, various checks are done on the
  local node.

  If the I{filelist} key is present, this list of
  files is checksummed and the file/checksum pairs are returned.

  If the I{nodelist} key is present, we check that we have
  connectivity via ssh with the target nodes (and check the hostname
  report).

  If the I{node-net-test} key is present, we check that we have
  connectivity to the given nodes via both primary IP and, if
  applicable, secondary IPs.

  @type what: C{dict}
  @param what: a dictionary of things to check:
      - filelist: list of files for which to compute checksums
      - nodelist: list of nodes we should check ssh communication with
      - node-net-test: list of nodes we should check node daemon port
        connectivity with
      - hypervisor: list with hypervisors to run the verify for
  @rtype: dict
  @return: a dictionary with the same keys as the input dict, and
      values representing the result of the checks

  """"""
= {}
if
.
in
:
[
.
] =
= {}
for
in
[
.
]:
[
] =
.
GetHypervisor
(
).
Verify
()
if
.
in
:
[
.
] =
.
FingerprintFiles
(
[
.
])
if
.
in
:
[
.
] =
= {}
.
shuffle
(
[
.
])
for
in
[
.
]:
,
=
_GetSshRunner
(
).
VerifyNodeHostname
(
)
if not
:
[
] =
if
.
in
:
[
.
] =
= {}
=
.
HostInfo
().
=
=
None
for
,
,
in
[
.
]:
if
==
:
=
=
break
if not
:
[
] = (
""Can't find my own primary/secondary IP""
"" in the node list""
)
else
:
=
.
GetNodeDaemonPort
()
for
,
,
in
[
.
]:
= []
if not
.
TcpPing
(
,
,
=
):
.
append
(
""primary""
)
if
!=
:
if not
.
TcpPing
(
,
,
=
):
.
append
(
""secondary""
)
if
:
[
] = (
""failure using the %s interface(s)""
%
"" and ""
.
join
(
))
if
.
in
:
[
.
] =
GetVolumeList
(
[
.
])
if
.
in
:
[
.
] =
GetInstanceList
(
[
.
])
if
.
in
:
[
.
] =
ListVolumeGroups
()
if
.
in
:
[
.
] = (
.
,
.
)
if
.
in
:
=
.
GetHypervisor
(
[
.
])
[
.
] =
.
GetNodeInfo
()
if
.
in
:
try
:
=
.
.
GetUsedDevs
().
keys
()
except
.
,
:
.
warning
(
""Can't get used minors list""
,
=
True
)
=
str
(
)
[
.
] =
return
def
GetVolumeList
(
):
""""""Compute list of logical volumes and their size.

  @type vg_name: str
  @param vg_name: the volume group whose LVs we should list
  @rtype: dict
  @return:
      dictionary of all partions (key) with value being a tuple of
      their size (in MiB), inactive and online status::

        {'test1': ('20.06', True, True)}

      in case of errors, a string is returned with the error
      details.

  """"""
= {}
=
'|'
=
.
RunCmd
([
""lvs""
,
""--noheadings""
,
""--units=m""
,
""--nosuffix""
,
""--separator=%s""
%
,
""-olv_name,lv_size,lv_attr""
,
])
if
.
:
.
error
(
""Failed to list logical volumes, lvs output: %s""
,
.
)
return
.
=
.
compile
(
""^ *([^|]+)\|([0-9.]+)\|([^|]{6})\|?$""
)
for
in
.
.
splitlines
():
=
.
strip
()
=
.
match
(
)
if not
:
.
error
(
""Invalid line returned from lvs output: '%s'""
,
)
continue
,
,
=
.
groups
()
=
[
4
] ==
'-'
=
[
5
] ==
'o'
[
] = (
,
,
)
return
def
ListVolumeGroups
():
""""""List the volume groups and their size.

  @rtype: dict
  @return: dictionary with keys volume name and values the
      size of the volume

  """"""
return
.
ListVolumeGroups
()
def
NodeVolumes
():
""""""List all volumes on this node.

  @rtype: list
  @return:
    A list of dictionaries, each having four keys:
      - name: the logical volume name,
      - size: the size of the logical volume
      - dev: the physical device on which the LV lives
      - vg: the volume group to which it belongs

    In case of errors, we return an empty list and log the
    error.

    Note that since a logical volume can live on multiple physical
    volumes, the resulting list might include a logical volume
    multiple times.

  """"""
=
.
RunCmd
([
""lvs""
,
""--noheadings""
,
""--units=m""
,
""--nosuffix""
,
""--separator=|""
,
""--options=lv_name,lv_size,devices,vg_name""
])
if
.
:
.
error
(
""Failed to list logical volumes, lvs output: %s""
,
.
)
return
[]
def
parse_dev
(
):
if
'('
in
:
return
.
split
(
'('
)[
0
]
else
:
return
def
map_line
(
):
return
{
'name'
:
[
0
].
strip
(),
'size'
:
[
1
].
strip
(),
'dev'
:
parse_dev
(
[
2
].
strip
()),
'vg'
:
[
3
].
strip
(),
}
return
[
map_line
(
.
split
(
'|'
))
for
in
.
.
splitlines
()
if
.
count
(
'|'
) >=
3
]
def
BridgesExist
(
):
""""""Check if a list of bridges exist on the current node.

  @rtype: boolean
  @return: C{True} if all of them exist, C{False} otherwise

  """"""
for
in
:
if not
.
BridgeExists
(
):
return False
return True
def
GetInstanceList
(
):
""""""Provides a list of instances.

  @type hypervisor_list: list
  @param hypervisor_list: the list of hypervisors to query information

  @rtype: list
  @return: a list of all running instances on the current node
    - instance1.example.com
    - instance2.example.com

  """"""
= []
for
in
:
try
:
=
.
GetHypervisor
(
).
ListInstances
()
.
extend
(
)
except
.
:
.
exception
(
""Error enumerating instances for hypevisor %s""
,
)
raise
return
def
GetInstanceInfo
(
,
):
""""""Gives back the information about an instance as a dictionary.

  @type instance: string
  @param instance: the instance name
  @type hname: string
  @param hname: the hypervisor type of the instance

  @rtype: dict
  @return: dictionary with the following keys:
      - memory: memory size of instance (int)
      - state: xen state of instance (string)
      - time: cpu time of instance (float)

  """"""
= {}
=
.
GetHypervisor
(
).
GetInstanceInfo
(
)
if
is not None
:
[
'memory'
] =
[
2
]
[
'state'
] =
[
4
]
[
'time'
] =
[
5
]
return
def
GetInstanceMigratable
(
):
""""""Gives whether an instance can be migrated.

  @type instance: L{objects.Instance}
  @param instance: object representing the instance to be checked.

  @rtype: tuple
  @return: tuple of (result, description) where:
      - result: whether the instance can be migrated or not
      - description: a description of the issue, if relevant

  """"""
=
.
GetHypervisor
(
.
)
if
.
not in
.
ListInstances
():
return
(
False
,
'not running'
)
for
in
range
(
len
(
.
)):
=
_GetBlockDevSymlinkPath
(
.
,
)
if not
.
.
islink
(
):
return
(
False
,
'not restarted since ganeti 1.2.5'
)
return
(
True
,
''
)
def
GetAllInstancesInfo
(
):
""""""Gather data about all instances.

  This is the equivalent of L{GetInstanceInfo}, except that it
  computes data for all instances at once, thus being faster if one
  needs data about more than one instance.

  @type hypervisor_list: list
  @param hypervisor_list: list of hypervisors to query for instance data

  @rtype: dict
  @return: dictionary of instance: data, with data having the following keys:
      - memory: memory size of instance (int)
      - state: xen state of instance (string)
      - time: cpu time of instance (float)
      - vcpus: the number of vcpus

  """"""
= {}
for
in
:
=
.
GetHypervisor
(
).
GetAllInstancesInfo
()
if
:
for
,
,
,
,
,
in
:
= {
'memory'
:
,
'vcpus'
:
,
'state'
:
,
'time'
:
,
}
if
in
:
# we only check static parameters, like memory and vcpus,
# and not state and time which can change between the
# invocations of the different hypervisors
for
in
'memory'
,
'vcpus'
:
if
[
] !=
[
][
]:
raise
.
HypervisorError
(
""Instance %s is running twice""
"" with different parameters""
%
)
[
] =
return
def
InstanceOsAdd
(
):
""""""Add an OS to an instance.

  @type instance: L{objects.Instance}
  @param instance: Instance whose OS is to be installed
  @rtype: boolean
  @return: the success of the operation

  """"""
try
:
=
OSFromDisk
(
.
)
except
.
,
:
,
,
=
.
if
is None
:
return
(
False
,
""Can't find OS '%s': %s""
% (
,
))
else
:
return
(
False
,
""Error parsing OS '%s' in directory %s: %s""
%
(
,
,
))
=
OSEnvironment
(
)
=
""%s/add-%s-%s-%d.log""
% (
.
,
.
,
.
,
int
(
.
time
()))
=
.
RunCmd
([
.
],
=
,
=
.
,
=
,)
if
.
:
.
error
(
""os create command '%s' returned error: %s, logfile: %s,""
"" output: %s""
,
.
,
.
,
,
.
)
= [
.
SafeEncode
(
)
for
in
.
TailFile
(
,
=
20
)]
return
(
False
,
""OS create script failed (%s), last lines in the""
"" log file:
\n
%s""
% (
.
,
""
\n
""
.
join
(
)))
return
(
True
,
""Successfully installed""
)
def
RunRenameInstance
(
,
):
""""""Run the OS rename script for an instance.

  @type instance: L{objects.Instance}
  @param instance: Instance whose OS is to be installed
  @type old_name: string
  @param old_name: previous instance name
  @rtype: boolean
  @return: the success of the operation

  """"""
=
OSFromDisk
(
.
)
=
OSEnvironment
(
)
[
'OLD_INSTANCE_NAME'
] =
=
""%s/rename-%s-%s-%s-%d.log""
% (
.
,
.
,
,
.
,
int
(
.
time
()))
=
.
RunCmd
([
.
],
=
,
=
.
,
=
)
if
.
:
.
error
(
""os create command '%s' returned error: %s output: %s""
,
.
,
.
,
.
)
= [
.
SafeEncode
(
)
for
in
.
TailFile
(
,
=
20
)]
return
(
False
,
""OS rename script failed (%s), last lines in the""
"" log file:
\n
%s""
% (
.
,
""
\n
""
.
join
(
)))
return
(
True
,
""Rename successful""
)
def
_GetVGInfo
(
):
""""""Get information about the volume group.

  @type vg_name: str
  @param vg_name: the volume group which we query
  @rtype: dict
  @return:
    A dictionary with the following keys:
      - C{vg_size} is the total size of the volume group in MiB
      - C{vg_free} is the free size of the volume group in MiB
      - C{pv_count} are the number of physical disks in that VG

    If an error occurs during gathering of data, we return the same dict
    with keys all set to None.

  """"""
=
dict
.
fromkeys
([
""vg_size""
,
""vg_free""
,
""pv_count""
])
=
.
RunCmd
([
""vgs""
,
""-ovg_size,vg_free,pv_count""
,
""--noheadings""
,
""--nosuffix""
,
""--units=m""
,
""--separator=:""
,
])
if
.
:
.
error
(
""volume group %s not present""
,
)
return
=
.
.
strip
().
rstrip
(
':'
).
split
(
':'
)
if
len
(
) ==
3
:
try
:
= {
""vg_size""
:
int
(
round
(
float
(
[
0
]),
0
)),
""vg_free""
:
int
(
round
(
float
(
[
1
]),
0
)),
""pv_count""
:
int
(
[
2
]),
}
except
ValueError
,
:
.
exception
(
""Fail to parse vgs output""
)
else
:
.
error
(
""vgs output has the wrong number of fields (expected""
"" three): %s""
,
str
(
))
return
def
_GetBlockDevSymlinkPath
(
,
):
return
.
.
join
(
.
,
""%s:%d""
% (
,
))
def
_SymlinkBlockDev
(
,
,
):
""""""Set up symlinks to a instance's block device.

  This is an auxiliary function run when an instance is start (on the primary
  node) or when an instance is migrated (on the target node).


  @param instance_name: the name of the target instance
  @param device_path: path of the physical block device, on the node
  @param idx: the disk index
  @return: absolute path to the disk's symlink

  """"""
=
_GetBlockDevSymlinkPath
(
,
)
try
:
.
symlink
(
,
)
except
OSError
,
:
if
.
==
.
:
if
(
not
.
.
islink
(
)
or
.
readlink
(
) !=
):
.
remove
(
)
.
symlink
(
,
)
else
:
raise
return
def
_RemoveBlockDevLinks
(
,
):
""""""Remove the block device symlinks belonging to the given instance.

  """"""
for
,
in
enumerate
(
):
=
_GetBlockDevSymlinkPath
(
,
)
if
.
.
islink
(
):
try
:
.
remove
(
)
except
OSError
:
.
exception
(
""Can't remove symlink '%s'""
,
)
def
_GatherAndLinkBlockDevs
(
):
""""""Set up an instance's block device(s).

  This is run on the primary node at instance startup. The block
  devices must be already assembled.

  @type instance: L{objects.Instance}
  @param instance: the instance whose disks we shoul assemble
  @rtype: list
  @return: list of (disk_object, device_path)

  """"""
= []
for
,
in
enumerate
(
.
):
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Block device '%s' is not set up.""
%
str
(
))
.
Open
()
try
:
=
_SymlinkBlockDev
(
.
,
.
,
)
except
OSError
,
:
raise
.
BlockDeviceError
(
""Cannot create block device symlink: %s""
%
.
)
.
append
((
,
))
return
def
StartInstance
(
):
""""""Start an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance object
  @rtype: boolean
  @return: whether the startup was successful or not

  """"""
=
GetInstanceList
([
.
])
if
.
in
:
return
(
True
,
""Already running""
)
try
:
=
_GatherAndLinkBlockDevs
(
)
=
.
GetHypervisor
(
.
)
.
StartInstance
(
,
)
except
.
,
:
.
exception
(
""Failed to start instance""
)
return
(
False
,
""Block device error: %s""
%
str
(
))
except
.
,
:
.
exception
(
""Failed to start instance""
)
_RemoveBlockDevLinks
(
.
,
.
)
return
(
False
,
""Hypervisor error: %s""
%
str
(
))
return
(
True
,
""Instance started successfully""
)
def
InstanceShutdown
(
):
""""""Shut an instance down.

  @note: this functions uses polling with a hardcoded timeout.

  @type instance: L{objects.Instance}
  @param instance: the instance object
  @rtype: boolean
  @return: whether the startup was successful or not

  """"""
=
.
=
GetInstanceList
([
])
if
.
not in
:
return
(
True
,
""Instance already stopped""
)
=
.
GetHypervisor
(
)
try
:
.
StopInstance
(
)
except
.
,
:
=
""Failed to stop instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
# test every 10secs for 2min
.
sleep
(
1
)
for
in
range
(
11
):
if
.
not in
GetInstanceList
([
]):
break
.
sleep
(
10
)
else
:
# the shutdown did not succeed
.
error
(
""Shutdown of '%s' unsuccessful, using destroy""
,
.
)
try
:
.
StopInstance
(
,
=
True
)
except
.
,
:
=
""Failed to force stop instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
.
sleep
(
1
)
if
.
in
GetInstanceList
([
]):
= (
""Could not shutdown instance %s even by destroy""
%
.
)
.
error
(
)
return
(
False
,
)
_RemoveBlockDevLinks
(
.
,
.
)
return
(
True
,
""Instance has been shutdown successfully""
)
def
InstanceReboot
(
,
):
""""""Reboot an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance object to reboot
  @type reboot_type: str
  @param reboot_type: the type of reboot, one the following
    constants:
      - L{constants.INSTANCE_REBOOT_SOFT}: only reboot the
        instance OS, do not recreate the VM
      - L{constants.INSTANCE_REBOOT_HARD}: tear down and
        restart the VM (at the hypervisor level)
      - the other reboot type (L{constants.INSTANCE_REBOOT_FULL}) is
        not accepted here, since that mode is handled differently, in
        cmdlib, and translates into full stop and start of the
        instance (instead of a call_instance_reboot RPC)
  @rtype: boolean
  @return: the success of the operation

  """"""
=
GetInstanceList
([
.
])
if
.
not in
:
=
""Cannot reboot instance %s that is not running""
%
.
.
error
(
)
return
(
False
,
)
=
.
GetHypervisor
(
.
)
if
==
.
:
try
:
.
RebootInstance
(
)
except
.
,
:
=
""Failed to soft reboot instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
elif
==
.
:
try
:
=
InstanceShutdown
(
)
if not
[
0
]:
return
return
StartInstance
(
)
except
.
,
:
=
""Failed to hard reboot instance %s: %s""
% (
.
,
)
.
error
(
)
return
(
False
,
)
else
:
return
(
False
,
""Invalid reboot_type received: %s""
% (
,))
return
(
True
,
""Reboot successful""
)
def
MigrationInfo
(
):
""""""Gather information about an instance to be migrated.

  @type instance: L{objects.Instance}
  @param instance: the instance definition

  """"""
=
.
GetHypervisor
(
.
)
try
:
=
.
MigrationInfo
(
)
except
.
,
:
=
""Failed to fetch migration information""
.
exception
(
)
return
(
False
,
'%s: %s'
% (
,
))
return
(
True
,
)
def
AcceptInstance
(
,
,
):
""""""Prepare the node to accept an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance definition
  @type info: string/data (opaque)
  @param info: migration information, from the source node
  @type target: string
  @param target: target host (usually ip), on this node

  """"""
=
.
GetHypervisor
(
.
)
try
:
.
AcceptInstance
(
,
,
)
except
.
,
:
=
""Failed to accept instance""
.
exception
(
)
return
(
False
,
'%s: %s'
% (
,
))
return
(
True
,
""Accept successful""
)
def
FinalizeMigration
(
,
,
):
""""""Finalize any preparation to accept an instance.

  @type instance: L{objects.Instance}
  @param instance: the instance definition
  @type info: string/data (opaque)
  @param info: migration information, from the source node
  @type success: boolean
  @param success: whether the migration was a success or a failure

  """"""
=
.
GetHypervisor
(
.
)
try
:
.
FinalizeMigration
(
,
,
)
except
.
,
:
=
""Failed to finalize migration""
.
exception
(
)
return
(
False
,
'%s: %s'
% (
,
))
return
(
True
,
""Migration Finalized""
)
def
MigrateInstance
(
,
,
):
""""""Migrates an instance to another node.

  @type instance: L{objects.Instance}
  @param instance: the instance definition
  @type target: string
  @param target: the target node name
  @type live: boolean
  @param live: whether the migration should be done live or not (the
      interpretation of this parameter is left to the hypervisor)
  @rtype: tuple
  @return: a tuple of (success, msg) where:
      - succes is a boolean denoting the success/failure of the operation
      - msg is a string with details in case of failure

  """"""
=
.
GetHypervisor
(
.
)
try
:
.
MigrateInstance
(
.
,
,
)
except
.
,
:
=
""Failed to migrate instance""
.
exception
(
)
return
(
False
,
""%s: %s""
% (
,
))
return
(
True
,
""Migration successful""
)
def
BlockdevCreate
(
,
,
,
,
):
""""""Creates a block device for an instance.

  @type disk: L{objects.Disk}
  @param disk: the object describing the disk we should create
  @type size: int
  @param size: the size of the physical underlying device, in MiB
  @type owner: str
  @param owner: the name of the instance for which disk is created,
      used for device cache data
  @type on_primary: boolean
  @param on_primary:  indicates if it is the primary node or not
  @type info: string
  @param info: string that will be sent to the physical device
      creation, used for example to set (LVM) tags on LVs

  @return: the new unique_id of the device (this can sometime be
      computed only after creation), or None. On secondary nodes,
      it's not required to return anything.

  """"""
= []
if
.
:
for
in
.
:
try
:
=
_RecursiveAssembleBD
(
,
,
)
except
.
,
:
=
""Can't assemble device %s: %s""
% (
,
)
.
error
(
)
return False
,
if
or
.
AssembleOnSecondary
():
# we need the children open in case the device itself has to
# be assembled
try
:
.
Open
()
except
.
,
:
=
""Can't make child '%s' read-write: %s""
% (
,
)
.
error
(
)
return False
,
.
append
(
)
try
:
=
.
Create
(
.
,
.
,
,
.
)
except
.
,
:
return False
,
""Can't create block device: %s""
%
str
(
)
if
or
.
AssembleOnSecondary
():
try
:
.
Assemble
()
except
.
,
:
= (
""Can't assemble device after creation, very""
"" unusual event: %s""
%
str
(
))
.
error
(
)
return False
,
.
SetSyncSpeed
(
.
)
if
or
.
OpenOnSecondary
():
try
:
.
Open
(
=
True
)
except
.
,
:
= (
""Can't make device r/w after creation, very""
"" unusual event: %s""
%
str
(
))
.
error
(
)
return False
,
.
UpdateCache
(
.
,
,
,
.
)
.
SetInfo
(
)
=
.
return True
,
def
BlockdevRemove
(
):
""""""Remove a block device.

  @note: This is intended to be called recursively.

  @type disk: L{objects.Disk}
  @param disk: the disk object we should remove
  @rtype: boolean
  @return: the success of the operation

  """"""
= []
=
True
try
:
=
_RecursiveFindBD
(
)
except
.
,
:
# probably can't attach
.
info
(
""Can't attach to device %s in remove""
,
)
=
None
if
is not None
:
=
.
try
:
.
Remove
()
except
.
,
:
.
append
(
str
(
))
=
False
if
:
.
RemoveCache
(
)
if
.
:
for
in
.
:
,
=
BlockdevRemove
(
)
=
and
if
:
# not an empty message
.
append
(
)
return
(
,
""; ""
.
join
(
))
def
_RecursiveAssembleBD
(
,
,
):
""""""Activate a block device for an instance.

  This is run on the primary and secondary nodes for an instance.

  @note: this function is called recursively.

  @type disk: L{objects.Disk}
  @param disk: the disk we try to assemble
  @type owner: str
  @param owner: the name of the instance which owns the disk
  @type as_primary: boolean
  @param as_primary: if we should make the block device
      read/write

  @return: the assembled device or None (in case no device
      was assembled)
  @raise errors.BlockDeviceError: in case there is an error
      during the activation of the children or the device
      itself

  """"""
= []
if
.
:
=
.
ChildrenNeeded
()
if
== -
1
:
=
0
# max number of Nones allowed
else
:
=
len
(
.
) -
# max number of Nones
for
in
.
:
try
:
=
_RecursiveAssembleBD
(
,
,
)
except
.
,
:
if
.
count
(
None
) >=
:
raise
=
None
.
error
(
""Error in child activation (but continuing): %s""
,
str
(
))
.
append
(
)
if
or
.
AssembleOnSecondary
():
=
.
Assemble
(
.
,
.
,
,
.
)
.
SetSyncSpeed
(
.
)
=
if
or
.
OpenOnSecondary
():
.
Open
()
.
UpdateCache
(
.
,
,
,
.
)
else
:
=
True
return
def
BlockdevAssemble
(
,
,
):
""""""Activate a block device for an instance.

  This is a wrapper over _RecursiveAssembleBD.

  @rtype: str or boolean
  @return: a C{/dev/...} path for primary nodes, and
      C{True} for secondary nodes

  """"""
=
True
=
""no error information""
try
:
=
_RecursiveAssembleBD
(
,
,
)
if
isinstance
(
,
.
):
=
.
except
.
,
:
=
""Error while assembling disk: %s""
%
str
(
)
=
False
return
(
,
)
def
BlockdevShutdown
(
):
""""""Shut down a block device.

  First, if the device is assembled (Attach() is successful), then
  the device is shutdown. Then the children of the device are
  shutdown.

  This function is called recursively. Note that we don't cache the
  children or such, as oppossed to assemble, shutdown of different
  devices doesn't require that the upper device was active.

  @type disk: L{objects.Disk}
  @param disk: the description of the disk we should
      shutdown
  @rtype: boolean
  @return: the success of the operation

  """"""
= []
=
True
=
_RecursiveFindBD
(
)
if
is not None
:
=
.
try
:
.
Shutdown
()
.
RemoveCache
(
)
except
.
,
:
.
append
(
str
(
))
=
False
if
.
:
for
in
.
:
,
=
BlockdevShutdown
(
)
=
and
if
:
# not an empty message
.
append
(
)
return
(
,
""; ""
.
join
(
))
def
BlockdevAddchildren
(
,
):
""""""Extend a mirrored block device.

  @type parent_cdev: L{objects.Disk}
  @param parent_cdev: the disk to which we should add children
  @type new_cdevs: list of L{objects.Disk}
  @param new_cdevs: the list of children which we should add
  @rtype: boolean
  @return: the success of the operation

  """"""
=
_RecursiveFindBD
(
)
if
is None
:
.
error
(
""Can't find parent device""
)
return False
= [
_RecursiveFindBD
(
)
for
in
]
if
.
count
(
None
) >
0
:
.
error
(
""Can't find new device(s) to add: %s:%s""
,
,
)
return False
.
AddChildren
(
)
return True
def
BlockdevRemovechildren
(
,
):
""""""Shrink a mirrored block device.

  @type parent_cdev: L{objects.Disk}
  @param parent_cdev: the disk from which we should remove children
  @type new_cdevs: list of L{objects.Disk}
  @param new_cdevs: the list of children which we should remove
  @rtype: boolean
  @return: the success of the operation

  """"""
=
_RecursiveFindBD
(
)
if
is None
:
.
error
(
""Can't find parent in remove children: %s""
,
)
return False
= []
for
in
:
=
.
StaticDevPath
()
if
is None
:
=
_RecursiveFindBD
(
)
if
is None
:
.
error
(
""Can't find dynamic device %s while removing children""
,
)
return False
else
:
.
append
(
.
)
else
:
.
append
(
)
.
RemoveChildren
(
)
return True
def
BlockdevGetmirrorstatus
(
):
""""""Get the mirroring status of a list of devices.

  @type disks: list of L{objects.Disk}
  @param disks: the list of disks which we should query
  @rtype: disk
  @return:
      a list of (mirror_done, estimated_time) tuples, which
      are the result of L{bdev.BlockDev.CombinedSyncStatus}
  @raise errors.BlockDeviceError: if any of the disks cannot be
      found

  """"""
= []
for
in
:
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Can't find device %s""
%
str
(
))
.
append
(
.
CombinedSyncStatus
())
return
def
_RecursiveFindBD
(
):
""""""Check if a device is activated.

  If so, return information about the real device.

  @type disk: L{objects.Disk}
  @param disk: the disk object we need to find

  @return: None if the device can't be found,
      otherwise the device instance

  """"""
= []
if
.
:
for
in
.
:
.
append
(
_RecursiveFindBD
(
))
return
.
FindDevice
(
.
,
.
,
,
.
)
def
BlockdevFind
(
):
""""""Check if a device is activated.

  If it is, return information about the real device.

  @type disk: L{objects.Disk}
  @param disk: the disk to find
  @rtype: None or tuple
  @return: None if the disk cannot be found, otherwise a
      tuple (device_path, major, minor, sync_percent,
      estimated_time, is_degraded)

  """"""
try
:
=
_RecursiveFindBD
(
)
except
.
,
:
return
(
False
,
str
(
))
if
is None
:
return
(
True
,
None
)
return
(
True
, (
.
,
.
,
.
) +
.
GetSyncStatus
())
def
BlockdevGetsize
(
):
""""""Computes the size of the given disks.

  If a disk is not found, returns None instead.

  @type disks: list of L{objects.Disk}
  @param disks: the list of disk to compute the size for
  @rtype: list
  @return: list with elements None if the disk cannot be found,
      otherwise the size

  """"""
= []
for
in
:
try
:
=
_RecursiveFindBD
(
)
except
.
,
:
.
append
(
None
)
continue
if
is None
:
.
append
(
None
)
else
:
.
append
(
.
GetActualSize
())
return
def
UploadFile
(
,
,
,
,
,
,
):
""""""Write a file to the filesystem.

  This allows the master to overwrite(!) a file. It will only perform
  the operation if the file belongs to a list of configuration files.

  @type file_name: str
  @param file_name: the target file name
  @type data: str
  @param data: the new contents of the file
  @type mode: int
  @param mode: the mode to give the file (can be None)
  @type uid: int
  @param uid: the owner of the file (can be -1 for default)
  @type gid: int
  @param gid: the group of the file (can be -1 for default)
  @type atime: float
  @param atime: the atime to set on the file (can be None)
  @type mtime: float
  @param mtime: the mtime to set on the file (can be None)
  @rtype: boolean
  @return: the success of the operation; errors are logged
      in the node daemon log

  """"""
if not
.
.
isabs
(
):
.
error
(
""Filename passed to UploadFile is not absolute: '%s'""
,
)
return False
if
not in
:
.
error
(
""Filename passed to UploadFile not in allowed""
"" upload targets: '%s'""
,
)
return False
=
_Decompress
(
)
.
WriteFile
(
,
=
,
=
,
=
,
=
,
=
,
=
)
return True
def
WriteSsconfFiles
(
):
""""""Update all ssconf files.

  Wrapper around the SimpleStore.WriteFiles.

  """"""
.
SimpleStore
().
WriteFiles
(
)
def
_ErrnoOrStr
(
):
""""""Format an EnvironmentError exception.

  If the L{err} argument has an errno attribute, it will be looked up
  and converted into a textual C{E...} description. Otherwise the
  string representation of the error will be returned.

  @type err: L{EnvironmentError}
  @param err: the exception to format

  """"""
if
hasattr
(
,
'errno'
):
=
.
[
.
]
else
:
=
str
(
)
return
def
_OSOndiskVersion
(
,
):
""""""Compute and return the API version of a given OS.

  This function will try to read the API version of the OS given by
  the 'name' parameter and residing in the 'os_dir' directory.

  @type name: str
  @param name: the OS name we should look for
  @type os_dir: str
  @param os_dir: the directory inwhich we should look for the OS
  @rtype: int or None
  @return:
      Either an integer denoting the version or None in the
      case when this is not a valid OS name.
  @raise errors.InvalidOS: if the OS cannot be found

  """"""
=
.
.
.
join
([
,
""ganeti_api_version""
])
try
:
=
.
stat
(
)
except
EnvironmentError
,
:
raise
.
InvalidOS
(
,
,
""'ganeti_api_version' file not""
"" found (%s)""
%
_ErrnoOrStr
(
))
if not
.
S_ISREG
(
.
S_IFMT
(
.
)):
raise
.
InvalidOS
(
,
,
""'ganeti_api_version' file is not""
"" a regular file""
)
try
:
=
open
(
)
try
:
=
.
readlines
()
finally
:
.
close
()
except
EnvironmentError
,
:
raise
.
InvalidOS
(
,
,
""error while reading the""
"" API version (%s)""
%
_ErrnoOrStr
(
))
= [
.
strip
()
for
in
]
try
:
= [
int
(
)
for
in
]
except
(
TypeError
,
ValueError
),
:
raise
.
InvalidOS
(
,
,
""API version is not integer (%s)""
%
str
(
))
return
def
DiagnoseOS
(
=
None
):
""""""Compute the validity for all OSes.

  @type top_dirs: list
  @param top_dirs: the list of directories in which to
      search (if not given defaults to
      L{constants.OS_SEARCH_PATH})
  @rtype: list of L{objects.OS}
  @return: an OS object for each name in all the given
      directories

  """"""
if
is None
:
=
.
= []
for
in
:
if
.
.
isdir
(
):
try
:
=
.
ListVisibleFiles
(
)
except
EnvironmentError
,
:
.
exception
(
""Can't list the OS directory %s""
,
)
break
for
in
:
try
:
=
OSFromDisk
(
,
=
)
.
append
(
)
except
.
,
:
.
append
(
.
.
FromInvalidOS
(
))
return
def
OSFromDisk
(
,
=
None
):
""""""Create an OS instance from disk.

  This function will return an OS instance if the given name is a
  valid OS name. Otherwise, it will raise an appropriate
  L{errors.InvalidOS} exception, detailing why this is not a valid OS.

  @type base_dir: string
  @keyword base_dir: Base directory containing OS installations.
                     Defaults to a search in all the OS_SEARCH_PATH dirs.
  @rtype: L{objects.OS}
  @return: the OS instance if we find a valid one
  @raise errors.InvalidOS: if we don't find a valid OS

  """"""
if
is None
:
=
.
FindFile
(
,
.
,
.
.
)
else
:
=
.
FindFile
(
, [
],
.
.
)
if
is None
:
raise
.
InvalidOS
(
,
None
,
""OS dir not found in search path""
)
=
_OSOndiskVersion
(
,
)
if
.
not in
:
raise
.
InvalidOS
(
,
,
""API version mismatch""
"" (found %s want %s)""
% (
,
.
))
# OS Scripts dictionary, we will populate it with the actual script names
=
dict
.
fromkeys
(
.
)
for
in
:
[
] =
.
.
.
join
([
,
])
try
:
=
.
stat
(
[
])
except
EnvironmentError
,
:
raise
.
InvalidOS
(
,
,
""'%s' script missing (%s)""
%
(
,
_ErrnoOrStr
(
)))
if
.
S_IMODE
(
.
) &
.
!=
.
:
raise
.
InvalidOS
(
,
,
""'%s' script not executable""
%
)
if not
.
S_ISREG
(
.
S_IFMT
(
.
)):
raise
.
InvalidOS
(
,
,
""'%s' is not a regular file""
%
)
return
.
OS
(
=
,
=
,
=
.
,
=
[
.
],
=
[
.
],
=
[
.
],
=
[
.
],
=
)
def
OSEnvironment
(
,
=
0
):
""""""Calculate the environment for an os script.

  @type instance: L{objects.Instance}
  @param instance: target instance for the os script run
  @type debug: integer
  @param debug: debug level (0 or 1, for OS Api 10)
  @rtype: dict
  @return: dict of environment variables
  @raise errors.BlockDeviceError: if the block device
      cannot be found

  """"""
= {}
[
'OS_API_VERSION'
] =
'%d'
%
.
[
'INSTANCE_NAME'
] =
.
[
'INSTANCE_OS'
] =
.
[
'HYPERVISOR'
] =
.
[
'DISK_COUNT'
] =
'%d'
%
len
(
.
)
[
'NIC_COUNT'
] =
'%d'
%
len
(
.
)
[
'DEBUG_LEVEL'
] =
'%d'
%
for
,
in
enumerate
(
.
):
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Block device '%s' is not set up""
%
str
(
))
.
Open
()
[
'DISK_%d_PATH'
%
] =
.
[
'DISK_%d_ACCESS'
%
] =
.
if
.
in
.
:
[
'DISK_%d_FRONTEND_TYPE'
%
] =
.
[
.
]
if
.
in
.
:
[
'DISK_%d_BACKEND_TYPE'
%
] =
'block'
elif
.
==
.
:
[
'DISK_%d_BACKEND_TYPE'
%
] =
'file:%s'
%
.
[
0
]
for
,
in
enumerate
(
.
):
[
'NIC_%d_MAC'
%
] =
.
if
.
:
[
'NIC_%d_IP'
%
] =
.
[
'NIC_%d_BRIDGE'
%
] =
.
if
.
in
.
:
[
'NIC_%d_FRONTEND_TYPE'
%
] =
.
[
.
]
for
,
in
[(
.
,
""BE""
), (
.
,
""HV""
)]:
for
,
in
.
items
():
[
""INSTANCE_%s_%s""
% (
,
)] =
str
(
)
return
def
BlockdevGrow
(
,
):
""""""Grow a stack of block devices.

  This function is called recursively, with the childrens being the
  first ones to resize.

  @type disk: L{objects.Disk}
  @param disk: the disk to be grown
  @rtype: (status, result)
  @return: a tuple with the status of the operation
      (True/False), and the errors message if status
      is False

  """"""
=
_RecursiveFindBD
(
)
if
is None
:
return False
,
""Cannot find block device %s""
% (
,)
try
:
.
Grow
(
)
except
.
,
:
return False
,
str
(
)
return True
,
None
def
BlockdevSnapshot
(
):
""""""Create a snapshot copy of a block device.

  This function is called recursively, and the snapshot is actually created
  just for the leaf lvm backend device.

  @type disk: L{objects.Disk}
  @param disk: the disk to be snapshotted
  @rtype: string
  @return: snapshot disk path

  """"""
if
.
:
if
len
(
.
) ==
1
:
# only one child, let's recurse on it
return
BlockdevSnapshot
(
.
[
0
])
else
:
# more than one child, choose one that matches
for
in
.
:
if
.
==
.
:
# return implies breaking the loop
return
BlockdevSnapshot
(
)
elif
.
==
.
:
=
_RecursiveFindBD
(
)
if
is not None
:
# let's stay on the safe side and ask for the full size, for now
return
.
Snapshot
(
.
)
else
:
return None
else
:
raise
.
ProgrammerError
(
""Cannot snapshot non-lvm block device""
"" '%s' of type '%s'""
%
(
.
,
.
))
def
ExportSnapshot
(
,
,
,
,
):
""""""Export a block device snapshot to a remote node.

  @type disk: L{objects.Disk}
  @param disk: the description of the disk to export
  @type dest_node: str
  @param dest_node: the destination node to export to
  @type instance: L{objects.Instance}
  @param instance: the instance object to whom the disk belongs
  @type cluster_name: str
  @param cluster_name: the cluster name, needed for SSH hostalias
  @type idx: int
  @param idx: the index of the disk in the instance's disk list,
      used to export to the OS scripts environment
  @rtype: boolean
  @return: the success of the operation

  """"""
=
OSEnvironment
(
)
=
OSFromDisk
(
.
)
=
.
=
""%s/exp-%s-%s-%s.log""
% (
.
,
.
,
.
,
int
(
.
time
()))
if not
.
.
exists
(
.
):
.
mkdir
(
.
,
0750
)
=
_RecursiveFindBD
(
)
if
is None
:
raise
.
BlockDeviceError
(
""Block device '%s' is not set up""
%
str
(
))
.
Open
()
[
'EXPORT_DEVICE'
] =
.
[
'EXPORT_INDEX'
] =
str
(
)
=
.
.
join
(
.
,
.
+
"".new""
)
=
.
[
1
]
# the target command is built out of three individual commands,
# which are joined by pipes; we check each individual command for
# valid parameters
=
.
BuildShellCmd
(
""set -e; set -o pipefail; cd %s; %s 2>%s""
,
.
,
,
)
=
""gzip""
=
.
BuildShellCmd
(
""mkdir -p %s && cat > %s/%s""
,
,
,
)
=
_GetSshRunner
(
).
BuildCmd
(
,
.
,
)
# all commands have been checked, so we're safe to combine them
=
'|'
.
join
([
,
,
.
ShellQuoteArgs
(
)])
=
.
RunCmd
([
""bash""
,
""-c""
,
],
=
)
if
.
:
.
error
(
""os snapshot export command '%s' returned error: %s""
"" output: %s""
,
,
.
,
.
)
return False
return True
def
FinalizeExport
(
,
):
""""""Write out the export configuration information.

  @type instance: L{objects.Instance}
  @param instance: the instance which we export, used for
      saving configuration
  @type snap_disks: list of L{objects.Disk}
  @param snap_disks: list of snapshot block devices, which
      will be used to get the actual name of the dump file

  @rtype: boolean
  @return: the success of the operation

  """"""
=
.
.
join
(
.
,
.
+
"".new""
)
=
.
.
join
(
.
,
.
)
=
.
SerializableConfigParser
()
.
add_section
(
.
)
.
set
(
.
,
'version'
,
'0'
)
.
set
(
.
,
'timestamp'
,
'%d'
%
int
(
.
time
()))
.
set
(
.
,
'source'
,
.
)
.
set
(
.
,
'os'
,
.
)
.
set
(
.
,
'compression'
,
'gzip'
)
.
add_section
(
.
)
.
set
(
.
,
'name'
,
.
)
.
set
(
.
,
'memory'
,
'%d'
%
.
[
.
])
.
set
(
.
,
'vcpus'
,
'%d'
%
.
[
.
])
.
set
(
.
,
'disk_template'
,
.
)
=
0
for
,
in
enumerate
(
.
):
+=
1
.
set
(
.
,
'nic%d_mac'
%
,
'%s'
%
.
)
.
set
(
.
,
'nic%d_ip'
%
,
'%s'
%
.
)
.
set
(
.
,
'nic%d_bridge'
%
,
'%s'
%
.
)
# TODO: redundant: on load can read nics until it doesn't exist
.
set
(
.
,
'nic_count'
,
'%d'
%
)
=
0
for
,
in
enumerate
(
):
if
:
+=
1
.
set
(
.
,
'disk%d_ivname'
%
,
(
'%s'
%
.
))
.
set
(
.
,
'disk%d_dump'
%
,
(
'%s'
%
.
[
1
]))
.
set
(
.
,
'disk%d_size'
%
,
(
'%d'
%
.
))
.
set
(
.
,
'disk_count'
,
'%d'
%
)
.
WriteFile
(
.
.
join
(
,
.
),
=
.
Dumps
())
.
rmtree
(
,
True
)
.
move
(
,
)
return True
def
ExportInfo
(
):
""""""Get export configuration information.

  @type dest: str
  @param dest: directory containing the export

  @rtype: L{objects.SerializableConfigParser}
  @return: a serializable config file containing the
      export info

  """"""
=
.
.
join
(
,
.
)
=
.
SerializableConfigParser
()
.
read
(
)
if
(
not
.
has_section
(
.
)
or
not
.
has_section
(
.
)):
return None
return
def
ImportOSIntoInstance
(
,
,
,
):
""""""Import an os image into an instance.

  @type instance: L{objects.Instance}
  @param instance: instance to import the disks into
  @type src_node: string
  @param src_node: source node for the disk images
  @type src_images: list of string
  @param src_images: absolute paths of the disk images
  @rtype: list of boolean
  @return: each boolean represent the success of importing the n-th disk

  """"""
=
OSEnvironment
(
)
=
OSFromDisk
(
.
)
=
.
=
""%s/import-%s-%s-%s.log""
% (
.
,
.
,
.
,
int
(
.
time
()))
if not
.
.
exists
(
.
):
.
mkdir
(
.
,
0750
)
=
""gunzip""
=
.
BuildShellCmd
(
""(cd %s; %s >%s 2>&1)""
,
.
,
,
)
= []
for
,
in
enumerate
(
):
if
:
=
.
BuildShellCmd
(
'cat %s'
,
)
=
_GetSshRunner
(
).
BuildCmd
(
,
.
,
)
=
'|'
.
join
([
.
ShellQuoteArgs
(
),
,
])
[
'IMPORT_DEVICE'
] =
[
'DISK_%d_PATH'
%
]
[
'IMPORT_INDEX'
] =
str
(
)
=
.
RunCmd
(
,
=
)
if
.
:
.
error
(
""Disk import command '%s' returned error: %s""
"" output: %s""
,
,
.
,
.
)
.
append
(
False
)
else
:
.
append
(
True
)
else
:
.
append
(
True
)
return
def
ListExports
():
""""""Return a list of exports currently available on this machine.

  @rtype: list
  @return: list of the exports

  """"""
if
.
.
isdir
(
.
):
return
.
ListVisibleFiles
(
.
)
else
:
return
[]
def
RemoveExport
(
):
""""""Remove an existing export from the node.

  @type export: str
  @param export: the name of the export to remove
  @rtype: boolean
  @return: the success of the operation

  """"""
=
.
.
join
(
.
,
)
.
rmtree
(
)
# TODO: catch some of the relevant exceptions and provide a pretty
# error message if rmtree fails.
return True
def
BlockdevRename
(
):
""""""Rename a list of block devices.

  @type devlist: list of tuples
  @param devlist: list of tuples of the form  (disk,
      new_logical_id, new_physical_id); disk is an
      L{objects.Disk} object describing the current disk,
      and new logical_id/physical_id is the name we
      rename it to
  @rtype: boolean
  @return: True if all renames succeeded, False otherwise

  """"""
=
True
for
,
in
:
=
_RecursiveFindBD
(
)
if
is None
:
=
False
continue
try
:
=
.
.
Rename
(
)
=
.
if
!=
:
.
RemoveCache
(
)
# FIXME: we should add the new cache information here, like:
# DevCacheManager.UpdateCache(new_rpath, owner, ...)
# but we don't have the owner here - maybe parse from existing
# cache? for now, we only lose lvm data when we rename, which
# is less critical than DRBD or MD
except
.
:
.
exception
(
""Can't rename device '%s' to '%s'""
,
,
)
=
False
return
def
_TransformFileStorageDir
(
):
""""""Checks whether given file_storage_dir is valid.

  Checks wheter the given file_storage_dir is within the cluster-wide
  default file_storage_dir stored in SimpleStore. Only paths under that
  directory are allowed.

  @type file_storage_dir: str
  @param file_storage_dir: the path to check

  @return: the normalized path if valid, None otherwise

  """"""
=
_GetConfig
()
=
.
.
normpath
(
)
=
.
GetFileStorageDir
()
if
(
not
.
.
commonprefix
([
,
]) ==
):
.
error
(
""file storage directory '%s' is not under base file""
"" storage directory '%s'""
,
,
)
return None
return
def
CreateFileStorageDir
(
):
""""""Create file storage directory.

  @type file_storage_dir: str
  @param file_storage_dir: directory to create

  @rtype: tuple
  @return: tuple with first element a boolean indicating wheter dir
      creation was successful or not

  """"""
=
_TransformFileStorageDir
(
)
=
True
,
if not
:
=
False
,
else
:
if
.
.
exists
(
):
if not
.
.
isdir
(
):
.
error
(
""'%s' is not a directory""
,
)
=
False
,
else
:
try
:
.
makedirs
(
,
0750
)
except
OSError
,
:
.
error
(
""Cannot create file storage directory '%s': %s""
,
,
)
=
False
,
return
def
RemoveFileStorageDir
(
):
""""""Remove file storage directory.

  Remove it only if it's empty. If not log an error and return.

  @type file_storage_dir: str
  @param file_storage_dir: the directory we should cleanup
  @rtype: tuple (success,)
  @return: tuple of one element, C{success}, denoting
      whether the operation was successful

  """"""
=
_TransformFileStorageDir
(
)
=
True
,
if not
:
=
False
,
else
:
if
.
.
exists
(
):
if not
.
.
isdir
(
):
.
error
(
""'%s' is not a directory""
,
)
=
False
,
# deletes dir only if empty, otherwise we want to return False
try
:
.
rmdir
(
)
except
OSError
:
.
exception
(
""Cannot remove file storage directory '%s'""
,
)
=
False
,
return
def
RenameFileStorageDir
(
,
):
""""""Rename the file storage directory.

  @type old_file_storage_dir: str
  @param old_file_storage_dir: the current path
  @type new_file_storage_dir: str
  @param new_file_storage_dir: the name we should rename to
  @rtype: tuple (success,)
  @return: tuple of one element, C{success}, denoting
      whether the operation was successful

  """"""
=
_TransformFileStorageDir
(
)
=
_TransformFileStorageDir
(
)
=
True
,
if not
or not
:
=
False
,
else
:
if not
.
.
exists
(
):
if
.
.
isdir
(
):
try
:
.
rename
(
,
)
except
OSError
:
.
exception
(
""Cannot rename '%s' to '%s'""
,
,
)
=
False
,
else
:
.
error
(
""'%s' is not a directory""
,
)
=
False
,
else
:
if
.
.
exists
(
):
.
error
(
""Cannot rename '%s' to '%s'. Both locations exist.""
,
,
)
=
False
,
return
def
_IsJobQueueFile
(
):
""""""Checks whether the given filename is in the queue directory.

  @type file_name: str
  @param file_name: the file name we should check
  @rtype: boolean
  @return: whether the file is under the queue directory

  """"""
=
.
.
normpath
(
.
)
= (
.
.
commonprefix
([
,
]) ==
)
if not
:
.
error
(
""'%s' is not a file in the queue directory""
,
)
return
def
JobQueueUpdate
(
,
):
""""""Updates a file in the queue directory.

  This is just a wrapper over L{utils.WriteFile}, with proper
  checking.

  @type file_name: str
  @param file_name: the job file name
  @type content: str
  @param content: the new job contents
  @rtype: boolean
  @return: the success of the operation

  """"""
if not
_IsJobQueueFile
(
):
return False
# Write and replace the file atomically
.
WriteFile
(
,
=
_Decompress
(
))
return True
def
JobQueueRename
(
,
):
""""""Renames a job queue file.

  This is just a wrapper over os.rename with proper checking.

  @type old: str
  @param old: the old (actual) file name
  @type new: str
  @param new: the desired file name
  @rtype: boolean
  @return: the success of the operation

  """"""
if not
(
_IsJobQueueFile
(
)
and
_IsJobQueueFile
(
)):
return False
.
RenameFile
(
,
,
=
True
)
return True
def
JobQueueSetDrainFlag
(
):
""""""Set the drain flag for the queue.

  This will set or unset the queue drain flag.

  @type drain_flag: boolean
  @param drain_flag: if True, will set the drain flag, otherwise reset it.
  @rtype: boolean
  @return: always True
  @warning: the function always returns True

  """"""
if
:
.
WriteFile
(
.
,
=
""""
,
=
True
)
else
:
.
RemoveFile
(
.
)
return True
def
BlockdevClose
(
,
):
""""""Closes the given block devices.

  This means they will be switched to secondary mode (in case of
  DRBD).

  @param instance_name: if the argument is not empty, the symlinks
      of this instance will be removed
  @type disks: list of L{objects.Disk}
  @param disks: the list of disks to be closed
  @rtype: tuple (success, message)
  @return: a tuple of success and message, where success
      indicates the succes of the operation, and message
      which will contain the error details in case we
      failed

  """"""
= []
for
in
:
=
_RecursiveFindBD
(
)
if
is None
:
return
(
False
,
""Can't find device %s""
%
)
.
append
(
)
= []
for
in
:
try
:
.
Close
()
except
.
,
:
.
append
(
str
(
))
if
:
return
(
False
,
""Can't make devices secondary: %s""
%
"",""
.
join
(
))
else
:
if
:
_RemoveBlockDevLinks
(
,
)
return
(
True
,
""All devices secondary""
)
def
ValidateHVParams
(
,
):
""""""Validates the given hypervisor parameters.

  @type hvname: string
  @param hvname: the hypervisor name
  @type hvparams: dict
  @param hvparams: the hypervisor parameters to be validated
  @rtype: tuple (success, message)
  @return: a tuple of success and message, where success
      indicates the succes of the operation, and message
      which will contain the error details in case we
      failed

  """"""
try
:
=
.
GetHypervisor
(
)
.
ValidateParameters
(
)
return
(
True
,
""Validation passed""
)
except
.
,
:
return
(
False
,
str
(
))
def
DemoteFromMC
():
""""""Demotes the current node from master candidate role.

  """"""
# try to ensure we're not the master by mistake
,
=
.
GetMasterAndMyself
()
if
==
:
return
(
False
,
""ssconf status shows I'm the master node, will not demote""
)
=
.
DaemonPidFileName
(
.
)
if
.
IsProcessAlive
(
.
ReadPidFile
(
)):
return
(
False
,
""The master daemon is running, will not demote""
)
try
:
if
.
.
isfile
(
.
):
.
CreateBackup
(
.
)
except
EnvironmentError
,
:
if
.
!=
.
:
return
(
False
,
""Error while backing up cluster file: %s""
%
str
(
))
.
RemoveFile
(
.
)
return
(
True
,
""Done""
)
def
_FindDisks
(
,
):
""""""Sets the physical ID on disks and returns the block devices.

  """"""
# set the correct physical ID
=
.
HostInfo
().
for
in
:
.
SetPhysicalID
(
,
)
= []
for
in
:
=
_RecursiveFindBD
(
)
if
is None
:
return
(
False
,
""Can't find device %s""
%
)
.
append
(
)
return
(
True
,
)
def
DrbdDisconnectNet
(
,
):
""""""Disconnects the network on a list of drbd devices.

  """"""
,
=
_FindDisks
(
,
)
if not
:
return
,
# disconnect disks
for
in
:
try
:
.
DisconnectNet
()
except
.
,
:
.
exception
(
""Failed to go into standalone mode""
)
return
(
False
,
""Can't change network configuration: %s""
%
str
(
))
return
(
True
,
""All disks are now disconnected""
)
def
DrbdAttachNet
(
,
,
,
):
""""""Attaches the network on a list of drbd devices.

  """"""
,
=
_FindDisks
(
,
)
if not
:
return
,
if
:
for
,
in
enumerate
(
):
try
:
_SymlinkBlockDev
(
,
.
,
)
except
EnvironmentError
,
:
return
(
False
,
""Can't create symlink: %s""
%
str
(
))
# reconnect disks, switch to new master configuration and if
# needed primary mode
for
in
:
try
:
.
AttachNet
(
)
except
.
,
:
return
(
False
,
""Can't change network configuration: %s""
%
str
(
))
# wait until the disks are connected; we need to retry the re-attach
# if the device becomes standalone, as this might happen if the one
# node disconnects and reconnects in a different mode before the
# other node reconnects; in this case, one or both of the nodes will
# decide it has wrong configuration and switch to standalone
=
2
*
60
=
0.100
# start with 100 miliseconds
=
.
time
() +
while
.
time
() <
:
=
True
for
in
:
=
.
GetProcStatus
()
if not
(
.
or
.
):
=
False
if
.
:
# peer had different config info and this node became
# standalone, even though this should not happen with the
# new staged way of changing disk configs
try
:
.
AttachNet
(
)
except
.
,
:
return
(
False
,
""Can't change network configuration: %s""
%
str
(
))
if
:
break
.
sleep
(
)
=
min
(
5
,
*
1.5
)
if not
:
return
(
False
,
""Timeout in disk reconnecting""
)
if
:
# change to primary mode
for
in
:
try
:
.
Open
()
except
.
,
:
return
(
False
,
""Can't change to primary mode: %s""
%
str
(
))
if
:
=
""multi-master and primary""
else
:
=
""single-master""
return
(
True
,
""Disks are now configured as %s""
%
)
def
DrbdWaitSync
(
,
):
""""""Wait until DRBDs have synchronized.

  """"""
,
=
_FindDisks
(
,
)
if not
:
return
,
=
100
=
True
=
False
for
in
:
=
.
GetProcStatus
()
if not
(
.
or
.
):
=
True
break
=
and
(
not
.
)
if
.
is not None
:
=
min
(
,
.
)
return
(
not
, (
,
))
class
HooksRunner
(
object
):
""""""Hook runner.

  This class is instantiated on the node side (ganeti-noded) and not
  on the master side.

  """"""
def
__init__
(
,
=
None
):
""""""Constructor for hooks runner.

    @type hooks_base_dir: str or None
    @param hooks_base_dir: if not None, this overrides the
        L{constants.HOOKS_BASE_DIR} (useful for unittests)

    """"""
if
is None
:
=
.
.
=
@
staticmethod
def
ExecHook
(
,
):
""""""Exec one hook script.

    @type script: str
    @param script: the full path to the script
    @type env: dict
    @param env: the environment with which to exec the script
    @rtype: tuple (success, message)
    @return: a tuple of success and message, where success
        indicates the succes of the operation, and message
        which will contain the error details in case we
        failed

    """"""
# exec the process using subprocess and log the output
=
None
try
:
=
open
(
""/dev/null""
,
""r""
)
=
.
Popen
([
],
=
,
=
.
,
=
.
,
=
True
,
=
False
,
=
""/""
,
=
)
=
""""
try
:
=
.
.
read
(
4096
)
.
.
close
()
except
EnvironmentError
,
:
+=
""Hook script error: %s""
%
str
(
)
while True
:
try
:
=
.
wait
()
break
except
EnvironmentError
,
:
if
.
==
.
:
continue
raise
finally
:
# try not to leak fds
for
in
(
, ):
if
is not None
:
try
:
.
close
()
except
EnvironmentError
,
:
# just log the error
#logging.exception(""Error while closing fd %s"", fd)
pass
return
==
0
,
.
SafeEncode
(
.
strip
())
def
RunHooks
(
,
,
,
):
""""""Run the scripts in the hooks directory.

    @type hpath: str
    @param hpath: the path to the hooks directory which
        holds the scripts
    @type phase: str
    @param phase: either L{constants.HOOKS_PHASE_PRE} or
        L{constants.HOOKS_PHASE_POST}
    @type env: dict
    @param env: dictionary with the environment for the hook
    @rtype: list
    @return: list of 3-element tuples:
      - script path
      - script result, either L{constants.HKR_SUCCESS} or
        L{constants.HKR_FAIL}
      - output of the script

    @raise errors.ProgrammerError: for invalid input
        parameters

    """"""
if
==
.
:
=
""pre""
elif
==
.
:
=
""post""
else
:
raise
.
ProgrammerError
(
""Unknown hooks phase: '%s'""
%
)
= []
=
""%s-%s.d""
% (
,
)
=
""%s/%s""
% (
.
,
)
try
:
=
.
ListVisibleFiles
(
)
except
OSError
:
# FIXME: must log output in case of failures
return
# we use the standard python sort order,
# so 00name is the recommended naming scheme
.
sort
()
for
in
:
=
.
.
join
(
,
)
if not
(
.
.
isfile
(
)
and
.
access
(
,
.
)
and
.
.
match
(
)
is not None
):
=
.
=
""""
else
:
,
=
.
ExecHook
(
,
)
if not
:
=
.
else
:
=
.
.
append
((
""%s/%s""
% (
,
),
,
))
return
class
IAllocatorRunner
(
object
):
""""""IAllocator runner.

  This class is instantiated on the node side (ganeti-noded) and not on
  the master side.

  """"""
def
Run
(
,
,
):
""""""Run an iallocator script.

    @type name: str
    @param name: the iallocator script name
    @type idata: str
    @param idata: the allocator input data

    @rtype: tuple
    @return: four element tuple of:
       - run status (one of the IARUN_ constants)
       - stdout
       - stderr
       - fail reason (as from L{utils.RunResult})

    """"""
=
.
FindFile
(
,
.
,
.
.
)
if
is None
:
return
(
.
,
None
,
None
,
None
)
,
=
.
mkstemp
(
=
""ganeti-iallocator.""
)
try
:
.
write
(
,
)
.
close
(
)
=
.
RunCmd
([
,
])
if
.
:
return
(
.
,
.
,
.
,
.
)
finally
:
.
unlink
(
)
return
(
.
,
.
,
.
,
None
)
class
DevCacheManager
(
object
):
""""""Simple class for managing a cache of block device information.

  """"""
=
""/dev/""
=
.
@
classmethod
def
_ConvertPath
(
,
):
""""""Converts a /dev/name path to the cache file name.

    This replaces slashes with underscores and strips the /dev
    prefix. It then returns the full path to the cache file.

    @type dev_path: str
    @param dev_path: the C{/dev/} path name
    @rtype: str
    @return: the converted path name

    """"""
if
.
startswith
(
.
):
=
[
len
(
.
):]
=
.
replace
(
""/""
,
""_""
)
=
""%s/bdev_%s""
% (
.
,
)
return
@
classmethod
def
UpdateCache
(
,
,
,
,
):
""""""Updates the cache information for a given device.

    @type dev_path: str
    @param dev_path: the pathname of the device
    @type owner: str
    @param owner: the owner (instance name) of the device
    @type on_primary: bool
    @param on_primary: whether this is the primary
        node nor not
    @type iv_name: str
    @param iv_name: the instance-visible name of the
        device, as in objects.Disk.iv_name

    @rtype: None

    """"""
if
is None
:
.
error
(
""DevCacheManager.UpdateCache got a None dev_path""
)
return
=
.
_ConvertPath
(
)
if
:
=
""primary""
else
:
=
""secondary""
if
is None
:
=
""not_visible""
=
""%s %s %s
\n
""
% (
str
(
),
,
)
try
:
.
WriteFile
(
,
=
)
except
EnvironmentError
:
.
exception
(
""Can't update bdev cache for %s""
,
)
@
classmethod
def
RemoveCache
(
,
):
""""""Remove data for a dev_path.

    This is just a wrapper over L{utils.RemoveFile} with a converted
    path name and logging.

    @type dev_path: str
    @param dev_path: the pathname of the device

    @rtype: None

    """"""
if
is None
:
.
error
(
""DevCacheManager.RemoveCache got a None dev_path""
)
return
=
.
_ConvertPath
(
)
try
:
.
RemoveFile
(
)
except
EnvironmentError
:
.
exception
(
""Can't update bdev cache for %s""
,
)
"
CVE-2009-4261,https://www.cvedetails.com/cve/CVE-2009-4261/,CWE-22,,Exec Code +Priv Dir. Trav.,2009-12-21,2018-10-10,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple directory traversal vulnerabilities in the iallocator framework in Ganeti 1.2.4 through 1.2.8, 2.0.0 through 2.0.4, and 2.1.0 before 2.1.0~rc2 allow (1) remote attackers to execute arbitrary programs via a crafted external script name supplied through the HTTP remote API (RAPI) and allow (2) local users to execute arbitrary programs and gain privileges via a crafted external script name supplied through a gnt-* command, related to ""path sanitization errors.""",Python,ganeti,http://git.ganeti.org/?p=ganeti.git;a=commit;h=f95c81bf21c177f7e6a2c53ea0613034326329bd,f95c81bf21c177f7e6a2c53ea0613034326329bd,4fe80ef2ed1cda3a6357274eccafe5c1f21a5283,"@@ -1633,9 +1633,17 @@ def FindFile(name, search_path, test=os.path.exists):
   @return: full path to the object if found, None otherwise
 
   """"""
+  # validate the filename mask
+  if constants.EXT_PLUGIN_MASK.match(name) is None:
+    logging.critical(""Invalid value passed for external script name: '%s'"",
+                     name)
+    return None
+
   for dir_name in search_path:
     item_name = os.path.sep.join([dir_name, name])
-    if test(item_name):
+    # check the user test and that we're indeed resolving to the given
+    # basename
+    if test(item_name) and os.path.basename(item_name) == name:
       return item_name
   return None",http://git.ganeti.org/?p=ganeti.git;a=blob;f=lib/utils.py;h=df2d18027e83b7783e146cbbe58f7efa92317980;hb=df2d18027e83b7783e146cbbe58f7efa92317980,http://git.ganeti.org/?p=ganeti.git;a=blob;f=lib/utils.py;h=bcd8e107bbc44ff94a4bc3dc405b5547719f001d;hb=bcd8e107bbc44ff94a4bc3dc405b5547719f001d,"#
#
# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
""""""Ganeti utility module.

This module holds functions that can be used in both daemons (all) and
the command line scripts.

""""""
import
import
import
import
import
import
import
import
import
import
import
import
import
import
import
from
import
try
:
from
import
except
ImportError
:
import
=
.
from
import
from
import
= []
=
.
compile
(
'^[-.,=:/_+@A-Za-z0-9]+$'
)
=
False
#: when set to True, L{RunCmd} is disabled
=
False
class
RunResult
(
object
):
""""""Holds the result of running external programs.

  @type exit_code: int
  @ivar exit_code: the exit code of the program, or None (if the program
      didn't exit())
  @type signal: int or None
  @ivar signal: the signal that caused the program to finish, or None
      (if the program wasn't terminated by a signal)
  @type stdout: str
  @ivar stdout: the standard output of the program
  @type stderr: str
  @ivar stderr: the standard error of the program
  @type failed: boolean
  @ivar failed: True in case the program was
      terminated by a signal or exited with a non-zero exit code
  @ivar fail_reason: a string detailing the termination reason

  """"""
= [
""exit_code""
,
""signal""
,
""stdout""
,
""stderr""
,
""failed""
,
""fail_reason""
,
""cmd""
]
def
__init__
(
,
,
,
,
,
):
.
=
.
=
.
=
.
=
.
=
.
= (
is not None or
!=
0
)
if
.
is not None
:
.
=
""terminated by signal %s""
%
.
elif
.
is not None
:
.
=
""exited with exit code %s""
%
.
else
:
.
=
""unable to determine termination reason""
if
.
:
.
debug
(
""Command '%s' failed (%s); output: %s""
,
.
,
.
,
.
)
def
_GetOutput
(
):
""""""Returns the combined stdout and stderr for easier usage.

    """"""
return
.
+
.
=
property
(
,
None
,
None
,
""Return full output""
)
def
RunCmd
(
,
=
None
,
=
None
,
=
'/'
):
""""""Execute a (shell) command.

  The command should not read from its standard input, as it will be
  closed.

  @type  cmd: string or list
  @param cmd: Command to run
  @type env: dict
  @param env: Additional environment
  @type output: str
  @param output: if desired, the output of the command can be
      saved in a file instead of the RunResult instance; this
      parameter denotes the file name (if not None)
  @type cwd: string
  @param cwd: if specified, will be used as the working
      directory for the command; the default will be /
  @rtype: L{RunResult}
  @return: RunResult instance
  @raise errors.ProgrammerError: if we call this when forks are disabled

  """"""
if
:
raise
.
ProgrammerError
(
""utils.RunCmd() called with fork() disabled""
)
if
isinstance
(
,
list
):
= [
str
(
)
for
in
]
=
"" ""
.
join
(
)
=
False
else
:
=
=
True
.
debug
(
""RunCmd '%s'""
,
)
=
.
.
copy
()
[
""LC_ALL""
] =
""C""
if
is not None
:
.
update
(
)
try
:
if
is None
:
,
,
=
_RunCmdPipe
(
,
,
,
)
else
:
=
_RunCmdFile
(
,
,
,
,
)
=
=
""""
except
OSError
,
:
if
.
==
.
:
raise
.
OpExecError
(
""Can't execute '%s': not found (%s)""
%
(
,
))
else
:
raise
if
>=
0
:
=
=
None
else
:
=
None
= -
return
RunResult
(
,
,
,
,
)
def
_RunCmdPipe
(
,
,
,
):
""""""Run a command and return its output.

  @type  cmd: string or list
  @param cmd: Command to run
  @type env: dict
  @param env: The environment to use
  @type via_shell: bool
  @param via_shell: if we should run via the shell
  @type cwd: string
  @param cwd: the working directory for the program
  @rtype: tuple
  @return: (out, err, status)

  """"""
=
.
poll
()
=
.
Popen
(
,
=
,
=
.
,
=
.
,
=
.
,
=
True
,
=
,
=
)
.
.
close
()
.
register
(
.
,
.
)
.
register
(
.
,
.
)
=
StringIO
()
=
StringIO
()
= {
.
.
fileno
(): (
,
.
),
.
.
fileno
(): (
,
.
),
}
for
in
:
=
.
fcntl
(
,
.
)
.
fcntl
(
,
.
,
|
.
)
while
:
try
:
=
.
poll
()
except
EnvironmentError
,
:
if
.
==
.
:
continue
raise
except
.
,
:
if
[
0
] ==
.
:
continue
raise
for
,
in
:
if
&
.
or
&
.
:
=
[
][
1
].
read
()
# no data from read signifies EOF (the same as POLLHUP)
if not
:
.
unregister
(
)
del
[
]
continue
[
][
0
].
write
(
)
if
(
&
.
or
&
.
or
&
.
):
.
unregister
(
)
del
[
]
=
.
getvalue
()
=
.
getvalue
()
=
.
wait
()
return
,
,
def
_RunCmdFile
(
,
,
,
,
):
""""""Run a command and save its output to a file.

  @type  cmd: string or list
  @param cmd: Command to run
  @type env: dict
  @param env: The environment to use
  @type via_shell: bool
  @param via_shell: if we should run via the shell
  @type output: str
  @param output: the filename in which to save the output
  @type cwd: string
  @param cwd: the working directory for the program
  @rtype: int
  @return: the exit status

  """"""
=
open
(
,
""a""
)
try
:
=
.
Popen
(
,
=
,
=
.
,
=
,
=
.
,
=
True
,
=
,
=
)
.
.
close
()
=
.
wait
()
finally
:
.
close
()
return
def
RemoveFile
(
):
""""""Remove a file ignoring some errors.

  Remove a file, ignoring non-existing ones or directories. Other
  errors are passed.

  @type filename: str
  @param filename: the file to be removed

  """"""
try
:
.
unlink
(
)
except
OSError
,
:
if
.
not in
(
.
,
.
):
raise
def
RenameFile
(
,
,
=
False
,
=
0750
):
""""""Renames a file.

  @type old: string
  @param old: Original path
  @type new: string
  @param new: New path
  @type mkdir: bool
  @param mkdir: Whether to create target directory if it doesn't exist
  @type mkdir_mode: int
  @param mkdir_mode: Mode for newly created directories

  """"""
try
:
return
.
rename
(
,
)
except
OSError
,
:
# In at least one use case of this function, the job queue, directory
# creation is very rare. Checking for the directory before renaming is not
# as efficient.
if
and
.
==
.
:
# Create directory and try again
.
makedirs
(
.
.
dirname
(
),
)
return
.
rename
(
,
)
raise
def
_FingerprintFile
(
):
""""""Compute the fingerprint of a file.

  If the file does not exist, a None will be returned
  instead.

  @type filename: str
  @param filename: the filename to checksum
  @rtype: str
  @return: the hex digest of the sha checksum of the contents
      of the file

  """"""
if not
(
.
.
exists
(
)
and
.
.
isfile
(
)):
return None
=
open
(
)
=
sha1
()
while True
:
=
.
read
(
4096
)
if not
:
break
.
update
(
)
return
.
hexdigest
()
def
FingerprintFiles
(
):
""""""Compute fingerprints for a list of files.

  @type files: list
  @param files: the list of filename to fingerprint
  @rtype: dict
  @return: a dictionary filename: fingerprint, holding only
      existing files

  """"""
= {}
for
in
:
=
_FingerprintFile
(
)
if
:
[
] =
return
def
CheckDict
(
,
,
=
None
):
""""""Ensure a dictionary has a required set of keys.

  For the given dictionaries I{target} and I{template}, ensure
  I{target} has all the keys from I{template}. Missing keys are added
  with values from template.

  @type target: dict
  @param target: the dictionary to update
  @type template: dict
  @param template: the dictionary holding the default values
  @type logname: str or None
  @param logname: if not None, causes the missing keys to be
      logged with this name

  """"""
= []
for
in
:
if
not in
:
.
append
(
)
[
] =
[
]
if
and
:
.
warning
(
'%s missing keys %s'
,
,
', '
.
join
(
))
def
ForceDictType
(
,
,
=
None
):
""""""Force the values of a dict to have certain types.

  @type target: dict
  @param target: the dict to update
  @type key_types: dict
  @param key_types: dict mapping target dict keys to types
                    in constants.ENFORCEABLE_TYPES
  @type allowed_values: list
  @keyword allowed_values: list of specially allowed values

  """"""
if
is None
:
= []
for
in
:
if
not in
:
=
""Unknown key '%s'""
%
raise
.
TypeEnforcementError
(
)
if
[
]
in
:
continue
type
=
[
]
if
type
not in
.
:
=
""'%s' has non-enforceable type %s""
% (
,
type
)
raise
.
ProgrammerError
(
)
if
type
==
.
:
if not
isinstance
(
[
],
):
if
isinstance
(
[
],
bool
)
and not
[
]:
[
] =
''
else
:
=
""'%s' (value %s) is not a valid string""
% (
,
[
])
raise
.
TypeEnforcementError
(
)
elif
type
==
.
:
if
isinstance
(
[
],
)
and
[
]:
if
[
].
lower
() ==
.
:
[
] =
False
elif
[
].
lower
() ==
.
:
[
] =
True
else
:
=
""'%s' (value %s) is not a valid boolean""
% (
,
[
])
raise
.
TypeEnforcementError
(
)
elif
[
]:
[
] =
True
else
:
[
] =
False
elif
type
==
.
:
try
:
[
] =
ParseUnit
(
[
])
except
.
,
:
=
""'%s' (value %s) is not a valid size. error: %s""
%
(
,
[
],
)
raise
.
TypeEnforcementError
(
)
elif
type
==
.
:
try
:
[
] =
int
(
[
])
except
(
ValueError
,
TypeError
):
=
""'%s' (value %s) is not a valid integer""
% (
,
[
])
raise
.
TypeEnforcementError
(
)
def
IsProcessAlive
(
):
""""""Check if a given pid exists on the system.

  @note: zombie status is not handled, so zombie processes
      will be returned as alive
  @type pid: int
  @param pid: the process ID to check
  @rtype: boolean
  @return: True if the process exists

  """"""
if
<=
0
:
return False
try
:
.
stat
(
""/proc/%d/status""
%
)
return True
except
EnvironmentError
,
:
if
.
in
(
.
,
.
):
return False
raise
def
ReadPidFile
(
):
""""""Read a pid from a file.

  @type  pidfile: string
  @param pidfile: path to the file containing the pid
  @rtype: int
  @return: The process id, if the file exists and contains a valid PID,
           otherwise 0

  """"""
try
:
=
open
(
,
'r'
)
except
EnvironmentError
,
:
if
.
!=
.
:
.
exception
(
""Can't read pid file?!""
)
return
0
try
:
=
int
(
.
read
())
except
ValueError
,
:
.
info
(
""Can't parse pid file contents""
,
=
True
)
return
0
return
def
MatchNameComponent
(
,
):
""""""Try to match a name against a list.

  This function will try to match a name like test1 against a list
  like C{['test1.example.com', 'test2.example.com', ...]}. Against
  this list, I{'test1'} as well as I{'test1.example'} will match, but
  not I{'test1.ex'}. A multiple match will be considered as no match
  at all (e.g. I{'test1'} against C{['test1.example.com',
  'test1.example.org']}).

  @type key: str
  @param key: the name to be searched
  @type name_list: list
  @param name_list: the list of strings against which to search the key

  @rtype: None or str
  @return: None if there is no match I{or} if there are multiple matches,
      otherwise the element from the list which matches

  """"""
=
.
compile
(
""^%s(\..*)?$""
%
.
escape
(
))
= [
for
in
if
.
match
(
)
is not None
]
if
len
(
) !=
1
:
return None
return
[
0
]
class
:
""""""Class implementing resolver and hostname functionality

  """"""
def
__init__
(
,
=
None
):
""""""Initialize the host name object.

    If the name argument is not passed, it will use this system's
    name.

    """"""
if
is None
:
=
.
SysName
()
.
=
.
,
.
,
.
=
.
LookupHostname
(
)
.
=
.
[
0
]
def
ShortName
(
):
""""""Returns the hostname without domain.

    """"""
return
.
.
split
(
'.'
)[
0
]
@
staticmethod
def
SysName
():
""""""Return the current system's name.

    This is simply a wrapper over C{socket.gethostname()}.

    """"""
return
.
gethostname
()
@
staticmethod
def
LookupHostname
(
):
""""""Look up hostname

    @type hostname: str
    @param hostname: hostname to look up

    @rtype: tuple
    @return: a tuple (name, aliases, ipaddrs) as returned by
        C{socket.gethostbyname_ex}
    @raise errors.ResolverError: in case of errors in resolving

    """"""
try
:
=
.
gethostbyname_ex
(
)
except
.
,
:
# hostname not found in DNS
raise
.
ResolverError
(
,
.
[
0
],
.
[
1
])
return
def
ListVolumeGroups
():
""""""List volume groups and their size

  @rtype: dict
  @return:
       Dictionary with keys volume name and values
       the size of the volume

  """"""
=
""vgs --noheadings --units m --nosuffix -o name,size""
=
RunCmd
(
)
= {}
if
.
:
return
for
in
.
.
splitlines
():
try
:
,
=
.
split
()
=
int
(
float
(
))
except
(
IndexError
,
ValueError
),
:
.
error
(
""Invalid output from vgs (%s): %s""
,
,
)
continue
[
] =
return
def
BridgeExists
(
):
""""""Check whether the given bridge exists in the system

  @type bridge: str
  @param bridge: the bridge name to check
  @rtype: boolean
  @return: True if it does

  """"""
return
.
.
isdir
(
""/sys/class/net/%s/bridge""
%
)
def
NiceSort
(
):
""""""Sort a list of strings based on digit and non-digit groupings.

  Given a list of names C{['a1', 'a10', 'a11', 'a2']} this function
  will sort the list in the logical order C{['a1', 'a2', 'a10',
  'a11']}.

  The sort algorithm breaks each name in groups of either only-digits
  or no-digits. Only the first eight such groups are considered, and
  after that we just use what's left of the string.

  @type name_list: list
  @param name_list: the names to be sorted
  @rtype: list
  @return: a copy of the name list sorted with our algorithm

  """"""
=
""(\D+|\d+)""
=
""^%s%s?%s?%s?%s?%s?%s?%s?.*$""
% (
,
,
,
,
,
,
,
)
=
.
compile
(
)
=
.
compile
(
""^\D*$""
)
def
_TryInt
(
):
""""""Attempts to convert a variable to integer.""""""
if
is None or
.
match
(
):
return
=
int
(
)
return
= [([
_TryInt
(
)
for
in
.
match
(
).
groups
()],
)
for
in
]
.
sort
()
return
[
[
1
]
for
in
]
def
TryConvert
(
,
):
""""""Try to convert a value ignoring errors.

  This function tries to apply function I{fn} to I{val}. If no
  C{ValueError} or C{TypeError} exceptions are raised, it will return
  the result, else it will return the original value. Any other
  exceptions are propagated to the caller.

  @type fn: callable
  @param fn: function to apply to the value
  @param val: the value to be converted
  @return: The converted value if the conversion was successful,
      otherwise the original value.

  """"""
try
:
=
fn
(
)
except
(
ValueError
,
TypeError
):
=
return
def
IsValidIP
(
):
""""""Verifies the syntax of an IPv4 address.

  This function checks if the IPv4 address passes is valid or not based
  on syntax (not IP range, class calculations, etc.).

  @type ip: str
  @param ip: the address to be checked
  @rtype: a regular expression match object
  @return: a regular expression match object, or None if the
      address is not valid

  """"""
=
""(0|[1-9]\d{0,2})""
#TODO: convert and return only boolean
return
.
match
(
""^%s\.%s\.%s\.%s$""
% (
,
,
,
),
)
def
IsValidShellParam
(
):
""""""Verifies is the given word is safe from the shell's p.o.v.

  This means that we can pass this to a command via the shell and be
  sure that it doesn't alter the command line and is passed as such to
  the actual command.

  Note that we are overly restrictive here, in order to be on the safe
  side.

  @type word: str
  @param word: the word to check
  @rtype: boolean
  @return: True if the word is 'safe'

  """"""
return
bool
(
.
match
(
""^[-a-zA-Z0-9._+/:%@]+$""
,
))
def
BuildShellCmd
(
, *
):
""""""Build a safe shell command line from the given arguments.

  This function will check all arguments in the args list so that they
  are valid shell parameters (i.e. they don't contain shell
  metacharacters). If everything is ok, it will return the result of
  template % args.

  @type template: str
  @param template: the string holding the template for the
      string formatting
  @rtype: str
  @return: the expanded command line

  """"""
for
in
:
if not
IsValidShellParam
(
):
raise
.
ProgrammerError
(
""Shell argument '%s' contains""
"" invalid characters""
%
)
return
%
def
FormatUnit
(
,
):
""""""Formats an incoming number of MiB with the appropriate unit.

  @type value: int
  @param value: integer representing the value in MiB (1048576)
  @type units: char
  @param units: the type of formatting we should do:
      - 'h' for automatic scaling
      - 'm' for MiBs
      - 'g' for GiBs
      - 't' for TiBs
  @rtype: str
  @return: the formatted value (with suffix)

  """"""
if
not in
(
'm'
,
'g'
,
't'
,
'h'
):
raise
.
ProgrammerError
(
""Invalid unit specified '%s'""
%
str
(
))
=
''
if
==
'm'
or
(
==
'h'
and
<
1024
):
if
==
'h'
:
=
'M'
return
""%d%s""
% (
round
(
,
0
),
)
elif
==
'g'
or
(
==
'h'
and
< (
1024
*
1024
)):
if
==
'h'
:
=
'G'
return
""%0.1f%s""
% (
round
(
float
(
) /
1024
,
1
),
)
else
:
if
==
'h'
:
=
'T'
return
""%0.1f%s""
% (
round
(
float
(
) /
1024
/
1024
,
1
),
)
def
ParseUnit
(
):
""""""Tries to extract number and scale from the given string.

  Input must be in the format C{NUMBER+ [DOT NUMBER+] SPACE*
  [UNIT]}. If no unit is specified, it defaults to MiB. Return value
  is always an int in MiB.

  """"""
=
.
match
(
'^([.\d]+)\s*([a-zA-Z]+)?$'
,
str
(
))
if not
:
raise
.
UnitParseError
(
""Invalid format""
)
=
float
(
.
groups
()[
0
])
=
.
groups
()[
1
]
if
:
=
.
lower
()
else
:
=
'm'
if
in
(
'm'
,
'mb'
,
'mib'
):
# Value already in MiB
pass
elif
in
(
'g'
,
'gb'
,
'gib'
):
*=
1024
elif
in
(
't'
,
'tb'
,
'tib'
):
*=
1024
*
1024
else
:
raise
.
UnitParseError
(
""Unknown unit: %s""
%
)
# Make sure we round up
if
int
(
) <
:
+=
1
# Round up to the next multiple of 4
=
int
(
)
if
%
4
:
+=
4
-
%
4
return
def
AddAuthorizedKey
(
,
):
""""""Adds an SSH public key to an authorized_keys file.

  @type file_name: str
  @param file_name: path to authorized_keys file
  @type key: str
  @param key: string containing key

  """"""
=
.
split
()
=
open
(
,
'a+'
)
try
:
=
True
for
in
:
# Ignore whitespace changes
if
.
split
() ==
:
break
=
.
endswith
(
'
\n
'
)
else
:
if not
:
.
write
(
""
\n
""
)
.
write
(
.
rstrip
(
'
\r\n
'
))
.
write
(
""
\n
""
)
.
flush
()
finally
:
.
close
()
def
RemoveAuthorizedKey
(
,
):
""""""Removes an SSH public key from an authorized_keys file.

  @type file_name: str
  @param file_name: path to authorized_keys file
  @type key: str
  @param key: string containing key

  """"""
=
.
split
()
,
=
.
mkstemp
(
dir
=
.
.
dirname
(
))
try
:
=
.
fdopen
(
,
'w'
)
try
:
=
open
(
,
'r'
)
try
:
for
in
:
# Ignore whitespace changes while comparing lines
if
.
split
() !=
:
.
write
(
)
.
flush
()
.
rename
(
,
)
finally
:
.
close
()
finally
:
.
close
()
except
:
RemoveFile
(
)
raise
def
SetEtcHostsEntry
(
,
,
,
):
""""""Sets the name of an IP address and hostname in /etc/hosts.

  @type file_name: str
  @param file_name: path to the file to modify (usually C{/etc/hosts})
  @type ip: str
  @param ip: the IP address
  @type hostname: str
  @param hostname: the hostname to be added
  @type aliases: list
  @param aliases: the list of aliases to add for the hostname

  """"""
# FIXME: use WriteFile + fn rather than duplicating its efforts
# Ensure aliases are unique
=
UniqueSequence
([
] +
)[
1
:]
,
=
.
mkstemp
(
dir
=
.
.
dirname
(
))
try
:
=
.
fdopen
(
,
'w'
)
try
:
=
open
(
,
'r'
)
try
:
for
in
:
=
.
split
()
if
and not
[
0
].
startswith
(
'#'
)
and
==
[
0
]:
continue
.
write
(
)
.
write
(
""%s
\t
%s""
% (
,
))
if
:
.
write
(
"" %s""
%
' '
.
join
(
))
.
write
(
'
\n
'
)
.
flush
()
.
fsync
(
)
.
chmod
(
,
0644
)
.
rename
(
,
)
finally
:
.
close
()
finally
:
.
close
()
except
:
RemoveFile
(
)
raise
def
AddHostToEtcHosts
(
):
""""""Wrapper around SetEtcHostsEntry.

  @type hostname: str
  @param hostname: a hostname that will be resolved and added to
      L{constants.ETC_HOSTS}

  """"""
=
HostInfo
(
=
)
SetEtcHostsEntry
(
.
,
.
,
.
, [
.
ShortName
()])
def
RemoveEtcHostsEntry
(
,
):
""""""Removes a hostname from /etc/hosts.

  IP addresses without names are removed from the file.

  @type file_name: str
  @param file_name: path to the file to modify (usually C{/etc/hosts})
  @type hostname: str
  @param hostname: the hostname to be removed

  """"""
# FIXME: use WriteFile + fn rather than duplicating its efforts
,
=
.
mkstemp
(
dir
=
.
.
dirname
(
))
try
:
=
.
fdopen
(
,
'w'
)
try
:
=
open
(
,
'r'
)
try
:
for
in
:
=
.
split
()
if
len
(
) >
1
and not
[
0
].
startswith
(
'#'
):
=
[
1
:]
if
in
:
while
in
:
.
remove
(
)
if
:
.
write
(
""%s %s
\n
""
% (
[
0
],
' '
.
join
(
)))
continue
.
write
(
)
.
flush
()
.
fsync
(
)
.
chmod
(
,
0644
)
.
rename
(
,
)
finally
:
.
close
()
finally
:
.
close
()
except
:
RemoveFile
(
)
raise
def
RemoveHostFromEtcHosts
(
):
""""""Wrapper around RemoveEtcHostsEntry.

  @type hostname: str
  @param hostname: hostname that will be resolved and its
      full and shot name will be removed from
      L{constants.ETC_HOSTS}

  """"""
=
HostInfo
(
=
)
RemoveEtcHostsEntry
(
.
,
.
)
RemoveEtcHostsEntry
(
.
,
.
ShortName
())
def
CreateBackup
(
):
""""""Creates a backup of a file.

  @type file_name: str
  @param file_name: file to be backed up
  @rtype: str
  @return: the path to the newly created backup
  @raise errors.ProgrammerError: for invalid file names

  """"""
if not
.
.
isfile
(
):
raise
.
ProgrammerError
(
""Can't make a backup of a non-file '%s'""
%
)
=
'%s.backup-%d.'
% (
.
.
basename
(
),
int
(
.
time
()))
=
.
.
dirname
(
)
=
open
(
,
'rb'
)
try
:
(
,
) =
.
mkstemp
(
=
,
dir
=
)
=
.
fdopen
(
,
'wb'
)
try
:
.
copyfileobj
(
,
)
finally
:
.
close
()
finally
:
.
close
()
return
def
ShellQuote
(
):
""""""Quotes shell argument according to POSIX.

  @type value: str
  @param value: the argument to be quoted
  @rtype: str
  @return: the quoted value

  """"""
if
.
match
(
):
return
else
:
return
""'%s'""
%
.
replace
(
""'""
,
""'
\\
''""
)
def
ShellQuoteArgs
(
):
""""""Quotes a list of shell arguments.

  @type args: list
  @param args: list of arguments to be quoted
  @rtype: str
  @return: the quoted arguments concatenated with spaces

  """"""
return
' '
.
join
([
ShellQuote
(
)
for
in
])
def
TcpPing
(
,
,
=
10
,
=
False
,
=
None
):
""""""Simple ping implementation using TCP connect(2).

  Check if the given IP is reachable by doing attempting a TCP connect
  to it.

  @type target: str
  @param target: the IP or hostname to ping
  @type port: int
  @param port: the port to connect to
  @type timeout: int
  @param timeout: the timeout on the connection attempt
  @type live_port_needed: boolean
  @param live_port_needed: whether a closed port will cause the
      function to return failure, as if there was a timeout
  @type source: str or None
  @param source: if specified, will cause the connect to be made
      from this specific source address; failures to bind other
      than C{EADDRNOTAVAIL} will be ignored

  """"""
=
.
socket
(
.
,
.
)
=
False
if
is not None
:
try
:
.
bind
((
,
0
))
except
.
, (
,
):
if
==
.
:
=
False
.
settimeout
(
)
try
:
.
connect
((
,
))
.
close
()
=
True
except
.
:
=
False
except
.
, (
,
):
= (
not
)
and
(
==
.
)
return
def
OwnIpAddress
(
):
""""""Check if the current host has the the given IP address.

  Currently this is done by TCP-pinging the address from the loopback
  address.

  @type address: string
  @param address: the address to check
  @rtype: bool
  @return: True if we own the address

  """"""
return
TcpPing
(
,
.
,
=
.
)
def
ListVisibleFiles
(
):
""""""Returns a list of visible files in a directory.

  @type path: str
  @param path: the directory to enumerate
  @rtype: list
  @return: the list of all files not starting with a dot

  """"""
= [
for
in
.
listdir
(
)
if not
.
startswith
(
"".""
)]
.
sort
()
return
def
GetHomeDir
(
,
=
None
):
""""""Try to get the homedir of the given user.

  The user can be passed either as a string (denoting the name) or as
  an integer (denoting the user id). If the user is not found, the
  'default' argument is returned, which defaults to None.

  """"""
try
:
if
isinstance
(
,
):
=
.
getpwnam
(
)
elif
isinstance
(
, (
int
,
long
)):
=
.
getpwuid
(
)
else
:
raise
.
ProgrammerError
(
""Invalid type passed to GetHomeDir (%s)""
%
type
(
))
except
KeyError
:
return
return
.
def
NewUUID
():
""""""Returns a random UUID.

  @note: This is a Linux-specific method as it uses the /proc
      filesystem.
  @rtype: str

  """"""
=
open
(
""/proc/sys/kernel/random/uuid""
,
""r""
)
try
:
return
.
read
(
128
).
rstrip
(
""
\n
""
)
finally
:
.
close
()
def
GenerateSecret
():
""""""Generates a random secret.

  This will generate a pseudo-random secret, and return its sha digest
  (so that it can be used where an ASCII string is needed).

  @rtype: str
  @return: a sha1 hexdigest of a block of 64 random bytes

  """"""
return
sha1
(
.
urandom
(
64
)).
hexdigest
()
def
EnsureDirs
(
):
""""""Make required directories, if they don't exist.

  @param dirs: list of tuples (dir_name, dir_mode)
  @type dirs: list of (string, integer)

  """"""
for
,
in
:
try
:
.
mkdir
(
,
)
except
EnvironmentError
,
:
if
.
!=
.
:
raise
.
GenericError
(
""Cannot create needed directory""
"" '%s': %s""
% (
,
))
if not
.
.
isdir
(
):
raise
.
GenericError
(
""%s is not a directory""
%
)
def
ReadFile
(
,
=
None
):
""""""Reads a file.

  @type size: None or int
  @param size: Read at most size bytes
  @rtype: str
  @return: the (possibly partial) content of the file

  """"""
=
open
(
,
""r""
)
try
:
if
is None
:
return
.
read
()
else
:
return
.
read
(
)
finally
:
.
close
()
def
WriteFile
(
,
=
None
,
=
None
,
=
None
,
=-
1
,
=-
1
,
=
None
,
=
None
,
=
True
,
=
False
,
=
False
,
=
None
,
=
None
):
""""""(Over)write a file atomically.

  The file_name and either fn (a function taking one argument, the
  file descriptor, and which should write the data to it) or data (the
  contents of the file) must be passed. The other arguments are
  optional and allow setting the file mode, owner and group, and the
  mtime/atime of the file.

  If the function doesn't raise an exception, it has succeeded and the
  target file has the new contents. If the function has raised an
  exception, an existing target file should be unmodified and the
  temporary file should be removed.

  @type file_name: str
  @param file_name: the target filename
  @type fn: callable
  @param fn: content writing function, called with
      file descriptor as parameter
  @type data: str
  @param data: contents of the file
  @type mode: int
  @param mode: file mode
  @type uid: int
  @param uid: the owner of the file
  @type gid: int
  @param gid: the group of the file
  @type atime: int
  @param atime: a custom access time to be set on the file
  @type mtime: int
  @param mtime: a custom modification time to be set on the file
  @type close: boolean
  @param close: whether to close file after writing it
  @type prewrite: callable
  @param prewrite: function to be called before writing content
  @type postwrite: callable
  @param postwrite: function to be called after writing content

  @rtype: None or int
  @return: None if the 'close' parameter evaluates to True,
      otherwise the file descriptor

  @raise errors.ProgrammerError: if any of the arguments are not valid

  """"""
if not
.
.
isabs
(
):
raise
.
ProgrammerError
(
""Path passed to WriteFile is not""
"" absolute: '%s'""
%
)
if
[
,
].
count
(
None
) !=
1
:
raise
.
ProgrammerError
(
""fn or data required""
)
if
[
,
].
count
(
None
) ==
1
:
raise
.
ProgrammerError
(
""Both atime and mtime must be either""
"" set or None""
)
if
and not
and
.
.
isfile
(
):
CreateBackup
(
)
,
=
.
.
split
(
)
,
=
.
mkstemp
(
'.new'
,
,
)
=
True
# here we need to make sure we remove the temp file, if any error
# leaves it in place
try
:
if
!= -
1
or
!= -
1
:
.
chown
(
,
,
)
if
:
.
chmod
(
,
)
if
callable
(
):
prewrite
(
)
if
is not None
:
.
write
(
,
)
else
:
fn
(
)
if
callable
(
):
postwrite
(
)
.
fsync
(
)
if
is not None and
is not None
:
.
utime
(
, (
,
))
if not
:
.
rename
(
,
)
=
False
finally
:
if
:
.
close
(
)
=
None
else
:
=
if
:
RemoveFile
(
)
return
def
FirstFree
(
,
=
0
):
""""""Returns the first non-existing integer from seq.

  The seq argument should be a sorted list of positive integers. The
  first time the index of an element is smaller than the element
  value, the index will be returned.

  The base argument is used to start at a different offset,
  i.e. C{[3, 4, 6]} with I{offset=3} will return 5.

  Example: C{[0, 1, 3]} will return I{2}.

  @type seq: sequence
  @param seq: the sequence to be analyzed.
  @type base: int
  @param base: use this value as the base index of the sequence
  @rtype: int
  @return: the first non-used index in the sequence

  """"""
for
,
in
enumerate
(
):
assert
>=
,
""Passed element is higher than base offset""
if
>
+
:
# idx is not used
return
+
return None
def
all
(
,
=
bool
):
""Returns True if pred(x) is True for every element in the iterable""
for
in
.
ifilterfalse
(
,
):
return False
return True
def
any
(
,
=
bool
):
""Returns True if pred(x) is True for at least one element in the iterable""
for
in
.
ifilter
(
,
):
return True
return False
def
UniqueSequence
(
):
""""""Returns a list with unique elements.

  Element order is preserved.

  @type seq: sequence
  @param seq: the sequence with the source elements
  @rtype: list
  @return: list of unique elements from seq

  """"""
=
set
()
return
[
for
in
if
not in
and not
.
add
(
)]
def
IsValidMac
(
):
""""""Predicate to check if a MAC address is valid.

  Checks whether the supplied MAC address is formally correct, only
  accepts colon separated format.

  @type mac: str
  @param mac: the MAC to be validated
  @rtype: boolean
  @return: True is the MAC seems valid

  """"""
=
.
compile
(
""^([0-9a-f]{2}(:|$)){6}$""
)
return
.
match
(
)
is not None
def
TestDelay
(
):
""""""Sleep for a fixed amount of time.

  @type duration: float
  @param duration: the sleep duration
  @rtype: boolean
  @return: False for negative value, True otherwise

  """"""
if
<
0
:
return False
.
sleep
(
)
return True
def
_CloseFDNoErr
(
,
=
5
):
""""""Close a file descriptor ignoring errors.

  @type fd: int
  @param fd: the file descriptor
  @type retries: int
  @param retries: how many retries to make, in case we get any
      other error than EBADF

  """"""
try
:
.
close
(
)
except
OSError
,
:
if
.
!=
.
:
if
>
0
:
_CloseFDNoErr
(
,
-
1
)
# else either it's closed already or we're out of retries, so we
# ignore this and go on
def
CloseFDs
(
=
None
):
""""""Close file descriptors.

  This closes all file descriptors above 2 (i.e. except
  stdin/out/err).

  @type noclose_fds: list or None
  @param noclose_fds: if given, it denotes a list of file descriptor
      that should not be closed

  """"""
# Default maximum for the number of available file descriptors.
if
'SC_OPEN_MAX'
in
.
:
try
:
=
.
sysconf
(
'SC_OPEN_MAX'
)
if
<
0
:
=
1024
except
OSError
:
=
1024
else
:
=
1024
=
.
getrlimit
(
.
)[
1
]
if
(
==
.
):
=
# Iterate through and close all file descriptors (except the standard ones)
for
in
range
(
3
,
):
if
and
in
:
continue
_CloseFDNoErr
(
)
def
Daemonize
(
):
""""""Daemonize the current process.

  This detaches the current process from the controlling terminal and
  runs it in the background as a daemon.

  @type logfile: str
  @param logfile: the logfile to which we should redirect stdout/stderr
  @rtype: int
  @return: the value zero

  """"""
=
077
=
""/""
# this might fail
=
.
fork
()
if
(
==
0
):
# The first child.
.
setsid
()
# this might fail
=
.
fork
()
# Fork a second child.
if
(
==
0
):
# The second child.
.
chdir
(
)
.
umask
(
)
else
:
# exit() or _exit()?  See below.
.
_exit
(
0
)
# Exit parent (the first child) of the second child.
else
:
.
_exit
(
0
)
# Exit parent of the first child.
for
in
range
(
3
):
_CloseFDNoErr
(
)
=
.
open
(
""/dev/null""
,
.
)
# stdin
assert
==
0
,
""Can't close/reopen stdin""
=
.
open
(
,
.
|
.
|
.
,
0600
)
# stdout
assert
==
1
,
""Can't close/reopen stdout""
# Duplicate standard output to standard error.
.
dup2
(
1
,
2
)
return
0
def
DaemonPidFileName
(
):
""""""Compute a ganeti pid file absolute path

  @type name: str
  @param name: the daemon name
  @rtype: str
  @return: the full path to the pidfile corresponding to the given
      daemon name

  """"""
return
.
.
join
(
.
,
""%s.pid""
%
)
def
WritePidFile
(
):
""""""Write the current process pidfile.

  The file will be written to L{constants.RUN_GANETI_DIR}I{/name.pid}

  @type name: str
  @param name: the daemon name to use
  @raise errors.GenericError: if the pid file already exists and
      points to a live process

  """"""
=
.
getpid
()
=
DaemonPidFileName
(
)
if
IsProcessAlive
(
ReadPidFile
(
)):
raise
.
GenericError
(
""%s contains a live process""
%
)
WriteFile
(
,
=
""%d
\n
""
%
)
def
RemovePidFile
(
):
""""""Remove the current process pidfile.

  Any errors are ignored.

  @type name: str
  @param name: the daemon name used to derive the pidfile name

  """"""
=
DaemonPidFileName
(
)
# TODO: we could check here that the file contains our pid
try
:
RemoveFile
(
)
except
:
pass
def
KillProcess
(
,
=
.
,
=
30
,
=
False
):
""""""Kill a process given by its pid.

  @type pid: int
  @param pid: The PID to terminate.
  @type signal_: int
  @param signal_: The signal to send, by default SIGTERM
  @type timeout: int
  @param timeout: The timeout after which, if the process is still alive,
                  a SIGKILL will be sent. If not positive, no such checking
                  will be done
  @type waitpid: boolean
  @param waitpid: If true, we should waitpid on this process after
      sending signals, since it's our own child and otherwise it
      would remain as zombie

  """"""
def
_helper
(
,
,
):
""""""Simple helper to encapsulate the kill/waitpid sequence""""""
.
kill
(
,
)
if
:
try
:
.
waitpid
(
,
.
)
except
OSError
:
pass
if
<=
0
:
# kill with pid=0 == suicide
raise
.
ProgrammerError
(
""Invalid pid given '%s'""
%
)
if not
IsProcessAlive
(
):
return
_helper
(
,
,
)
if
<=
0
:
return
# Wait up to $timeout seconds
=
.
time
() +
=
0.01
while
.
time
() <
and
IsProcessAlive
(
):
try
:
(
,
) =
.
waitpid
(
,
.
)
if
>
0
:
break
except
OSError
:
pass
.
sleep
(
)
# Make wait time longer for next try
if
<
0.1
:
*=
1.5
if
IsProcessAlive
(
):
# Kill process if it's still alive
_helper
(
,
.
,
)
def
FindFile
(
,
,
=
.
.
):
""""""Look for a filesystem object in a given path.

  This is an abstract method to search for filesystem object (files,
  dirs) under a given search path.

  @type name: str
  @param name: the name to look for
  @type search_path: str
  @param search_path: location to start at
  @type test: callable
  @param test: a function taking one argument that should return True
      if the a given object is valid; the default value is
      os.path.exists, causing only existing files to be returned
  @rtype: str or None
  @return: full path to the object if found, None otherwise

  """"""
for
in
:
=
.
.
.
join
([
,
])
if
test
(
):
return
return None
def
CheckVolumeGroupSize
(
,
,
):
""""""Checks if the volume group list is valid.

  The function will check if a given volume group is in the list of
  volume groups and has a minimum size.

  @type vglist: dict
  @param vglist: dictionary of volume group names and their size
  @type vgname: str
  @param vgname: the volume group we should check
  @type minsize: int
  @param minsize: the minimum size we accept
  @rtype: None or str
  @return: None for success, otherwise the error message

  """"""
=
.
get
(
,
None
)
if
is None
:
return
""volume group '%s' missing""
%
elif
<
:
return
(
""volume group '%s' too small (%s MiB required, %d MiB found)""
%
(
,
,
))
return None
def
SplitTime
(
):
""""""Splits time as floating point number into a tuple.

  @param value: Time in seconds
  @type value: int or float
  @return: Tuple containing (seconds, microseconds)

  """"""
(
,
) =
divmod
(
int
(
*
1000000
),
1000000
)
assert
0
<=
,
""Seconds must be larger than or equal to 0, but are %s""
%
assert
0
<=
<=
999999
,
""Microseconds must be 0-999999, but are %s""
%
return
(
int
(
),
int
(
))
def
MergeTime
(
):
""""""Merges a tuple into time as a floating point number.

  @param timetuple: Time as tuple, (seconds, microseconds)
  @type timetuple: tuple
  @return: Time as a floating point number expressed in seconds

  """"""
(
,
) =
assert
0
<=
,
""Seconds must be larger than or equal to 0, but are %s""
%
assert
0
<=
<=
999999
,
""Microseconds must be 0-999999, but are %s""
%
return
float
(
) + (
float
(
) *
0.000001
)
def
GetNodeDaemonPort
():
""""""Get the node daemon port for this cluster.

  Note that this routine does not read a ganeti-specific file, but
  instead uses C{socket.getservbyname} to allow pre-customization of
  this parameter outside of Ganeti.

  @rtype: int

  """"""
try
:
=
.
getservbyname
(
""ganeti-noded""
,
""tcp""
)
except
.
:
=
.
return
def
SetupLogging
(
,
=
False
,
=
False
,
=
""""
,
=
False
):
""""""Configures the logging module.

  @type logfile: str
  @param logfile: the filename to which we should log
  @type debug: boolean
  @param debug: whether to enable debug messages too or
      only those at C{INFO} and above level
  @type stderr_logging: boolean
  @param stderr_logging: whether we should also log to the standard error
  @type program: str
  @param program: the name under which we should log messages
  @type multithreaded: boolean
  @param multithreaded: if True, will add the thread name to the log file
  @raise EnvironmentError: if we can't open the log file and
      stderr logging is disabled

  """"""
=
""%(asctime)s: ""
+
+
"" pid=%(process)d""
if
:
+=
""/%(threadName)s""
if
:
+=
"" %(module)s:%(lineno)s""
+=
"" %(levelname)s %(message)s""
=
.
Formatter
(
)
=
.
getLogger
(
""""
)
.
setLevel
(
.
)
# Remove all previously setup handlers
for
in
.
:
.
close
()
.
removeHandler
(
)
if
:
=
.
StreamHandler
()
.
setFormatter
(
)
if
:
.
setLevel
(
.
)
else
:
.
setLevel
(
.
)
.
addHandler
(
)
# this can fail, if the logging directories are not setup or we have
# a permisssion problem; in this case, it's best to log but ignore
# the error if stderr_logging is True, and if false we re-raise the
# exception since otherwise we could run but without any logs at all
try
:
=
.
FileHandler
(
)
.
setFormatter
(
)
if
:
.
setLevel
(
.
)
else
:
.
setLevel
(
.
)
.
addHandler
(
)
except
EnvironmentError
:
if
:
.
exception
(
""Failed to enable logging to file '%s'""
,
)
else
:
# we need to re-raise the exception
raise
def
TailFile
(
,
=
20
):
""""""Return the last lines from a file.

  @note: this function will only read and parse the last 4KB of
      the file; if the lines are very long, it could be that less
      than the requested number of lines are returned

  @param fname: the file name
  @type lines: int
  @param lines: the (maximum) number of lines to return

  """"""
=
open
(
,
""r""
)
try
:
.
seek
(
0
,
2
)
=
.
tell
()
=
max
(
0
,
-
4096
)
.
seek
(
,
0
)
=
.
read
()
finally
:
.
close
()
=
.
splitlines
()
return
[-
:]
def
SafeEncode
(
):
""""""Return a 'safe' version of a source string.

  This function mangles the input string and returns a version that
  should be safe to display/encode as ASCII. To this end, we first
  convert it to ASCII using the 'backslashreplace' encoding which
  should get rid of any non-ASCII chars, and then we process it
  through a loop copied from the string repr sources in the python; we
  don't use string_escape anymore since that escape single quotes and
  backslashes too, and that is too much; and that escaping is not
  stable, i.e. string_escape(string_escape(x)) != string_escape(x).

  @type text: str or unicode
  @param text: input data
  @rtype: str
  @return: a safe version of text

  """"""
if
isinstance
(
,
unicode
):
# only if unicode; if str already, we handle it below
=
.
encode
(
'ascii'
,
'backslashreplace'
)
=
""""
for
in
:
=
ord
(
)
if
==
'
\t
'
:
+=
'\t'
elif
==
'
\n
'
:
+=
'\n'
elif
==
'
\r
'
:
+=
'\'r'
elif
<
32
or
>=
127
:
# non-printable
+=
""
\\
x%02x""
% (
&
0xff
)
else
:
+=
return
def
CommaJoin
(
):
""""""Nicely join a set of identifiers.

  @param names: set, list or tuple
  @return: a string with the formatted results

  """"""
return
"", ""
.
join
([
""'%s'""
%
for
in
])
def
LockedMethod
(
):
""""""Synchronized object access decorator.

  This decorator is intended to protect access to an object using the
  object's own lock which is hardcoded to '_lock'.

  """"""
def
_LockDebug
(*
, **
):
if
:
.
debug
(*
, **
)
def
wrapper
(
, *
, **
):
assert
hasattr
(
,
'_lock'
)
=
.
_LockDebug
(
""Waiting for %s""
,
)
.
acquire
()
try
:
_LockDebug
(
""Acquired %s""
,
)
=
fn
(
, *
, **
)
finally
:
_LockDebug
(
""Releasing %s""
,
)
.
release
()
_LockDebug
(
""Released %s""
,
)
return
return
def
LockFile
(
):
""""""Locks a file using POSIX locks.

  @type fd: int
  @param fd: the file descriptor we need to lock

  """"""
try
:
.
flock
(
,
.
|
.
)
except
IOError
,
:
if
.
==
.
:
raise
.
LockError
(
""File already locked""
)
raise
class
FileLock
(
object
):
""""""Utility class for file locks.

  """"""
def
__init__
(
,
):
""""""Constructor for FileLock.

    This will open the file denoted by the I{filename} argument.

    @type filename: str
    @param filename: path to the file to be locked

    """"""
.
=
.
=
open
(
.
,
""w""
)
def
__del__
(
):
.
Close
()
def
Close
(
):
""""""Close the file and release the lock.

    """"""
if
.
:
.
.
close
()
.
=
None
def
_flock
(
,
,
,
,
):
""""""Wrapper for fcntl.flock.

    @type flag: int
    @param flag: operation flag
    @type blocking: bool
    @param blocking: whether the operation should be done in blocking mode.
    @type timeout: None or float
    @param timeout: for how long the operation should be retried (implies
                    non-blocking mode).
    @type errmsg: string
    @param errmsg: error message in case operation fails.

    """"""
assert
.
,
""Lock was closed""
assert
is None or
>=
0
,
""If specified, timeout must be positive""
if
is not None
:
|=
.
=
.
time
() +
# Blocking doesn't have effect with timeout
elif not
:
|=
.
=
None
=
True
while
:
try
:
.
flock
(
.
,
)
=
False
except
IOError
,
:
if
.
in
(
.
, ):
if
is not None and
.
time
() <
:
# Wait before trying again
.
sleep
(
max
(
0.1
,
min
(
1.0
,
)))
else
:
raise
.
LockError
(
)
else
:
.
exception
(
""fcntl.flock failed""
)
raise
def
Exclusive
(
,
=
False
,
=
None
):
""""""Locks the file in exclusive mode.

    @type blocking: boolean
    @param blocking: whether to block and wait until we
        can lock the file or return immediately
    @type timeout: int or None
    @param timeout: if not None, the duration to wait for the lock
        (in blocking mode)

    """"""
.
_flock
(
.
,
,
,
""Failed to lock %s in exclusive mode""
%
.
)
def
Shared
(
,
=
False
,
=
None
):
""""""Locks the file in shared mode.

    @type blocking: boolean
    @param blocking: whether to block and wait until we
        can lock the file or return immediately
    @type timeout: int or None
    @param timeout: if not None, the duration to wait for the lock
        (in blocking mode)

    """"""
.
_flock
(
.
,
,
,
""Failed to lock %s in shared mode""
%
.
)
def
Unlock
(
,
=
True
,
=
None
):
""""""Unlocks the file.

    According to C{flock(2)}, unlocking can also be a nonblocking
    operation::

      To make a non-blocking request, include LOCK_NB with any of the above
      operations.

    @type blocking: boolean
    @param blocking: whether to block and wait until we
        can lock the file or return immediately
    @type timeout: int or None
    @param timeout: if not None, the duration to wait for the lock
        (in blocking mode)

    """"""
.
_flock
(
.
,
,
,
""Failed to unlock %s""
%
.
)
class
SignalHandler
(
object
):
""""""Generic signal handler class.

  It automatically restores the original handler when deconstructed or
  when L{Reset} is called. You can either pass your own handler
  function in or query the L{called} attribute to detect whether the
  signal was sent.

  @type signum: list
  @ivar signum: the signals we handle
  @type called: boolean
  @ivar called: tracks whether any of the signals have been raised

  """"""
def
__init__
(
,
):
""""""Constructs a new SignalHandler instance.

    @type signum: int or list of ints
    @param signum: Single signal number or set of signal numbers

    """"""
if
isinstance
(
, (
int
,
long
)):
.
=
set
([
])
else
:
.
=
set
(
)
.
=
False
.
= {}
try
:
for
in
.
:
# Setup handler
=
.
signal
(
,
.
)
try
:
.
[
] =
except
:
# Restore previous handler
.
signal
(
,
)
raise
except
:
# Reset all handlers
.
Reset
()
# Here we have a race condition: a handler may have already been called,
# but there's not much we can do about it at this point.
raise
def
__del__
(
):
.
Reset
()
def
Reset
(
):
""""""Restore previous handler.

    This will reset all the signals to their previous handlers.

    """"""
for
,
in
.
.
items
():
.
signal
(
,
)
# If successful, remove from dict
del
.
[
]
def
Clear
(
):
""""""Unsets the L{called} flag.

    This function can be used in case a signal may arrive several times.

    """"""
.
=
False
def
_HandleSignal
(
,
,
):
""""""Actual signal handling function.

    """"""
# This is not nice and not absolutely atomic, but it appears to be the only
# solution in Python -- there are no atomic types.
.
=
True
class
FieldSet
(
object
):
""""""A simple field set.

  Among the features are:
    - checking if a string is among a list of static string or regex objects
    - checking if a whole list of string matches
    - returning the matching groups from a regex match

  Internally, all fields are held as regular expression objects.

  """"""
def
__init__
(
, *
):
.
= [
.
compile
(
""^%s$""
%
)
for
in
]
def
Extend
(
,
):
""""""Extend the field set with the items from another one""""""
.
.
extend
(
.
)
def
Matches
(
,
):
""""""Checks if a field matches the current set

    @type field: str
    @param field: the string to match
    @return: either False or a regular expression match object

    """"""
for
in
.
ifilter
(
None
, (
.
match
(
)
for
in
.
)):
return
return False
def
NonMatching
(
,
):
""""""Returns the list of fields not matching the current set

    @type items: list
    @param items: the list of fields to check
    @rtype: list
    @return: list of non-matching fields

    """"""
return
[
for
in
if not
.
Matches
(
)]
","#
#
# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
""""""Ganeti utility module.

This module holds functions that can be used in both daemons (all) and
the command line scripts.

""""""
import
import
import
import
import
import
import
import
import
import
import
import
import
import
import
from
import
try
:
from
import
except
ImportError
:
import
=
.
from
import
from
import
= []
=
.
compile
(
'^[-.,=:/_+@A-Za-z0-9]+$'
)
=
False
#: when set to True, L{RunCmd} is disabled
=
False
class
RunResult
(
object
):
""""""Holds the result of running external programs.

  @type exit_code: int
  @ivar exit_code: the exit code of the program, or None (if the program
      didn't exit())
  @type signal: int or None
  @ivar signal: the signal that caused the program to finish, or None
      (if the program wasn't terminated by a signal)
  @type stdout: str
  @ivar stdout: the standard output of the program
  @type stderr: str
  @ivar stderr: the standard error of the program
  @type failed: boolean
  @ivar failed: True in case the program was
      terminated by a signal or exited with a non-zero exit code
  @ivar fail_reason: a string detailing the termination reason

  """"""
= [
""exit_code""
,
""signal""
,
""stdout""
,
""stderr""
,
""failed""
,
""fail_reason""
,
""cmd""
]
def
__init__
(
,
,
,
,
,
):
.
=
.
=
.
=
.
=
.
=
.
= (
is not None or
!=
0
)
if
.
is not None
:
.
=
""terminated by signal %s""
%
.
elif
.
is not None
:
.
=
""exited with exit code %s""
%
.
else
:
.
=
""unable to determine termination reason""
if
.
:
.
debug
(
""Command '%s' failed (%s); output: %s""
,
.
,
.
,
.
)
def
_GetOutput
(
):
""""""Returns the combined stdout and stderr for easier usage.

    """"""
return
.
+
.
=
property
(
,
None
,
None
,
""Return full output""
)
def
RunCmd
(
,
=
None
,
=
None
,
=
'/'
):
""""""Execute a (shell) command.

  The command should not read from its standard input, as it will be
  closed.

  @type  cmd: string or list
  @param cmd: Command to run
  @type env: dict
  @param env: Additional environment
  @type output: str
  @param output: if desired, the output of the command can be
      saved in a file instead of the RunResult instance; this
      parameter denotes the file name (if not None)
  @type cwd: string
  @param cwd: if specified, will be used as the working
      directory for the command; the default will be /
  @rtype: L{RunResult}
  @return: RunResult instance
  @raise errors.ProgrammerError: if we call this when forks are disabled

  """"""
if
:
raise
.
ProgrammerError
(
""utils.RunCmd() called with fork() disabled""
)
if
isinstance
(
,
list
):
= [
str
(
)
for
in
]
=
"" ""
.
join
(
)
=
False
else
:
=
=
True
.
debug
(
""RunCmd '%s'""
,
)
=
.
.
copy
()
[
""LC_ALL""
] =
""C""
if
is not None
:
.
update
(
)
try
:
if
is None
:
,
,
=
_RunCmdPipe
(
,
,
,
)
else
:
=
_RunCmdFile
(
,
,
,
,
)
=
=
""""
except
OSError
,
:
if
.
==
.
:
raise
.
OpExecError
(
""Can't execute '%s': not found (%s)""
%
(
,
))
else
:
raise
if
>=
0
:
=
=
None
else
:
=
None
= -
return
RunResult
(
,
,
,
,
)
def
_RunCmdPipe
(
,
,
,
):
""""""Run a command and return its output.

  @type  cmd: string or list
  @param cmd: Command to run
  @type env: dict
  @param env: The environment to use
  @type via_shell: bool
  @param via_shell: if we should run via the shell
  @type cwd: string
  @param cwd: the working directory for the program
  @rtype: tuple
  @return: (out, err, status)

  """"""
=
.
poll
()
=
.
Popen
(
,
=
,
=
.
,
=
.
,
=
.
,
=
True
,
=
,
=
)
.
.
close
()
.
register
(
.
,
.
)
.
register
(
.
,
.
)
=
StringIO
()
=
StringIO
()
= {
.
.
fileno
(): (
,
.
),
.
.
fileno
(): (
,
.
),
}
for
in
:
=
.
fcntl
(
,
.
)
.
fcntl
(
,
.
,
|
.
)
while
:
try
:
=
.
poll
()
except
EnvironmentError
,
:
if
.
==
.
:
continue
raise
except
.
,
:
if
[
0
] ==
.
:
continue
raise
for
,
in
:
if
&
.
or
&
.
:
=
[
][
1
].
read
()
# no data from read signifies EOF (the same as POLLHUP)
if not
:
.
unregister
(
)
del
[
]
continue
[
][
0
].
write
(
)
if
(
&
.
or
&
.
or
&
.
):
.
unregister
(
)
del
[
]
=
.
getvalue
()
=
.
getvalue
()
=
.
wait
()
return
,
,
def
_RunCmdFile
(
,
,
,
,
):
""""""Run a command and save its output to a file.

  @type  cmd: string or list
  @param cmd: Command to run
  @type env: dict
  @param env: The environment to use
  @type via_shell: bool
  @param via_shell: if we should run via the shell
  @type output: str
  @param output: the filename in which to save the output
  @type cwd: string
  @param cwd: the working directory for the program
  @rtype: int
  @return: the exit status

  """"""
=
open
(
,
""a""
)
try
:
=
.
Popen
(
,
=
,
=
.
,
=
,
=
.
,
=
True
,
=
,
=
)
.
.
close
()
=
.
wait
()
finally
:
.
close
()
return
def
RemoveFile
(
):
""""""Remove a file ignoring some errors.

  Remove a file, ignoring non-existing ones or directories. Other
  errors are passed.

  @type filename: str
  @param filename: the file to be removed

  """"""
try
:
.
unlink
(
)
except
OSError
,
:
if
.
not in
(
.
,
.
):
raise
def
RenameFile
(
,
,
=
False
,
=
0750
):
""""""Renames a file.

  @type old: string
  @param old: Original path
  @type new: string
  @param new: New path
  @type mkdir: bool
  @param mkdir: Whether to create target directory if it doesn't exist
  @type mkdir_mode: int
  @param mkdir_mode: Mode for newly created directories

  """"""
try
:
return
.
rename
(
,
)
except
OSError
,
:
# In at least one use case of this function, the job queue, directory
# creation is very rare. Checking for the directory before renaming is not
# as efficient.
if
and
.
==
.
:
# Create directory and try again
.
makedirs
(
.
.
dirname
(
),
)
return
.
rename
(
,
)
raise
def
_FingerprintFile
(
):
""""""Compute the fingerprint of a file.

  If the file does not exist, a None will be returned
  instead.

  @type filename: str
  @param filename: the filename to checksum
  @rtype: str
  @return: the hex digest of the sha checksum of the contents
      of the file

  """"""
if not
(
.
.
exists
(
)
and
.
.
isfile
(
)):
return None
=
open
(
)
=
sha1
()
while True
:
=
.
read
(
4096
)
if not
:
break
.
update
(
)
return
.
hexdigest
()
def
FingerprintFiles
(
):
""""""Compute fingerprints for a list of files.

  @type files: list
  @param files: the list of filename to fingerprint
  @rtype: dict
  @return: a dictionary filename: fingerprint, holding only
      existing files

  """"""
= {}
for
in
:
=
_FingerprintFile
(
)
if
:
[
] =
return
def
CheckDict
(
,
,
=
None
):
""""""Ensure a dictionary has a required set of keys.

  For the given dictionaries I{target} and I{template}, ensure
  I{target} has all the keys from I{template}. Missing keys are added
  with values from template.

  @type target: dict
  @param target: the dictionary to update
  @type template: dict
  @param template: the dictionary holding the default values
  @type logname: str or None
  @param logname: if not None, causes the missing keys to be
      logged with this name

  """"""
= []
for
in
:
if
not in
:
.
append
(
)
[
] =
[
]
if
and
:
.
warning
(
'%s missing keys %s'
,
,
', '
.
join
(
))
def
ForceDictType
(
,
,
=
None
):
""""""Force the values of a dict to have certain types.

  @type target: dict
  @param target: the dict to update
  @type key_types: dict
  @param key_types: dict mapping target dict keys to types
                    in constants.ENFORCEABLE_TYPES
  @type allowed_values: list
  @keyword allowed_values: list of specially allowed values

  """"""
if
is None
:
= []
for
in
:
if
not in
:
=
""Unknown key '%s'""
%
raise
.
TypeEnforcementError
(
)
if
[
]
in
:
continue
type
=
[
]
if
type
not in
.
:
=
""'%s' has non-enforceable type %s""
% (
,
type
)
raise
.
ProgrammerError
(
)
if
type
==
.
:
if not
isinstance
(
[
],
):
if
isinstance
(
[
],
bool
)
and not
[
]:
[
] =
''
else
:
=
""'%s' (value %s) is not a valid string""
% (
,
[
])
raise
.
TypeEnforcementError
(
)
elif
type
==
.
:
if
isinstance
(
[
],
)
and
[
]:
if
[
].
lower
() ==
.
:
[
] =
False
elif
[
].
lower
() ==
.
:
[
] =
True
else
:
=
""'%s' (value %s) is not a valid boolean""
% (
,
[
])
raise
.
TypeEnforcementError
(
)
elif
[
]:
[
] =
True
else
:
[
] =
False
elif
type
==
.
:
try
:
[
] =
ParseUnit
(
[
])
except
.
,
:
=
""'%s' (value %s) is not a valid size. error: %s""
%
(
,
[
],
)
raise
.
TypeEnforcementError
(
)
elif
type
==
.
:
try
:
[
] =
int
(
[
])
except
(
ValueError
,
TypeError
):
=
""'%s' (value %s) is not a valid integer""
% (
,
[
])
raise
.
TypeEnforcementError
(
)
def
IsProcessAlive
(
):
""""""Check if a given pid exists on the system.

  @note: zombie status is not handled, so zombie processes
      will be returned as alive
  @type pid: int
  @param pid: the process ID to check
  @rtype: boolean
  @return: True if the process exists

  """"""
if
<=
0
:
return False
try
:
.
stat
(
""/proc/%d/status""
%
)
return True
except
EnvironmentError
,
:
if
.
in
(
.
,
.
):
return False
raise
def
ReadPidFile
(
):
""""""Read a pid from a file.

  @type  pidfile: string
  @param pidfile: path to the file containing the pid
  @rtype: int
  @return: The process id, if the file exists and contains a valid PID,
           otherwise 0

  """"""
try
:
=
open
(
,
'r'
)
except
EnvironmentError
,
:
if
.
!=
.
:
.
exception
(
""Can't read pid file?!""
)
return
0
try
:
=
int
(
.
read
())
except
ValueError
,
:
.
info
(
""Can't parse pid file contents""
,
=
True
)
return
0
return
def
MatchNameComponent
(
,
):
""""""Try to match a name against a list.

  This function will try to match a name like test1 against a list
  like C{['test1.example.com', 'test2.example.com', ...]}. Against
  this list, I{'test1'} as well as I{'test1.example'} will match, but
  not I{'test1.ex'}. A multiple match will be considered as no match
  at all (e.g. I{'test1'} against C{['test1.example.com',
  'test1.example.org']}).

  @type key: str
  @param key: the name to be searched
  @type name_list: list
  @param name_list: the list of strings against which to search the key

  @rtype: None or str
  @return: None if there is no match I{or} if there are multiple matches,
      otherwise the element from the list which matches

  """"""
=
.
compile
(
""^%s(\..*)?$""
%
.
escape
(
))
= [
for
in
if
.
match
(
)
is not None
]
if
len
(
) !=
1
:
return None
return
[
0
]
class
:
""""""Class implementing resolver and hostname functionality

  """"""
def
__init__
(
,
=
None
):
""""""Initialize the host name object.

    If the name argument is not passed, it will use this system's
    name.

    """"""
if
is None
:
=
.
SysName
()
.
=
.
,
.
,
.
=
.
LookupHostname
(
)
.
=
.
[
0
]
def
ShortName
(
):
""""""Returns the hostname without domain.

    """"""
return
.
.
split
(
'.'
)[
0
]
@
staticmethod
def
SysName
():
""""""Return the current system's name.

    This is simply a wrapper over C{socket.gethostname()}.

    """"""
return
.
gethostname
()
@
staticmethod
def
LookupHostname
(
):
""""""Look up hostname

    @type hostname: str
    @param hostname: hostname to look up

    @rtype: tuple
    @return: a tuple (name, aliases, ipaddrs) as returned by
        C{socket.gethostbyname_ex}
    @raise errors.ResolverError: in case of errors in resolving

    """"""
try
:
=
.
gethostbyname_ex
(
)
except
.
,
:
# hostname not found in DNS
raise
.
ResolverError
(
,
.
[
0
],
.
[
1
])
return
def
ListVolumeGroups
():
""""""List volume groups and their size

  @rtype: dict
  @return:
       Dictionary with keys volume name and values
       the size of the volume

  """"""
=
""vgs --noheadings --units m --nosuffix -o name,size""
=
RunCmd
(
)
= {}
if
.
:
return
for
in
.
.
splitlines
():
try
:
,
=
.
split
()
=
int
(
float
(
))
except
(
IndexError
,
ValueError
),
:
.
error
(
""Invalid output from vgs (%s): %s""
,
,
)
continue
[
] =
return
def
BridgeExists
(
):
""""""Check whether the given bridge exists in the system

  @type bridge: str
  @param bridge: the bridge name to check
  @rtype: boolean
  @return: True if it does

  """"""
return
.
.
isdir
(
""/sys/class/net/%s/bridge""
%
)
def
NiceSort
(
):
""""""Sort a list of strings based on digit and non-digit groupings.

  Given a list of names C{['a1', 'a10', 'a11', 'a2']} this function
  will sort the list in the logical order C{['a1', 'a2', 'a10',
  'a11']}.

  The sort algorithm breaks each name in groups of either only-digits
  or no-digits. Only the first eight such groups are considered, and
  after that we just use what's left of the string.

  @type name_list: list
  @param name_list: the names to be sorted
  @rtype: list
  @return: a copy of the name list sorted with our algorithm

  """"""
=
""(\D+|\d+)""
=
""^%s%s?%s?%s?%s?%s?%s?%s?.*$""
% (
,
,
,
,
,
,
,
)
=
.
compile
(
)
=
.
compile
(
""^\D*$""
)
def
_TryInt
(
):
""""""Attempts to convert a variable to integer.""""""
if
is None or
.
match
(
):
return
=
int
(
)
return
= [([
_TryInt
(
)
for
in
.
match
(
).
groups
()],
)
for
in
]
.
sort
()
return
[
[
1
]
for
in
]
def
TryConvert
(
,
):
""""""Try to convert a value ignoring errors.

  This function tries to apply function I{fn} to I{val}. If no
  C{ValueError} or C{TypeError} exceptions are raised, it will return
  the result, else it will return the original value. Any other
  exceptions are propagated to the caller.

  @type fn: callable
  @param fn: function to apply to the value
  @param val: the value to be converted
  @return: The converted value if the conversion was successful,
      otherwise the original value.

  """"""
try
:
=
fn
(
)
except
(
ValueError
,
TypeError
):
=
return
def
IsValidIP
(
):
""""""Verifies the syntax of an IPv4 address.

  This function checks if the IPv4 address passes is valid or not based
  on syntax (not IP range, class calculations, etc.).

  @type ip: str
  @param ip: the address to be checked
  @rtype: a regular expression match object
  @return: a regular expression match object, or None if the
      address is not valid

  """"""
=
""(0|[1-9]\d{0,2})""
#TODO: convert and return only boolean
return
.
match
(
""^%s\.%s\.%s\.%s$""
% (
,
,
,
),
)
def
IsValidShellParam
(
):
""""""Verifies is the given word is safe from the shell's p.o.v.

  This means that we can pass this to a command via the shell and be
  sure that it doesn't alter the command line and is passed as such to
  the actual command.

  Note that we are overly restrictive here, in order to be on the safe
  side.

  @type word: str
  @param word: the word to check
  @rtype: boolean
  @return: True if the word is 'safe'

  """"""
return
bool
(
.
match
(
""^[-a-zA-Z0-9._+/:%@]+$""
,
))
def
BuildShellCmd
(
, *
):
""""""Build a safe shell command line from the given arguments.

  This function will check all arguments in the args list so that they
  are valid shell parameters (i.e. they don't contain shell
  metacharacters). If everything is ok, it will return the result of
  template % args.

  @type template: str
  @param template: the string holding the template for the
      string formatting
  @rtype: str
  @return: the expanded command line

  """"""
for
in
:
if not
IsValidShellParam
(
):
raise
.
ProgrammerError
(
""Shell argument '%s' contains""
"" invalid characters""
%
)
return
%
def
FormatUnit
(
,
):
""""""Formats an incoming number of MiB with the appropriate unit.

  @type value: int
  @param value: integer representing the value in MiB (1048576)
  @type units: char
  @param units: the type of formatting we should do:
      - 'h' for automatic scaling
      - 'm' for MiBs
      - 'g' for GiBs
      - 't' for TiBs
  @rtype: str
  @return: the formatted value (with suffix)

  """"""
if
not in
(
'm'
,
'g'
,
't'
,
'h'
):
raise
.
ProgrammerError
(
""Invalid unit specified '%s'""
%
str
(
))
=
''
if
==
'm'
or
(
==
'h'
and
<
1024
):
if
==
'h'
:
=
'M'
return
""%d%s""
% (
round
(
,
0
),
)
elif
==
'g'
or
(
==
'h'
and
< (
1024
*
1024
)):
if
==
'h'
:
=
'G'
return
""%0.1f%s""
% (
round
(
float
(
) /
1024
,
1
),
)
else
:
if
==
'h'
:
=
'T'
return
""%0.1f%s""
% (
round
(
float
(
) /
1024
/
1024
,
1
),
)
def
ParseUnit
(
):
""""""Tries to extract number and scale from the given string.

  Input must be in the format C{NUMBER+ [DOT NUMBER+] SPACE*
  [UNIT]}. If no unit is specified, it defaults to MiB. Return value
  is always an int in MiB.

  """"""
=
.
match
(
'^([.\d]+)\s*([a-zA-Z]+)?$'
,
str
(
))
if not
:
raise
.
UnitParseError
(
""Invalid format""
)
=
float
(
.
groups
()[
0
])
=
.
groups
()[
1
]
if
:
=
.
lower
()
else
:
=
'm'
if
in
(
'm'
,
'mb'
,
'mib'
):
# Value already in MiB
pass
elif
in
(
'g'
,
'gb'
,
'gib'
):
*=
1024
elif
in
(
't'
,
'tb'
,
'tib'
):
*=
1024
*
1024
else
:
raise
.
UnitParseError
(
""Unknown unit: %s""
%
)
# Make sure we round up
if
int
(
) <
:
+=
1
# Round up to the next multiple of 4
=
int
(
)
if
%
4
:
+=
4
-
%
4
return
def
AddAuthorizedKey
(
,
):
""""""Adds an SSH public key to an authorized_keys file.

  @type file_name: str
  @param file_name: path to authorized_keys file
  @type key: str
  @param key: string containing key

  """"""
=
.
split
()
=
open
(
,
'a+'
)
try
:
=
True
for
in
:
# Ignore whitespace changes
if
.
split
() ==
:
break
=
.
endswith
(
'
\n
'
)
else
:
if not
:
.
write
(
""
\n
""
)
.
write
(
.
rstrip
(
'
\r\n
'
))
.
write
(
""
\n
""
)
.
flush
()
finally
:
.
close
()
def
RemoveAuthorizedKey
(
,
):
""""""Removes an SSH public key from an authorized_keys file.

  @type file_name: str
  @param file_name: path to authorized_keys file
  @type key: str
  @param key: string containing key

  """"""
=
.
split
()
,
=
.
mkstemp
(
dir
=
.
.
dirname
(
))
try
:
=
.
fdopen
(
,
'w'
)
try
:
=
open
(
,
'r'
)
try
:
for
in
:
# Ignore whitespace changes while comparing lines
if
.
split
() !=
:
.
write
(
)
.
flush
()
.
rename
(
,
)
finally
:
.
close
()
finally
:
.
close
()
except
:
RemoveFile
(
)
raise
def
SetEtcHostsEntry
(
,
,
,
):
""""""Sets the name of an IP address and hostname in /etc/hosts.

  @type file_name: str
  @param file_name: path to the file to modify (usually C{/etc/hosts})
  @type ip: str
  @param ip: the IP address
  @type hostname: str
  @param hostname: the hostname to be added
  @type aliases: list
  @param aliases: the list of aliases to add for the hostname

  """"""
# FIXME: use WriteFile + fn rather than duplicating its efforts
# Ensure aliases are unique
=
UniqueSequence
([
] +
)[
1
:]
,
=
.
mkstemp
(
dir
=
.
.
dirname
(
))
try
:
=
.
fdopen
(
,
'w'
)
try
:
=
open
(
,
'r'
)
try
:
for
in
:
=
.
split
()
if
and not
[
0
].
startswith
(
'#'
)
and
==
[
0
]:
continue
.
write
(
)
.
write
(
""%s
\t
%s""
% (
,
))
if
:
.
write
(
"" %s""
%
' '
.
join
(
))
.
write
(
'
\n
'
)
.
flush
()
.
fsync
(
)
.
chmod
(
,
0644
)
.
rename
(
,
)
finally
:
.
close
()
finally
:
.
close
()
except
:
RemoveFile
(
)
raise
def
AddHostToEtcHosts
(
):
""""""Wrapper around SetEtcHostsEntry.

  @type hostname: str
  @param hostname: a hostname that will be resolved and added to
      L{constants.ETC_HOSTS}

  """"""
=
HostInfo
(
=
)
SetEtcHostsEntry
(
.
,
.
,
.
, [
.
ShortName
()])
def
RemoveEtcHostsEntry
(
,
):
""""""Removes a hostname from /etc/hosts.

  IP addresses without names are removed from the file.

  @type file_name: str
  @param file_name: path to the file to modify (usually C{/etc/hosts})
  @type hostname: str
  @param hostname: the hostname to be removed

  """"""
# FIXME: use WriteFile + fn rather than duplicating its efforts
,
=
.
mkstemp
(
dir
=
.
.
dirname
(
))
try
:
=
.
fdopen
(
,
'w'
)
try
:
=
open
(
,
'r'
)
try
:
for
in
:
=
.
split
()
if
len
(
) >
1
and not
[
0
].
startswith
(
'#'
):
=
[
1
:]
if
in
:
while
in
:
.
remove
(
)
if
:
.
write
(
""%s %s
\n
""
% (
[
0
],
' '
.
join
(
)))
continue
.
write
(
)
.
flush
()
.
fsync
(
)
.
chmod
(
,
0644
)
.
rename
(
,
)
finally
:
.
close
()
finally
:
.
close
()
except
:
RemoveFile
(
)
raise
def
RemoveHostFromEtcHosts
(
):
""""""Wrapper around RemoveEtcHostsEntry.

  @type hostname: str
  @param hostname: hostname that will be resolved and its
      full and shot name will be removed from
      L{constants.ETC_HOSTS}

  """"""
=
HostInfo
(
=
)
RemoveEtcHostsEntry
(
.
,
.
)
RemoveEtcHostsEntry
(
.
,
.
ShortName
())
def
CreateBackup
(
):
""""""Creates a backup of a file.

  @type file_name: str
  @param file_name: file to be backed up
  @rtype: str
  @return: the path to the newly created backup
  @raise errors.ProgrammerError: for invalid file names

  """"""
if not
.
.
isfile
(
):
raise
.
ProgrammerError
(
""Can't make a backup of a non-file '%s'""
%
)
=
'%s.backup-%d.'
% (
.
.
basename
(
),
int
(
.
time
()))
=
.
.
dirname
(
)
=
open
(
,
'rb'
)
try
:
(
,
) =
.
mkstemp
(
=
,
dir
=
)
=
.
fdopen
(
,
'wb'
)
try
:
.
copyfileobj
(
,
)
finally
:
.
close
()
finally
:
.
close
()
return
def
ShellQuote
(
):
""""""Quotes shell argument according to POSIX.

  @type value: str
  @param value: the argument to be quoted
  @rtype: str
  @return: the quoted value

  """"""
if
.
match
(
):
return
else
:
return
""'%s'""
%
.
replace
(
""'""
,
""'
\\
''""
)
def
ShellQuoteArgs
(
):
""""""Quotes a list of shell arguments.

  @type args: list
  @param args: list of arguments to be quoted
  @rtype: str
  @return: the quoted arguments concatenated with spaces

  """"""
return
' '
.
join
([
ShellQuote
(
)
for
in
])
def
TcpPing
(
,
,
=
10
,
=
False
,
=
None
):
""""""Simple ping implementation using TCP connect(2).

  Check if the given IP is reachable by doing attempting a TCP connect
  to it.

  @type target: str
  @param target: the IP or hostname to ping
  @type port: int
  @param port: the port to connect to
  @type timeout: int
  @param timeout: the timeout on the connection attempt
  @type live_port_needed: boolean
  @param live_port_needed: whether a closed port will cause the
      function to return failure, as if there was a timeout
  @type source: str or None
  @param source: if specified, will cause the connect to be made
      from this specific source address; failures to bind other
      than C{EADDRNOTAVAIL} will be ignored

  """"""
=
.
socket
(
.
,
.
)
=
False
if
is not None
:
try
:
.
bind
((
,
0
))
except
.
, (
,
):
if
==
.
:
=
False
.
settimeout
(
)
try
:
.
connect
((
,
))
.
close
()
=
True
except
.
:
=
False
except
.
, (
,
):
= (
not
)
and
(
==
.
)
return
def
OwnIpAddress
(
):
""""""Check if the current host has the the given IP address.

  Currently this is done by TCP-pinging the address from the loopback
  address.

  @type address: string
  @param address: the address to check
  @rtype: bool
  @return: True if we own the address

  """"""
return
TcpPing
(
,
.
,
=
.
)
def
ListVisibleFiles
(
):
""""""Returns a list of visible files in a directory.

  @type path: str
  @param path: the directory to enumerate
  @rtype: list
  @return: the list of all files not starting with a dot

  """"""
= [
for
in
.
listdir
(
)
if not
.
startswith
(
"".""
)]
.
sort
()
return
def
GetHomeDir
(
,
=
None
):
""""""Try to get the homedir of the given user.

  The user can be passed either as a string (denoting the name) or as
  an integer (denoting the user id). If the user is not found, the
  'default' argument is returned, which defaults to None.

  """"""
try
:
if
isinstance
(
,
):
=
.
getpwnam
(
)
elif
isinstance
(
, (
int
,
long
)):
=
.
getpwuid
(
)
else
:
raise
.
ProgrammerError
(
""Invalid type passed to GetHomeDir (%s)""
%
type
(
))
except
KeyError
:
return
return
.
def
NewUUID
():
""""""Returns a random UUID.

  @note: This is a Linux-specific method as it uses the /proc
      filesystem.
  @rtype: str

  """"""
=
open
(
""/proc/sys/kernel/random/uuid""
,
""r""
)
try
:
return
.
read
(
128
).
rstrip
(
""
\n
""
)
finally
:
.
close
()
def
GenerateSecret
():
""""""Generates a random secret.

  This will generate a pseudo-random secret, and return its sha digest
  (so that it can be used where an ASCII string is needed).

  @rtype: str
  @return: a sha1 hexdigest of a block of 64 random bytes

  """"""
return
sha1
(
.
urandom
(
64
)).
hexdigest
()
def
EnsureDirs
(
):
""""""Make required directories, if they don't exist.

  @param dirs: list of tuples (dir_name, dir_mode)
  @type dirs: list of (string, integer)

  """"""
for
,
in
:
try
:
.
mkdir
(
,
)
except
EnvironmentError
,
:
if
.
!=
.
:
raise
.
GenericError
(
""Cannot create needed directory""
"" '%s': %s""
% (
,
))
if not
.
.
isdir
(
):
raise
.
GenericError
(
""%s is not a directory""
%
)
def
ReadFile
(
,
=
None
):
""""""Reads a file.

  @type size: None or int
  @param size: Read at most size bytes
  @rtype: str
  @return: the (possibly partial) content of the file

  """"""
=
open
(
,
""r""
)
try
:
if
is None
:
return
.
read
()
else
:
return
.
read
(
)
finally
:
.
close
()
def
WriteFile
(
,
=
None
,
=
None
,
=
None
,
=-
1
,
=-
1
,
=
None
,
=
None
,
=
True
,
=
False
,
=
False
,
=
None
,
=
None
):
""""""(Over)write a file atomically.

  The file_name and either fn (a function taking one argument, the
  file descriptor, and which should write the data to it) or data (the
  contents of the file) must be passed. The other arguments are
  optional and allow setting the file mode, owner and group, and the
  mtime/atime of the file.

  If the function doesn't raise an exception, it has succeeded and the
  target file has the new contents. If the function has raised an
  exception, an existing target file should be unmodified and the
  temporary file should be removed.

  @type file_name: str
  @param file_name: the target filename
  @type fn: callable
  @param fn: content writing function, called with
      file descriptor as parameter
  @type data: str
  @param data: contents of the file
  @type mode: int
  @param mode: file mode
  @type uid: int
  @param uid: the owner of the file
  @type gid: int
  @param gid: the group of the file
  @type atime: int
  @param atime: a custom access time to be set on the file
  @type mtime: int
  @param mtime: a custom modification time to be set on the file
  @type close: boolean
  @param close: whether to close file after writing it
  @type prewrite: callable
  @param prewrite: function to be called before writing content
  @type postwrite: callable
  @param postwrite: function to be called after writing content

  @rtype: None or int
  @return: None if the 'close' parameter evaluates to True,
      otherwise the file descriptor

  @raise errors.ProgrammerError: if any of the arguments are not valid

  """"""
if not
.
.
isabs
(
):
raise
.
ProgrammerError
(
""Path passed to WriteFile is not""
"" absolute: '%s'""
%
)
if
[
,
].
count
(
None
) !=
1
:
raise
.
ProgrammerError
(
""fn or data required""
)
if
[
,
].
count
(
None
) ==
1
:
raise
.
ProgrammerError
(
""Both atime and mtime must be either""
"" set or None""
)
if
and not
and
.
.
isfile
(
):
CreateBackup
(
)
,
=
.
.
split
(
)
,
=
.
mkstemp
(
'.new'
,
,
)
=
True
# here we need to make sure we remove the temp file, if any error
# leaves it in place
try
:
if
!= -
1
or
!= -
1
:
.
chown
(
,
,
)
if
:
.
chmod
(
,
)
if
callable
(
):
prewrite
(
)
if
is not None
:
.
write
(
,
)
else
:
fn
(
)
if
callable
(
):
postwrite
(
)
.
fsync
(
)
if
is not None and
is not None
:
.
utime
(
, (
,
))
if not
:
.
rename
(
,
)
=
False
finally
:
if
:
.
close
(
)
=
None
else
:
=
if
:
RemoveFile
(
)
return
def
FirstFree
(
,
=
0
):
""""""Returns the first non-existing integer from seq.

  The seq argument should be a sorted list of positive integers. The
  first time the index of an element is smaller than the element
  value, the index will be returned.

  The base argument is used to start at a different offset,
  i.e. C{[3, 4, 6]} with I{offset=3} will return 5.

  Example: C{[0, 1, 3]} will return I{2}.

  @type seq: sequence
  @param seq: the sequence to be analyzed.
  @type base: int
  @param base: use this value as the base index of the sequence
  @rtype: int
  @return: the first non-used index in the sequence

  """"""
for
,
in
enumerate
(
):
assert
>=
,
""Passed element is higher than base offset""
if
>
+
:
# idx is not used
return
+
return None
def
all
(
,
=
bool
):
""Returns True if pred(x) is True for every element in the iterable""
for
in
.
ifilterfalse
(
,
):
return False
return True
def
any
(
,
=
bool
):
""Returns True if pred(x) is True for at least one element in the iterable""
for
in
.
ifilter
(
,
):
return True
return False
def
UniqueSequence
(
):
""""""Returns a list with unique elements.

  Element order is preserved.

  @type seq: sequence
  @param seq: the sequence with the source elements
  @rtype: list
  @return: list of unique elements from seq

  """"""
=
set
()
return
[
for
in
if
not in
and not
.
add
(
)]
def
IsValidMac
(
):
""""""Predicate to check if a MAC address is valid.

  Checks whether the supplied MAC address is formally correct, only
  accepts colon separated format.

  @type mac: str
  @param mac: the MAC to be validated
  @rtype: boolean
  @return: True is the MAC seems valid

  """"""
=
.
compile
(
""^([0-9a-f]{2}(:|$)){6}$""
)
return
.
match
(
)
is not None
def
TestDelay
(
):
""""""Sleep for a fixed amount of time.

  @type duration: float
  @param duration: the sleep duration
  @rtype: boolean
  @return: False for negative value, True otherwise

  """"""
if
<
0
:
return False
.
sleep
(
)
return True
def
_CloseFDNoErr
(
,
=
5
):
""""""Close a file descriptor ignoring errors.

  @type fd: int
  @param fd: the file descriptor
  @type retries: int
  @param retries: how many retries to make, in case we get any
      other error than EBADF

  """"""
try
:
.
close
(
)
except
OSError
,
:
if
.
!=
.
:
if
>
0
:
_CloseFDNoErr
(
,
-
1
)
# else either it's closed already or we're out of retries, so we
# ignore this and go on
def
CloseFDs
(
=
None
):
""""""Close file descriptors.

  This closes all file descriptors above 2 (i.e. except
  stdin/out/err).

  @type noclose_fds: list or None
  @param noclose_fds: if given, it denotes a list of file descriptor
      that should not be closed

  """"""
# Default maximum for the number of available file descriptors.
if
'SC_OPEN_MAX'
in
.
:
try
:
=
.
sysconf
(
'SC_OPEN_MAX'
)
if
<
0
:
=
1024
except
OSError
:
=
1024
else
:
=
1024
=
.
getrlimit
(
.
)[
1
]
if
(
==
.
):
=
# Iterate through and close all file descriptors (except the standard ones)
for
in
range
(
3
,
):
if
and
in
:
continue
_CloseFDNoErr
(
)
def
Daemonize
(
):
""""""Daemonize the current process.

  This detaches the current process from the controlling terminal and
  runs it in the background as a daemon.

  @type logfile: str
  @param logfile: the logfile to which we should redirect stdout/stderr
  @rtype: int
  @return: the value zero

  """"""
=
077
=
""/""
# this might fail
=
.
fork
()
if
(
==
0
):
# The first child.
.
setsid
()
# this might fail
=
.
fork
()
# Fork a second child.
if
(
==
0
):
# The second child.
.
chdir
(
)
.
umask
(
)
else
:
# exit() or _exit()?  See below.
.
_exit
(
0
)
# Exit parent (the first child) of the second child.
else
:
.
_exit
(
0
)
# Exit parent of the first child.
for
in
range
(
3
):
_CloseFDNoErr
(
)
=
.
open
(
""/dev/null""
,
.
)
# stdin
assert
==
0
,
""Can't close/reopen stdin""
=
.
open
(
,
.
|
.
|
.
,
0600
)
# stdout
assert
==
1
,
""Can't close/reopen stdout""
# Duplicate standard output to standard error.
.
dup2
(
1
,
2
)
return
0
def
DaemonPidFileName
(
):
""""""Compute a ganeti pid file absolute path

  @type name: str
  @param name: the daemon name
  @rtype: str
  @return: the full path to the pidfile corresponding to the given
      daemon name

  """"""
return
.
.
join
(
.
,
""%s.pid""
%
)
def
WritePidFile
(
):
""""""Write the current process pidfile.

  The file will be written to L{constants.RUN_GANETI_DIR}I{/name.pid}

  @type name: str
  @param name: the daemon name to use
  @raise errors.GenericError: if the pid file already exists and
      points to a live process

  """"""
=
.
getpid
()
=
DaemonPidFileName
(
)
if
IsProcessAlive
(
ReadPidFile
(
)):
raise
.
GenericError
(
""%s contains a live process""
%
)
WriteFile
(
,
=
""%d
\n
""
%
)
def
RemovePidFile
(
):
""""""Remove the current process pidfile.

  Any errors are ignored.

  @type name: str
  @param name: the daemon name used to derive the pidfile name

  """"""
=
DaemonPidFileName
(
)
# TODO: we could check here that the file contains our pid
try
:
RemoveFile
(
)
except
:
pass
def
KillProcess
(
,
=
.
,
=
30
,
=
False
):
""""""Kill a process given by its pid.

  @type pid: int
  @param pid: The PID to terminate.
  @type signal_: int
  @param signal_: The signal to send, by default SIGTERM
  @type timeout: int
  @param timeout: The timeout after which, if the process is still alive,
                  a SIGKILL will be sent. If not positive, no such checking
                  will be done
  @type waitpid: boolean
  @param waitpid: If true, we should waitpid on this process after
      sending signals, since it's our own child and otherwise it
      would remain as zombie

  """"""
def
_helper
(
,
,
):
""""""Simple helper to encapsulate the kill/waitpid sequence""""""
.
kill
(
,
)
if
:
try
:
.
waitpid
(
,
.
)
except
OSError
:
pass
if
<=
0
:
# kill with pid=0 == suicide
raise
.
ProgrammerError
(
""Invalid pid given '%s'""
%
)
if not
IsProcessAlive
(
):
return
_helper
(
,
,
)
if
<=
0
:
return
# Wait up to $timeout seconds
=
.
time
() +
=
0.01
while
.
time
() <
and
IsProcessAlive
(
):
try
:
(
,
) =
.
waitpid
(
,
.
)
if
>
0
:
break
except
OSError
:
pass
.
sleep
(
)
# Make wait time longer for next try
if
<
0.1
:
*=
1.5
if
IsProcessAlive
(
):
# Kill process if it's still alive
_helper
(
,
.
,
)
def
FindFile
(
,
,
=
.
.
):
""""""Look for a filesystem object in a given path.

  This is an abstract method to search for filesystem object (files,
  dirs) under a given search path.

  @type name: str
  @param name: the name to look for
  @type search_path: str
  @param search_path: location to start at
  @type test: callable
  @param test: a function taking one argument that should return True
      if the a given object is valid; the default value is
      os.path.exists, causing only existing files to be returned
  @rtype: str or None
  @return: full path to the object if found, None otherwise

  """"""
# validate the filename mask
if
.
.
match
(
)
is None
:
.
critical
(
""Invalid value passed for external script name: '%s'""
,
)
return None
for
in
:
=
.
.
.
join
([
,
])
# check the user test and that we're indeed resolving to the given
# basename
if
test
(
)
and
.
.
basename
(
) ==
:
return
return None
def
CheckVolumeGroupSize
(
,
,
):
""""""Checks if the volume group list is valid.

  The function will check if a given volume group is in the list of
  volume groups and has a minimum size.

  @type vglist: dict
  @param vglist: dictionary of volume group names and their size
  @type vgname: str
  @param vgname: the volume group we should check
  @type minsize: int
  @param minsize: the minimum size we accept
  @rtype: None or str
  @return: None for success, otherwise the error message

  """"""
=
.
get
(
,
None
)
if
is None
:
return
""volume group '%s' missing""
%
elif
<
:
return
(
""volume group '%s' too small (%s MiB required, %d MiB found)""
%
(
,
,
))
return None
def
SplitTime
(
):
""""""Splits time as floating point number into a tuple.

  @param value: Time in seconds
  @type value: int or float
  @return: Tuple containing (seconds, microseconds)

  """"""
(
,
) =
divmod
(
int
(
*
1000000
),
1000000
)
assert
0
<=
,
""Seconds must be larger than or equal to 0, but are %s""
%
assert
0
<=
<=
999999
,
""Microseconds must be 0-999999, but are %s""
%
return
(
int
(
),
int
(
))
def
MergeTime
(
):
""""""Merges a tuple into time as a floating point number.

  @param timetuple: Time as tuple, (seconds, microseconds)
  @type timetuple: tuple
  @return: Time as a floating point number expressed in seconds

  """"""
(
,
) =
assert
0
<=
,
""Seconds must be larger than or equal to 0, but are %s""
%
assert
0
<=
<=
999999
,
""Microseconds must be 0-999999, but are %s""
%
return
float
(
) + (
float
(
) *
0.000001
)
def
GetNodeDaemonPort
():
""""""Get the node daemon port for this cluster.

  Note that this routine does not read a ganeti-specific file, but
  instead uses C{socket.getservbyname} to allow pre-customization of
  this parameter outside of Ganeti.

  @rtype: int

  """"""
try
:
=
.
getservbyname
(
""ganeti-noded""
,
""tcp""
)
except
.
:
=
.
return
def
SetupLogging
(
,
=
False
,
=
False
,
=
""""
,
=
False
):
""""""Configures the logging module.

  @type logfile: str
  @param logfile: the filename to which we should log
  @type debug: boolean
  @param debug: whether to enable debug messages too or
      only those at C{INFO} and above level
  @type stderr_logging: boolean
  @param stderr_logging: whether we should also log to the standard error
  @type program: str
  @param program: the name under which we should log messages
  @type multithreaded: boolean
  @param multithreaded: if True, will add the thread name to the log file
  @raise EnvironmentError: if we can't open the log file and
      stderr logging is disabled

  """"""
=
""%(asctime)s: ""
+
+
"" pid=%(process)d""
if
:
+=
""/%(threadName)s""
if
:
+=
"" %(module)s:%(lineno)s""
+=
"" %(levelname)s %(message)s""
=
.
Formatter
(
)
=
.
getLogger
(
""""
)
.
setLevel
(
.
)
# Remove all previously setup handlers
for
in
.
:
.
close
()
.
removeHandler
(
)
if
:
=
.
StreamHandler
()
.
setFormatter
(
)
if
:
.
setLevel
(
.
)
else
:
.
setLevel
(
.
)
.
addHandler
(
)
# this can fail, if the logging directories are not setup or we have
# a permisssion problem; in this case, it's best to log but ignore
# the error if stderr_logging is True, and if false we re-raise the
# exception since otherwise we could run but without any logs at all
try
:
=
.
FileHandler
(
)
.
setFormatter
(
)
if
:
.
setLevel
(
.
)
else
:
.
setLevel
(
.
)
.
addHandler
(
)
except
EnvironmentError
:
if
:
.
exception
(
""Failed to enable logging to file '%s'""
,
)
else
:
# we need to re-raise the exception
raise
def
TailFile
(
,
=
20
):
""""""Return the last lines from a file.

  @note: this function will only read and parse the last 4KB of
      the file; if the lines are very long, it could be that less
      than the requested number of lines are returned

  @param fname: the file name
  @type lines: int
  @param lines: the (maximum) number of lines to return

  """"""
=
open
(
,
""r""
)
try
:
.
seek
(
0
,
2
)
=
.
tell
()
=
max
(
0
,
-
4096
)
.
seek
(
,
0
)
=
.
read
()
finally
:
.
close
()
=
.
splitlines
()
return
[-
:]
def
SafeEncode
(
):
""""""Return a 'safe' version of a source string.

  This function mangles the input string and returns a version that
  should be safe to display/encode as ASCII. To this end, we first
  convert it to ASCII using the 'backslashreplace' encoding which
  should get rid of any non-ASCII chars, and then we process it
  through a loop copied from the string repr sources in the python; we
  don't use string_escape anymore since that escape single quotes and
  backslashes too, and that is too much; and that escaping is not
  stable, i.e. string_escape(string_escape(x)) != string_escape(x).

  @type text: str or unicode
  @param text: input data
  @rtype: str
  @return: a safe version of text

  """"""
if
isinstance
(
,
unicode
):
# only if unicode; if str already, we handle it below
=
.
encode
(
'ascii'
,
'backslashreplace'
)
=
""""
for
in
:
=
ord
(
)
if
==
'
\t
'
:
+=
'\t'
elif
==
'
\n
'
:
+=
'\n'
elif
==
'
\r
'
:
+=
'\'r'
elif
<
32
or
>=
127
:
# non-printable
+=
""
\\
x%02x""
% (
&
0xff
)
else
:
+=
return
def
CommaJoin
(
):
""""""Nicely join a set of identifiers.

  @param names: set, list or tuple
  @return: a string with the formatted results

  """"""
return
"", ""
.
join
([
""'%s'""
%
for
in
])
def
LockedMethod
(
):
""""""Synchronized object access decorator.

  This decorator is intended to protect access to an object using the
  object's own lock which is hardcoded to '_lock'.

  """"""
def
_LockDebug
(*
, **
):
if
:
.
debug
(*
, **
)
def
wrapper
(
, *
, **
):
assert
hasattr
(
,
'_lock'
)
=
.
_LockDebug
(
""Waiting for %s""
,
)
.
acquire
()
try
:
_LockDebug
(
""Acquired %s""
,
)
=
fn
(
, *
, **
)
finally
:
_LockDebug
(
""Releasing %s""
,
)
.
release
()
_LockDebug
(
""Released %s""
,
)
return
return
def
LockFile
(
):
""""""Locks a file using POSIX locks.

  @type fd: int
  @param fd: the file descriptor we need to lock

  """"""
try
:
.
flock
(
,
.
|
.
)
except
IOError
,
:
if
.
==
.
:
raise
.
LockError
(
""File already locked""
)
raise
class
FileLock
(
object
):
""""""Utility class for file locks.

  """"""
def
__init__
(
,
):
""""""Constructor for FileLock.

    This will open the file denoted by the I{filename} argument.

    @type filename: str
    @param filename: path to the file to be locked

    """"""
.
=
.
=
open
(
.
,
""w""
)
def
__del__
(
):
.
Close
()
def
Close
(
):
""""""Close the file and release the lock.

    """"""
if
.
:
.
.
close
()
.
=
None
def
_flock
(
,
,
,
,
):
""""""Wrapper for fcntl.flock.

    @type flag: int
    @param flag: operation flag
    @type blocking: bool
    @param blocking: whether the operation should be done in blocking mode.
    @type timeout: None or float
    @param timeout: for how long the operation should be retried (implies
                    non-blocking mode).
    @type errmsg: string
    @param errmsg: error message in case operation fails.

    """"""
assert
.
,
""Lock was closed""
assert
is None or
>=
0
,
""If specified, timeout must be positive""
if
is not None
:
|=
.
=
.
time
() +
# Blocking doesn't have effect with timeout
elif not
:
|=
.
=
None
=
True
while
:
try
:
.
flock
(
.
,
)
=
False
except
IOError
,
:
if
.
in
(
.
, ):
if
is not None and
.
time
() <
:
# Wait before trying again
.
sleep
(
max
(
0.1
,
min
(
1.0
,
)))
else
:
raise
.
LockError
(
)
else
:
.
exception
(
""fcntl.flock failed""
)
raise
def
Exclusive
(
,
=
False
,
=
None
):
""""""Locks the file in exclusive mode.

    @type blocking: boolean
    @param blocking: whether to block and wait until we
        can lock the file or return immediately
    @type timeout: int or None
    @param timeout: if not None, the duration to wait for the lock
        (in blocking mode)

    """"""
.
_flock
(
.
,
,
,
""Failed to lock %s in exclusive mode""
%
.
)
def
Shared
(
,
=
False
,
=
None
):
""""""Locks the file in shared mode.

    @type blocking: boolean
    @param blocking: whether to block and wait until we
        can lock the file or return immediately
    @type timeout: int or None
    @param timeout: if not None, the duration to wait for the lock
        (in blocking mode)

    """"""
.
_flock
(
.
,
,
,
""Failed to lock %s in shared mode""
%
.
)
def
Unlock
(
,
=
True
,
=
None
):
""""""Unlocks the file.

    According to C{flock(2)}, unlocking can also be a nonblocking
    operation::

      To make a non-blocking request, include LOCK_NB with any of the above
      operations.

    @type blocking: boolean
    @param blocking: whether to block and wait until we
        can lock the file or return immediately
    @type timeout: int or None
    @param timeout: if not None, the duration to wait for the lock
        (in blocking mode)

    """"""
.
_flock
(
.
,
,
,
""Failed to unlock %s""
%
.
)
class
SignalHandler
(
object
):
""""""Generic signal handler class.

  It automatically restores the original handler when deconstructed or
  when L{Reset} is called. You can either pass your own handler
  function in or query the L{called} attribute to detect whether the
  signal was sent.

  @type signum: list
  @ivar signum: the signals we handle
  @type called: boolean
  @ivar called: tracks whether any of the signals have been raised

  """"""
def
__init__
(
,
):
""""""Constructs a new SignalHandler instance.

    @type signum: int or list of ints
    @param signum: Single signal number or set of signal numbers

    """"""
if
isinstance
(
, (
int
,
long
)):
.
=
set
([
])
else
:
.
=
set
(
)
.
=
False
.
= {}
try
:
for
in
.
:
# Setup handler
=
.
signal
(
,
.
)
try
:
.
[
] =
except
:
# Restore previous handler
.
signal
(
,
)
raise
except
:
# Reset all handlers
.
Reset
()
# Here we have a race condition: a handler may have already been called,
# but there's not much we can do about it at this point.
raise
def
__del__
(
):
.
Reset
()
def
Reset
(
):
""""""Restore previous handler.

    This will reset all the signals to their previous handlers.

    """"""
for
,
in
.
.
items
():
.
signal
(
,
)
# If successful, remove from dict
del
.
[
]
def
Clear
(
):
""""""Unsets the L{called} flag.

    This function can be used in case a signal may arrive several times.

    """"""
.
=
False
def
_HandleSignal
(
,
,
):
""""""Actual signal handling function.

    """"""
# This is not nice and not absolutely atomic, but it appears to be the only
# solution in Python -- there are no atomic types.
.
=
True
class
FieldSet
(
object
):
""""""A simple field set.

  Among the features are:
    - checking if a string is among a list of static string or regex objects
    - checking if a whole list of string matches
    - returning the matching groups from a regex match

  Internally, all fields are held as regular expression objects.

  """"""
def
__init__
(
, *
):
.
= [
.
compile
(
""^%s$""
%
)
for
in
]
def
Extend
(
,
):
""""""Extend the field set with the items from another one""""""
.
.
extend
(
.
)
def
Matches
(
,
):
""""""Checks if a field matches the current set

    @type field: str
    @param field: the string to match
    @return: either False or a regular expression match object

    """"""
for
in
.
ifilter
(
None
, (
.
match
(
)
for
in
.
)):
return
return False
def
NonMatching
(
,
):
""""""Returns the list of fields not matching the current set

    @type items: list
    @param items: the list of fields to check
    @rtype: list
    @return: list of non-matching fields

    """"""
return
[
for
in
if not
.
Matches
(
)]
"
CVE-2018-1000517,https://www.cvedetails.com/cve/CVE-2018-1000517/,CWE-119,,Overflow,2018-06-26,2019-04-03,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,BusyBox project BusyBox wget version prior to commit 8e2174e9bd836e53c8b9c6e00d1bc6e2a718686e contains a Buffer Overflow vulnerability in Busybox wget that can result in heap buffer overflow. This attack appear to be exploitable via network connectivity. This vulnerability appears to have been fixed in after commit 8e2174e9bd836e53c8b9c6e00d1bc6e2a718686e.,C,busybox,https://git.busybox.net/busybox/commit/?id=8e2174e9bd836e53c8b9c6e00d1bc6e2a718686e,8e2174e9bd836e53c8b9c6e00d1bc6e2a718686e,7bcde5f00dc3a5c92f36bb6ef6bf849794cd766e,"@@ -801,7 +801,7 @@ static FILE* prepare_ftp_session(FILE **dfpp, struct host_info *target, len_and_         if (ftpcmd(""SIZE "", target->path, sfp) == 213) {                 G.content_len = BB_STRTOOFF(G.wget_buf + 4, NULL, 10);                 if (G.content_len < 0 || errno) {-                        bb_error_msg_and_die(""SIZE value is garbage"");+                        bb_error_msg_and_die(""bad SIZE value '%s'"", G.wget_buf + 4);                 }                 G.got_clen = 1;         }@@ -965,11 +965,19 @@ static void NOINLINE retrieve_file_data(FILE *dfp)                 if (!G.chunked)                         break; -                fgets_trim_sanitize(dfp, NULL); /* Eat empty line */+                /* Each chunk ends with ""\r\n"" - eat it */+                fgets_trim_sanitize(dfp, NULL);  get_clen:+                /* chunk size format is ""HEXNUM[;name[=val]]\r\n"" */                 fgets_trim_sanitize(dfp, NULL);+                errno = 0;                 G.content_len = STRTOOFF(G.wget_buf, NULL, 16);-                /* FIXME: error check? */+                /*+                 * Had a bug with inputs like ""ffffffff0001f400""+                 * smashing the heap later. Ensure >= 0.+                 */+                if (G.content_len < 0 || errno)+                        bb_error_msg_and_die(""bad chunk length '%s'"", G.wget_buf);                 if (G.content_len == 0)                         break; /* all done! */                 G.got_clen = 1;",https://git.busybox.net/busybox/tree/networking/wget.c?id=7bcde5f00dc3a5c92f36bb6ef6bf849794cd766e,https://git.busybox.net/busybox/tree/networking/wget.c?id=8e2174e9bd836e53c8b9c6e00d1bc6e2a718686e,,
CVE-2017-1000035,https://www.cvedetails.com/cve/CVE-2017-1000035/,CWE-79,,XSS,2017-07-17,2017-10-06,4.3,None,Remote,Medium,Not required,None,Partial,None,Tiny Tiny RSS before 829d478f is vulnerable to XSS window.opener attack,Php,tt-rss,https://git.tt-rss.org/git/tt-rss/commit/829d478f1b054c8ce1eeb4f15170dc4a1abb3e47,829d478f1b054c8ce1eeb4f15170dc4a1abb3e47,23c8ef7e360816f6e6d03965303e6a26b54f2287,"@@ -1957,7 +1957,7 @@
                        
                
        
                
                        
                                
                                 #                                $entry .= "" <a target=\""_blank\"" href=\"""" . htmlspecialchars($url) . ""\"">"" .
                        
                
        
                
                        
                                
                                 #                                        $filename . "" ("" . $ctype . "")"" . ""</a>"";
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                -                                $entry = ""<div onclick=\""window.open('"".htmlspecialchars($url).""')\""
                        
                
        
                
                        
                                
                                +                                $entry = ""<div onclick=\""openUrlPopup('"".htmlspecialchars($url).""')\""
                        
                
        
                
                        
                                
                                                                         dojoType=\""dijit.MenuItem\"">$filename ($ctype)</div>"";
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                                                 array_push($entries_html, $entry);
                        
                
        

        
                
                        
                                
                                @@ -2038,7 +2038,7 @@
                        
                
        
                
                        
                                
                                                                 else
                        
                
        
                
                        
                                
                                                                         $filename = """";
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                -                                $rv .= ""<div onclick='window.open(\"""".htmlspecialchars($entry[""url""]).""\"")'
                        
                
        
                
                        
                                
                                +                                $rv .= ""<div onclick='openUrlPopup(\"""".htmlspecialchars($entry[""url""]).""\"")'
                        
                
        
                
                        
                                
                                                                         dojoType=\""dijit.MenuItem\"">"".$filename . $title.""</div>"";
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                                         };
                        
                
        

                                                                                
                                                                        
                                                                
                                                        
                                                
                                        
                                
                        
                
        ",https://git.tt-rss.org/fox/tt-rss/src/23c8ef7e360816f6e6d03965303e6a26b54f2287/include/functions2.php,https://git.tt-rss.org/fox/tt-rss/src/829d478f1b054c8ce1eeb4f15170dc4a1abb3e47/include/functions2.php,,
CVE-2017-1000035,https://www.cvedetails.com/cve/CVE-2017-1000035/,CWE-79,,XSS,2017-07-17,2017-10-06,4.3,None,Remote,Medium,Not required,None,Partial,None,Tiny Tiny RSS before 829d478f is vulnerable to XSS window.opener attack,Js,tt-rss,https://git.tt-rss.org/git/tt-rss/commit/829d478f1b054c8ce1eeb4f15170dc4a1abb3e47,829d478f1b054c8ce1eeb4f15170dc4a1abb3e47,23c8ef7e360816f6e6d03965303e6a26b54f2287,"@@ -2064,9 +2064,17 @@ function getSelectionText() {
                        
                
        
                
                        
                                
                                         return text.stripTags();
                        
                
        
                
                        
                                
                                 }
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                +function openUrlPopup(url) {
                        
                
        
                
                        
                                
                                +        var w = window.open("""");
                        
                
        
                
                        
                                
                                +
                        
                
        
                
                        
                                
                                +        w.opener = null;
                        
                
        
                
                        
                                
                                +        w.location = url;
                        
                
        
                
                        
                                
                                +}
                        
                
        
                
                        
                                
                                 function openArticlePopup(id) {
                        
                
        
                
                        
                                
                                -        window.open(""backend.php?op=article&method=view&mode=raw&html=1&zoom=1&id="" + id +
                        
                
        
                
                        
                                
                                -                ""&csrf_token="" + getInitParam(""csrf_token""),
                        
                
        
                
                        
                                
                                +        var w = window.open("""",
                        
                
        
                
                        
                                
                                                 ""ttrss_article_popup"",
                        
                
        
                
                        
                                
                                                 ""height=900,width=900,resizable=yes,status=no,location=no,menubar=no,directories=no,scrollbars=yes,toolbar=no"");
                        
                
        
                
                        
                                
                                +
                        
                
        
                
                        
                                
                                +        w.opener = null;
                        
                
        
                
                        
                                
                                +        w.location = ""backend.php?op=article&method=view&mode=raw&html=1&zoom=1&id="" + id + ""&csrf_token="" + getInitParam(""csrf_token"");
                        
                
        
                
                        
                                
                                 }",https://git.tt-rss.org/fox/tt-rss/src/23c8ef7e360816f6e6d03965303e6a26b54f2287/js/functions.js,https://git.tt-rss.org/fox/tt-rss/src/829d478f1b054c8ce1eeb4f15170dc4a1abb3e47/js/functions.js,,
CVE-2017-1000035,https://www.cvedetails.com/cve/CVE-2017-1000035/,CWE-79,,XSS,2017-07-17,2017-10-06,4.3,None,Remote,Medium,Not required,None,Partial,None,Tiny Tiny RSS before 829d478f is vulnerable to XSS window.opener attack,Js,tt-rss,https://git.tt-rss.org/git/tt-rss/commit/829d478f1b054c8ce1eeb4f15170dc4a1abb3e47,829d478f1b054c8ce1eeb4f15170dc4a1abb3e47,23c8ef7e360816f6e6d03965303e6a26b54f2287,"@@ -1729,7 +1729,10 @@ function hlClicked(event, id) {
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                 function openArticleInNewWindow(id) {
                        
                
        
                
                        
                                
                                         toggleUnread(id, 0, false);
                        
                
        
                
                        
                                
                                -        window.open(""backend.php?op=article&method=redirect&id="" + id);
                        
                
        
                
                        
                                
                                +
                        
                
        
                
                        
                                
                                +        var w = window.open("""");
                        
                
        
                
                        
                                
                                +        w.opener = null;
                        
                
        
                
                        
                                
                                +        w.location = ""backend.php?op=article&method=redirect&id="" + id;
                        
                
        
                
                        
                                
                                 }
                        
                
        
                
                        
                                
                                 
                        
                
        
                
                        
                                
                                 function isCdmMode() {",https://git.tt-rss.org/fox/tt-rss/src/23c8ef7e360816f6e6d03965303e6a26b54f2287/js/viewfeed.js,https://git.tt-rss.org/fox/tt-rss/src/829d478f1b054c8ce1eeb4f15170dc4a1abb3e47/js/viewfeed.js,,
CVE-2013-6449,https://www.cvedetails.com/cve/CVE-2013-6449/,CWE-310,,DoS,2013-12-23,2018-10-09,4.3,None,Remote,Medium,Not required,None,None,Partial,"The ssl_get_algorithm2 function in ssl/s3_lib.c in OpenSSL before 1.0.2 obtains a certain version number from an incorrect data structure, which allows remote attackers to cause a denial of service (daemon crash) via crafted traffic from a TLS 1.2 client.",C,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ca989269a2876bae79393bd54c3e72d49975fc75,ca989269a2876bae79393bd54c3e72d49975fc75,2ec4181ba92fc6b828687d2dc47c13dcd35a5d93,"@@ -4286,7 +4286,7 @@ need to go to SSL_ST_ACCEPT.
 long ssl_get_algorithm2(SSL *s)
        {
        long alg2 = s->s3->tmp.new_cipher->algorithm2;
-       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
+       if (s->method->version == TLS1_2_VERSION &&
            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
        return alg2;",https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_lib.c;h=bf832bb6cc89a83cf22f6020014d53531882f7f9;hb=bf832bb6cc89a83cf22f6020014d53531882f7f9,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_lib.c;h=c4ef2738d7b11b77af88e8d2fd8a29a125590640;hb=c4ef2738d7b11b77af88e8d2fd8a29a125590640,,
CVE-2013-6420,https://www.cvedetails.com/cve/CVE-2013-6420/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2013-12-16,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The asn1_time_to_time_t function in ext/openssl/openssl.c in PHP before 5.3.28, 5.4.x before 5.4.23, and 5.5.x before 5.5.7 does not properly parse (1) notBefore and (2) notAfter timestamps in X.509 certificates, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted certificate that is not properly handled by the openssl_x509_parse function.",C,php,https://git.php.net/?p=php-src.git;a=commit;h=c1224573c773b6845e83505f717fbf820fc18415,c1224573c773b6845e83505f717fbf820fc18415,32873cd0ddea7df8062213bb025beb6fb070e59d,"@@ -644,18 +644,28 @@ static time_t asn1_time_to_time_t(ASN1_UTCTIME * timestr TSRMLS_DC) /* {{{ */
        char * thestr;
        long gmadjust = 0;
 
-       if (timestr->length < 13) {
-               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""extension author too lazy to parse %s correctly"", timestr->data);
+       if (ASN1_STRING_type(timestr) != V_ASN1_UTCTIME) {
+               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""illegal ASN1 data type for timestamp"");
                return (time_t)-1;
        }
 
-       strbuf = estrdup((char *)timestr->data);
+       if (ASN1_STRING_length(timestr) != strlen(ASN1_STRING_data(timestr))) {
+               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""illegal length in timestamp"");
+               return (time_t)-1;
+       }
+
+       if (ASN1_STRING_length(timestr) < 13) {
+               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""unable to parse time string %s correctly"", timestr->data);
+               return (time_t)-1;
+       }
+
+       strbuf = estrdup((char *)ASN1_STRING_data(timestr));
 
        memset(&thetime, 0, sizeof(thetime));
 
        /* we work backwards so that we can use atoi more easily */
 
-       thestr = strbuf + timestr->length - 3;
+       thestr = strbuf + ASN1_STRING_length(timestr) - 3;
 
        thetime.tm_sec = atoi(thestr);
        *thestr = '\0';",https://git.php.net/?p=php-src.git;a=blob;f=ext/openssl/openssl.c;h=e7672e4a34c0169d4f333350e1696004b92bba8b;hb=e7672e4a34c0169d4f333350e1696004b92bba8b,https://git.php.net/?p=php-src.git;a=blob;f=ext/openssl/openssl.c;h=0d2d6442df1a25f7125d0f3dc9037188b825917f;hb=0d2d6442df1a25f7125d0f3dc9037188b825917f,,
CVE-2018-1000200,https://www.cvedetails.com/cve/CVE-2018-1000200/,CWE-476,,,2018-06-05,2018-10-31,4.9,None,Local,Low,Not required,None,None,Complete,"The Linux Kernel versions 4.14, 4.15, and 4.16 has a null pointer dereference which can result in an out of memory (OOM) killing of large mlocked processes. The issue arises from an oom killed process's final thread calling exit_mmap(), which calls munlock_vma_pages_all() for mlocked vmas.This can happen synchronously with the oom reaper's unmap_page_range() since the vma's VM_LOCKED bit is cleared before munlocking (to determine if any other vmas share the memory and are mlocked).",H,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,013567be19761e2d14fc2a2676fe7686ac54c9ac,"@@ -95,6 +95,8 @@ static inline int check_stable_address_space(struct mm_struct *mm)
 	return 0;
 }
 
+void __oom_reap_task_mm(struct mm_struct *mm);
+
 extern unsigned long oom_badness(struct task_struct *p,
 		struct mem_cgroup *memcg, const nodemask_t *nodemask,
 		unsigned long totalpages);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/oom.h?id=013567be19761e2d14fc2a2676fe7686ac54c9ac,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/oom.h?id=27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,,
CVE-2018-1000200,https://www.cvedetails.com/cve/CVE-2018-1000200/,CWE-476,,,2018-06-05,2018-10-31,4.9,None,Local,Low,Not required,None,None,Complete,"The Linux Kernel versions 4.14, 4.15, and 4.16 has a null pointer dereference which can result in an out of memory (OOM) killing of large mlocked processes. The issue arises from an oom killed process's final thread calling exit_mmap(), which calls munlock_vma_pages_all() for mlocked vmas.This can happen synchronously with the oom reaper's unmap_page_range() since the vma's VM_LOCKED bit is cleared before munlocking (to determine if any other vmas share the memory and are mlocked).",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,013567be19761e2d14fc2a2676fe7686ac54c9ac,"@@ -3024,6 +3024,32 @@ void exit_mmap(struct mm_struct *mm)
 	/* mm's last user has gone, and its about to be pulled down */
 	mmu_notifier_release(mm);
 
+	if (unlikely(mm_is_oom_victim(mm))) {
+		/*
+		 * Manually reap the mm to free as much memory as possible.
+		 * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard
+		 * this mm from further consideration.  Taking mm->mmap_sem for
+		 * write after setting MMF_OOM_SKIP will guarantee that the oom
+		 * reaper will not run on this mm again after mmap_sem is
+		 * dropped.
+		 *
+		 * Nothing can be holding mm->mmap_sem here and the above call
+		 * to mmu_notifier_release(mm) ensures mmu notifier callbacks in
+		 * __oom_reap_task_mm() will not block.
+		 *
+		 * This needs to be done before calling munlock_vma_pages_all(),
+		 * which clears VM_LOCKED, otherwise the oom reaper cannot
+		 * reliably test it.
+		 */
+		mutex_lock(&oom_lock);
+		__oom_reap_task_mm(mm);
+		mutex_unlock(&oom_lock);
+
+		set_bit(MMF_OOM_SKIP, &mm->flags);
+		down_write(&mm->mmap_sem);
+		up_write(&mm->mmap_sem);
+	}
+
 	if (mm->locked_vm) {
 		vma = mm->mmap;
 		while (vma) {
@@ -3045,24 +3071,6 @@ void exit_mmap(struct mm_struct *mm)
 	/* update_hiwater_rss(mm) here? but nobody should be looking */
 	/* Use -1 here to ensure all VMAs in the mm are unmapped */
 	unmap_vmas(&tlb, vma, 0, -1);
-
-	if (unlikely(mm_is_oom_victim(mm))) {
-		/*
-		 * Wait for oom_reap_task() to stop working on this
-		 * mm. Because MMF_OOM_SKIP is already set before
-		 * calling down_read(), oom_reap_task() will not run
-		 * on this ""mm"" post up_write().
-		 *
-		 * mm_is_oom_victim() cannot be set from under us
-		 * either because victim->mm is already set to NULL
-		 * under task_lock before calling mmput and oom_mm is
-		 * set not NULL by the OOM killer only if victim->mm
-		 * is found not NULL while holding the task_lock.
-		 */
-		set_bit(MMF_OOM_SKIP, &mm->flags);
-		down_write(&mm->mmap_sem);
-		up_write(&mm->mmap_sem);
-	}
 	free_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);
 	tlb_finish_mmu(&tlb, 0, -1);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/mmap.c?id=013567be19761e2d14fc2a2676fe7686ac54c9ac,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/mmap.c?id=27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,,
CVE-2018-1000200,https://www.cvedetails.com/cve/CVE-2018-1000200/,CWE-476,,,2018-06-05,2018-10-31,4.9,None,Local,Low,Not required,None,None,Complete,"The Linux Kernel versions 4.14, 4.15, and 4.16 has a null pointer dereference which can result in an out of memory (OOM) killing of large mlocked processes. The issue arises from an oom killed process's final thread calling exit_mmap(), which calls munlock_vma_pages_all() for mlocked vmas.This can happen synchronously with the oom reaper's unmap_page_range() since the vma's VM_LOCKED bit is cleared before munlocking (to determine if any other vmas share the memory and are mlocked).",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,013567be19761e2d14fc2a2676fe7686ac54c9ac,"@@ -469,7 +469,6 @@ bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)
 	return false;
 }
 
-
 #ifdef CONFIG_MMU
 /*
  * OOM Reaper kernel thread which tries to reap the memory used by the OOM
@@ -480,16 +479,54 @@ static DECLARE_WAIT_QUEUE_HEAD(oom_reaper_wait);
 static struct task_struct *oom_reaper_list;
 static DEFINE_SPINLOCK(oom_reaper_lock);
 
-static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
+void __oom_reap_task_mm(struct mm_struct *mm)
 {
-	struct mmu_gather tlb;
 	struct vm_area_struct *vma;
+
+	/*
+	 * Tell all users of get_user/copy_from_user etc... that the content
+	 * is no longer stable. No barriers really needed because unmapping
+	 * should imply barriers already and the reader would hit a page fault
+	 * if it stumbled over a reaped memory.
+	 */
+	set_bit(MMF_UNSTABLE, &mm->flags);
+
+	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
+		if (!can_madv_dontneed_vma(vma))
+			continue;
+
+		/*
+		 * Only anonymous pages have a good chance to be dropped
+		 * without additional steps which we cannot afford as we
+		 * are OOM already.
+		 *
+		 * We do not even care about fs backed pages because all
+		 * which are reclaimable have already been reclaimed and
+		 * we do not want to block exit_mmap by keeping mm ref
+		 * count elevated without a good reason.
+		 */
+		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
+			const unsigned long start = vma->vm_start;
+			const unsigned long end = vma->vm_end;
+			struct mmu_gather tlb;
+
+			tlb_gather_mmu(&tlb, mm, start, end);
+			mmu_notifier_invalidate_range_start(mm, start, end);
+			unmap_page_range(&tlb, vma, start, end, NULL);
+			mmu_notifier_invalidate_range_end(mm, start, end);
+			tlb_finish_mmu(&tlb, start, end);
+		}
+	}
+}
+
+static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
+{
 	bool ret = true;
 
 	/*
 	 * We have to make sure to not race with the victim exit path
 	 * and cause premature new oom victim selection:
-	 * __oom_reap_task_mm		exit_mm
+	 * oom_reap_task_mm		exit_mm
 	 *   mmget_not_zero
 	 *				  mmput
 	 *				    atomic_dec_and_test
@@ -534,39 +571,8 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 
 	trace_start_task_reaping(tsk->pid);
 
-	/*
-	 * Tell all users of get_user/copy_from_user etc... that the content
-	 * is no longer stable. No barriers really needed because unmapping
-	 * should imply barriers already and the reader would hit a page fault
-	 * if it stumbled over a reaped memory.
-	 */
-	set_bit(MMF_UNSTABLE, &mm->flags);
-
-	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
-		if (!can_madv_dontneed_vma(vma))
-			continue;
+	__oom_reap_task_mm(mm);
 
-		/*
-		 * Only anonymous pages have a good chance to be dropped
-		 * without additional steps which we cannot afford as we
-		 * are OOM already.
-		 *
-		 * We do not even care about fs backed pages because all
-		 * which are reclaimable have already been reclaimed and
-		 * we do not want to block exit_mmap by keeping mm ref
-		 * count elevated without a good reason.
-		 */
-		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
-			const unsigned long start = vma->vm_start;
-			const unsigned long end = vma->vm_end;
-
-			tlb_gather_mmu(&tlb, mm, start, end);
-			mmu_notifier_invalidate_range_start(mm, start, end);
-			unmap_page_range(&tlb, vma, start, end, NULL);
-			mmu_notifier_invalidate_range_end(mm, start, end);
-			tlb_finish_mmu(&tlb, start, end);
-		}
-	}
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
@@ -587,14 +593,13 @@ static void oom_reap_task(struct task_struct *tsk)
 	struct mm_struct *mm = tsk->signal->oom_mm;
 
 	/* Retry the down_read_trylock(mmap_sem) a few times */
-	while (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))
+	while (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))
 		schedule_timeout_idle(HZ/10);
 
 	if (attempts <= MAX_OOM_REAP_RETRIES ||
 	    test_bit(MMF_OOM_SKIP, &mm->flags))
 		goto done;
 
-
 	pr_info(""oom_reaper: unable to reap pid:%d (%s)\n"",
 		task_pid_nr(tsk), tsk->comm);
 	debug_show_all_locks();",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/oom_kill.c?id=013567be19761e2d14fc2a2676fe7686ac54c9ac,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/oom_kill.c?id=27ae357fa82be5ab73b2ef8d39dcb8ca2563483a,,
CVE-2009-4135,https://www.cvedetails.com/cve/CVE-2009-4135/,CWE-59,,+Priv,2009-12-11,2017-08-16,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,The distcheck rule in dist-check.mk in GNU coreutils 5.2.1 through 8.1 allows local users to gain privileges via a symlink attack on a file in a directory tree under /tmp.,Mk,savannah,https://git.savannah.gnu.org/cgit/coreutils.git/commit/?id=ae034822c535fa5,ae034822c535fa5168069a75fb5e1c58f93a7834,d8cadda3b9b656870d54fe89dc94e72ecd496013,"@@ -4,14 +4,15 @@ bin=bin-$$$$
 
 write_loser = printf '\#!%s\necho $$0: bad path 1>&2; exit 1\n' '$(SHELL)'
 
-TMPDIR ?= /tmp
-t=$(TMPDIR)/$(PACKAGE)/test
+tmpdir = $(abs_top_builddir)/tests/torture
+
+t=$(tmpdir)/$(PACKAGE)/test
 pfx=$(t)/i
 
 # More than once, tainted build and source directory names would
 # have caused at least one ""make check"" test to apply ""chmod 700""
 # to all directories under $HOME.  Make sure it doesn't happen again.
-tp := $(shell echo ""$(TMPDIR)/$(PACKAGE)-$$$$"")
+tp = $(tmpdir)/taint
 t_prefix = $(tp)/a
 t_taint = '$(t_prefix) b'
 fake_home = $(tp)/home
@@ -30,10 +31,11 @@ taint-distcheck: $(DIST_ARCHIVES)
 	touch $(fake_home)/f
 	mkdir -p $(fake_home)/d/e
 	ls -lR $(fake_home) $(t_prefix) > $(tp)/.ls-before
+	HOME=$(fake_home); export HOME;			\
 	cd $(t_taint)/$(distdir)			\
 	  && ./configure				\
 	  && $(MAKE)					\
-	  && HOME=$(fake_home) $(MAKE) check		\
+	  && $(MAKE) check				\
 	  && ls -lR $(fake_home) $(t_prefix) > $(tp)/.ls-after \
 	  && diff $(tp)/.ls-before $(tp)/.ls-after	\
 	  && test -d $(t_prefix)
@@ -52,6 +54,7 @@ endef
 # Install, then verify that all binaries and man pages are in place.
 # Note that neither the binary, ginstall, nor the ].1 man page is installed.
 define my-instcheck
+  echo running my-instcheck;				\
   $(MAKE) prefix=$(pfx) install				\
     && test ! -f $(pfx)/bin/ginstall			\
     && { fail=0;					\
@@ -70,6 +73,7 @@ endef
 
 define coreutils-path-check
   {							\
+    echo running coreutils-path-check;			\
     if test -f $(srcdir)/src/true.c; then		\
       fail=1;						\
       mkdir $(bin)					\
@@ -117,7 +121,7 @@ my-distcheck: $(DIST_ARCHIVES) $(local-check)
 	mkdir -p $(t)
 	GZIP=$(GZIP_ENV) $(AMTAR) -C $(t) -zxf $(distdir).tar.gz
 	cd $(t)/$(distdir)				\
-	  && ./configure --enable-gcc-warnings --disable-nls \
+	  && ./configure --quiet --enable-gcc-warnings --disable-nls \
 	  && $(MAKE) AM_MAKEFLAGS='$(null_AM_MAKEFLAGS)' \
 	  && $(MAKE) dvi				\
 	  && $(install-transform-check)			\
@@ -128,6 +132,7 @@ my-distcheck: $(DIST_ARCHIVES) $(local-check)
 	  && $(AMTAR) -zxf - ) < $(distdir).tar.gz
 	diff -ur $(t)/$(distdir).old $(t)/$(distdir)
 	-rm -rf $(t)
+	rmdir $(tmpdir)/$(PACKAGE) $(tmpdir)
 	@echo ""========================""; \
 	echo ""$(distdir).tar.gz is ready for distribution""; \
 	echo ""========================""",https://git.savannah.gnu.org/cgit/coreutils.git/tree/dist-check.mk?id=d8cadda3b9b656870d54fe89dc94e72ecd496013,https://git.savannah.gnu.org/cgit/coreutils.git/tree/dist-check.mk?id=ae034822c535fa5168069a75fb5e1c58f93a7834,,
CVE-2011-4128,https://www.cvedetails.com/cve/CVE-2011-4128/,CWE-119,,DoS Overflow,2011-12-08,2017-12-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.",C,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=190cef6eed37d0e73a73c1e205eb31d45ab60a3c,190cef6eed37d0e73a73c1e205eb31d45ab60a3c,c6b1847aff211db23cb1f12e8c55ce6055943750,"@@ -63,13 +63,13 @@ gnutls_session_get_data (gnutls_session_t session,
       gnutls_assert ();
       return ret;
     }
-  *session_data_size = psession.size;
 
   if (psession.size > *session_data_size)
     {
       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;
       goto error;
     }
+  *session_data_size = psession.size;
 
   if (session_data != NULL)
     memcpy (session_data, psession.data, psession.size);",https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=blob;f=lib/gnutls_session.c;h=8028d5a4f8ec607b1713aaa1ad842ca7046f0a1c;hb=8028d5a4f8ec607b1713aaa1ad842ca7046f0a1c,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=blob;f=lib/gnutls_session.c;h=418a2ba16ea65908dc16a9c6e9e27bc80d64acb2;hb=418a2ba16ea65908dc16a9c6e9e27bc80d64acb2,,
CVE-2011-4128,https://www.cvedetails.com/cve/CVE-2011-4128/,CWE-119,,DoS Overflow,2011-12-08,2017-12-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.",C,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=e82ef4545e9e98cbcb032f55d7c750b81e3a0450,e82ef4545e9e98cbcb032f55d7c750b81e3a0450,8fe80d662c3320156f5731a672016d7a1b9dba1b,"@@ -66,6 +66,7 @@ gnutls_session_get_data (gnutls_session_t session,
 
   if (psession.size > *session_data_size)
     {
+      *session_data_size = psession.size;
       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;
       goto error;
     }",https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=blob;f=lib/gnutls_session.c;h=418a2ba16ea65908dc16a9c6e9e27bc80d64acb2;hb=418a2ba16ea65908dc16a9c6e9e27bc80d64acb2,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=blob;f=lib/gnutls_session.c;h=fd012fe235312ceaeae17e5bcfc197079d7cf077;hb=fd012fe235312ceaeae17e5bcfc197079d7cf077,,
CVE-2015-7804,https://www.cvedetails.com/cve/CVE-2015-7804/,CWE-189,,DoS,2015-12-11,2016-12-07,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.,C,php,https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1,1ddf72180a52d247db88ea42a3e35f824a8fbda1,f98ab19dc0c978e3caaa2614579e4a61f2c317f5,"@@ -207,7 +207,7 @@ static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC)
        zend_hash_internal_pointer_reset(manifest);
 
        while (FAILURE != zend_hash_has_more_elements(manifest)) {
-               if (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {
+               if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {
                        break;
                }
 ",https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/dirstream.c;h=4728e29f9c9303d3e5c206498744427da704bd79;hb=4728e29f9c9303d3e5c206498744427da704bd79,https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/dirstream.c;h=75cf049adefbd1e723a69e495016b31e20dbcf85;hb=75cf049adefbd1e723a69e495016b31e20dbcf85,,
CVE-2015-7804,https://www.cvedetails.com/cve/CVE-2015-7804/,CWE-189,,DoS,2015-12-11,2016-12-07,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.,C,php,https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1,1ddf72180a52d247db88ea42a3e35f824a8fbda2,f98ab19dc0c978e3caaa2614579e4a61f2c317f6,"@@ -1977,7 +1977,7 @@ void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename
 
        while ((s = zend_memrchr(filename, '/', filename_len))) {
                filename_len = s - filename;
-               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {
+               if (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {
                        break;
                }
        }",https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/util.c;h=e7decda9cde3741d0c4a9a4407a9795d45e6fdc0;hb=e7decda9cde3741d0c4a9a4407a9795d45e6fdc0,https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/util.c;h=303daede45570591c74e8fbc94f0d6ebf617a529;hb=303daede45570591c74e8fbc94f0d6ebf617a529,,
CVE-2015-7804,https://www.cvedetails.com/cve/CVE-2015-7804/,CWE-189,,DoS,2015-12-11,2016-12-07,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.,C,php,https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1,1ddf72180a52d247db88ea42a3e35f824a8fbda3,f98ab19dc0c978e3caaa2614579e4a61f2c317f7,"@@ -396,7 +396,9 @@ foundit:
 
                if (entry.filename[entry.filename_len - 1] == '/') {
                        entry.is_dir = 1;
-                       entry.filename_len--;
+                       if(entry.filename_len > 1) {
+                               entry.filename_len--;
+                       }
                        entry.flags |= PHAR_ENT_PERM_DEF_DIR;
                } else {
                        entry.is_dir = 0;",https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/zip.c;h=142165c31da4dc6748cf0c4befc0a4239d23989a;hb=142165c31da4dc6748cf0c4befc0a4239d23989a,https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/zip.c;h=e4883d3533dd8a297b7a6eaf8de10ef9c162e82d;hb=e4883d3533dd8a297b7a6eaf8de10ef9c162e82d,,
CVE-2015-7803,https://www.cvedetails.com/cve/CVE-2015-7803/,,,DoS,2015-12-11,2016-12-07,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The phar_get_entry_data function in ext/phar/util.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a .phar file with a crafted TAR archive entry in which the Link indicator references a file that does not exist.,C,php,https://git.php.net/?p=php-src.git;a=commit;h=d698f0ae51f67c9cce870b09c59df3d6ba959244,d698f0ae51f67c9cce870b09c59df3d6ba959244,bb98ed600ab6787d9d367927d49439be9a83441e,"@@ -494,7 +494,11 @@ really_get_entry:
        (*ret)->is_tar = entry->is_tar;
        (*ret)->fp = phar_get_efp(entry, 1 TSRMLS_CC);
        if (entry->link) {
-               (*ret)->zero = phar_get_fp_offset(phar_get_link_source(entry TSRMLS_CC) TSRMLS_CC);
+               phar_entry_info *link = phar_get_link_source(entry TSRMLS_CC);
+               if(!link) {
+                       return FAILURE;
+               }
+               (*ret)->zero = phar_get_fp_offset(link TSRMLS_CC);
        } else {
                (*ret)->zero = phar_get_fp_offset(entry TSRMLS_CC);
        }",https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/util.c;h=2c41adf92a7eac5b20f6d33a9f6cccce5826e3bd;hb=2c41adf92a7eac5b20f6d33a9f6cccce5826e3bd,https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/util.c;h=69da7b9b89db376e46c1f4abfb107ea7ee155447;hb=69da7b9b89db376e46c1f4abfb107ea7ee155447,,
CVE-2015-7665,https://www.cvedetails.com/cve/CVE-2015-7665/,CWE-200,,+Info,2015-12-27,2016-11-28,5.0,None,Remote,Low,Not required,Partial,None,None,"Tails before 1.7 includes the wget program but does not prevent automatic fallback from passive FTP to active FTP, which allows remote FTP servers to discover the Tor client IP address by reading a (1) PORT or (2) EPRT command.  NOTE: within wget itself, the automatic fallback is not considered a vulnerability by CVE.",C,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=075d7556964f5a871a73c22ac4b69f5361295099,075d7556964f5a871a73c22ac4b69f5361295099,7578e47d4957b019d90bbe77bcab98113a8923bc,"@@ -252,7 +252,6 @@ getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
-  bool pasv_mode_open = false;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
@@ -883,13 +882,19 @@ Error in server response, closing control connection.\n""));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
-              pasv_mode_open = true;  /* Flag to avoid accept port */
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
-            } /* err==FTP_OK */
-        }
+            }
+          else
+            return err;
 
-      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */
+          /*
+           * We do not want to fall back from PASSIVE mode to ACTIVE mode !
+           * The reason is the PORT command exposes the client's real IP address
+           * to the server. Bad for someone who relies on privacy via a ftp proxy.
+           */
+        }
+      else
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
@@ -1148,8 +1153,8 @@ Error in server response, closing control connection.\n""));
     }
 
   /* If no transmission was required, then everything is OK.  */
-  if (!pasv_mode_open)  /* we are not using pasive mode so we need
-                              to accept */
+  if (!opt.ftp_pasv)  /* we are not using passive mode so we need
+                         to accept */
     {
       /* Wait for the server to connect to the address we're waiting
          at.  */",https://git.savannah.gnu.org/cgit/wget.git/tree/src/ftp.c?id=7578e47d4957b019d90bbe77bcab98113a8923bc,https://git.savannah.gnu.org/cgit/wget.git/tree/src/ftp.c?id=075d7556964f5a871a73c22ac4b69f5361295099,,
CVE-2015-7665,https://www.cvedetails.com/cve/CVE-2015-7665/,CWE-200,,+Info,2015-12-27,2016-11-28,5.0,None,Remote,Low,Not required,Partial,None,None,"Tails before 1.7 includes the wget program but does not prevent automatic fallback from passive FTP to active FTP, which allows remote FTP servers to discover the Tor client IP address by reading a (1) PORT or (2) EPRT command.  NOTE: within wget itself, the automatic fallback is not considered a vulnerability by CVE.",Pm,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=075d7556964f5a871a73c22ac4b69f5361295099,075d7556964f5a871a73c22ac4b69f5361295099,7578e47d4957b019d90bbe77bcab98113a8923bc,"@@ -740,6 +740,14 @@ sub run
                     last;
                 }
 
+                if (defined($self->{_server_behavior}{pasv_not_supported})
+                    && $cmd eq 'PASV')
+                {
+                    print {$conn->{socket}}
+                      ""500 PASV not supported.\r\n"";
+                    next;
+                }
+
                 # Run the command.
                 &{$command_table->{$cmd}}($conn, $cmd, $rest);
             }",https://git.savannah.gnu.org/cgit/wget.git/tree/tests/FTPServer.pm?id=7578e47d4957b019d90bbe77bcab98113a8923bc,https://git.savannah.gnu.org/cgit/wget.git/tree/tests/FTPServer.pm?id=075d7556964f5a871a73c22ac4b69f5361295099,,
CVE-2015-7665,https://www.cvedetails.com/cve/CVE-2015-7665/,CWE-200,,+Info,2015-12-27,2016-11-28,5.0,None,Remote,Low,Not required,Partial,None,None,"Tails before 1.7 includes the wget program but does not prevent automatic fallback from passive FTP to active FTP, which allows remote FTP servers to discover the Tor client IP address by reading a (1) PORT or (2) EPRT command.  NOTE: within wget itself, the automatic fallback is not considered a vulnerability by CVE.",Am,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=075d7556964f5a871a73c22ac4b69f5361295099,075d7556964f5a871a73c22ac4b69f5361295099,7578e47d4957b019d90bbe77bcab98113a8923bc,"@@ -127,7 +127,8 @@ PX_TESTS = \
              Test--start-pos.px \
              Test--start-pos--continue.px \
              Test--httpsonly-r.px \
-             Test-204.px
+             Test-204.px \
+             Test-ftp-pasv-not-supported.px
 
 EXTRA_DIST = FTPServer.pm FTPTest.pm HTTPServer.pm HTTPTest.pm \
              WgetTests.pm WgetFeature.pm WgetFeature.cfg $(PX_TESTS) \",https://git.savannah.gnu.org/cgit/wget.git/tree/tests/Makefile.am?id=7578e47d4957b019d90bbe77bcab98113a8923bc,https://git.savannah.gnu.org/cgit/wget.git/tree/tests/Makefile.am?id=075d7556964f5a871a73c22ac4b69f5361295099,,
CVE-2013-6051,https://www.cvedetails.com/cve/CVE-2013-6051/,,,DoS,2013-12-14,2013-12-16,4.3,None,Remote,Medium,Not required,None,None,Partial,"The bgp_attr_unknown function in bgp_attr.c in Quagga 0.99.21 does not properly initialize the total variable, which allows remote attackers to cause a denial of service (bgpd crash) via a crafted BGP update.",C,savannah,https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=8794e8d229dc9fe29ea31424883433d4880ef408,8794e8d229dc9fe29ea31424883433d4880ef408,7621f336e2f346edee43227f0b1ef93fe769720b,"@@ -1646,7 +1646,7 @@ bgp_attr_ext_communities (struct bgp_attr_parser_args *args)
 static bgp_attr_parse_ret_t
 bgp_attr_unknown (struct bgp_attr_parser_args *args)
 {
-  bgp_size_t total;
+  bgp_size_t total = args->total;
   struct transit *transit;
   struct attr_extra *attre;
   struct peer *const peer = args->peer; ",https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=blob;f=bgpd/bgp_attr.c;h=0d82aba04edc7164e14e9cf89d9fbca85db01582,https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=blob;f=bgpd/bgp_attr.c;h=81802ce8124b637a469485af3cea47b27a7f22fc;hb=8794e8d229dc9fe29ea31424883433d4880ef408,,
CVE-2018-1000040,https://www.cvedetails.com/cve/CVE-2018-1000040/,CWE-20,,DoS,2018-05-24,2018-11-27,4.3,None,Remote,Medium,Not required,None,None,Partial,"In MuPDF 1.12.0 and earlier, multiple use of uninitialized value bugs in the PDF parser could allow an attacker to cause a denial of service (crash) or influence program flow via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=83d4dae44c71816c084a635550acc1a51529b881;hp=f597300439e62f5e921f0d7b1e880b5c1a1f1607,83d4dae44c71816c084a635550acc1a51529b881,f597300439e62f5e921f0d7b1e880b5c1a1f1607,"@@ -3663,6 +3663,7 @@ void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_
                fz_drop_color_converter(ctx, &cached->base);
                fz_drop_hash_table(ctx, cached->hash);
                fz_free(ctx, cached);
+               cc->opaque = NULL;
                fz_rethrow(ctx);
        }
 }",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/fitz/colorspace.c;h=c099297a86204fd8cf05c93930264191b0c875e9;hb=f597300439e62f5e921f0d7b1e880b5c1a1f1607,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/fitz/colorspace.c;h=336513feffd19099f318b2f9564dced531da09e0;hb=83d4dae44c71816c084a635550acc1a51529b881,,
CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,,DoS Exec Code,2018-05-24,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=f597300439e62f5e921f0d7b1e880b5c1a1f1607;hp=093fc3b098dc5fadef5d8ad4b225db9fb124758b,f597300439e62f5e921f0d7b1e880b5c1a1f1607,093fc3b098dc5fadef5d8ad4b225db9fb124758b,"@@ -525,6 +525,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
+                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=29d9c50693d0fb6ac35437e3997f713af729111f;hb=093fc3b098dc5fadef5d8ad4b225db9fb124758b,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=00e2afb72bab07def6ddece70db56c15cee241b9;hb=f597300439e62f5e921f0d7b1e880b5c1a1f1607,,
CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,,DoS Exec Code,2018-05-24,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=4dcc6affe04368461310a21238f7e1871a752a05;hp=8ec561d1bccc46e9db40a9f61310cd8b3763914e,4dcc6affe04368461310a21238f7e1871a752a05,8ec561d1bccc46e9db40a9f61310cd8b3763914e,"@@ -135,7 +135,7 @@ begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)
        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);
 
        if (gstate->luminosity && !mask_colorspace)
-               mask_colorspace = fz_device_gray(ctx);
+               mask_colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));
 
        fz_try(ctx)
        {",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-op-run.c;h=16c5c2f45f534f2fc03d847932e642ee53756e10;hb=8ec561d1bccc46e9db40a9f61310cd8b3763914e,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-op-run.c;h=c51bb535c7f2b0d12487b9f181b3a387f2c6b5f9;hb=4dcc6affe04368461310a21238f7e1871a752a05,,
CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,,DoS Exec Code,2018-05-24,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=71ceebcf56e682504da22c4035b39a2d451e8ffd;hp=7f82c01523505052615492f8e220f4348ba46995,71ceebcf56e682504da22c4035b39a2d451e8ffd,7f82c01523505052615492f8e220f4348ba46995,"@@ -520,7 +520,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
-                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
+                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=ade72c443be3388fe522c55ea1105fbd8a7c1735;hb=7f82c01523505052615492f8e220f4348ba46995,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=bedc13045aa0566e40cc1b4179e108f961d28ff6;hb=71ceebcf56e682504da22c4035b39a2d451e8ffd,,
CVE-2018-1000038,https://www.cvedetails.com/cve/CVE-2018-1000038/,CWE-119,,Exec Code Overflow,2018-05-24,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In MuPDF 1.12.0 and earlier, a stack buffer overflow in function pdf_lookup_cmap_full in pdf/pdf-cmap.c could allow an attacker to execute arbitrary code via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=f597300439e62f5e921f0d7b1e880b5c1a1f1607;hp=093fc3b098dc5fadef5d8ad4b225db9fb124758b,f597300439e62f5e921f0d7b1e880b5c1a1f1607,093fc3b098dc5fadef5d8ad4b225db9fb124758b,"@@ -525,6 +525,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
+                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=29d9c50693d0fb6ac35437e3997f713af729111f;hb=093fc3b098dc5fadef5d8ad4b225db9fb124758b,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=00e2afb72bab07def6ddece70db56c15cee241b9;hb=f597300439e62f5e921f0d7b1e880b5c1a1f1607,,
CVE-2018-1000038,https://www.cvedetails.com/cve/CVE-2018-1000038/,CWE-119,,Exec Code Overflow,2018-05-24,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In MuPDF 1.12.0 and earlier, a stack buffer overflow in function pdf_lookup_cmap_full in pdf/pdf-cmap.c could allow an attacker to execute arbitrary code via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=71ceebcf56e682504da22c4035b39a2d451e8ffd;hp=7f82c01523505052615492f8e220f4348ba46995,71ceebcf56e682504da22c4035b39a2d451e8ffd,7f82c01523505052615492f8e220f4348ba46995,"@@ -520,7 +520,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
-                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
+                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=ade72c443be3388fe522c55ea1105fbd8a7c1735;hb=7f82c01523505052615492f8e220f4348ba46995,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=bedc13045aa0566e40cc1b4179e108f961d28ff6;hb=71ceebcf56e682504da22c4035b39a2d451e8ffd,,
CVE-2018-1000037,https://www.cvedetails.com/cve/CVE-2018-1000037/,CWE-20,,DoS,2018-05-24,2018-11-27,4.3,None,Remote,Medium,Not required,None,None,Partial,"In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=71ceebcf56e682504da22c4035b39a2d451e8ffd;hp=7f82c01523505052615492f8e220f4348ba46995,71ceebcf56e682504da22c4035b39a2d451e8ffd,7f82c01523505052615492f8e220f4348ba46995,"@@ -520,7 +520,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
-                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
+                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=ade72c443be3388fe522c55ea1105fbd8a7c1735;hb=7f82c01523505052615492f8e220f4348ba46995,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=bedc13045aa0566e40cc1b4179e108f961d28ff6;hb=71ceebcf56e682504da22c4035b39a2d451e8ffd,,
CVE-2018-1000037,https://www.cvedetails.com/cve/CVE-2018-1000037/,CWE-20,,DoS,2018-05-24,2018-11-27,4.3,None,Remote,Medium,Not required,None,None,Partial,"In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=b2e7d38e845c7d4922d05e6e41f3a2dc1bc1b14a;hp=f51836b9732c38d945b87fda0770009a77ba680c,b2e7d38e845c7d4922d05e6e41f3a2dc1bc1b14a,f51836b9732c38d945b87fda0770009a77ba680c,"@@ -501,12 +501,47 @@ pdf_show_pattern(fz_context *ctx, pdf_run_processor *pr, pdf_pattern *pat, pdf_g
 }
 
 static void
+pdf_show_image_imp(fz_context *ctx, pdf_run_processor *pr, fz_image *image, fz_matrix *image_ctm, fz_rect *bbox)
+{
+       pdf_gstate *gstate = pr->gstate + pr->gtop;
+
+       if (image->colorspace)
+       {
+               fz_fill_image(ctx, pr->dev, image, image_ctm, gstate->fill.alpha, &gstate->fill.color_params);
+               return;
+       }
+
+       if (gstate->fill.kind == PDF_MAT_COLOR)
+               fz_fill_image_mask(ctx, pr->dev, image, image_ctm,
+                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);
+       else if (gstate->fill.kind == PDF_MAT_PATTERN && gstate->fill.pattern)
+       {
+               fz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);
+               fz_try(ctx)
+                       pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], bbox, PDF_FILL);
+               fz_always(ctx)
+                       fz_pop_clip(ctx, pr->dev);
+               fz_catch(ctx)
+                       fz_rethrow(ctx);
+       }
+       else if (gstate->fill.kind == PDF_MAT_SHADE && gstate->fill.shade)
+       {
+               fz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);
+               fz_try(ctx)
+                       fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);
+               fz_always(ctx)
+                       fz_pop_clip(ctx, pr->dev);
+               fz_catch(ctx)
+                       fz_rethrow(ctx);
+       }
+}
+
+static void
 pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)
 {
        pdf_gstate *gstate = pr->gstate + pr->gtop;
        fz_matrix image_ctm;
        fz_rect bbox;
-       softmask_save softmask = { NULL };
 
        if (pr->super.hidden)
                return;
@@ -518,57 +553,52 @@ pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)
        bbox = fz_unit_rect;
        fz_transform_rect(&bbox, &image_ctm);
 
-       if (image->mask)
+       if (image->mask && gstate->blendmode)
        {
                /* apply blend group even though we skip the soft mask */
-               if (gstate->blendmode)
-                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);
-               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
-       }
-       else
-               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);
+               fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);
 
-       if (!image->colorspace)
-       {
-               switch (gstate->fill.kind)
+               fz_try(ctx)
+                       fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
+               fz_catch(ctx)
                {
-               case PDF_MAT_NONE:
-                       break;
-               case PDF_MAT_COLOR:
-                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,
-                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);
-                       break;
-               case PDF_MAT_PATTERN:
-                       if (gstate->fill.pattern)
-                       {
-                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
-                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);
-                               fz_pop_clip(ctx, pr->dev);
-                       }
-                       break;
-               case PDF_MAT_SHADE:
-                       if (gstate->fill.shade)
-                       {
-                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
-                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);
-                               fz_pop_clip(ctx, pr->dev);
-                       }
-                       break;
+                       fz_end_group(ctx, pr->dev);
+                       fz_rethrow(ctx);
                }
+
+               fz_try(ctx)
+                       pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);
+               fz_always(ctx)
+               {
+                       fz_pop_clip(ctx, pr->dev);
+                       fz_end_group(ctx, pr->dev);
+               }
+               fz_catch(ctx)
+                       fz_rethrow(ctx);
        }
-       else
+       else if (image->mask)
        {
-               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);
+               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
+               fz_try(ctx)
+                       pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);
+               fz_always(ctx)
+                       fz_pop_clip(ctx, pr->dev);
+               fz_catch(ctx)
+                       fz_rethrow(ctx);
        }
-
-       if (image->mask)
+       else
        {
-               fz_pop_clip(ctx, pr->dev);
-               if (gstate->blendmode)
-                       fz_end_group(ctx, pr->dev);
+               softmask_save softmask = { NULL };
+
+               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);
+
+               fz_try(ctx)
+                       pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);
+               fz_always(ctx)
+                       pdf_end_group(ctx, pr, &softmask);
+               fz_catch(ctx)
+                       fz_rethrow(ctx);
        }
-       else
-               pdf_end_group(ctx, pr, &softmask);
 }
 
 static void",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-op-run.c;h=355e94d221bf6adb9d55c27673dddb7cd113e11a;hb=355e94d221bf6adb9d55c27673dddb7cd113e11a,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-op-run.c;h=f16d228bcf434033c7cef16fe13c244e7af556bd;hb=f16d228bcf434033c7cef16fe13c244e7af556bd,,
CVE-2018-1000037,https://www.cvedetails.com/cve/CVE-2018-1000037/,CWE-20,,DoS,2018-05-24,2018-11-27,4.3,None,Remote,Medium,Not required,None,None,Partial,"In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=8a3257b01faa899dd9b5e35c6bb3403cd709c371;hp=de39f005f12a1afc6973c1f5cec362d6545f70cb,8a3257b01faa899dd9b5e35c6bb3403cd709c371,de39f005f12a1afc6973c1f5cec362d6545f70cb,"@@ -264,8 +264,6 @@ pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_ob
                        fz_var(xobj);
 
                        group = pdf_dict_get(ctx, obj, PDF_NAME_G);
-                       if (!group)
-                               fz_throw(ctx, FZ_ERROR_SYNTAX, ""cannot load softmask xobject (%d 0 R)"", pdf_to_num(ctx, obj));
                        xobj = pdf_load_xobject(ctx, csi->doc, group);
 ",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-interpret.c;h=6ce63eb603b6d8bcae2933e75b51542eb05e2e92;hb=6ce63eb603b6d8bcae2933e75b51542eb05e2e92,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-interpret.c;h=3aeeeae73918a2143177aa914855c0dbd8a12c05;hb=3aeeeae73918a2143177aa914855c0dbd8a12c05,,
CVE-2018-1000037,https://www.cvedetails.com/cve/CVE-2018-1000037/,CWE-20,,DoS,2018-05-24,2018-11-27,4.3,None,Remote,Medium,Not required,None,None,Partial,"In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file.",C,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=8a3257b01faa899dd9b5e35c6bb3403cd709c371;hp=de39f005f12a1afc6973c1f5cec362d6545f70cb,8a3257b01faa899dd9b5e35c6bb3403cd709c371,de39f005f12a1afc6973c1f5cec362d6545f70cb,"@@ -97,6 +97,9 @@ pdf_load_xobject(fz_context *ctx, pdf_document *doc, pdf_obj *dict)
 {
        pdf_xobject *form;
 
+       if (!pdf_is_stream(ctx, dict))
+               fz_throw(ctx, FZ_ERROR_SYNTAX, ""XObject must be a stream"");
+
        if ((form = pdf_find_item(ctx, pdf_drop_xobject_imp, dict)) != NULL)
                return form;",http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-xobject.c;h=c7b03a4e0343713be06b9b6d2d271fe7c8865a60;hb=c7b03a4e0343713be06b9b6d2d271fe7c8865a60,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-xobject.c;h=38a31c48e303efea77617fbbd04934b2202b95d7;hb=38a31c48e303efea77617fbbd04934b2202b95d7,,
CVE-2015-7540,https://www.cvedetails.com/cve/CVE-2015-7540/,CWE-399,,DoS,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The LDAP server in the AD domain controller in Samba 4.x before 4.1.22 does not check return values to ensure successful ASN.1 memory allocation, which allows remote attackers to cause a denial of service (memory consumption and daemon crash) via crafted packets.",C,samba,https://git.samba.org/?p=samba.git;a=commit;h=9d989c9dd7a5b92d0c5d65287935471b83b6e884,9d989c9dd7a5b92d0c5d65287935471b83b6e884,530d50a1abdcdf4d1775652d4c456c1274d83d8d,"@@ -326,87 +326,76 @@ bool asn1_write_OID(struct asn1_data *data, const char *OID)
 /* write an octet string */
 bool asn1_write_OctetString(struct asn1_data *data, const void *p, size_t length)
 {
-       asn1_push_tag(data, ASN1_OCTET_STRING);
-       asn1_write(data, p, length);
-       asn1_pop_tag(data);
-       return !data->has_error;
+       if (!asn1_push_tag(data, ASN1_OCTET_STRING)) return false;
+       if (!asn1_write(data, p, length)) return false;
+       return asn1_pop_tag(data);
 }
 
 /* write a LDAP string */
 bool asn1_write_LDAPString(struct asn1_data *data, const char *s)
 {
-       asn1_write(data, s, strlen(s));
-       return !data->has_error;
+       return asn1_write(data, s, strlen(s));
 }
 
 /* write a LDAP string from a DATA_BLOB */
 bool asn1_write_DATA_BLOB_LDAPString(struct asn1_data *data, const DATA_BLOB *s)
 {
-       asn1_write(data, s->data, s->length);
-       return !data->has_error;
+       return asn1_write(data, s->data, s->length);
 }
 
 /* write a general string */
 bool asn1_write_GeneralString(struct asn1_data *data, const char *s)
 {
-       asn1_push_tag(data, ASN1_GENERAL_STRING);
-       asn1_write_LDAPString(data, s);
-       asn1_pop_tag(data);
-       return !data->has_error;
+       if (!asn1_push_tag(data, ASN1_GENERAL_STRING)) return false;
+       if (!asn1_write_LDAPString(data, s)) return false;
+       return asn1_pop_tag(data);
 }
 
 bool asn1_write_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blob)
 {
-       asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(num));
-       asn1_write(data, blob->data, blob->length);
-       asn1_pop_tag(data);
-       return !data->has_error;
+       if (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(num))) return false;
+       if (!asn1_write(data, blob->data, blob->length)) return false;
+       return asn1_pop_tag(data);
 }
 
 /* write a BOOLEAN */
 bool asn1_write_BOOLEAN(struct asn1_data *data, bool v)
 {
-       asn1_push_tag(data, ASN1_BOOLEAN);
-       asn1_write_uint8(data, v ? 0xFF : 0);
-       asn1_pop_tag(data);
-       return !data->has_error;
+       if (!asn1_push_tag(data, ASN1_BOOLEAN)) return false;
+       if (!asn1_write_uint8(data, v ? 0xFF : 0)) return false;
+       return asn1_pop_tag(data);
 }
 
 bool asn1_read_BOOLEAN(struct asn1_data *data, bool *v)
 {
        uint8_t tmp = 0;
-       asn1_start_tag(data, ASN1_BOOLEAN);
-       asn1_read_uint8(data, &tmp);
+       if (!asn1_start_tag(data, ASN1_BOOLEAN)) return false;
+       *v = false;
+       if (!asn1_read_uint8(data, &tmp)) return false;
        if (tmp == 0xFF) {
                *v = true;
-       } else {
-               *v = false;
        }
-       asn1_end_tag(data);
-       return !data->has_error;
+       return asn1_end_tag(data);
 }
 
 /* write a BOOLEAN in a simple context */
 bool asn1_write_BOOLEAN_context(struct asn1_data *data, bool v, int context)
 {
-       asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context));
-       asn1_write_uint8(data, v ? 0xFF : 0);
-       asn1_pop_tag(data);
-       return !data->has_error;
+       if (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;
+       if (!asn1_write_uint8(data, v ? 0xFF : 0)) return false;
+       return asn1_pop_tag(data);
 }
 
 bool asn1_read_BOOLEAN_context(struct asn1_data *data, bool *v, int context)
 {
        uint8_t tmp = 0;
-       asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context));
-       asn1_read_uint8(data, &tmp);
+       if (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;
+       *v = false;
+       if (!asn1_read_uint8(data, &tmp)) return false;
        if (tmp == 0xFF) {
                *v = true;
-       } else {
-               *v = false;
        }
-       asn1_end_tag(data);
-       return !data->has_error;
+       return asn1_end_tag(data);
 }
 
 /* check a BOOLEAN */
@@ -414,12 +403,12 @@ bool asn1_check_BOOLEAN(struct asn1_data *data, bool v)
 {
        uint8_t b = 0;
 
-       asn1_read_uint8(data, &b);
+       if (!asn1_read_uint8(data, &b)) return false;
        if (b != ASN1_BOOLEAN) {
                data->has_error = true;
                return false;
        }
-       asn1_read_uint8(data, &b);
+       if (!asn1_read_uint8(data, &b)) return false;
        if (b != v) {
                data->has_error = true;
                return false;
@@ -770,9 +759,8 @@ bool asn1_read_OID(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **OID)
                return false;
        }
 
-       asn1_read(data, blob.data, len);
-       asn1_end_tag(data);
-       if (data->has_error) {
+       if (!asn1_read(data, blob.data, len)) return false;
+       if (!asn1_end_tag(data)) {
                data_blob_free(&blob);
                return false;
        }
@@ -817,9 +805,8 @@ bool asn1_read_LDAPString(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **s)
                data->has_error = true;
                return false;
        }
-       asn1_read(data, *s, len);
        (*s)[len] = 0;
-       return !data->has_error;
+       return asn1_read(data, *s, len);
 }
 
 
@@ -848,17 +835,17 @@ bool asn1_read_OctetString(struct asn1_data *data, TALLOC_CTX *mem_ctx, DATA_BLO
                data->has_error = true;
                return false;
        }
-       asn1_read(data, blob->data, len);
-       asn1_end_tag(data);
+       if (!asn1_read(data, blob->data, len)) goto err;
+       if (!asn1_end_tag(data)) goto err;
        blob->length--;
        blob->data[len] = 0;
-       
-       if (data->has_error) {
-               data_blob_free(blob);
-               *blob = data_blob_null;
-               return false;
-       }
        return true;
+
+  err:
+
+       data_blob_free(blob);
+       *blob = data_blob_null;
+       return false;
 }
 
 bool asn1_read_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blob)
@@ -876,9 +863,8 @@ bool asn1_read_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blo
                data->has_error = true;
                return false;
        }
-       asn1_read(data, blob->data, len);
-       asn1_end_tag(data);
-       return !data->has_error;
+       if (!asn1_read(data, blob->data, len)) return false;
+       return asn1_end_tag(data);
 }
 
 /* read an integer without tag*/
@@ -966,8 +952,8 @@ bool asn1_check_enumerated(struct asn1_data *data, int v)
 {
        uint8_t b;
        if (!asn1_start_tag(data, ASN1_ENUMERATED)) return false;
-       asn1_read_uint8(data, &b);
-       asn1_end_tag(data);
+       if (!asn1_read_uint8(data, &b)) return false;
+       if (!asn1_end_tag(data)) return false;
 
        if (v != b)
                data->has_error = false;
@@ -979,9 +965,8 @@ bool asn1_check_enumerated(struct asn1_data *data, int v)
 bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
 {
        if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
-       asn1_write_uint8(data, v);
-       asn1_pop_tag(data);
-       return !data->has_error;
+       if (!asn1_write_uint8(data, v)) return false;
+       return asn1_pop_tag(data);
 }
 
 /*
@@ -1022,8 +1007,7 @@ NTSTATUS asn1_full_tag(DATA_BLOB blob, uint8_t tag, size_t *packet_size)
 
        asn1->data = blob.data;
        asn1->length = blob.length;
-       asn1_start_tag(asn1, tag);
-       if (asn1->has_error) {
+       if (!asn1_start_tag(asn1, tag)) {
                talloc_free(asn1);
                return STATUS_MORE_ENTRIES;
        }",https://git.samba.org/?p=samba.git;a=blob;f=lib/util/asn1.c;h=70637a3e065c48d5063a95d22bea392559f35622;hb=70637a3e065c48d5063a95d22bea392559f35622,https://git.samba.org/?p=samba.git;a=blob;f=lib/util/asn1.c;h=ec294503b5970d5b54f3306afeff94a1ee9c15c2;hb=ec294503b5970d5b54f3306afeff94a1ee9c15c2,,
CVE-2015-7540,https://www.cvedetails.com/cve/CVE-2015-7540/,CWE-399,,DoS,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The LDAP server in the AD domain controller in Samba 4.x before 4.1.22 does not check return values to ensure successful ASN.1 memory allocation, which allows remote attackers to cause a denial of service (memory consumption and daemon crash) via crafted packets.",C,samba,https://git.samba.org/?p=samba.git;a=commit;h=530d50a1abdcdf4d1775652d4c456c1274d83d8d,530d50a1abdcdf4d1775652d4c456c1274d83d8d,582d0e7b7549008c908cb30878a1db0bbe4d21bb,,https://git.samba.org/?p=samba.git;a=blob;f=libcli/ldap/ldap_message.c;h=1c5542c0d90b7d3106a2c92f4506fb77b692a2a4;hb=1c5542c0d90b7d3106a2c92f4506fb77b692a2a4,https://git.samba.org/?p=samba.git;a=blob;f=libcli/ldap/ldap_message.c;h=ba94f4ccfacbbcad21c17a09df7c706459214e47;hb=ba94f4ccfacbbcad21c17a09df7c706459214e47,,
CVE-2015-7540,https://www.cvedetails.com/cve/CVE-2015-7540/,CWE-399,,DoS,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The LDAP server in the AD domain controller in Samba 4.x before 4.1.22 does not check return values to ensure successful ASN.1 memory allocation, which allows remote attackers to cause a denial of service (memory consumption and daemon crash) via crafted packets.",H,samba,https://git.samba.org/?p=samba.git;a=commit;h=530d50a1abdcdf4d1775652d4c456c1274d83d8d,530d50a1abdcdf4d1775652d4c456c1274d83d8d,582d0e7b7549008c908cb30878a1db0bbe4d21bb,"@@ -228,7 +228,7 @@ bool asn1_read_OctetString_talloc(TALLOC_CTX *mem_ctx,
                                  struct asn1_data *data,
                                  const char **result);
 
-void ldap_decode_attribs_bare(TALLOC_CTX *mem_ctx, struct asn1_data *data,
+bool ldap_decode_attribs_bare(TALLOC_CTX *mem_ctx, struct asn1_data *data,
                              struct ldb_message_element **attributes,
                              int *num_attributes);",https://git.samba.org/?p=samba.git;a=blob;f=libcli/ldap/ldap_message.h;h=b41f7f5497b984f5ce192bc6ef6c7175dbf84785;hb=b41f7f5497b984f5ce192bc6ef6c7175dbf84785,https://git.samba.org/?p=samba.git;a=blob;f=libcli/ldap/ldap_message.h;h=2f64881c053e9f590502055de0309d8377d6d46c;hb=2f64881c053e9f590502055de0309d8377d6d46c,,
CVE-2015-7540,https://www.cvedetails.com/cve/CVE-2015-7540/,CWE-399,,DoS,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The LDAP server in the AD domain controller in Samba 4.x before 4.1.22 does not check return values to ensure successful ASN.1 memory allocation, which allows remote attackers to cause a denial of service (memory consumption and daemon crash) via crafted packets.",C,samba,https://git.samba.org/?p=samba.git;a=commit;h=530d50a1abdcdf4d1775652d4c456c1274d83d8d,530d50a1abdcdf4d1775652d4c456c1274d83d8d,582d0e7b7549008c908cb30878a1db0bbe4d21bb,"@@ -1187,10 +1187,10 @@ static bool decode_openldap_dereference(void *mem_ctx, DATA_BLOB in, void *_out)
                        if (!asn1_start_tag(data, ASN1_CONTEXT(0))) {
                                return false;
                        }
-                       
-                       ldap_decode_attribs_bare(r, data, &r[i]->attributes,
-                                                &r[i]->num_attributes);
-                       
+                       if (!ldap_decode_attribs_bare(r, data, &r[i]->attributes,
+                                                &r[i]->num_attributes)) {
+                               return false;
+                       }
                        if (!asn1_end_tag(data)) {
                                return false;
                        }",https://git.samba.org/?p=samba.git;a=blob;f=source4/libcli/ldap/ldap_controls.c;h=17d96f6f9d7dd016180ecf4f2152e12ca75f8c40;hb=17d96f6f9d7dd016180ecf4f2152e12ca75f8c40,https://git.samba.org/?p=samba.git;a=blob;f=source4/libcli/ldap/ldap_controls.c;h=983082bdd220917f1045e16f390cb345d36fee2f;hb=983082bdd220917f1045e16f390cb345d36fee2f,,
CVE-2019-17056,https://www.cvedetails.com/cve/CVE-2019-17056/,CWE-276,,,2019-10-01,2019-10-08,2.1,None,Local,Low,Not required,None,Partial,None,"llcp_sock_create in net/nfc/llcp_sock.c in the AF_NFC network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-3a359798b176.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3a359798b176183ef09efb7a3dc59abad1cc7104,3a359798b176183ef09efb7a3dc59abad1cc7104,e69dbd4619e7674c1679cba49afd9dd9ac347eef,"@@ -1004,10 +1004,13 @@ static int llcp_sock_create(struct net *net, struct socket *sock,
 	    sock->type != SOCK_RAW)
 		return -ESOCKTNOSUPPORT;
 
-	if (sock->type == SOCK_RAW)
+	if (sock->type == SOCK_RAW) {
+		if (!capable(CAP_NET_RAW))
+			return -EPERM;
 		sock->ops = &llcp_rawsock_ops;
-	else
+	} else {
 		sock->ops = &llcp_sock_ops;
+	}
 
 	sk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);
 	if (sk == NULL)",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/nfc/llcp_sock.c?id=e69dbd4619e7674c1679cba49afd9dd9ac347eef,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/nfc/llcp_sock.c?id=3a359798b176183ef09efb7a3dc59abad1cc7104,,
CVE-2019-17055,https://www.cvedetails.com/cve/CVE-2019-17055/,CWE-20,,,2019-10-01,2019-10-08,2.1,None,Local,Low,Not required,None,Partial,None,"base_sock_create in drivers/isdn/mISDN/socket.c in the AF_ISDN network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-b91ee4aa2a21.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b91ee4aa2a2199ba4d4650706c272985a5a32d80,b91ee4aa2a2199ba4d4650706c272985a5a32d80,3d66b89c30f9220a72e92847768fc8ba4d027d88,"@@ -754,6 +754,8 @@ base_sock_create(struct net *net, struct socket *sock, int protocol, int kern)
 
 	if (sock->type != SOCK_RAW)
 		return -ESOCKTNOSUPPORT;
+	if (!capable(CAP_NET_RAW))
+		return -EPERM;
 
 	sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);
 	if (!sk)",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/isdn/mISDN/socket.c?id=3d66b89c30f9220a72e92847768fc8ba4d027d88,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/isdn/mISDN/socket.c?id=b91ee4aa2a2199ba4d4650706c272985a5a32d80,,
CVE-2019-17054,https://www.cvedetails.com/cve/CVE-2019-17054/,CWE-276,,,2019-10-01,2019-10-08,2.1,None,Local,Low,Not required,None,Partial,None,"atalk_create in net/appletalk/ddp.c in the AF_APPLETALK network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-6cc03e8aa36c.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac,6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac,b91ee4aa2a2199ba4d4650706c272985a5a32d80,"@@ -1023,6 +1023,11 @@ static int atalk_create(struct net *net, struct socket *sock, int protocol,
 	 */
 	if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 		goto out;
+
+	rc = -EPERM;
+	if (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))
+		goto out;
+
 	rc = -ENOMEM;
 	sk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);
 	if (!sk)",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/appletalk/ddp.c?id=b91ee4aa2a2199ba4d4650706c272985a5a32d80,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/appletalk/ddp.c?id=6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac,,
CVE-2019-17053,https://www.cvedetails.com/cve/CVE-2019-17053/,CWE-276,,,2019-10-01,2019-10-08,2.1,None,Local,Low,Not required,None,Partial,None,"ieee802154_create in net/ieee802154/socket.c in the AF_IEEE802154 network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-e69dbd4619e7.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e69dbd4619e7674c1679cba49afd9dd9ac347eef,e69dbd4619e7674c1679cba49afd9dd9ac347eef,0614e2b73768b502fc32a75349823356d98aae2c,"@@ -1008,6 +1008,9 @@ static int ieee802154_create(struct net *net, struct socket *sock,
 
 	switch (sock->type) {
 	case SOCK_RAW:
+		rc = -EPERM;
+		if (!capable(CAP_NET_RAW))
+			goto out;
 		proto = &ieee802154_raw_prot;
 		ops = &ieee802154_raw_ops;
 		break;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ieee802154/socket.c?id=0614e2b73768b502fc32a75349823356d98aae2c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ieee802154/socket.c?id=e69dbd4619e7674c1679cba49afd9dd9ac347eef,,
CVE-2019-17052,https://www.cvedetails.com/cve/CVE-2019-17052/,CWE-276,,,2019-10-01,2019-10-08,2.1,None,Local,Low,Not required,None,Partial,None,"ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0614e2b73768b502fc32a75349823356d98aae2c,0614e2b73768b502fc32a75349823356d98aae2c,6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac,"@@ -855,6 +855,8 @@ static int ax25_create(struct net *net, struct socket *sock, int protocol,
 		break;
 
 	case SOCK_RAW:
+		if (!capable(CAP_NET_RAW))
+			return -EPERM;
 		break;
 	default:
 		return -ESOCKTNOSUPPORT;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ax25/af_ax25.c?id=6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ax25/af_ax25.c?id=0614e2b73768b502fc32a75349823356d98aae2c,,
CVE-2018-20482,https://www.cvedetails.com/cve/CVE-2018-20482/,CWE-835,,DoS,2018-12-26,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",C,savannah,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454,c15c42ccd1e2377945fd0414eca1a49294bff454,3c2a2cd94d3b062aa5bf850b82364039ec9c6029,"@@ -1,6 +1,6 @@
 /* Functions for dealing with sparse files
 
-   Copyright 2003-2007, 2010, 2013-2017 Free Software Foundation, Inc.
+   Copyright 2003-2007, 2010, 2013-2018 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
@@ -427,6 +427,30 @@ sparse_dump_region (struct tar_sparse_file *file, size_t i)
 			     bufsize);
 	  return false;
 	}
+      else if (bytes_read == 0)
+	{
+	  char buf[UINTMAX_STRSIZE_BOUND];
+	  struct stat st;
+	  size_t n;
+	  if (fstat (file->fd, &st) == 0)
+	    n = file->stat_info->stat.st_size - st.st_size;
+	  else
+	    n = file->stat_info->stat.st_size
+	      - (file->stat_info->sparse_map[i].offset
+		 + file->stat_info->sparse_map[i].numbytes
+		 - bytes_left);
+	  
+	  WARNOPT (WARN_FILE_SHRANK,
+		   (0, 0,
+		    ngettext (""%s: File shrank by %s byte; padding with zeros"",
+			      ""%s: File shrank by %s bytes; padding with zeros"",
+			      n),
+		    quotearg_colon (file->stat_info->orig_file_name),
+		    STRINGIFY_BIGINT (n, buf)));
+	  if (! ignore_failed_read_option)
+	    set_exit_status (TAREXIT_DIFFERS);
+	  return false;
+	}
 
       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);
       bytes_left -= bytes_read;
@@ -464,9 +488,9 @@ sparse_extract_region (struct tar_sparse_file *file, size_t i)
 	  return false;
 	}
       set_next_block_after (blk);
+      file->dumped_size += BLOCKSIZE;
       count = blocking_write (file->fd, blk->buffer, wrbytes);
       write_size -= count;
-      file->dumped_size += count;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       file->offset += count;
       if (count != wrbytes)
@@ -598,6 +622,12 @@ check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)
 			     rdsize);
 	  return false;
 	}
+      else if (bytes_read == 0)
+	{
+	  report_difference (file->stat_info, _(""Size differs""));
+	  return false;
+	}
+      
       if (!zero_block_p (diff_buffer, bytes_read))
 	{
 	  char begbuf[INT_BUFSIZE_BOUND (off_t)];
@@ -609,6 +639,7 @@ check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)
 
       beg += bytes_read;
     }
+
   return true;
 }
 
@@ -635,6 +666,7 @@ check_data_region (struct tar_sparse_file *file, size_t i)
 	  return false;
 	}
       set_next_block_after (blk);
+      file->dumped_size += BLOCKSIZE;      
       bytes_read = safe_read (file->fd, diff_buffer, rdsize);
       if (bytes_read == SAFE_READ_ERROR)
 	{
@@ -645,7 +677,11 @@ check_data_region (struct tar_sparse_file *file, size_t i)
 			     rdsize);
 	  return false;
 	}
-      file->dumped_size += bytes_read;
+      else if (bytes_read == 0)
+	{
+	  report_difference (&current_stat_info, _(""Size differs""));
+	  return false;
+	}
       size_left -= bytes_read;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       if (memcmp (blk->buffer, diff_buffer, rdsize))
@@ -1213,7 +1249,8 @@ pax_decode_header (struct tar_sparse_file *file)
       union block *blk;
       char *p;
       size_t i;
-
+      off_t start;
+      
 #define COPY_BUF(b,buf,src) do                                     \
  {                                                                 \
    char *endp = b->buffer + BLOCKSIZE;                             \
@@ -1229,7 +1266,6 @@ pax_decode_header (struct tar_sparse_file *file)
        if (src == endp)                                            \
 	 {                                                         \
 	   set_next_block_after (b);                               \
-           file->dumped_size += BLOCKSIZE;                         \
            b = find_next_block ();                                 \
            src = b->buffer;                                        \
 	   endp = b->buffer + BLOCKSIZE;                           \
@@ -1240,8 +1276,8 @@ pax_decode_header (struct tar_sparse_file *file)
    dst[-1] = 0;                                                    \
  } while (0)
 
+      start = current_block_ordinal ();
       set_next_block_after (current_header);
-      file->dumped_size += BLOCKSIZE;
       blk = find_next_block ();
       p = blk->buffer;
       COPY_BUF (blk,nbuf,p);
@@ -1278,6 +1314,8 @@ pax_decode_header (struct tar_sparse_file *file)
 	  sparse_add_map (file->stat_info, &sp);
 	}
       set_next_block_after (blk);
+
+      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);
     }
 
   return true;",https://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=3c2a2cd94d3b062aa5bf850b82364039ec9c6029,https://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=c15c42ccd1e2377945fd0414eca1a49294bff454,,
CVE-2018-20482,https://www.cvedetails.com/cve/CVE-2018-20482/,CWE-835,,DoS,2018-12-26,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",am,savannah,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454,c15c42ccd1e2377945fd0414eca1a49294bff454,3c2a2cd94d3b062aa5bf850b82364039ec9c6029,"@@ -1,6 +1,6 @@
 # Makefile for GNU tar regression tests.
 
-# Copyright 1996-1997, 1999-2001, 2003-2007, 2009, 2012-2015 Free Software
+# Copyright 1996-1997, 1999-2001, 2003-2007, 2009, 2012-2018 Free Software
 
 # This file is part of GNU tar.
 
@@ -238,6 +238,9 @@ TESTSUITE_AT = \
  spmvp00.at\
  spmvp01.at\
  spmvp10.at\
+ sptrcreat.at\
+ sptrdiff00.at\
+ sptrdiff01.at\
  time01.at\
  time02.at\
  truncate.at\",https://git.savannah.gnu.org/cgit/tar.git/tree/tests/Makefile.am?id=3c2a2cd94d3b062aa5bf850b82364039ec9c6029,https://git.savannah.gnu.org/cgit/tar.git/tree/tests/Makefile.am?id=c15c42ccd1e2377945fd0414eca1a49294bff454,,
CVE-2018-20482,https://www.cvedetails.com/cve/CVE-2018-20482/,CWE-835,,DoS,2018-12-26,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",at,savannah,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454,c15c42ccd1e2377945fd0414eca1a49294bff454,3c2a2cd94d3b062aa5bf850b82364039ec9c6029,"@@ -1,7 +1,7 @@
 # Process this file with autom4te to create testsuite. -*- Autotest -*-
 
 # Test suite for GNU tar.
-# Copyright 2004-2008, 2010-2017 Free Software Foundation, Inc.
+# Copyright 2004-2008, 2010-2018 Free Software Foundation, Inc.
 
 # This file is part of GNU tar.
 
@@ -416,6 +416,9 @@ m4_include([sparsemv.at])
 m4_include([spmvp00.at])
 m4_include([spmvp01.at])
 m4_include([spmvp10.at])
+m4_include([sptrcreat.at])
+m4_include([sptrdiff00.at])
+m4_include([sptrdiff01.at])
 
 AT_BANNER([Updates])
 m4_include([update.at])",https://git.savannah.gnu.org/cgit/tar.git/tree/tests/testsuite.at?id=3c2a2cd94d3b062aa5bf850b82364039ec9c6029,https://git.savannah.gnu.org/cgit/tar.git/tree/tests/testsuite.at?id=c15c42ccd1e2377945fd0414eca1a49294bff454,,
CVE-2019-16413,https://www.cvedetails.com/cve/CVE-2019-16413/,CWE-835,,DoS,2019-09-18,2019-10-04,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",H,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,"@@ -40,6 +40,9 @@
  */
 #define P9_LOCK_TIMEOUT (30*HZ)
 
+/* flags for v9fs_stat2inode() & v9fs_stat2inode_dotl() */
+#define V9FS_STAT2INODE_KEEP_ISIZE 1
+
 extern struct file_system_type v9fs_fs_type;
 extern const struct address_space_operations v9fs_addr_operations;
 extern const struct file_operations v9fs_file_operations;
@@ -61,8 +64,10 @@ int v9fs_init_inode(struct v9fs_session_info *v9ses,
 		    struct inode *inode, umode_t mode, dev_t);
 void v9fs_evict_inode(struct inode *inode);
 ino_t v9fs_qid2ino(struct p9_qid *qid);
-void v9fs_stat2inode(struct p9_wstat *, struct inode *, struct super_block *);
-void v9fs_stat2inode_dotl(struct p9_stat_dotl *, struct inode *);
+void v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,
+		      struct super_block *sb, unsigned int flags);
+void v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,
+			   unsigned int flags);
 int v9fs_dir_release(struct inode *inode, struct file *filp);
 int v9fs_file_open(struct inode *inode, struct file *file);
 void v9fs_inode2stat(struct inode *inode, struct p9_wstat *stat);
@@ -83,4 +88,18 @@ static inline void v9fs_invalidate_inode_attr(struct inode *inode)
 }
 
 int v9fs_open_to_dotl_flags(int flags);
+
+static inline void v9fs_i_size_write(struct inode *inode, loff_t i_size)
+{
+	/*
+	 * 32-bit need the lock, concurrent updates could break the
+	 * sequences and make i_size_read() loop forever.
+	 * 64-bit updates are atomic and can skip the locking.
+	 */
+	if (sizeof(i_size) > sizeof(long))
+		spin_lock(&inode->i_lock);
+	i_size_write(inode, i_size);
+	if (sizeof(i_size) > sizeof(long))
+		spin_unlock(&inode->i_lock);
+}
 #endif",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/v9fs_vfs.h?id=3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/v9fs_vfs.h?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,,
CVE-2019-16413,https://www.cvedetails.com/cve/CVE-2019-16413/,CWE-835,,DoS,2019-09-18,2019-10-04,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,"@@ -446,7 +446,11 @@ v9fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 		i_size = i_size_read(inode);
 		if (iocb->ki_pos > i_size) {
 			inode_add_bytes(inode, iocb->ki_pos - i_size);
-			i_size_write(inode, iocb->ki_pos);
+			/*
+			 * Need to serialize against i_size_write() in
+			 * v9fs_stat2inode()
+			 */
+			v9fs_i_size_write(inode, iocb->ki_pos);
 		}
 		return retval;
 	}",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_file.c?id=3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_file.c?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,,
CVE-2019-16413,https://www.cvedetails.com/cve/CVE-2019-16413/,CWE-835,,DoS,2019-09-18,2019-10-04,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,"@@ -538,7 +538,7 @@ static struct inode *v9fs_qid_iget(struct super_block *sb,
 	if (retval)
 		goto error;
 
-	v9fs_stat2inode(st, inode, sb);
+	v9fs_stat2inode(st, inode, sb, 0);
 	v9fs_cache_inode_get_cookie(inode);
 	unlock_new_inode(inode);
 	return inode;
@@ -1092,7 +1092,7 @@ v9fs_vfs_getattr(const struct path *path, struct kstat *stat,
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode(st, d_inode(dentry), dentry->d_sb);
+	v9fs_stat2inode(st, d_inode(dentry), dentry->d_sb, 0);
 	generic_fillattr(d_inode(dentry), stat);
 
 	p9stat_free(st);
@@ -1170,12 +1170,13 @@ static int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)
  * @stat: Plan 9 metadata (mistat) structure
  * @inode: inode to populate
  * @sb: superblock of filesystem
+ * @flags: control flags (e.g. V9FS_STAT2INODE_KEEP_ISIZE)
  *
  */
 
 void
 v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,
-	struct super_block *sb)
+		 struct super_block *sb, unsigned int flags)
 {
 	umode_t mode;
 	char ext[32];
@@ -1216,10 +1217,11 @@ v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,
 	mode = p9mode2perm(v9ses, stat);
 	mode |= inode->i_mode & ~S_IALLUGO;
 	inode->i_mode = mode;
-	i_size_write(inode, stat->length);
 
+	if (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))
+		v9fs_i_size_write(inode, stat->length);
 	/* not real number of blocks, but 512 byte ones ... */
-	inode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;
+	inode->i_blocks = (stat->length + 512 - 1) >> 9;
 	v9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;
 }
 
@@ -1416,9 +1418,9 @@ int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)
 {
 	int umode;
 	dev_t rdev;
-	loff_t i_size;
 	struct p9_wstat *st;
 	struct v9fs_session_info *v9ses;
+	unsigned int flags;
 
 	v9ses = v9fs_inode2v9ses(inode);
 	st = p9_client_stat(fid);
@@ -1431,16 +1433,13 @@ int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)
 	if ((inode->i_mode & S_IFMT) != (umode & S_IFMT))
 		goto out;
 
-	spin_lock(&inode->i_lock);
 	/*
 	 * We don't want to refresh inode->i_size,
 	 * because we may have cached data
 	 */
-	i_size = inode->i_size;
-	v9fs_stat2inode(st, inode, inode->i_sb);
-	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)
-		inode->i_size = i_size;
-	spin_unlock(&inode->i_lock);
+	flags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?
+		V9FS_STAT2INODE_KEEP_ISIZE : 0;
+	v9fs_stat2inode(st, inode, inode->i_sb, flags);
 out:
 	p9stat_free(st);
 	kfree(st);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_inode.c?id=3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_inode.c?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,,
CVE-2019-16413,https://www.cvedetails.com/cve/CVE-2019-16413/,CWE-835,,DoS,2019-09-18,2019-10-04,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,"@@ -143,7 +143,7 @@ static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,
 	if (retval)
 		goto error;
 
-	v9fs_stat2inode_dotl(st, inode);
+	v9fs_stat2inode_dotl(st, inode, 0);
 	v9fs_cache_inode_get_cookie(inode);
 	retval = v9fs_get_acl(inode, fid);
 	if (retval)
@@ -496,7 +496,7 @@ v9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode_dotl(st, d_inode(dentry));
+	v9fs_stat2inode_dotl(st, d_inode(dentry), 0);
 	generic_fillattr(d_inode(dentry), stat);
 	/* Change block size to what the server returned */
 	stat->blksize = st->st_blksize;
@@ -607,11 +607,13 @@ int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)
  * v9fs_stat2inode_dotl - populate an inode structure with stat info
  * @stat: stat structure
  * @inode: inode to populate
+ * @flags: ctrl flags (e.g. V9FS_STAT2INODE_KEEP_ISIZE)
  *
  */
 
 void
-v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)
+v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,
+		      unsigned int flags)
 {
 	umode_t mode;
 	struct v9fs_inode *v9inode = V9FS_I(inode);
@@ -631,7 +633,8 @@ v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)
 		mode |= inode->i_mode & ~S_IALLUGO;
 		inode->i_mode = mode;
 
-		i_size_write(inode, stat->st_size);
+		if (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))
+			v9fs_i_size_write(inode, stat->st_size);
 		inode->i_blocks = stat->st_blocks;
 	} else {
 		if (stat->st_result_mask & P9_STATS_ATIME) {
@@ -661,8 +664,9 @@ v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)
 		}
 		if (stat->st_result_mask & P9_STATS_RDEV)
 			inode->i_rdev = new_decode_dev(stat->st_rdev);
-		if (stat->st_result_mask & P9_STATS_SIZE)
-			i_size_write(inode, stat->st_size);
+		if (!(flags & V9FS_STAT2INODE_KEEP_ISIZE) &&
+		    stat->st_result_mask & P9_STATS_SIZE)
+			v9fs_i_size_write(inode, stat->st_size);
 		if (stat->st_result_mask & P9_STATS_BLOCKS)
 			inode->i_blocks = stat->st_blocks;
 	}
@@ -928,9 +932,9 @@ v9fs_vfs_get_link_dotl(struct dentry *dentry,
 
 int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)
 {
-	loff_t i_size;
 	struct p9_stat_dotl *st;
 	struct v9fs_session_info *v9ses;
+	unsigned int flags;
 
 	v9ses = v9fs_inode2v9ses(inode);
 	st = p9_client_getattr_dotl(fid, P9_STATS_ALL);
@@ -942,16 +946,13 @@ int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)
 	if ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))
 		goto out;
 
-	spin_lock(&inode->i_lock);
 	/*
 	 * We don't want to refresh inode->i_size,
 	 * because we may have cached data
 	 */
-	i_size = inode->i_size;
-	v9fs_stat2inode_dotl(st, inode);
-	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)
-		inode->i_size = i_size;
-	spin_unlock(&inode->i_lock);
+	flags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?
+		V9FS_STAT2INODE_KEEP_ISIZE : 0;
+	v9fs_stat2inode_dotl(st, inode, flags);
 out:
 	kfree(st);
 	return 0;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_inode_dotl.c?id=3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_inode_dotl.c?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,,
CVE-2019-16413,https://www.cvedetails.com/cve/CVE-2019-16413/,CWE-835,,DoS,2019-09-18,2019-10-04,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",C,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,"@@ -172,7 +172,7 @@ static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,
 			goto release_sb;
 		}
 		d_inode(root)->i_ino = v9fs_qid2ino(&st->qid);
-		v9fs_stat2inode_dotl(st, d_inode(root));
+		v9fs_stat2inode_dotl(st, d_inode(root), 0);
 		kfree(st);
 	} else {
 		struct p9_wstat *st = NULL;
@@ -183,7 +183,7 @@ static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,
 		}
 
 		d_inode(root)->i_ino = v9fs_qid2ino(&st->qid);
-		v9fs_stat2inode(st, d_inode(root), sb);
+		v9fs_stat2inode(st, d_inode(root), sb, 0);
 
 		p9stat_free(st);
 		kfree(st);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_super.c?id=3bbe8b1a4ae9585e9cf15e7036bf9e5374a482df,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/9p/vfs_super.c?id=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=1eee7ee3a0c3441e02c51e10eb3429166b084b17,1eee7ee3a0c3441e02c51e10eb3429166b084b17,bc16c7a0e3bf7ee41a1ce6bddae4ee6843b96c13,"@@ -51,8 +51,17 @@ if (!empty($CFG->forceloginforprofiles)) {
 
 // Get all external badges of a user.
 $out = get_backpack_settings($userid);
+
+// If we didn't find any badges then print an error.
+if (is_null($out)) {
+    print_error('error:externalbadgedoesntexist', 'badges');
+}
+
 $badges = $out->badges;
 
+// The variable to store the badge we want.
+$badge = '';
+
 // Loop through the badges and check if supplied badge hash exists in user external badges.
 foreach ($badges as $b) {
     if ($hash == hash(""md5"", $b->hostedUrl)) {
@@ -61,9 +70,9 @@ foreach ($badges as $b) {
     }
 }
 
-// If we didn't find the badge, a user might be trying to replace userid parameter.
-if (is_null($badge)) {
-    print_error(get_string('error:externalbadgedoesntexist', 'badges'));
+// If we didn't find the badge a user might be trying to replace the userid parameter.
+if (empty($badge)) {
+    print_error('error:externalbadgedoesntexist', 'badges');
 }
 
 $PAGE->set_context(context_system::instance());",http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/external.php;h=e9c4ab3580e4f0f1c65140e30b1259a0250c5250;hb=e9c4ab3580e4f0f1c65140e30b1259a0250c5250,http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/external.php;h=f18883bf42bc5d3e6051f7d761883cf32834029a;hb=f18883bf42bc5d3e6051f7d761883cf32834029a,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -27,14 +27,50 @@
 require_once(dirname(dirname(__FILE__)) . '/config.php');
 require_once($CFG->libdir . '/badgeslib.php');
 
-$json = required_param('badge', PARAM_RAW);
+$json = optional_param('badge', null, PARAM_RAW);
+// Redirect to homepage if users are trying to access external badge through old url.
+if ($json) {
+    redirect($CFG->wwwroot, get_string('invalidrequest', 'error'), 3);
+}
+
+$hash = required_param('hash', PARAM_ALPHANUM);
+$userid = required_param('user', PARAM_INT);
+
+$PAGE->set_url(new moodle_url('/badges/external.php', array('hash' => $hash, 'user' => $userid)));
+
+// Using the same setting as user profile page.
+if (!empty($CFG->forceloginforprofiles)) {
+    require_login();
+    if (isguestuser()) {
+        $SESSION->wantsurl = $PAGE->url->out(false);
+        redirect(get_login_url());
+    }
+} else if (!empty($CFG->forcelogin)) {
+    require_login();
+}
+
+// Get all external badges of a user.
+$out = get_backpack_settings($userid);
+$badges = $out->badges;
+
+// Loop through the badges and check if supplied badge hash exists in user external badges.
+foreach ($badges as $b) {
+    if ($hash == hash(""md5"", $b->hostedUrl)) {
+        $badge = $b;
+        break;
+    }
+}
+
+// If we didn't find the badge, a user might be trying to replace userid parameter.
+if (is_null($badge)) {
+    print_error(get_string('error:externalbadgedoesntexist', 'badges'));
+}
 
 $PAGE->set_context(context_system::instance());
 $output = $PAGE->get_renderer('core', 'badges');
 
-$badge = new external_badge(unserialize($json));
+$badge = new external_badge($badge);
 
-$PAGE->set_url('/badges/external.php');
 $PAGE->set_pagelayout('base');
 $PAGE->set_title(get_string('issuedbadge', 'badges'));",http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/external.php;h=5436f016ecd5915550978a3b26506c391baf3bd2,http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/external.php;h=cf0ac0f8fd13c01f5a7a32be093ea60f28eba4df;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -53,11 +53,13 @@ $PAGE->set_heading($title);
 $PAGE->set_pagelayout('mydashboard');
 
 $backpack = $DB->get_record('badge_backpack', array('userid' => $USER->id));
+$badgescache = cache::make('core', 'externalbadges');
 
 if ($disconnect && $backpack) {
     require_sesskey();
     $DB->delete_records('badge_external', array('backpackid' => $backpack->id));
     $DB->delete_records('badge_backpack', array('userid' => $USER->id));
+    $badgescache->delete($USER->id);
     redirect(new moodle_url('/badges/mybackpack.php'));
 }
 
@@ -103,6 +105,7 @@ if ($backpack) {
                 $DB->insert_record('badge_external', $obj);
             }
         }
+        $badgescache->delete($USER->id);
         redirect(new moodle_url('/badges/mybadges.php'));
     }
 } else {",http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/mybackpack.php;h=1f524539900830380b6e2bb108c292545cf5b7bc,http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/mybackpack.php;h=875d025b1d39e8dec74d3b08d8f7a5afc39a3a15;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -81,9 +81,10 @@ class core_badges_renderer extends plugin_renderer_base {
                 $url = new moodle_url('badge.php', array('hash' => $badge->uniquehash));
             } else {
                 if (!$external) {
-                    $url = new moodle_url($CFG->wwwroot . '/badges/badge.php', array('hash' => $badge->uniquehash));
+                    $url = new moodle_url('/badges/badge.php', array('hash' => $badge->uniquehash));
                 } else {
-                    $url = new moodle_url($CFG->wwwroot . '/badges/external.php', array('badge' => serialize($badge)));
+                    $hash = hash('md5', $badge->hostedUrl);
+                    $url = new moodle_url('/badges/external.php', array('hash' => $hash, 'user' => $userid));
                 }
             }
             $actions = html_writer::tag('div', $push . $download . $status, array('class' => 'badge-actions'));
@@ -918,10 +919,10 @@ class external_badge implements renderable {
     /**
      * Initializes the badge to display
      *
-     * @param string $json External badge information.
+     * @param object $badge External badge information.
      */
-    public function __construct($json) {
-        $this->issued = $json;
+    public function __construct($badge) {
+        $this->issued = $badge;
     }
 }
 
@@ -1016,7 +1017,7 @@ class badge_user_collection extends badge_collection implements renderable {
         parent::__construct($badges);
 
         if (!empty($CFG->badges_allowexternalbackpack)) {
-            $this->backpack = get_backpack_settings($userid);
+            $this->backpack = get_backpack_settings($userid, true);
         }
     }
 }",http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/renderer.php;h=088b443ca966238f3855570d26378432f7bfd6f5,http://git.moodle.org/gw?p=moodle.git;a=blob;f=badges/renderer.php;h=bf88e84197f001c5f1342b6bc329e6b44f76ab8c;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -101,7 +101,9 @@ $string['badgeprivacysetting_help'] = 'Badges you earn can be displayed on your
 You can still control individual badge privacy settings on your ""My badges"" page.';
 $string['badgeprivacysetting_str'] = 'Automatically show badges I earn on my profile page';
 $string['badgesalt'] = 'Salt for hashing the recepient\'s email address';
-$string['badgesalt_desc'] = 'Using a hash allows backpack services to confirm the badge earner without having to expose their email address. This setting should only use numbers and letters.';
+$string['badgesalt_desc'] = 'Using a hash allows backpack services to confirm the badge earner without having to expose their email address. This setting should only use numbers and letters.
+
+Note: For recipient verification purposes, please avoid changing this setting once you start issuing badges.';
 $string['badgesdisabled'] = 'Badges are not enabled on this site.';
 $string['badgesearned'] = 'Number of badges earned: {$a}';
 $string['badgesettings'] = 'Badges settings';
@@ -203,6 +205,7 @@ $string['error:cannotact'] = 'Cannot activate the badge. ';
 $string['error:cannotawardbadge'] = 'Cannot award badge to a user.';
 $string['error:clone'] = 'Cannot clone the badge.';
 $string['error:duplicatename'] = 'Badge with such name already exists in the system.';
+$string['error:externalbadgedoesntexist'] = 'Badge not found';
 $string['error:invalidbadgeurl'] = 'Invalid badge issuer URL format.';
 $string['error:invalidcriteriatype'] = 'Invalid criteria type.';
 $string['error:invalidexpiredate'] = 'Expiry date has to be in the future.';",http://git.moodle.org/gw?p=moodle.git;a=blob;f=lang/en/badges.php;h=9e5b147dabefe16446f6b788ad69c25a3265c577,http://git.moodle.org/gw?p=moodle.git;a=blob;f=lang/en/badges.php;h=bc45007bc1cbee46579b0d158afd63a37c99028d;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -44,6 +44,7 @@ $string['cachedef_coursecontacts'] = 'List of course contacts';
 $string['cachedef_coursecattree'] = 'Course categories tree';
 $string['cachedef_databasemeta'] = 'Database meta information';
 $string['cachedef_eventinvalidation'] = 'Event invalidation';
+$string['cachedef_externalbadges'] = 'External badges for particular user';
 $string['cachedef_groupdata'] = 'Course group information';
 $string['cachedef_htmlpurifier'] = 'HTML Purifier - cleaned content';
 $string['cachedef_langmenu'] = 'List of available languages';",http://git.moodle.org/gw?p=moodle.git;a=blob;f=lang/en/cache.php;h=a60b503113b96f1ae8a93db07da03fd0c23efbad,http://git.moodle.org/gw?p=moodle.git;a=blob;f=lang/en/cache.php;h=47403f2f8e834fa0d7492be263a7d8f44acfd133;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -1086,13 +1086,25 @@ function badges_bake($hash, $badgeid, $userid = 0, $pathhash = false) {
 /**
  * Returns external backpack settings and badges from this backpack.
  *
+ * This function first checks if badges for the user are cached and
+ * tries to retrieve them from the cache. Otherwise, badges are obtained
+ * through curl request to the backpack.
+ *
  * @param int $userid Backpack user ID.
+ * @param boolean $refresh Refresh badges collection in cache.
  * @return null|object Returns null is there is no backpack or object with backpack settings.
  */
-function get_backpack_settings($userid) {
+function get_backpack_settings($userid, $refresh = false) {
     global $DB;
     require_once(dirname(dirname(__FILE__)) . '/badges/lib/backpacklib.php');
 
+    // Try to get badges from cache first.
+    $badgescache = cache::make('core', 'externalbadges');
+    $out = $badgescache->get($userid);
+    if ($out !== false && !$refresh) {
+        return $out;
+    }
+    // Get badges through curl request to the backpack.
     $record = $DB->get_record('badge_backpack', array('userid' => $userid));
     if ($record) {
         $backpack = new OpenBadgesBackpackHandler($record);
@@ -1117,6 +1129,7 @@ function get_backpack_settings($userid) {
             $out->totalcollections = 0;
         }
 
+        $badgescache->set($userid, $out);
         return $out;
     }",http://git.moodle.org/gw?p=moodle.git;a=blob;f=lib/badgeslib.php;h=490145681135978651a48a250a08e1cb1d04a115,http://git.moodle.org/gw?p=moodle.git;a=blob;f=lib/badgeslib.php;h=4a4b3fb8ab47bf2f04a72bbbba28c5fb8c7e12ae;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -233,4 +233,10 @@ $definitions = array(
         'mode' => cache_store::MODE_REQUEST,
         'persistent' => true,
     ),
+    // Used to store external badges.
+    'externalbadges' => array(
+        'mode' => cache_store::MODE_APPLICATION,
+        'simplekeys' => true,
+        'ttl' => 3600,
+    ),
 );",http://git.moodle.org/gw?p=moodle.git;a=blob;f=lib/db/caches.php;h=9f36f54fc441d5c38a5b8315f456814a30a37adf,http://git.moodle.org/gw?p=moodle.git;a=blob;f=lib/db/caches.php;h=d03f1c364e49a739a178e4fc71d724b119639057;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2013-5674,https://www.cvedetails.com/cve/CVE-2013-5674/,CWE-94,,,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"badges/external.php in Moodle 2.5.x before 2.5.2 does not properly handle an object obtained by unserializing a description of an external badge, which allows remote attackers to conduct PHP object injection attacks via unspecified vectors, as demonstrated by overwriting the value of the userid parameter.",Php,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=2d3c0faef15938638b722c2f73b899551a398494,2d3c0faef15938638b722c2f73b899551a398494,bff1d60c05429d2568f260e20610001b621ce700,"@@ -29,7 +29,7 @@
 
 defined('MOODLE_INTERNAL') || die();
 
-$version  = 2013083000.00;              // YYYYMMDD      = weekly release date of this DEV branch.
+$version  = 2013090200.00;              // YYYYMMDD      = weekly release date of this DEV branch.
                                         //         RR    = release increments - 00 in DEV branches.
                                         //           .XX = incremental changes.",http://git.moodle.org/gw?p=moodle.git;a=blob;f=version.php;h=f8e1fa70bd6699a29d7486248941ca40d89db65c,http://git.moodle.org/gw?p=moodle.git;a=blob;f=version.php;h=d43b093345931e141f1b46b9cd1b3403a09e7d6b;hb=2d3c0faef15938638b722c2f73b899551a398494,,
CVE-2019-16393,https://www.cvedetails.com/cve/CVE-2019-16393/,CWE-601,,,2019-09-17,2019-09-25,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"SPIP before 3.1.11 and 3.2 before 3.2.5 mishandles redirect URLs in ecrire/inc/headers.php with a %0D, %0A, or %20 character.",Php,spip,https://git.spip.net/SPIP/spip/commit/0b832408b0aabd5b94a81e261e9413c0f31a19f1,17c9990575b0eea8d5ba9e33d86e8a01b52750d9,0b832408b0aabd5b94a81e261e9413c0f31a19f1,"@@ -55,6 +55,10 @@ function redirige_par_entete($url, $equiv = '', $status = 302) {

	// ne pas laisser passer n'importe quoi dans l'url
	$url = str_replace(array('<', '""'), array('&lt;', '&quot;'), $url);
	$url = str_replace(array(""\r"", ""\n"", ' '), array('%0D', '%0A', '%20'), $url);
	while (strpos($url, '%0A') !== false) {
		$url = str_replace('%0A', '', $url);
	}
	// interdire les url inline avec des pseudo-protocoles :
	if (
		(preg_match("",data:,i"", $url) and preg_match(""/base64\s*,/i"", $url))

",https://git.spip.net/spip/spip/src/commit/17c9990575b0eea8d5ba9e33d86e8a01b52750d9/ecrire/inc/headers.php,https://git.spip.net/spip/spip/src/commit/0b832408b0aabd5b94a81e261e9413c0f31a19f1/ecrire/inc/headers.php,,
CVE-2019-16392,https://www.cvedetails.com/cve/CVE-2019-16392/,CWE-79,,XSS,2019-09-17,2019-09-25,4.3,None,Remote,Medium,Not required,None,Partial,None,SPIP before 3.1.11 and 3.2 before 3.2.5 allows prive/formulaires/login.php XSS via error messages.,Php,spip,https://git.spip.net/SPIP/spip/commit/3c12a82c7d9d4afd09e708748fa82e7836174028,3c12a82c7d9d4afd09e708748fa82e7836174028,e5d5150cfa5ec9eb0c3a08a90711eb45c6bfaf61,"@@ -138,8 +138,8 @@ function formulaires_login_charger_dist($cible = '', $login = '', $prive = null)
	} elseif ($erreur) {
		// une erreur d'un SSO indique dans la redirection vers ici
		// mais il faut se proteger de toute tentative d'injection malveilante
		include_spip('inc/texte');
		$valeurs['message_erreur'] = safehtml($erreur);
		include_spip('inc/filtres');
		$valeurs['message_erreur'] = textebrut($erreur);
	}

	return $valeurs;",https://git.spip.net/spip/spip/src/commit/e5d5150cfa5ec9eb0c3a08a90711eb45c6bfaf61/prive/formulaires/login.php,https://git.spip.net/spip/spip/src/commit/3c12a82c7d9d4afd09e708748fa82e7836174028/prive/formulaires/login.php,,
CVE-2019-16391,https://www.cvedetails.com/cve/CVE-2019-16391/,CWE-863,,,2019-09-17,2019-09-25,4.0,None,Remote,Low,Single system,None,Partial,None,SPIP before 3.1.11 and 3.2 before 3.2.5 allows authenticated visitors to modify any published content and execute other modifications in the database. This is related to ecrire/inc/meta.php and ecrire/inc/securiser_action.php.,Php,spip,https://git.spip.net/SPIP/spip/commit/187952ce85e73b52c2753f2d54fc2c44807b8f79,187952ce85e73b52c2753f2d54fc2c44807b8f79,319f0f1598e6e6dba0dd00690a2edcc175d34ab9,"@@ -32,7 +32,7 @@ function inc_meta_dist($table = 'meta') {
	// en cas d'install ne pas faire confiance au meta_cache eventuel
	$cache = cache_meta($table);

	if ((_request('exec') !== 'install' or !test_espace_prive())
	if ((!$exec = _request('exec') or !autoriser_sans_cookie($exec))
		and $new = jeune_fichier($cache, _META_CACHE_TIME)
		and lire_fichier_securise($cache, $meta)
		and $meta = @unserialize($meta)",,,,
CVE-2019-16391,https://www.cvedetails.com/cve/CVE-2019-16391/,CWE-863,,,2019-09-17,2019-09-25,4.0,None,Remote,Low,Single system,None,Partial,None,SPIP before 3.1.11 and 3.2 before 3.2.5 allows authenticated visitors to modify any published content and execute other modifications in the database. This is related to ecrire/inc/meta.php and ecrire/inc/securiser_action.php.,Php,spip,https://git.spip.net/SPIP/spip/commit/187952ce85e73b52c2753f2d54fc2c44807b8f79,187952ce85e73b52c2753f2d54fc2c44807b8f79,319f0f1598e6e6dba0dd00690a2edcc175d34ab9,"@@ -184,14 +184,16 @@ function caracteriser_auteur($id_auteur = null) {
function _action_auteur($action, $id_auteur, $pass, $alea) {
	static $sha = array();
	if (!isset($sha[$id_auteur . $pass . $alea])) {
		if (!isset($GLOBALS['meta'][$alea]) and _request('exec') !== 'install') {
			include_spip('inc/acces');
			charger_aleas();
			if (empty($GLOBALS['meta'][$alea])) {
				include_spip('inc/minipres');
				echo minipres();
				spip_log(""$alea indisponible"");
				exit;
		if (!isset($GLOBALS['meta'][$alea])) {
			if (!$exec = _request('exec') or !autoriser_sans_cookie($exec)){
				include_spip('inc/acces');
				charger_aleas();
				if (empty($GLOBALS['meta'][$alea])){
					include_spip('inc/minipres');
					echo minipres();
					spip_log(""$alea indisponible"");
					exit;
				}
			}
		}
		include_spip('auth/sha256.inc');",,,,
CVE-2019-16391,https://www.cvedetails.com/cve/CVE-2019-16391/,CWE-863,,,2019-09-17,2019-09-25,4.0,None,Remote,Low,Single system,None,Partial,None,SPIP before 3.1.11 and 3.2 before 3.2.5 allows authenticated visitors to modify any published content and execute other modifications in the database. This is related to ecrire/inc/meta.php and ecrire/inc/securiser_action.php.,Php,spip,https://git.spip.net/SPIP/spip/commit/187952ce85e73b52c2753f2d54fc2c44807b8f79,187952ce85e73b52c2753f2d54fc2c44807b8f79,319f0f1598e6e6dba0dd00690a2edcc175d34ab9,"@@ -1644,14 +1644,24 @@ function find_all_in_path($dir, $pattern, $recurs = false) {

/**
 * Prédicat sur les scripts de ecrire qui n'authentifient pas par cookie
 * et beneficient d'une exception
 *
 * @param string $nom
 * @param bool $strict
 * @return bool
 */
function autoriser_sans_cookie($nom) {
function autoriser_sans_cookie($nom, $strict = false) {
	static $autsanscookie = array('install', 'base_repair');
	$nom = preg_replace('/.php[3]?$/', '', basename($nom));

	return in_array($nom, $autsanscookie);
	if (in_array($nom, $autsanscookie)) {
		if (test_espace_prive()){
			include_spip('base/connect_sql');
			if (!$strict or !spip_connect()){
				return true;
			}
		}
	}
	return false;
}

/**

",,,,
CVE-2019-16391,https://www.cvedetails.com/cve/CVE-2019-16391/,CWE-863,,,2019-09-17,2019-09-25,4.0,None,Remote,Low,Single system,None,Partial,None,SPIP before 3.1.11 and 3.2 before 3.2.5 allows authenticated visitors to modify any published content and execute other modifications in the database. This is related to ecrire/inc/meta.php and ecrire/inc/securiser_action.php.,Php,spip,https://git.spip.net/SPIP/spip/commit/187952ce85e73b52c2753f2d54fc2c44807b8f79,187952ce85e73b52c2753f2d54fc2c44807b8f79,319f0f1598e6e6dba0dd00690a2edcc175d34ab9,,,,,
CVE-2019-16391,https://www.cvedetails.com/cve/CVE-2019-16391/,CWE-863,,,2019-09-17,2019-09-25,4.0,None,Remote,Low,Single system,None,Partial,None,SPIP before 3.1.11 and 3.2 before 3.2.5 allows authenticated visitors to modify any published content and execute other modifications in the database. This is related to ecrire/inc/meta.php and ecrire/inc/securiser_action.php.,,spip,https://git.spip.net/SPIP/spip/commit/3cbc758400323ab006c00ea78eacdb8f76aa5f66,,,,,,,
CVE-2017-17434,https://www.cvedetails.com/cve/CVE-2017-17434/,,,Bypass,2017-12-05,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The daemon in rsync 3.1.2, and 3.1.3-development before 2017-12-03, does not check for fnamecmp filenames in the daemon_filter_list data structure (in the recv_files function in receiver.c) and also does not apply the sanitize_paths protection mechanism to pathnames found in ""xname follows"" strings (in the read_ndx_and_attrs function in rsync.c), which allows remote attackers to bypass intended access restrictions.",,samba,https://git.samba.org/?p=rsync.git;a=commit;h=5509597decdbd7b91994210f700329d8a35e70a1,,,,,,,
CVE-2017-17434,https://www.cvedetails.com/cve/CVE-2017-17434/,,,Bypass,2017-12-05,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The daemon in rsync 3.1.2, and 3.1.3-development before 2017-12-03, does not check for fnamecmp filenames in the daemon_filter_list data structure (in the recv_files function in receiver.c) and also does not apply the sanitize_paths protection mechanism to pathnames found in ""xname follows"" strings (in the read_ndx_and_attrs function in rsync.c), which allows remote attackers to bypass intended access restrictions.",,samba,https://git.samba.org/?p=rsync.git;a=commit;h=70aeb5fddd1b2f8e143276f8d5a085db16c593b9,,,,,,,
CVE-2017-17433,https://www.cvedetails.com/cve/CVE-2017-17433/,CWE-862,,Bypass,2017-12-05,2019-10-02,4.3,None,Remote,Medium,Not required,None,Partial,None,"The recv_files function in receiver.c in the daemon in rsync 3.1.2, and 3.1.3-development before 2017-12-03, proceeds with certain file metadata updates before checking for a filename in the daemon_filter_list data structure, which allows remote attackers to bypass intended access restrictions.",,samba,https://git.samba.org/?p=rsync.git;a=commit;h=3e06d40029cfdce9d0f73d87cfd4edaf54be9c51,,,,,,,
CVE-2009-3736,https://www.cvedetails.com/cve/CVE-2009-3736/,,,+Priv,2009-11-29,2017-09-18,6.9,None,Local,Medium,Not required,Complete,Complete,Complete,"ltdl.c in libltdl in GNU Libtool 1.5.x, and 2.2.6 before 2.2.6b, as used in Ham Radio Control Libraries, Q, and possibly other products, attempts to open a .la file in the current working directory, which allows local users to gain privileges via a Trojan horse file.",,savannah,https://git.savannah.gnu.org/cgit/libtool.git/commit/?h=branch-1-5&id=29b48580df75f0c5baa2962548a4c101ec7ed7ec,,,,,,,
CVE-2018-20103,https://www.cvedetails.com/cve/CVE-2018-20103/,CWE-835,,,2018-12-12,2019-10-02,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in dns.c in HAProxy through 1.8.14. In the case of a compressed pointer, a crafted packet can trigger infinite recursion by making the pointer point to itself, or create a long chain of valid pointers resulting in stack exhaustion.",C,haproxy,https://git.haproxy.org/?p=haproxy.git;a=commit;h=58df5aea0a0c926b2238f65908f5e9f83d1cca25,58df5aea0a0c926b2238f65908f5e9f83d1cca25,adb222004120a3ab242d04469e08e44d8ae9c35b,"@@ -394,7 +394,7 @@ static inline unsigned short dns_response_get_query_id(unsigned char *resp)
  */
 int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                  unsigned char *name, char *destination, int dest_len,
-                 int *offset)
+                 int *offset, unsigned int depth)
 {
        int nb_bytes = 0, n = 0;
        int label_len;
@@ -408,8 +408,11 @@ int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                        if ((buffer + reader[1]) > reader)
                                goto err;
 
+                       if (depth++ > 100)
+                               goto err;
+
                        n = dns_read_name(buffer, bufend, buffer + reader[1],
-                                         dest, dest_len - nb_bytes, offset);
+                                         dest, dest_len - nb_bytes, offset, depth);
                        if (n == 0)
                                goto err;
 
@@ -695,7 +698,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                 * one query per response and the first one can't be compressed
                 * (using the 0x0c format) */
                offset = 0;
-               len = dns_read_name(resp, bufend, reader, dns_query->name, DNS_MAX_NAME_SIZE, &offset);
+               len = dns_read_name(resp, bufend, reader, dns_query->name, DNS_MAX_NAME_SIZE, &offset, 0);
 
                if (len == 0)
                        return DNS_RESP_INVALID;
@@ -732,7 +735,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                        return (DNS_RESP_INVALID);
 
                offset = 0;
-               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset);
+               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset, 0);
 
                if (len == 0) {
                        pool_free(dns_answer_item_pool, dns_answer_record);
@@ -829,7 +832,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                                }
 
                                offset = 0;
-                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset);
+                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset, 0);
                                if (len == 0) {
                                        pool_free(dns_answer_item_pool, dns_answer_record);
                                        return DNS_RESP_INVALID;
@@ -859,7 +862,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                                dns_answer_record->port = read_n16(reader);
                                reader += sizeof(uint16_t);
                                offset = 0;
-                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset);
+                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset, 0);
                                if (len == 0) {
                                        pool_free(dns_answer_item_pool, dns_answer_record);
                                        return DNS_RESP_INVALID;",https://git.haproxy.org/?p=haproxy.git;a=blob;f=src/dns.c;h=2a53c038c377d394371f7f7b535c2a0b236232c4;hb=2a53c038c377d394371f7f7b535c2a0b236232c4,https://git.haproxy.org/?p=haproxy.git;a=blob;f=src/dns.c;h=50fc16e09f8dc915a70a7c24075d0ec8496af1d2;hb=50fc16e09f8dc915a70a7c24075d0ec8496af1d2,,
CVE-2018-20102,https://www.cvedetails.com/cve/CVE-2018-20102/,CWE-125,,,2018-12-12,2019-06-11,5.0,None,Remote,Low,Not required,Partial,None,None,"An out-of-bounds read in dns_validate_dns_response in dns.c was discovered in HAProxy through 1.8.14. Due to a missing check when validating DNS responses, remote attackers might be able read the 16 bytes corresponding to an AAAA record from the non-initialized part of the buffer, possibly accessing anything that was left on the stack, or even past the end of the 8193-byte buffer, depending on the value of accepted_payload_size.",,haproxy,https://git.haproxy.org/?p=haproxy.git;a=commit;h=efbbdf72992cd20458259962346044cafd9331c0,,,,,,,
CVE-2015-6806,https://www.cvedetails.com/cve/CVE-2015-6806/,CWE-119,,DoS Overflow,2015-09-28,2019-06-02,5.0,None,Remote,Low,Not required,None,None,Partial,"The MScrollV function in ansi.c in GNU screen 4.3.1 and earlier does not properly limit recursion, which allows remote attackers to cause a denial of service (stack consumption) via an escape sequence with a large repeat count value.",,savannah,https://git.savannah.gnu.org/cgit/screen.git/commit/?id=b7484c224738247b510ed0d268cd577076958f1b,,,,,,,
CVE-2017-16896,https://www.cvedetails.com/cve/CVE-2017-16896/,CWE-89,,Sql,2017-11-20,2017-12-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,A SQL injection in classes/handler/public.php in the forgotpass component of Tiny Tiny RSS 17.4 exists via the login parameter.,,tt-rss,https://git.tt-rss.org/git/tt-rss/commit/2352c320c2ed34ec7df1ad22f0c55a1b26489815,,,,,,,
CVE-2009-3607,https://www.cvedetails.com/cve/CVE-2009-3607/,CWE-189,,DoS Exec Code Overflow Mem. Corr.,2009-10-21,2017-08-16,9.3,Admin,Remote,Medium,Not required,Complete,Complete,Complete,Integer overflow in the create_surface_from_thumbnail_data function in glib/poppler-page.cc in Poppler 0.x allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.  NOTE: some of these details are obtained from third party information.,CPP,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=c839b706,c839b706092583f6b12ed3cc634bf5af34b7a2bb,44462e0ca39392e5629020226b901e4026089b46,"@@ -609,28 +609,28 @@ create_surface_from_thumbnail_data (guchar *data,
 				    gint    rowstride)
 {
   guchar *cairo_pixels;
+  gint cairo_stride;
   cairo_surface_t *surface;
-  static cairo_user_data_key_t key;
   int j;
 
-  cairo_pixels = (guchar *)g_malloc (4 * width * height);
-  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,
-						 CAIRO_FORMAT_RGB24,
-						 width, height, 4 * width);
-  cairo_surface_set_user_data (surface, &key,
-			       cairo_pixels, (cairo_destroy_func_t)g_free);
+  surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, width, height);
+  if (cairo_surface_status (surface))
+    return NULL;
+
+  cairo_pixels = cairo_image_surface_get_data (surface);
+  cairo_stride = cairo_image_surface_get_stride (surface);
 
   for (j = height; j; j--) {
     guchar *p = data;
     guchar *q = cairo_pixels;
     guchar *end = p + 3 * width;
-	  
+
     while (p < end) {
 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
       q[0] = p[2];
       q[1] = p[1];
       q[2] = p[0];
-#else	  
+#else
       q[1] = p[0];
       q[2] = p[1];
       q[3] = p[2];
@@ -640,7 +640,7 @@ create_surface_from_thumbnail_data (guchar *data,
     }
 
     data += rowstride;
-    cairo_pixels += 4 * width;
+    cairo_pixels += cairo_stride;
   }
 
   return surface;",https://cgit.freedesktop.org/poppler/poppler/tree/glib/poppler-page.cc?id=44462e0ca39392e5629020226b901e4026089b46,https://cgit.freedesktop.org/poppler/poppler/tree/glib/poppler-page.cc?id=c839b706092583f6b12ed3cc634bf5af34b7a2bb,,
CVE-2009-3605,https://www.cvedetails.com/cve/CVE-2009-3605/,CWE-189,,DoS Exec Code Overflow,2009-11-02,2017-09-18,6.8,User,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=284a92899602daa4a7f429e61849e794569310b5,,,,,,,
CVE-2009-3605,https://www.cvedetails.com/cve/CVE-2009-3605/,CWE-189,,DoS Exec Code Overflow,2009-11-02,2017-09-18,6.8,User,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=7b2d314a61fd0e12f47c62996cb49ec0d1ba747a,,,,,,,
CVE-2009-3605,https://www.cvedetails.com/cve/CVE-2009-3605/,CWE-189,,DoS Exec Code Overflow,2009-11-02,2017-09-18,6.8,User,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb22f812b31858e519411f57747d39bd8,,,,,,,
CVE-2009-3604,https://www.cvedetails.com/cve/CVE-2009-3604/,CWE-399,,DoS Exec Code Overflow,2009-10-21,2017-09-18,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"The Splash::drawImage function in Splash.cc in Xpdf 2.x and 3.x before 3.02pl4, and Poppler 0.x, as used in GPdf and kdegraphics KPDF, does not properly allocate memory, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF document that triggers a NULL pointer dereference or a heap-based buffer overflow.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb2,,,,,,,
CVE-2017-16853,https://www.cvedetails.com/cve/CVE-2017-16853/,CWE-347,,,2017-11-16,2018-02-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The DynamicMetadataProvider class in saml/saml2/metadata/impl/DynamicMetadataProvider.cpp in OpenSAML-C in OpenSAML before 2.6.1 fails to properly configure itself with the MetadataFilter plugins and does not perform critical security checks such as signature verification, enforcement of validity periods, and other checks specific to deployments, aka CPPOST-105.",CPP,shibboleth,https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=commit;h=6182b0acf2df670e75423c2ed7afe6950ef11c9d,6182b0acf2df670e75423c2ed7afe6950ef11c9d,98724ab1055da940d15db628b63e3d06e0e34ba7,"@@ -79,7 +79,7 @@ namespace opensaml {
 };
 
 DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
-    : AbstractMetadataProvider(e),
+    : AbstractMetadataProvider(e), MetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
@@ -92,7 +92,7 @@ DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
-        Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
+        Category::getInstance(SAML_LOGCAT "".Metadata.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;",https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=blob;f=saml/saml2/metadata/impl/DynamicMetadataProvider.cpp;h=ae09b26e6adc3c812ef8b61e02ad35b48a8f77db;hb=ae09b26e6adc3c812ef8b61e02ad35b48a8f77db,https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=blob;f=saml/saml2/metadata/impl/DynamicMetadataProvider.cpp;h=af4e21c523fd2aacedab87157a8c45b6cde4c901;hb=af4e21c523fd2aacedab87157a8c45b6cde4c901,,
CVE-2017-16852,https://www.cvedetails.com/cve/CVE-2017-16852/,CWE-347,,,2017-11-16,2018-02-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"shibsp/metadata/DynamicMetadataProvider.cpp in the Dynamic MetadataProvider plugin in Shibboleth Service Provider before 2.6.1 fails to properly configure itself with the MetadataFilter plugins and does not perform critical security checks such as signature verification, enforcement of validity periods, and other checks specific to deployments, aka SSPCPP-763.",,shibboleth,https://git.shibboleth.net/view/?p=cpp-sp.git;a=commit;h=b66cceb0e992c351ad5e2c665229ede82f261b16,,,,,,,
CVE-2019-15938,https://www.cvedetails.com/cve/CVE-2019-15938/,CWE-119,,Overflow,2019-09-05,2019-09-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_req in fs/nfs.c because a length field is directly used for a memcpy.,C,pengutronix,https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208,574ce994016107ad8ab0f845a785f28d7eaa5208,84986ca024462058574432b5483f4bf9136c538d,"@@ -1023,6 +1023,10 @@ static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,
 	p = nfs_read_post_op_attr(p, NULL);
 
 	len = ntoh32(net_read_uint32(p)); /* new path length */
+
+	len = max_t(unsigned int, len,
+		    nfs_packet->len - sizeof(struct rpc_reply) - sizeof(uint32_t));
+
 	p++;
 
 	*target = xzalloc(len + 1);",https://git.pengutronix.de/cgit/barebox/tree/fs/nfs.c?h=next&id=84986ca024462058574432b5483f4bf9136c538d,https://git.pengutronix.de/cgit/barebox/tree/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208,,
CVE-2019-15937,https://www.cvedetails.com/cve/CVE-2019-15937/,CWE-119,,Overflow,2019-09-05,2019-09-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_reply in net/nfs.c because a length field is directly used for a memcpy.,,pengutronix,https://git.pengutronix.de/cgit/barebox/commit/net/nfs.c?h=next&id=84986ca024462058574432b5483f4bf9136c538d,,,,,,,
CVE-2019-15927,https://www.cvedetails.com/cve/CVE-2019-15927/,CWE-125,,,2019-09-04,2019-09-24,7.2,None,Local,Low,Not required,Complete,Complete,Complete,An issue was discovered in the Linux kernel before 4.20.2. An out-of-bounds access exists in the function build_audio_procunit in the file sound/usb/mixer.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f4351a199cc120ff9d59e06d02e8657d08e6cc46,,,,,,,
CVE-2019-15926,https://www.cvedetails.com/cve/CVE-2019-15926/,CWE-125,,,2019-09-04,2019-09-14,9.4,None,Remote,Low,Not required,Complete,None,Complete,An issue was discovered in the Linux kernel before 5.2.3. Out of bounds access exists in the functions ath6kl_wmi_pstream_timeout_event_rx and ath6kl_wmi_cac_event_rx in the file drivers/net/wireless/ath/ath6kl/wmi.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5d6751eaff672ea77642e74e92e6c0ac7f9709ab,,,,,,,
CVE-2019-15925,https://www.cvedetails.com/cve/CVE-2019-15925/,CWE-125,,,2019-09-04,2019-10-04,7.2,None,Local,Low,Not required,Complete,Complete,Complete,An issue was discovered in the Linux kernel before 5.2.3. An out of bounds access exists in the function hclge_tm_schd_mode_vnet_base_cfg in the file drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_tm.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=04f25edb48c441fc278ecc154c270f16966cbb90,,,,,,,
CVE-2019-15916,https://www.cvedetails.com/cve/CVE-2019-15916/,CWE-119,,DoS Overflow,2019-09-04,2019-10-04,7.8,None,Remote,Low,Not required,None,None,Complete,"An issue was discovered in the Linux kernel before 5.0.1. There is a memory leak in register_queue_kobjects() in net/core/net-sysfs.c, which will cause denial of service.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=895a5e96dbd6386c8e78e5b78e067dcc67b7f0ab,,,,,,,
CVE-2017-16612,https://www.cvedetails.com/cve/CVE-2017-16612/,CWE-190,,Overflow,2017-12-01,2018-04-10,5.0,None,Remote,Low,Not required,None,None,Partial,"libXcursor before 1.1.15 has various integer overflows that could lead to heap buffer overflows when processing malicious cursors, e.g., with programs like GIMP. It is also possible that an attack vector exists against the related code in cursor/xcursor.c in Wayland through 1.14.0.",,wayland,https://cgit.freedesktop.org/wayland/wayland/commit/?id=5d201df72f3d4f4cb8b8f75f980169b03507da38,,,,,,,
CVE-2017-16612,https://www.cvedetails.com/cve/CVE-2017-16612/,CWE-190,,Overflow,2017-12-01,2018-04-10,5.0,None,Remote,Low,Not required,None,None,Partial,"libXcursor before 1.1.15 has various integer overflows that could lead to heap buffer overflows when processing malicious cursors, e.g., with programs like GIMP. It is also possible that an attack vector exists against the related code in cursor/xcursor.c in Wayland through 1.14.0.",,xcursor,https://cgit.freedesktop.org/xorg/lib/libXcursor/commit/?id=4794b5dd34688158fb51a2943032569d3780c4b8,,,,,,,
CVE-2017-16548,https://www.cvedetails.com/cve/CVE-2017-16548/,CWE-125,,DoS,2017-11-06,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The receive_xattr function in xattrs.c in rsync 3.1.2 and 3.1.3-development does not check for a trailing '\0' character in an xattr name, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact by sending crafted data to the daemon.",,samba,https://git.samba.org/rsync.git/?p=rsync.git;a=commit;h=47a63d90e71d3e19e0e96052bb8c6b9cb140ecc1,,,,,,,
CVE-2017-16544,https://www.cvedetails.com/cve/CVE-2017-16544/,CWE-94,,Exec Code,2017-11-20,2019-06-13,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"In the add_match function in libbb/lineedit.c in BusyBox through 1.27.2, the tab autocomplete feature of the shell, used to get a list of filenames in a directory, does not sanitize filenames and results in executing any escape sequence in the terminal. This could potentially result in code execution, arbitrary file writes, or other attacks.",C,busybox,https://git.busybox.net/busybox/commit/?id=c3797d40a1c57352192c6106cc0f435e7d9c11e8,c3797d40a1c57352192c6106cc0f435e7d9c11e8,a5060b8364faa7c677c8950f1315c451403b0660,"@@ -645,6 +645,18 @@ static void free_tab_completion_data(void)
 
 static void add_match(char *matched)
 {
+	unsigned char *p = (unsigned char*)matched;
+	while (*p) {
+		/* ESC attack fix: drop any string with control chars */
+		if (*p < ' '
+		 || (!ENABLE_UNICODE_SUPPORT && *p >= 0x7f)
+		 || (ENABLE_UNICODE_SUPPORT && *p == 0x7f)
+		) {
+			free(matched);
+			return;
+		}
+		p++;
+	}
 	matches = xrealloc_vector(matches, 4, num_matches);
 	matches[num_matches] = matched;
 	num_matches++;",https://git.busybox.net/busybox/tree/libbb/lineedit.c?id=a5060b8364faa7c677c8950f1315c451403b0660,https://git.busybox.net/busybox/tree/libbb/lineedit.c?id=c3797d40a1c57352192c6106cc0f435e7d9c11e8,,
CVE-2015-6496,https://www.cvedetails.com/cve/CVE-2015-6496/,CWE-17,,DoS,2015-08-24,2018-05-22,5.0,None,Remote,Low,Not required,None,None,Partial,"conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",C,netfilter,https://git.netfilter.org/conntrack-tools/commit/?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,c392c159605956c7bd4a264ab4490e2b2704c0cd,20ddbf33277108da86c69bb78890fac09e055627,"@@ -105,14 +105,14 @@ static enum nf_conntrack_attr nat_type[] =
 	  ATTR_ORIG_NAT_SEQ_OFFSET_AFTER, ATTR_REPL_NAT_SEQ_CORRECTION_POS,
 	  ATTR_REPL_NAT_SEQ_OFFSET_BEFORE, ATTR_REPL_NAT_SEQ_OFFSET_AFTER };
 
+/* ICMP, UDP and TCP are always loaded with nf_conntrack_ipv4 */
 static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
@@ -122,12 +122,12 @@ static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
@@ -135,18 +135,22 @@ static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
 
 static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
+	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
+	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
+		return;
+
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);",https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=20ddbf33277108da86c69bb78890fac09e055627,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,,
CVE-2019-15807,https://www.cvedetails.com/cve/CVE-2019-15807/,CWE-399,,DoS,2019-08-29,2019-09-14,7.8,None,Remote,Low,Not required,None,None,Complete,"In the Linux kernel before 5.1.13, there is a memory leak in drivers/scsi/libsas/sas_expander.c when SAS expander discovery fails. This will cause a BUG and denial of service.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3b0541791453fbe7f42867e310e0c9eb6295364d,,,,,,,
CVE-2018-19489,https://www.cvedetails.com/cve/CVE-2018-19489/,CWE-362,,DoS,2018-12-13,2019-05-31,2.1,None,Local,Low,Not required,None,None,Partial,v9fs_wstat in hw/9pfs/9p.c in QEMU allows guest OS users to cause a denial of service (crash) because of a race condition during file renaming.,C,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8,1d20398694a3b67a388d955b7a945ba4aa90a8a8,5298f4d67a911dd9cefa4c4185eed242074d64c2,"@@ -2855,6 +2855,7 @@ static void coroutine_fn v9fs_wstat(void *opaque)
     struct stat stbuf;
     V9fsFidState *fidp;
     V9fsPDU *pdu = opaque;
+    V9fsState *s = pdu->s;
 
     v9fs_stat_init(&v9stat);
     err = pdu_unmarshal(pdu, offset, ""dwS"", &fid, &unused, &v9stat);
@@ -2920,7 +2921,9 @@ static void coroutine_fn v9fs_wstat(void *opaque)
         }
     }
     if (v9stat.name.size != 0) {
+        v9fs_path_write_lock(s);
         err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
+        v9fs_path_unlock(s);
         if (err < 0) {
             goto out;
         }",https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=267a25533b775b7e9a95c7bbd44a17914842e3cf;hb=267a25533b775b7e9a95c7bbd44a17914842e3cf,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=bdf7919abfc517ae90b41c66d965137f1c7ee510;hb=bdf7919abfc517ae90b41c66d965137f1c7ee510,,
CVE-2018-19486,https://www.cvedetails.com/cve/CVE-2018-19486/,CWE-426,,Exec Code,2018-11-23,2019-04-10,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Git before 2.19.2 on Linux and UNIX executes commands from the current working directory (as if '.' were at the end of $PATH) in certain cases involving the run_command() API and run-command.c, because there was a dangerous change from execvp to execv during 2017.",,linux kernel,https://git.kernel.org/pub/scm/git/git.git/commit/?id=321fd82389742398d2924640ce3a61791fd27d60,,,,,,,
CVE-2018-19477,https://www.cvedetails.com/cve/CVE-2018-19477/,CWE-704,,Bypass,2018-11-23,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,psi/zfjbig2.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a JBIG2Decode type confusion.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=ef252e7dc214bcbd9a2539216aab9202848602bb,,,,,,,
CVE-2018-19476,https://www.cvedetails.com/cve/CVE-2018-19476/,CWE-704,,Bypass,2018-11-23,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=67d760ab775dae4efe803b5944b0439aa3c0b04a,,,,,,,
CVE-2018-19475,https://www.cvedetails.com/cve/CVE-2018-19475/,,,Bypass,2018-11-23,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,psi/zdevice2.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because available stack space is not checked when the device remains the same.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=aeea342904978c9fe17d85f4906a0f6fcce2d315,,,,,,,
CVE-2018-19475,https://www.cvedetails.com/cve/CVE-2018-19475/,,,Bypass,2018-11-23,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,psi/zdevice2.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because available stack space is not checked when the device remains the same.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3005fcb9bb160af199e761e03bc70a9f249a987e,,,,,,,
CVE-2018-19409,https://www.cvedetails.com/cve/CVE-2018-19409/,,,,2018-11-21,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,An issue was discovered in Artifex Ghostscript before 9.26. LockSafetyParams is not checked correctly if another device is used.,,ghostscript,https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=661e8d8fb8248c38d67958beda32f3a5876d0c3f,,,,,,,
CVE-2013-4942,https://www.cvedetails.com/cve/CVE-2013-4942/,CWE-79,,XSS,2013-07-29,2013-07-29,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in flashuploader.swf in the Uploader component in Yahoo! YUI 3.5.0 through 3.9.1, as used in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, 2.5.x before 2.5.1, and other products, allows remote attackers to inject arbitrary web script or HTML via a crafted string in a URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39678,,,,,,,
CVE-2013-4941,https://www.cvedetails.com/cve/CVE-2013-4941/,CWE-79,,XSS,2013-07-29,2013-07-29,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in uploader.swf in the Uploader component in Yahoo! YUI 3.2.0 through 3.9.1, as used in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, 2.5.x before 2.5.1, and other products, allows remote attackers to inject arbitrary web script or HTML via a crafted string in a URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39678,,,,,,,
CVE-2013-4940,https://www.cvedetails.com/cve/CVE-2013-4940/,CWE-79,,XSS,2013-07-29,2013-10-03,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in io.swf in the IO Utility component in Yahoo! YUI 3.10.2, as used in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, 2.5.x before 2.5.1, and other products, allows remote attackers to inject arbitrary web script or HTML via a crafted string in a URL.  NOTE: this vulnerability exists because of a CVE-2013-4939 regression.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39678,,,,,,,
CVE-2013-4939,https://www.cvedetails.com/cve/CVE-2013-4939/,CWE-79,,XSS,2013-07-29,2013-07-29,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in io.swf in the IO Utility component in Yahoo! YUI 3.0.0 through 3.9.1, as used in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, 2.5.x before 2.5.1, and other products, allows remote attackers to inject arbitrary web script or HTML via a crafted string in a URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39678,,,,,,,
CVE-2013-4938,https://www.cvedetails.com/cve/CVE-2013-4938/,CWE-264,,+Info,2013-07-29,2013-07-29,4.3,None,Remote,Medium,Not required,Partial,None,None,"The LTI (aka IMS-LTI) mod_form implementation in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, and 2.5.x before 2.5.1 does not properly support the sendname, sendemailaddr, and acceptgrades settings, which allows remote attackers to obtain sensitive information in opportunistic circumstances by leveraging an environment in which there was an ineffective attempt to enable the more secure values.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-40308,,,,,,,
CVE-2019-15666,https://www.cvedetails.com/cve/CVE-2019-15666/,CWE-125,,DoS,2019-08-27,2019-09-14,7.8,None,Remote,Low,Not required,None,None,Complete,"An issue was discovered in the Linux kernel before 5.0.19. There is an out-of-bounds array access in __xfrm_policy_unlink, which will cause denial of service, because verify_newpolicy_info in net/xfrm/xfrm_user.c mishandles directory validation.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b805d78d300bcf2c83d6df7da0c818b0fee41427,,,,,,,
CVE-2017-16227,https://www.cvedetails.com/cve/CVE-2017-16227/,CWE-20,,DoS,2017-10-29,2017-11-18,5.0,None,Remote,Low,Not required,None,None,Partial,"The aspath_put function in bgpd/bgp_aspath.c in Quagga before 1.2.2 allows remote attackers to cause a denial of service (session drop) via BGP UPDATE messages, because AS_PATH size calculation for long paths counts certain bytes twice and consequently constructs an invalid message.",,savannah,https://git.savannah.gnu.org/cgit/quagga.git/commit/?id=7a42b78be9a4108d98833069a88e6fddb9285008,,,,,,,
CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,,Bypass,2017-10-29,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",,samba,https://git.samba.org/?p=rsync.git;a=commit;h=c252546ceeb0925eb8a4061315e3ff0a8c55b48b,,,,,,,
CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,,Bypass,2017-10-29,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",,samba,https://git.samba.org/?p=rsync.git;a=commit;h=9a480deec4d20277d8e20bc55515ef0640ca1e55 ,,,,,,,
CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,,Bypass,2017-10-29,2019-10-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",,samba,https://git.samba.org/?p=rsync.git;a=commit;h=7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,,,,,,,
CVE-2018-19134,https://www.cvedetails.com/cve/CVE-2018-19134/,CWE-704,,Exec Code,2018-12-20,2019-01-11,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=693baf02152119af6e6afd30bb8ec76d14f84bbf,,,,,,,
CVE-2019-15505,https://www.cvedetails.com/cve/CVE-2019-15505/,CWE-125,,,2019-08-23,2019-09-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,drivers/media/usb/dvb-usb/technisat-usb2.c in the Linux kernel through 5.2.9 has an out-of-bounds read via crafted USB device traffic (which may be remote via usbip or usbredir).,C,linuxtv,https://git.linuxtv.org/media_tree.git/commit/?id=0c4df39e504bf925ab666132ac3c98d6cbbe380b,0c4df39e504bf925ab666132ac3c98d6cbbe380b,5dd4b89dc098bf22cd13e82a308f42a02c102b2b,"@@ -608,10 +608,9 @@ static int technisat_usb2_frontend_attach(struct dvb_usb_adapter *a)
 static int technisat_usb2_get_ir(struct dvb_usb_device *d)
 {
 	struct technisat_usb2_state *state = d->priv;
-	u8 *buf = state->buf;
-	u8 *b;
-	int ret;
 	struct ir_raw_event ev;
+	u8 *buf = state->buf;
+	int i, ret;
 
 	buf[0] = GET_IR_DATA_VENDOR_REQUEST;
 	buf[1] = 0x08;
@@ -647,26 +646,25 @@ unlock:
 		return 0; /* no key pressed */
 
 	/* decoding */
-	b = buf+1;
 
 #if 0
 	deb_rc(""RC: %d "", ret);
-	debug_dump(b, ret, deb_rc);
+	debug_dump(buf + 1, ret, deb_rc);
 #endif
 
 	ev.pulse = 0;
-	while (1) {
-		ev.pulse = !ev.pulse;
-		ev.duration = (*b * FIRMWARE_CLOCK_DIVISOR * FIRMWARE_CLOCK_TICK) / 1000;
-		ir_raw_event_store(d->rc_dev, &ev);
-
-		b++;
-		if (*b == 0xff) {
+	for (i = 1; i < ARRAY_SIZE(state->buf); i++) {
+		if (buf[i] == 0xff) {
 			ev.pulse = 0;
 			ev.duration = 888888*2;
 			ir_raw_event_store(d->rc_dev, &ev);
 			break;
 		}
+
+		ev.pulse = !ev.pulse;
+		ev.duration = (buf[i] * FIRMWARE_CLOCK_DIVISOR *
+			       FIRMWARE_CLOCK_TICK) / 1000;
+		ir_raw_event_store(d->rc_dev, &ev);
 	}
 
 	ir_raw_event_handle(d->rc_dev);",https://git.linuxtv.org/media_tree.git/tree/drivers/media/usb/dvb-usb/technisat-usb2.c?id=5dd4b89dc098bf22cd13e82a308f42a02c102b2b,https://git.linuxtv.org/media_tree.git/tree/drivers/media/usb/dvb-usb/technisat-usb2.c?id=0c4df39e504bf925ab666132ac3c98d6cbbe380b,,
CVE-2017-15923,https://www.cvedetails.com/cve/CVE-2017-15923/,,,DoS,2017-11-15,2019-10-02,5.0,None,Remote,Low,Not required,None,None,Partial,"Konversation 1.4.x, 1.5.x, 1.6.x, and 1.7.x before 1.7.3 allow remote attackers to cause a denial of service (crash) via vectors related to parsing of IRC color formatting codes.",,kde,https://cgit.kde.org/konversation.git/commit/?h=1.7&id=6a7f59ee1b9dbc6e5cf9e5f3b306504d02b73ef0,,,,,,,
CVE-2017-15873,https://www.cvedetails.com/cve/CVE-2017-15873/,CWE-190,,Overflow,2017-10-24,2019-04-03,4.3,None,Remote,Medium,Not required,None,None,Partial,The get_next_block function in archival/libarchive/decompress_bunzip2.c in BusyBox 1.27.2 has an Integer Overflow that may lead to a write access violation.,,busybox,https://git.busybox.net/busybox/commit/?id=0402cb32df015d9372578e3db27db47b33d5c7b0,,,,,,,
CVE-2011-2895,https://www.cvedetails.com/cve/CVE-2011-2895/,CWE-119,,Exec Code Overflow,2011-08-19,2017-08-28,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"The LZW decompressor in (1) the BufCompressedFill function in fontfile/decompress.c in X.Org libXfont before 1.4.4 and (2) compress/compress.c in 4.3BSD, as used in zopen.c in OpenBSD before 3.8, FreeBSD, NetBSD 4.0.x and 5.0.x before 5.0.3 and 5.1.x before 5.1.1, FreeType 2.1.9, and other products, does not properly handle code words that are absent from the decompression table when encountered, which allows context-dependent attackers to trigger an infinite loop or a heap-based buffer overflow, and possibly execute arbitrary code, via a crafted compressed stream, a related issue to CVE-2006-1168 and CVE-2011-2896.",,libxfont,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0,,,,,,,
CVE-2019-15292,https://www.cvedetails.com/cve/CVE-2019-15292/,CWE-416,,,2019-08-21,2019-09-02,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"An issue was discovered in the Linux kernel before 5.0.9. There is a use-after-free in atalk_proc_exit, related to net/appletalk/atalk_proc.c, net/appletalk/ddp.c, and net/appletalk/sysctl_net_atalk.c.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6377f787aeb945cae7abbb6474798de129e1f3ac,,,,,,,
CVE-2019-15239,https://www.cvedetails.com/cve/CVE-2019-15239/,CWE-416,,,2019-08-20,2019-09-24,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"In the Linux kernel, a certain net/ipv4/tcp_output.c change, which was properly incorporated into 4.16.12, was incorrectly backported to the earlier longterm kernels, introducing a new vulnerability that was potentially more severe than the issue that was intended to be fixed by backporting. Specifically, by adding to a write queue between disconnection and re-connection, a local attacker can trigger multiple use-after-free conditions. This can result in a kernel crash, or potentially in privilege escalation. NOTE: this affects (for example) Linux distributions that use 4.9.x longterm kernels before 4.9.190 or 4.14.x longterm kernels before 4.14.139.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7f582b248d0a86bae5788c548d7bb5bca6f7691a,,,,,,,
CVE-2019-15223,https://www.cvedetails.com/cve/CVE-2019-15223/,CWE-476,,,2019-08-19,2019-09-05,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/driver.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0b074ab7fc0d575247b9cc9f93bb7e007ca38840,,,,,,,
CVE-2019-15222,https://www.cvedetails.com/cve/CVE-2019-15222/,CWE-476,,,2019-08-19,2019-09-05,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.2.8. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/helper.c (motu_microbookii) driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5d78e1c2b7f4be00bbe62141603a631dc7812f35,,,,,,,
CVE-2019-15221,https://www.cvedetails.com/cve/CVE-2019-15221/,CWE-476,,,2019-08-19,2019-09-02,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.1.17. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/pcm.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3450121997ce872eb7f1248417225827ea249710,,,,,,,
CVE-2019-15220,https://www.cvedetails.com/cve/CVE-2019-15220/,CWE-416,,,2019-08-19,2019-09-02,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.2.1. There is a use-after-free caused by a malicious USB device in the drivers/net/wireless/intersil/p54/p54usb.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e41e2257f1094acc37618bf6c856115374c6922,,,,,,,
CVE-2019-15219,https://www.cvedetails.com/cve/CVE-2019-15219/,CWE-476,,,2019-08-19,2019-08-22,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the drivers/usb/misc/sisusbvga/sisusb.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9a5729f68d3a82786aea110b1bfe610be318f80a,,,,,,,
CVE-2019-15218,https://www.cvedetails.com/cve/CVE-2019-15218/,CWE-476,,,2019-08-19,2019-08-22,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the drivers/media/usb/siano/smsusb.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=31e0456de5be379b10fea0fa94a681057114a96e,,,,,,,
CVE-2019-15217,https://www.cvedetails.com/cve/CVE-2019-15217/,CWE-476,,,2019-08-19,2019-09-05,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.2.3. There is a NULL pointer dereference caused by a malicious USB device in the drivers/media/usb/zr364xx/zr364xx.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5d2e73a5f80a5b5aff3caf1ec6d39b5b3f54b26e,,,,,,,
CVE-2019-15216,https://www.cvedetails.com/cve/CVE-2019-15216/,CWE-476,,,2019-08-19,2019-09-02,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.0.14. There is a NULL pointer dereference caused by a malicious USB device in the drivers/usb/misc/yurex.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ef61eb43ada6c1d6b94668f0f514e4c268093ff3,,,,,,,
CVE-2019-15215,https://www.cvedetails.com/cve/CVE-2019-15215/,CWE-416,,,2019-08-19,2019-09-02,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.2.6. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/cpia2/cpia2_usb.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eff73de2b1600ad8230692f00bc0ab49b166512a,,,,,,,
CVE-2019-15214,https://www.cvedetails.com/cve/CVE-2019-15214/,CWE-416,,,2019-08-19,2019-09-02,4.7,None,Local,Medium,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.0.10. There is a use-after-free in the sound subsystem because card disconnection causes certain data structures to be deleted too early. This is related to sound/core/init.c and sound/core/info.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8c2f870890fd28e023b0fcf49dcee333f2c8bad7,,,,,,,
CVE-2019-15214,https://www.cvedetails.com/cve/CVE-2019-15214/,CWE-416,,,2019-08-19,2019-09-02,4.7,None,Local,Medium,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.0.10. There is a use-after-free in the sound subsystem because card disconnection causes certain data structures to be deleted too early. This is related to sound/core/init.c and sound/core/info.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac,,,,,,,
CVE-2019-15213,https://www.cvedetails.com/cve/CVE-2019-15213/,CWE-416,,,2019-08-19,2019-09-05,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6cf97230cd5f36b7665099083272595c55d72be7,,,,,,,
CVE-2019-15212,https://www.cvedetails.com/cve/CVE-2019-15212/,CWE-415,,,2019-08-19,2019-09-02,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.1.8. There is a double-free caused by a malicious USB device in the drivers/usb/misc/rio500.c driver.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3864d33943b4a76c6e64616280e98d2410b1190f,,,,,,,
CVE-2019-15211,https://www.cvedetails.com/cve/CVE-2019-15211/,CWE-416,,,2019-08-19,2019-09-02,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 5.2.6. There is a use-after-free caused by a malicious USB device in the drivers/media/v4l2-core/v4l2-dev.c driver because drivers/media/radio/radio-raremono.c does not properly allocate memory.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c666355e60ddb4748ead3bdd983e3f7f2224aaf0,,,,,,,
CVE-2017-15650,https://www.cvedetails.com/cve/CVE-2017-15650/,CWE-119,,Overflow,2017-10-19,2017-11-08,5.0,None,Remote,Low,Not required,None,None,Partial,"musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query.",C,musl,https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395,45ca5d3fcb6f874bf5ba55d0e9651cef68515395,5b5eb527c5ed5ca2786bf82892a04ca3bdf33d31,"@@ -111,6 +111,7 @@ static int dns_parse_callback(void *c, int rr, const void *data, int len, const
 {
 	char tmp[256];
 	struct dpc_ctx *ctx = c;
+	if (ctx->cnt >= MAXADDRS) return -1;
 	switch (rr) {
 	case RR_A:
 		if (len != 4) return -1;",https://git.musl-libc.org/cgit/musl/tree/src/network/lookup_name.c?id=5b5eb527c5ed5ca2786bf82892a04ca3bdf33d31,https://git.musl-libc.org/cgit/musl/tree/src/network/lookup_name.c?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395,,
CVE-2013-4525,https://www.cvedetails.com/cve/CVE-2013-4525/,CWE-79,,XSS,2013-11-26,2013-11-27,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in mod/quiz/report/responses/responses_table.php in Moodle through 2.2.11, 2.3.x before 2.3.10, 2.4.x before 2.4.7, and 2.5.x before 2.5.3 allows remote authenticated users to inject arbitrary web script or HTML via an answer to a text-based quiz question.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-41820,,,,,,,
CVE-2013-4524,https://www.cvedetails.com/cve/CVE-2013-4524/,CWE-22,,Dir. Trav.,2013-11-26,2013-11-27,6.8,None,Remote,Low,Single system,Complete,None,None,"Directory traversal vulnerability in repository/filesystem/lib.php in Moodle through 2.2.11, 2.3.x before 2.3.10, 2.4.x before 2.4.7, and 2.5.x before 2.5.3 allows remote authenticated users to read arbitrary files via a .. (dot dot) in a path.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-41807,,,,,,,
CVE-2013-4523,https://www.cvedetails.com/cve/CVE-2013-4523/,CWE-79,,XSS,2013-11-26,2013-11-27,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in message/lib.php in Moodle through 2.2.11, 2.3.x before 2.3.10, 2.4.x before 2.4.7, and 2.5.x before 2.5.3 allows remote authenticated users to inject arbitrary web script or HTML via a crafted message.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-41941,,,,,,,
CVE-2013-4522,https://www.cvedetails.com/cve/CVE-2013-4522/,CWE-200,,+Info,2013-11-26,2013-11-27,5.0,None,Remote,Low,Not required,Partial,None,None,"lib/filelib.php in Moodle through 2.2.11, 2.3.x before 2.3.10, 2.4.x before 2.4.7, and 2.5.x before 2.5.3 does not send ""Cache-Control: private"" HTTP headers, which allows remote attackers to obtain sensitive information by requesting a file that had been previously retrieved by a caching proxy server.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-38743,,,,,,,
CVE-2019-15118,https://www.cvedetails.com/cve/CVE-2019-15118/,CWE-400,,,2019-08-16,2019-09-05,4.9,None,Local,Low,Not required,None,None,Complete,"check_input_term in sound/usb/mixer.c in the Linux kernel through 5.2.9 mishandles recursion, leading to kernel stack exhaustion.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git/commit/?id=19bce474c45be69a284ecee660aa12d8f1e88f18,,,,,,,
CVE-2019-15117,https://www.cvedetails.com/cve/CVE-2019-15117/,CWE-119,,Overflow,2019-08-16,2019-09-05,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"parse_audio_mixer_unit in sound/usb/mixer.c in the Linux kernel through 5.2.9 mishandles a short descriptor, leading to out-of-bounds memory access.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git/commit/?id=daac07156b330b18eb5071aec4b3ddca1c377f2c,,,,,,,
CVE-2013-4474,https://www.cvedetails.com/cve/CVE-2013-4474/,CWE-20,,DoS,2013-11-23,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,Format string vulnerability in the extractPages function in utils/pdfseparate.cc in poppler before 0.24.3 allows remote attackers to cause a denial of service (crash) via format string specifiers in a destination filename.,,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=61f79b8447c3ac8ab5a26e79e0c28053ffdccf75,,,,,,,
CVE-2013-4473,https://www.cvedetails.com/cve/CVE-2013-4473/,CWE-119,,DoS Exec Code Overflow,2013-11-23,2016-05-18,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Stack-based buffer overflow in the extractPages function in utils/pdfseparate.cc in poppler before 0.24.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a source filename.,,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/utils/pdfseparate.cc?id=b8682d868ddf7f741e93b,,,,,,,
CVE-2007-4849,https://www.cvedetails.com/cve/CVE-2007-4849/,CWE-264,,,2007-09-12,2008-09-05,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"JFFS2, as used on One Laptop Per Child (OLPC) build 542 and possibly other Linux systems, when POSIX ACL support is enabled, does not properly store permissions during (1) inode creation or (2) ACL setting, which might allow local users to access restricted files or directories after a remount of a filesystem, related to ""legacy modes"" and an inconsistency between dentry permissions and inode permissions.",C,infradead,http://git.infradead.org/?p=mtd-2.6.git;a=commitdiff;h=9ed437c50d89eabae763dd422579f73fdebf288d,9ed437c50d89eabae763dd422579f73fdebf288d,09b3fba562ce366312b90a6f71d0b727b4d93ba9,"@@ -176,7 +176,7 @@ static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct
        spin_unlock(&inode->i_lock);
 }
 
-static struct posix_acl *jffs2_get_acl(struct inode *inode, int type)
+struct posix_acl *jffs2_get_acl(struct inode *inode, int type)
 {
        struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
        struct posix_acl *acl;
@@ -247,8 +247,13 @@ static int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)
                        if (rc < 0)
                                return rc;
                        if (inode->i_mode != mode) {
-                               inode->i_mode = mode;
-                               jffs2_dirty_inode(inode);
+                               struct iattr attr;
+
+                               attr.ia_valid = ATTR_MODE;
+                               attr.ia_mode = mode;
+                               rc = jffs2_do_setattr(inode, &attr);
+                               if (rc < 0)
+                                       return rc;
                        }
                        if (rc == 0)
                                acl = NULL;
@@ -307,22 +312,16 @@ int jffs2_permission(struct inode *inode, int mask, struct nameidata *nd)
        return generic_permission(inode, mask, jffs2_check_acl);
 }
 
-int jffs2_init_acl(struct inode *inode, struct inode *dir)
+int jffs2_init_acl(struct inode *inode, struct posix_acl *acl)
 {
        struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-       struct posix_acl *acl = NULL, *clone;
+       struct posix_acl *clone;
        mode_t mode;
        int rc = 0;
 
        f->i_acl_access = JFFS2_ACL_NOT_CACHED;
        f->i_acl_default = JFFS2_ACL_NOT_CACHED;
-       if (!S_ISLNK(inode->i_mode)) {
-               acl = jffs2_get_acl(dir, ACL_TYPE_DEFAULT);
-               if (IS_ERR(acl))
-                       return PTR_ERR(acl);
-               if (!acl)
-                       inode->i_mode &= ~current->fs->umask;
-       }
+
        if (acl) {
                if (S_ISDIR(inode->i_mode)) {
                        rc = jffs2_set_acl(inode, ACL_TYPE_DEFAULT, acl);",http://git.infradead.org/mtd-2.6.git/blob/65b3a1b5b88dd0fc009ee4fc425f65d1ceda803e?f=fs/jffs2/acl.c,http://git.infradead.org/mtd-2.6.git/blob/9ed437c50d89eabae763dd422579f73fdebf288d:/fs/jffs2/acl.c,,
CVE-2007-4849,https://www.cvedetails.com/cve/CVE-2007-4849/,CWE-264,,,2007-09-12,2008-09-05,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"JFFS2, as used on One Laptop Per Child (OLPC) build 542 and possibly other Linux systems, when POSIX ACL support is enabled, does not properly store permissions during (1) inode creation or (2) ACL setting, which might allow local users to access restricted files or directories after a remount of a filesystem, related to ""legacy modes"" and an inconsistency between dentry permissions and inode permissions.",H,infradead,http://git.infradead.org/?p=mtd-2.6.git;a=commitdiff;h=9ed437c50d89eabae763dd422579f73fdebf288d,9ed437c50d89eabae763dd422579f73fdebf288d,09b3fba562ce366312b90a6f71d0b727b4d93ba9,"@@ -28,9 +28,10 @@ struct jffs2_acl_header {
 
 #define JFFS2_ACL_NOT_CACHED ((void *)-1)
 
+extern struct posix_acl *jffs2_get_acl(struct inode *inode, int type);
 extern int jffs2_permission(struct inode *, int, struct nameidata *);
 extern int jffs2_acl_chmod(struct inode *);
-extern int jffs2_init_acl(struct inode *, struct inode *);
+extern int jffs2_init_acl(struct inode *, struct posix_acl *);
 extern void jffs2_clear_acl(struct jffs2_inode_info *);
 
 extern struct xattr_handler jffs2_acl_access_xattr_handler;
@@ -38,6 +39,7 @@ extern struct xattr_handler jffs2_acl_default_xattr_handler;
 
 #else
 
+#define jffs2_get_acl(inode, type)     (NULL)
 #define jffs2_permission NULL
 #define jffs2_acl_chmod(inode)         (0)
 #define jffs2_init_acl(inode,dir)      (0)",http://git.infradead.org/mtd-2.6.git/blob/c84378cee82ab44a8617bf77b58c7480f52fbaa1?f=fs/jffs2/acl.h,http://git.infradead.org/mtd-2.6.git/blob/9ed437c50d89eabae763dd422579f73fdebf288d:/fs/jffs2/acl.h,,
CVE-2007-4849,https://www.cvedetails.com/cve/CVE-2007-4849/,CWE-264,,,2007-09-12,2008-09-05,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"JFFS2, as used on One Laptop Per Child (OLPC) build 542 and possibly other Linux systems, when POSIX ACL support is enabled, does not properly store permissions during (1) inode creation or (2) ACL setting, which might allow local users to access restricted files or directories after a remount of a filesystem, related to ""legacy modes"" and an inconsistency between dentry permissions and inode permissions.",C,infradead,http://git.infradead.org/?p=mtd-2.6.git;a=commitdiff;h=9ed437c50d89eabae763dd422579f73fdebf288d,9ed437c50d89eabae763dd422579f73fdebf288d,09b3fba562ce366312b90a6f71d0b727b4d93ba9,"@@ -182,6 +182,7 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,
        struct jffs2_inode_info *f, *dir_f;
        struct jffs2_sb_info *c;
        struct inode *inode;
+       struct posix_acl *acl;
        int ret;
 
        ri = jffs2_alloc_raw_inode();
@@ -192,7 +193,7 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,
 
        D1(printk(KERN_DEBUG ""jffs2_create()\n""));
 
-       inode = jffs2_new_inode(dir_i, mode, ri);
+       inode = jffs2_new_inode(dir_i, mode, ri, &acl);
 
        if (IS_ERR(inode)) {
                D1(printk(KERN_DEBUG ""jffs2_new_inode() failed\n""));
@@ -212,12 +213,12 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,
                              dentry->d_name.name, dentry->d_name.len);
 
        if (ret)
-               goto fail;
+               goto fail_acl;
 
        ret = jffs2_init_security(inode, dir_i);
        if (ret)
-               goto fail;
-       ret = jffs2_init_acl(inode, dir_i);
+               goto fail_acl;
+       ret = jffs2_init_acl(inode, acl);
        if (ret)
                goto fail;
 
@@ -230,6 +231,8 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,
                  inode->i_ino, inode->i_mode, inode->i_nlink, f->inocache->nlink, inode->i_mapping->nrpages));
        return 0;
 
+ fail_acl:
+       posix_acl_release(acl);
  fail:
        make_bad_inode(inode);
        iput(inode);
@@ -306,6 +309,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char
        struct jffs2_full_dirent *fd;
        int namelen;
        uint32_t alloclen;
+       struct posix_acl *acl;
        int ret, targetlen = strlen(target);
 
        /* FIXME: If you care. We'd need to use frags for the target
@@ -332,7 +336,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char
                return ret;
        }
 
-       inode = jffs2_new_inode(dir_i, S_IFLNK | S_IRWXUGO, ri);
+       inode = jffs2_new_inode(dir_i, S_IFLNK | S_IRWXUGO, ri, &acl);
 
        if (IS_ERR(inode)) {
                jffs2_free_raw_inode(ri);
@@ -362,6 +366,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char
                up(&f->sem);
                jffs2_complete_reservation(c);
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return PTR_ERR(fn);
        }
 
@@ -372,6 +377,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char
                up(&f->sem);
                jffs2_complete_reservation(c);
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return -ENOMEM;
        }
 
@@ -389,9 +395,10 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char
        ret = jffs2_init_security(inode, dir_i);
        if (ret) {
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return ret;
        }
-       ret = jffs2_init_acl(inode, dir_i);
+       ret = jffs2_init_acl(inode, acl);
        if (ret) {
                jffs2_clear_inode(inode);
                return ret;
@@ -469,6 +476,7 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)
        struct jffs2_full_dirent *fd;
        int namelen;
        uint32_t alloclen;
+       struct posix_acl *acl;
        int ret;
 
        mode |= S_IFDIR;
@@ -491,7 +499,7 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)
                return ret;
        }
 
-       inode = jffs2_new_inode(dir_i, mode, ri);
+       inode = jffs2_new_inode(dir_i, mode, ri, &acl);
 
        if (IS_ERR(inode)) {
                jffs2_free_raw_inode(ri);
@@ -518,6 +526,7 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)
                up(&f->sem);
                jffs2_complete_reservation(c);
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return PTR_ERR(fn);
        }
        /* No data here. Only a metadata node, which will be
@@ -531,9 +540,10 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)
        ret = jffs2_init_security(inode, dir_i);
        if (ret) {
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return ret;
        }
-       ret = jffs2_init_acl(inode, dir_i);
+       ret = jffs2_init_acl(inode, acl);
        if (ret) {
                jffs2_clear_inode(inode);
                return ret;
@@ -629,6 +639,7 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de
        union jffs2_device_node dev;
        int devlen = 0;
        uint32_t alloclen;
+       struct posix_acl *acl;
        int ret;
 
        if (!new_valid_dev(rdev))
@@ -655,7 +666,7 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de
                return ret;
        }
 
-       inode = jffs2_new_inode(dir_i, mode, ri);
+       inode = jffs2_new_inode(dir_i, mode, ri, &acl);
 
        if (IS_ERR(inode)) {
                jffs2_free_raw_inode(ri);
@@ -684,6 +695,7 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de
                up(&f->sem);
                jffs2_complete_reservation(c);
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return PTR_ERR(fn);
        }
        /* No data here. Only a metadata node, which will be
@@ -697,9 +709,10 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de
        ret = jffs2_init_security(inode, dir_i);
        if (ret) {
                jffs2_clear_inode(inode);
+               posix_acl_release(acl);
                return ret;
        }
-       ret = jffs2_init_acl(inode, dir_i);
+       ret = jffs2_init_acl(inode, acl);
        if (ret) {
                jffs2_clear_inode(inode);
                return ret;",http://git.infradead.org/mtd-2.6.git/blob/d293a1fad6d63470f24d2e8b1a5d1b442c38344a?f=fs/jffs2/dir.c,http://git.infradead.org/mtd-2.6.git/blob/9ed437c50d89eabae763dd422579f73fdebf288d:/fs/jffs2/dir.c,,
CVE-2007-4849,https://www.cvedetails.com/cve/CVE-2007-4849/,CWE-264,,,2007-09-12,2008-09-05,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"JFFS2, as used on One Laptop Per Child (OLPC) build 542 and possibly other Linux systems, when POSIX ACL support is enabled, does not properly store permissions during (1) inode creation or (2) ACL setting, which might allow local users to access restricted files or directories after a remount of a filesystem, related to ""legacy modes"" and an inconsistency between dentry permissions and inode permissions.",C,infradead,http://git.infradead.org/?p=mtd-2.6.git;a=commitdiff;h=9ed437c50d89eabae763dd422579f73fdebf288d,9ed437c50d89eabae763dd422579f73fdebf288d,09b3fba562ce366312b90a6f71d0b727b4d93ba9,"@@ -24,7 +24,7 @@
 
 static int jffs2_flash_setup(struct jffs2_sb_info *c);
 
-static int jffs2_do_setattr (struct inode *inode, struct iattr *iattr)
+int jffs2_do_setattr (struct inode *inode, struct iattr *iattr)
 {
        struct jffs2_full_dnode *old_metadata, *new_metadata;
        struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
@@ -36,10 +36,8 @@ static int jffs2_do_setattr (struct inode *inode, struct iattr *iattr)
        unsigned int ivalid;
        uint32_t alloclen;
        int ret;
+
        D1(printk(KERN_DEBUG ""jffs2_setattr(): ino #%lu\n"", inode->i_ino));
-       ret = inode_change_ok(inode, iattr);
-       if (ret)
-               return ret;
 
        /* Special cases - we don't want more than one data node
           for these types on the medium at any time. So setattr
@@ -183,9 +181,14 @@ int jffs2_setattr(struct dentry *dentry, struct iattr *iattr)
 {
        int rc;
 
+       rc = inode_change_ok(dentry->d_inode, iattr);
+       if (rc)
+               return rc;
+
        rc = jffs2_do_setattr(dentry->d_inode, iattr);
        if (!rc && (iattr->ia_valid & ATTR_MODE))
                rc = jffs2_acl_chmod(dentry->d_inode);
+
        return rc;
 }
 
@@ -399,7 +402,8 @@ void jffs2_write_super (struct super_block *sb)
 
 /* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,
    fill in the raw_inode while you're at it. */
-struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri)
+struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri,
+                              struct posix_acl **acl)
 {
        struct inode *inode;
        struct super_block *sb = dir_i->i_sb;
@@ -431,7 +435,23 @@ struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_i
        } else {
                ri->gid = cpu_to_je16(current->fsgid);
        }
-       ri->mode =  cpu_to_jemode(mode);
+
+       /* POSIX ACLs have to be processed now, at least partly.
+          The umask is only applied if there's no default ACL */
+       if (!S_ISLNK(mode)) {
+               *acl = jffs2_get_acl(dir_i, ACL_TYPE_DEFAULT);
+               if (IS_ERR(*acl)) {
+                       make_bad_inode(inode);
+                       iput(inode);
+                       inode = (void *)*acl;
+                       *acl = NULL;
+                       return inode;
+               }
+               if (!(*acl))
+                       mode &= ~current->fs->umask;
+       } else {
+               *acl = NULL;
+       }
        ret = jffs2_do_new_inode (c, f, mode, ri);
        if (ret) {
                make_bad_inode(inode);",http://git.infradead.org/mtd-2.6.git/blob/1d3b7a9fc828e92dcab7923a8808673695ec2d72?f=fs/jffs2/fs.c,http://git.infradead.org/mtd-2.6.git/blob/9ed437c50d89eabae763dd422579f73fdebf288d:/fs/jffs2/fs.c,,
CVE-2007-4849,https://www.cvedetails.com/cve/CVE-2007-4849/,CWE-264,,,2007-09-12,2008-09-05,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"JFFS2, as used on One Laptop Per Child (OLPC) build 542 and possibly other Linux systems, when POSIX ACL support is enabled, does not properly store permissions during (1) inode creation or (2) ACL setting, which might allow local users to access restricted files or directories after a remount of a filesystem, related to ""legacy modes"" and an inconsistency between dentry permissions and inode permissions.",H,infradead,http://git.infradead.org/?p=mtd-2.6.git;a=commitdiff;h=9ed437c50d89eabae763dd422579f73fdebf288d,9ed437c50d89eabae763dd422579f73fdebf288d,09b3fba562ce366312b90a6f71d0b727b4d93ba9,"@@ -173,12 +173,15 @@ int jffs2_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
 extern const struct inode_operations jffs2_symlink_inode_operations;
 
 /* fs.c */
+struct posix_acl;
+
 int jffs2_setattr (struct dentry *, struct iattr *);
+int jffs2_do_setattr (struct inode *, struct iattr *);
 void jffs2_read_inode (struct inode *);
 void jffs2_clear_inode (struct inode *);
 void jffs2_dirty_inode(struct inode *inode);
 struct inode *jffs2_new_inode (struct inode *dir_i, int mode,
-                              struct jffs2_raw_inode *ri);
+                              struct jffs2_raw_inode *ri, struct posix_acl **acl);
 int jffs2_statfs (struct dentry *, struct kstatfs *);
 void jffs2_write_super (struct super_block *);
 int jffs2_remount_fs (struct super_block *, int *, char *);",http://git.infradead.org/mtd-2.6.git/blob/80daea96bbc29207ceae517787b1c670c47b6034?f=fs/jffs2/os-linux.h,http://git.infradead.org/mtd-2.6.git/blob/9ed437c50d89eabae763dd422579f73fdebf288d:/fs/jffs2/os-linux.h,,
CVE-2019-15031,https://www.cvedetails.com/cve/CVE-2019-15031/,CWE-200,,+Info,2019-09-13,2019-09-18,3.6,None,Local,Low,Not required,Partial,None,Partial,"In the Linux kernel through 5.2.14 on the powerpc platform, a local user can read vector registers of other users' processes via an interrupt. To exploit the venerability, a local user starts a transaction (via the hardware transactional memory instruction tbegin) and then accesses vector registers. At some point, the vector registers will be corrupted with the values from a different local Linux process, because MSR_TM_ACTIVE is misused in arch/powerpc/kernel/process.c.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a8318c13e79badb92bc6640704a64cc022a6eb97,,,,,,,
CVE-2019-15030,https://www.cvedetails.com/cve/CVE-2019-15030/,CWE-20,,,2019-09-13,2019-09-18,3.6,None,Local,Low,Not required,Partial,None,Partial,"In the Linux kernel through 5.2.14 on the powerpc platform, a local user can read vector registers of other users' processes via a Facility Unavailable exception. To exploit the venerability, a local user starts a transaction (via the hardware transactional memory instruction tbegin) and then accesses vector registers. At some point, the vector registers will be corrupted with the values from a different local Linux process because of a missing arch/powerpc/kernel/process.c check.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8205d5d98ef7f155de211f5e2eb6ca03d95a5a60,,,,,,,
CVE-2013-4391,https://www.cvedetails.com/cve/CVE-2013-4391/,CWE-189,,DoS Exec Code Overflow,2013-10-28,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.",,systemd,https://cgit.freedesktop.org/systemd/systemd/commit/?id=505b6a61c22d5565e9308045c7b9bf79f7d0517e,,,,,,,
CVE-2019-14975,https://www.cvedetails.com/cve/CVE-2019-14975/,CWE-125,,,2019-08-14,2019-08-26,5.8,None,Remote,Medium,Not required,Partial,None,Partial,Artifex MuPDF before 1.16.0 has a heap-based buffer over-read in fz_chartorune in fitz/string.c because pdf/pdf-op-filter.c does not check for a missing string.,,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commit;h=97096297d409ec6f206298444ba00719607e8ba8,,,,,,,
CVE-2013-4341,https://www.cvedetails.com/cve/CVE-2013-4341/,CWE-79,,XSS,2013-09-16,2013-09-25,4.3,None,Remote,Medium,Not required,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in Moodle through 2.2.11, 2.3.x before 2.3.9, 2.4.x before 2.4.6, and 2.5.x before 2.5.2 allow remote attackers to inject arbitrary web script or HTML via a crafted blog link within an RSS feed.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-41623,,,,,,,
CVE-2013-4313,https://www.cvedetails.com/cve/CVE-2013-4313/,CWE-89,,Sql,2013-09-16,2013-09-25,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Moodle through 2.2.11, 2.3.x before 2.3.9, 2.4.x before 2.4.6, and 2.5.x before 2.5.2 does not prevent use of '\0' characters in query strings, which might allow remote attackers to conduct SQL injection attacks against Microsoft SQL Server via a crafted string.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-40676,,,,,,,
CVE-2013-4282,https://www.cvedetails.com/cve/CVE-2013-4282/,CWE-119,,DoS Overflow,2013-11-02,2019-04-22,5.0,None,Remote,Low,Not required,None,None,Partial,Stack-based buffer overflow in the reds_handle_ticket function in server/reds.c in SPICE 0.12.0 allows remote attackers to cause a denial of service (crash) via a long password in a SPICE ticket.,,spice,https://cgit.freedesktop.org/spice/spice/commit/?id=8af619009660b24e0b41ad26b30289eea288fcc2,,,,,,,
CVE-2019-14817,https://www.cvedetails.com/cve/CVE-2019-14817/,CWE-264,,Exec Code Bypass,2019-09-03,2019-09-09,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"A flaw was found in, ghostscript versions prior to 9.28, in the .pdfexectoken and other procedures where it did not properly secure its privileged calls, enabling scripts to bypass `-dSAFER` restrictions. A specially crafted PostScript file could disable security protection and then have access to the file system, or execute arbitrary commands.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=cd1b1cacadac2479e291efe611979bdc1b3bdb19,,,,,,,
CVE-2019-14813,https://www.cvedetails.com/cve/CVE-2019-14813/,CWE-264,,Exec Code Bypass,2019-09-06,2019-09-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"A flaw was found in ghostscript, versions 9.x before 9.28, in the setsystemparams procedure where it did not properly secure its privileged calls, enabling scripts to bypass `-dSAFER` restrictions. A specially crafted PostScript file could disable security protection and then have access to the file system, or execute arbitrary commands.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=885444fcbe10dc42787ecb76686c8ee4dd33bf33,,,,,,,
CVE-2013-4248,https://www.cvedetails.com/cve/CVE-2013-4248/,CWE-20,,,2013-08-17,2016-11-28,4.3,None,Remote,Medium,Not required,None,Partial,None,"The openssl_x509_parse function in openssl.c in the OpenSSL module in PHP before 5.4.18 and 5.5.x before 5.5.2 does not properly handle a '\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",,php,https://git.php.net/?p=php-src.git;a=commit;h=2874696a5a8d46639d261571f915c493cd875897,,,,,,,
CVE-2011-2724,https://www.cvedetails.com/cve/CVE-2011-2724/,CWE-20,,DoS,2011-09-06,2018-10-30,1.2,None,Local,High,Not required,None,None,Partial,"The check_mtab function in client/mount.cifs.c in mount.cifs in smbfs in Samba 3.5.10 and earlier does not properly verify that the (1) device name and (2) mountpoint strings are composed of valid characters, which allows local users to cause a denial of service (mtab corruption) via a crafted string.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-0547.",,samba,https://git.samba.org/?p=cifs-utils.git;a=commit;h=1e7a32924b22d1f786b6f490ce8590656f578f91,,,,,,,
CVE-2013-4130,https://www.cvedetails.com/cve/CVE-2013-4130/,CWE-399,,DoS,2013-08-20,2014-01-23,5.0,None,Remote,Low,Not required,None,None,Partial,"The (1) red_channel_pipes_add_type and (2) red_channel_pipes_add_empty_msg functions in server/red_channel.c in SPICE before 0.12.4 do not properly perform ring loops, which might allow remote attackers to cause a denial of service (reachable assertion and server exit) by triggering a network error.",,spice,https://cgit.freedesktop.org/spice/spice/commit/?id=53488f0275d6c8a121af49f7ac817d09ce68090d,,,,,,,
CVE-2017-14976,https://www.cvedetails.com/cve/CVE-2017-14976/,CWE-125,,DoS,2017-10-01,2019-05-03,5.0,None,Remote,Low,Not required,None,None,Partial,"The FoFiType1C::convertToType0 function in FoFiType1C.cc in Poppler 0.59.0 has a heap-based buffer over-read vulnerability if an out-of-bounds font dictionary index is encountered, which allows an attacker to launch a denial of service attack.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=da63c35549e8852a410946ab016a3f25ac701bdf,,,,,,,
CVE-2013-4113,https://www.cvedetails.com/cve/CVE-2013-4113/,CWE-119,,DoS Overflow Mem. Corr.,2013-07-13,2014-03-05,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"ext/xml/xml.c in PHP before 5.3.27 does not properly consider parsing depth, which allows remote attackers to cause a denial of service (heap memory corruption) or possibly have unspecified other impact via a crafted document that is processed by the xml_parse_into_struct function.",,php,https://git.php.net/?p=php-src.git;a=commit;h=7d163e8a0880ae8af2dd869071393e5dc07ef271,,,,,,,
CVE-2011-2685,https://www.cvedetails.com/cve/CVE-2011-2685/,CWE-119,,Exec Code Overflow,2011-07-21,2012-01-18,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,Stack-based buffer overflow in the Lotus Word Pro import filter in LibreOffice before 3.3.3 allows remote attackers to execute arbitrary code via a crafted .lwp file.,,libreoffice,https://cgit.freedesktop.org/libreoffice/filters/commit/?id=d93fa011d713100775cd3ac88c468b6830d48877,,,,,,,
CVE-2011-2685,https://www.cvedetails.com/cve/CVE-2011-2685/,CWE-119,,Exec Code Overflow,2011-07-21,2012-01-18,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,Stack-based buffer overflow in the Lotus Word Pro import filter in LibreOffice before 3.3.3 allows remote attackers to execute arbitrary code via a crafted .lwp file.,,libreoffice,https://cgit.freedesktop.org/libreoffice/filters/commit/?id=278831e37a23e9e2e29ca811c3a5398b7c67464d,,,,,,,
CVE-2018-18281,https://www.cvedetails.com/cve/CVE-2018-18281/,CWE-20,,,2018-10-30,2019-04-23,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"Since Linux kernel version 3.2, the mremap() syscall performs TLB flushes after dropping pagetable locks. If a syscall such as ftruncate() removes entries from the pagetables of a task that is in the middle of mremap(), a stale TLB entry can remain for a short time that permits access to a physical page after it has been released back to the page allocator and reused. This is fixed in the following kernel versions: 4.9.135, 4.14.78, 4.18.16, 4.19.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eb66ae030829605d61fbef1909ce310e29f78821,,,,,,,
CVE-2015-5352,https://www.cvedetails.com/cve/CVE-2015-5352/,CWE-264,,Bypass,2015-08-02,2018-10-24,4.3,None,Remote,Medium,Not required,None,Partial,None,"The x11_open_helper function in channels.c in ssh in OpenSSH before 6.9, when ForwardX11Trusted mode is not used, lacks a check of the refusal deadline for X connections, which makes it easier for remote attackers to bypass intended access restrictions via a connection outside of the permitted time window.",C,mindrot,https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,1bf477d3cdf1a864646d59820878783d42357a1d,47aa7a0f8551b471fcae0447c1d78464f6dba869,"@@ -1,4 +1,4 @@
-/* $OpenBSD: channels.c,v 1.346 2015/06/30 05:25:07 djm Exp $ */
+/* $OpenBSD: channels.c,v 1.347 2015/07/01 02:26:31 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -161,6 +161,9 @@ static char *x11_saved_proto = NULL;
 static char *x11_saved_data = NULL;
 static u_int x11_saved_data_len = 0;
 
+/* Deadline after which all X11 connections are refused */
+static u_int x11_refuse_time;
+
 /*
  * Fake X11 authentication data.  This is what the server will be sending us;
  * we should replace any occurrences of this by the real data.
@@ -912,6 +915,13 @@ x11_open_helper(Buffer *b)
 	u_char *ucp;
 	u_int proto_len, data_len;
 
+	/* Is this being called after the refusal deadline? */
+	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
+		verbose(""Rejected X11 connection after ForwardX11Timeout ""
+		    ""expired"");
+		return -1;
+	}
+
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
@@ -1483,6 +1493,12 @@ channel_set_reuseaddr(int fd)
 		error(""setsockopt SO_REUSEADDR fd %d: %s"", fd, strerror(errno));
 }
 
+void
+channel_set_x11_refuse_time(u_int refuse_time)
+{
+	x11_refuse_time = refuse_time;
+}
+
 /*
  * This socket is listening for connections to a forwarded TCP/IP port.
  */",https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=47aa7a0f8551b471fcae0447c1d78464f6dba869,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,,
CVE-2015-5352,https://www.cvedetails.com/cve/CVE-2015-5352/,CWE-264,,Bypass,2015-08-02,2018-10-24,4.3,None,Remote,Medium,Not required,None,Partial,None,"The x11_open_helper function in channels.c in ssh in OpenSSH before 6.9, when ForwardX11Trusted mode is not used, lacks a check of the refusal deadline for X connections, which makes it easier for remote attackers to bypass intended access restrictions via a connection outside of the permitted time window.",H,mindrot,https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,1bf477d3cdf1a864646d59820878783d42357a1d,47aa7a0f8551b471fcae0447c1d78464f6dba869,"@@ -1,4 +1,4 @@
-/* $OpenBSD: channels.h,v 1.117 2015/05/08 06:45:13 djm Exp $ */
+/* $OpenBSD: channels.h,v 1.118 2015/07/01 02:26:31 djm Exp $ */
 
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
@@ -284,6 +284,7 @@ int	 permitopen_port(const char *);
 
 /* x11 forwarding */
 
+void	 channel_set_x11_refuse_time(u_int);
 int	 x11_connect_display(void);
 int	 x11_create_display_inet(int, int, int, u_int *, int **);
 int      x11_input_open(int, u_int32_t, void *);",https://anongit.mindrot.org/openssh.git/tree/channels.h?h=V_6_9&id=47aa7a0f8551b471fcae0447c1d78464f6dba869,https://anongit.mindrot.org/openssh.git/tree/channels.h?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,,
CVE-2015-5352,https://www.cvedetails.com/cve/CVE-2015-5352/,CWE-264,,Bypass,2015-08-02,2018-10-24,4.3,None,Remote,Medium,Not required,None,Partial,None,"The x11_open_helper function in channels.c in ssh in OpenSSH before 6.9, when ForwardX11Trusted mode is not used, lacks a check of the refusal deadline for X connections, which makes it easier for remote attackers to bypass intended access restrictions via a connection outside of the permitted time window.",C,mindrot,https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,1bf477d3cdf1a864646d59820878783d42357a1d,47aa7a0f8551b471fcae0447c1d78464f6dba869,"@@ -1,4 +1,4 @@
-/* $OpenBSD: clientloop.c,v 1.273 2015/05/04 06:10:48 djm Exp $ */
+/* $OpenBSD: clientloop.c,v 1.274 2015/07/01 02:26:31 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -163,7 +163,7 @@ static int connection_in;	/* Connection to server (input). */
 static int connection_out;	/* Connection to server (output). */
 static int need_rekeying;	/* Set to non-zero if rekeying is requested. */
 static int session_closed;	/* In SSH2: login session closed. */
-static int x11_refuse_time;	/* If >0, refuse x11 opens after this time. */
+static u_int x11_refuse_time;	/* If >0, refuse x11 opens after this time. */
 
 static void client_init_dispatch(void);
 int	session_ident = -1;
@@ -298,7 +298,8 @@ client_x11_display_valid(const char *display)
 	return 1;
 }
 
-#define SSH_X11_PROTO ""MIT-MAGIC-COOKIE-1""
+#define SSH_X11_PROTO		""MIT-MAGIC-COOKIE-1""
+#define X11_TIMEOUT_SLACK	60
 void
 client_x11_get_proto(const char *display, const char *xauth_path,
     u_int trusted, u_int timeout, char **_proto, char **_data)
@@ -311,7 +312,7 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 	int got_data = 0, generated = 0, do_unlink = 0, i;
 	char *xauthdir, *xauthfile;
 	struct stat st;
-	u_int now;
+	u_int now, x11_timeout_real;
 
 	xauthdir = xauthfile = NULL;
 	*_proto = proto;
@@ -344,6 +345,15 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 			xauthdir = xmalloc(PATH_MAX);
 			xauthfile = xmalloc(PATH_MAX);
 			mktemp_proto(xauthdir, PATH_MAX);
+			/*
+			 * The authentication cookie should briefly outlive
+			 * ssh's willingness to forward X11 connections to
+			 * avoid nasty fail-open behaviour in the X server.
+			 */
+			if (timeout >= UINT_MAX - X11_TIMEOUT_SLACK)
+				x11_timeout_real = UINT_MAX;
+			else
+				x11_timeout_real = timeout + X11_TIMEOUT_SLACK;
 			if (mkdtemp(xauthdir) != NULL) {
 				do_unlink = 1;
 				snprintf(xauthfile, PATH_MAX, ""%s/xauthfile"",
@@ -351,17 +361,20 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 				snprintf(cmd, sizeof(cmd),
 				    ""%s -f %s generate %s "" SSH_X11_PROTO
 				    "" untrusted timeout %u 2>"" _PATH_DEVNULL,
-				    xauth_path, xauthfile, display, timeout);
+				    xauth_path, xauthfile, display,
+				    x11_timeout_real);
 				debug2(""x11_get_proto: %s"", cmd);
-				if (system(cmd) == 0)
-					generated = 1;
 				if (x11_refuse_time == 0) {
 					now = monotime() + 1;
 					if (UINT_MAX - timeout < now)
 						x11_refuse_time = UINT_MAX;
 					else
 						x11_refuse_time = now + timeout;
+					channel_set_x11_refuse_time(
+					    x11_refuse_time);
 				}
+				if (system(cmd) == 0)
+					generated = 1;
 			}
 		}
 
@@ -1889,7 +1902,7 @@ client_request_x11(const char *request_type, int rchan)
 		    ""malicious server."");
 		return NULL;
 	}
-	if (x11_refuse_time != 0 && monotime() >= x11_refuse_time) {
+	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
 		verbose(""Rejected X11 connection after ForwardX11Timeout ""
 		    ""expired"");
 		return NULL;",https://anongit.mindrot.org/openssh.git/tree/clientloop.c?h=V_6_9&id=47aa7a0f8551b471fcae0447c1d78464f6dba869,https://anongit.mindrot.org/openssh.git/tree/clientloop.c?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,,
CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=538d305de91e34a2938f5f219f18bf0e1918763f,,,,,,,
CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=7f51ec8c4ed9ba1f53d722e44fb6fb3cde933b72 ,,,,,,,
CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=a118d4220ed85749c07fb43c1229d9e2fecbea6b,,,,,,,
CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=ba5dbda6d0174a59d221c45cca52ecd232820d48,,,,,,,
CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=f36cb71c330a52106e36028b3029d952257baf15,,,,,,,
CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=0454b95657846fcecf0f51b6f1194faac02518bd,,,,,,,
CVE-2018-18073,https://www.cvedetails.com/cve/CVE-2018-18073/,CWE-200,,Bypass +Info,2018-10-15,2018-12-18,4.3,None,Remote,Medium,Not required,Partial,None,None,Artifex Ghostscript allows attackers to bypass a sandbox protection mechanism by leveraging exposure of system operators in the saved execution stack in an error object.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=34cc326eb2c5695833361887fe0b32e8d987741c,,,,,,,
CVE-2015-5299,https://www.cvedetails.com/cve/CVE-2015-5299/,CWE-200,,+Info,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,Partial,None,None,"The shadow_copy2_get_shadow_copy_data function in modules/vfs_shadow_copy2.c in Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not verify that the DIRECTORY_LIST access right has been granted, which allows remote attackers to access snapshots by visiting a shadow copy directory.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=675fd8d771f9d43e354dba53ddd9b5483ae0a1d7,,,,,,,
CVE-2015-5296,https://www.cvedetails.com/cve/CVE-2015-5296/,CWE-20,,,2015-12-29,2018-10-30,4.3,None,Remote,Medium,Not required,None,Partial,None,"Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 supports connections that are encrypted but unsigned, which allows man-in-the-middle attackers to conduct encrypted-to-unencrypted downgrade attacks by modifying the client-server data stream, related to clidfs.c, libsmb_server.c, and smbXcli_base.c.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=a819d2b440aafa3138d95ff6e8b824da885a70e9,,,,,,,
CVE-2015-5296,https://www.cvedetails.com/cve/CVE-2015-5296/,CWE-20,,,2015-12-29,2018-10-30,4.3,None,Remote,Medium,Not required,None,Partial,None,"Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 supports connections that are encrypted but unsigned, which allows man-in-the-middle attackers to conduct encrypted-to-unencrypted downgrade attacks by modifying the client-server data stream, related to clidfs.c, libsmb_server.c, and smbXcli_base.c.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=d724f835acb9f4886c0001af32cd325dbbf1f895,,,,,,,
CVE-2015-5296,https://www.cvedetails.com/cve/CVE-2015-5296/,CWE-20,,,2015-12-29,2018-10-30,4.3,None,Remote,Medium,Not required,None,Partial,None,"Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 supports connections that are encrypted but unsigned, which allows man-in-the-middle attackers to conduct encrypted-to-unencrypted downgrade attacks by modifying the client-server data stream, related to clidfs.c, libsmb_server.c, and smbXcli_base.c.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=1ba49b8f389eda3414b14410c7fbcb4041ca06b1,,,,,,,
CVE-2015-5289,https://www.cvedetails.com/cve/CVE-2015-5289/,CWE-119,,DoS Overflow,2015-10-26,2017-06-30,6.4,None,Remote,Low,Not required,Partial,None,Partial,"Multiple stack-based buffer overflows in json parsing in PostgreSQL before 9.3.x before 9.3.10 and 9.4.x before 9.4.5 allow attackers to cause a denial of service (server crash) via unspecified vectors, which are not properly handled in (1) json or (2) jsonb values.",C,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=08fa47c4850cea32c3116665975bca219fbf2fe6,08fa47c4850cea32c3116665975bca219fbf2fe6,1d812c8b059d0b9b1fba4a459c9876de0f6259b6,"@@ -490,6 +490,8 @@ parse_object(JsonLexContext *lex, JsonSemAction *sem)
    json_struct_action oend = sem->object_end;
    JsonTokenType tok;
 
+   check_stack_depth();
+
    if (ostart != NULL)
        (*ostart) (sem->semstate);
 
@@ -568,6 +570,8 @@ parse_array(JsonLexContext *lex, JsonSemAction *sem)
    json_struct_action astart = sem->array_start;
    json_struct_action aend = sem->array_end;
 
+   check_stack_depth();
+
    if (astart != NULL)
        (*astart) (sem->semstate);
 
@@ -1433,6 +1437,8 @@ datum_to_json(Datum val, bool is_null, StringInfo result,
    char       *outputstr;
    text       *jsontext;
 
+   check_stack_depth();
+
    /* callers are expected to ensure that null keys are not passed in */
    Assert(!(key_scalar && is_null));
 ",https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/adt/json.c;h=eefe93bc8ab926fe6d69c1170e80f2c8f08d0190;hb=eefe93bc8ab926fe6d69c1170e80f2c8f08d0190,https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/adt/json.c;h=f394942bc359b73068c2bf3a2a514758ecf5c957;hb=f394942bc359b73068c2bf3a2a514758ecf5c957,,
CVE-2015-5289,https://www.cvedetails.com/cve/CVE-2015-5289/,CWE-119,,DoS Overflow,2015-10-26,2017-06-30,6.4,None,Remote,Low,Not required,Partial,None,Partial,"Multiple stack-based buffer overflows in json parsing in PostgreSQL before 9.3.x before 9.3.10 and 9.4.x before 9.4.5 allow attackers to cause a denial of service (server crash) via unspecified vectors, which are not properly handled in (1) json or (2) jsonb values.",C,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=08fa47c4850cea32c3116665975bca219fbf2fe6,08fa47c4850cea32c3116665975bca219fbf2fe6,1d812c8b059d0b9b1fba4a459c9876de0f6259b6,"@@ -712,6 +712,8 @@ datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,
    JsonbValue  jb;
    bool        scalar_jsonb = false;
 
+   check_stack_depth();
+
    if (is_null)
    {
        Assert(!key_scalar);",https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/adt/jsonb.c;h=f0f1651e9da557ebd99e30618ce68daedd1be575;hb=f0f1651e9da557ebd99e30618ce68daedd1be575,https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/adt/jsonb.c;h=8fef35ea38a53c94082b8e7ca4382707ccc758a9;hb=8fef35ea38a53c94082b8e7ca4382707ccc758a9,,
CVE-2015-5289,https://www.cvedetails.com/cve/CVE-2015-5289/,CWE-119,,DoS Overflow,2015-10-26,2017-06-30,6.4,None,Remote,Low,Not required,Partial,None,Partial,"Multiple stack-based buffer overflows in json parsing in PostgreSQL before 9.3.x before 9.3.10 and 9.4.x before 9.4.5 allow attackers to cause a denial of service (server crash) via unspecified vectors, which are not properly handled in (1) json or (2) jsonb values.",C,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=08fa47c4850cea32c3116665975bca219fbf2fe6,08fa47c4850cea32c3116665975bca219fbf2fe6,1d812c8b059d0b9b1fba4a459c9876de0f6259b6,"@@ -3724,6 +3724,8 @@ setPath(JsonbIterator **it, Datum *path_elems,
    JsonbValue *res = NULL;
    int         r;
 
+   check_stack_depth();
+
    if (path_nulls[level])
        elog(ERROR, ""path element at the position %d is NULL"", level + 1);",https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/adt/jsonfuncs.c;h=01b6bb0a483a7762d940aba1b67ff8c4b89a516b;hb=01b6bb0a483a7762d940aba1b67ff8c4b89a516b,https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/adt/jsonfuncs.c;h=f33864e619dca5f605aedbdb3e24d17bbb23b718;hb=f33864e619dca5f605aedbdb3e24d17bbb23b718,,
CVE-2015-5279,https://www.cvedetails.com/cve/CVE-2015-5279/,CWE-119,,DoS Exec Code Overflow,2015-09-28,2017-12-27,7.2,None,Local,Low,Not required,Complete,Complete,Complete,Heap-based buffer overflow in the ne2000_receive function in hw/net/ne2000.c in QEMU before 2.4.0.1 allows guest OS users to cause a denial of service (instance crash) or possibly execute arbitrary code via vectors related to receiving packets.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=7aa2bcad0ca837dd6d4bf4fa38a80314b4a6b755,,,,,,,
CVE-2018-17961,https://www.cvedetails.com/cve/CVE-2018-17961/,CWE-209,,Bypass,2018-10-15,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Artifex Ghostscript 9.25 and earlier allows attackers to bypass a sandbox protection mechanism via vectors involving errorhandler setup. NOTE: this issue exists because of an incomplete fix for CVE-2018-17183.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=a54c9e61e7d0,,,,,,,
CVE-2018-17961,https://www.cvedetails.com/cve/CVE-2018-17961/,CWE-209,,Bypass,2018-10-15,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Artifex Ghostscript 9.25 and earlier allows attackers to bypass a sandbox protection mechanism via vectors involving errorhandler setup. NOTE: this issue exists because of an incomplete fix for CVE-2018-17183.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=a5a9bf8c6a63,,,,,,,
CVE-2018-17961,https://www.cvedetails.com/cve/CVE-2018-17961/,CWE-209,,Bypass,2018-10-15,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Artifex Ghostscript 9.25 and earlier allows attackers to bypass a sandbox protection mechanism via vectors involving errorhandler setup. NOTE: this issue exists because of an incomplete fix for CVE-2018-17183.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=a6807394bd94,,,,,,,
CVE-2015-5252,https://www.cvedetails.com/cve/CVE-2015-5252/,CWE-264,,Bypass,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,Partial,None,"vfs.c in smbd in Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, when share names with certain substring relationships exist, allows remote attackers to bypass intended file-access restrictions via a symlink that points outside of a share.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=4278ef25f64d5fdbf432ff1534e275416ec9561e,,,,,,,
CVE-2017-14482,https://www.cvedetails.com/cve/CVE-2017-14482/,,,Exec Code,2017-09-14,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"GNU Emacs before 25.3 allows remote attackers to execute arbitrary code via email with crafted ""Content-Type: text/enriched"" data containing an x-display XML element that specifies execution of shell commands, related to an unsafe text/enriched extension in lisp/textmodes/enriched.el, and unsafe Gnus support for enriched and richtext inline MIME objects in lisp/gnus/mm-view.el. In particular, an Emacs user can be instantly compromised by reading a crafted email message (or Usenet news article).",,savannah,https://git.savannah.gnu.org/cgit/emacs.git/commit/?h=emacs-25&id=9ad0fcc54442a9a01d41be19880250783426db70,,,,,,,
CVE-2019-13638,https://www.cvedetails.com/cve/CVE-2019-13638/,CWE-78,,,2019-07-26,2019-08-16,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,GNU patch through 2.7.6 is vulnerable to OS shell command injection that can be exploited by opening a crafted patch file that contains an ed style diff payload with shell metacharacters. The ed editor does not need to be present on the vulnerable system. This is different from CVE-2018-1000156.,,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=3fcd042d26d70856e826a42b5f93dc4854d80bf0,,,,,,,
CVE-2019-13636,https://www.cvedetails.com/cve/CVE-2019-13636/,CWE-59,,,2019-07-17,2019-07-24,5.8,None,Remote,Medium,Not required,None,Partial,Partial,"In GNU patch through 2.7.6, the following of symlinks is mishandled in certain cases other than input files. This affects inp.c and util.c.",,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,,,,,,,
CVE-2011-2200,https://www.cvedetails.com/cve/CVE-2011-2200/,CWE-20,,DoS +Info,2011-06-22,2017-08-28,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"The _dbus_header_byteswap function in dbus-marshal-header.c in D-Bus (aka DBus) 1.2.x before 1.2.28, 1.4.x before 1.4.12, and 1.5.x before 1.5.4 does not properly handle a non-native byte order, which allows local users to cause a denial of service (connection loss), obtain potentially sensitive information, or conduct unspecified state-modification attacks via crafted messages.",,dbus,https://cgit.freedesktop.org/dbus/dbus/commit/?h=dbus-1.4&id=c3223ba6c401ba81df1305851312a47c485e6cd7,,,,,,,
CVE-2011-2200,https://www.cvedetails.com/cve/CVE-2011-2200/,CWE-20,,DoS +Info,2011-06-22,2017-08-28,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"The _dbus_header_byteswap function in dbus-marshal-header.c in D-Bus (aka DBus) 1.2.x before 1.2.28, 1.4.x before 1.4.12, and 1.5.x before 1.5.4 does not properly handle a non-native byte order, which allows local users to cause a denial of service (connection loss), obtain potentially sensitive information, or conduct unspecified state-modification attacks via crafted messages.",,dbus,https://cgit.freedesktop.org/dbus/dbus/commit/?h=dbus-1.2&id=6519a1f77c61d753d4c97efd6e15630eb275336e,,,,,,,
CVE-2017-14226,https://www.cvedetails.com/cve/CVE-2017-14226/,CWE-125,,DoS,2017-09-09,2019-10-02,5.0,None,Remote,Low,Not required,None,None,Partial,"WP1StylesListener.cpp, WP5StylesListener.cpp, and WP42StylesListener.cpp in libwpd 0.10.1 mishandle iterators, which allows remote attackers to cause a denial of service (heap-based buffer over-read in the WPXTableList class in WPXTable.cpp). This vulnerability can be triggered in LibreOffice before 5.3.7. It may lead to suffering a remote attack against a LibreOffice application.",,libreoffice,https://cgit.freedesktop.org/libreoffice/core/commit/?id=dd89afa6ee8166b69e7a1e86f22616ca8fc122c9,,,,,,,
CVE-2018-17183,https://www.cvedetails.com/cve/CVE-2018-17183/,CWE-20,,,2018-09-19,2018-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Artifex Ghostscript before 9.25 allowed a user-writable error exception table, which could be used by remote attackers able to supply crafted PostScript to potentially overwrite or replace error handlers to inject code.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=fb713b3818b52d8a6cf62c951eba2e1795ff9624,,,,,,,
CVE-2018-17141,https://www.cvedetails.com/cve/CVE-2018-17141/,CWE-20,,Exec Code,2018-09-21,2018-11-15,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"HylaFAX 6.0.6 and HylaFAX+ 5.6.0 allow remote attackers to execute arbitrary code via a dial-in session that provides a FAX page with the JPEG bit enabled, which is mishandled in FaxModem::writeECMData() in the faxd/CopyQuality.c++ file.",C++,hylafax,http://git.hylafax.org/HylaFAX?a=commit;h=c6cac8d8cd0dbe313689ba77023e12bc5b3027be,c6cac8d8cd0dbe313689ba77023e12bc5b3027be,dfc8a6ffe5a6031c6df716186681f92dac0d07cb,"@@ -485,6 +485,15 @@ Class2Modem::parseClass2Capabilities(const char* cap, Class2Params& params, bool
        } else {
            if (jpscan == 0x1) params.jp = JP_GREY;
            else if (jpscan & 0x2) params.jp = JP_COLOR;
+           /*
+            * ITU T.30 does not specify that bits 16 (MR) or 31 (MMR) must be set to zero if color fax is used;
+            * and ITU T.32 Table 21 provides a data field, ""JP"", for JPEG support separate from ""DF"" for data
+            * format and does not specify that DF is meaningless in DCS when JP is used; but because T.4/T.6
+            * (MH/MR/MMR), JBIG, and JPEG are distinct formats from each other, we must conclude that any
+            * indication of JPEG in DCS must, therefore, invalidate any indication in DCS of MH/MR/MMR/JBIG.
+            * Otherwise, having both df and jp be non-zero will be confusing and possibly cause problems.
+            */
+           if (params.jp != JP_NONE) params.df = 0;    // Yes, this is DF_1DMH, but there is no ""DF_NONE"".
        }
        return (true);
     } else {",http://git.hylafax.org/HylaFAX?a=blob;f=faxd/Class2.c%2B%2B;h=9bd312d3b778b93f8e3ed5382bdd93e4f5f64a99;hb=dfc8a6ffe5a6031c6df716186681f92dac0d07cb,http://git.hylafax.org/HylaFAX?a=blob;f=faxd/Class2.c%2B%2B;h=6439719094995c4315adc05dd0c56e721d71a314;hb=c6cac8d8cd0dbe313689ba77023e12bc5b3027be,,
CVE-2018-17141,https://www.cvedetails.com/cve/CVE-2018-17141/,CWE-20,,Exec Code,2018-09-21,2018-11-15,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"HylaFAX 6.0.6 and HylaFAX+ 5.6.0 allow remote attackers to execute arbitrary code via a dial-in session that provides a FAX page with the JPEG bit enabled, which is mishandled in FaxModem::writeECMData() in the faxd/CopyQuality.c++ file.",C++,hylafax,http://git.hylafax.org/HylaFAX?a=commit;h=c6cac8d8cd0dbe313689ba77023e12bc5b3027be,c6cac8d8cd0dbe313689ba77023e12bc5b3027be,dfc8a6ffe5a6031c6df716186681f92dac0d07cb,"@@ -38,6 +38,7 @@
 #include <ctype.h>
 
 #define        RCVBUFSIZ       (32*1024)               // XXX
+#define        COLORBUFSIZ     (2000*1024)             // 1MB is not big enough
 
 static void setupCompression(TIFF*, u_int, u_int, uint32);
 
@@ -356,7 +357,7 @@ FaxModem::recvPageDLEData(TIFF* tif, bool checkQuality,
                 * rather fax-specific.
                 */
                recvEOLCount = 0;
-               recvRow = (u_char*) malloc(1024*1000);    // 1M should do it?
+               recvRow = (u_char*) malloc(COLORBUFSIZ);
                fxAssert(recvRow != NULL, ""page buffering error (JPEG page)."");
                recvPageStart = recvRow;
            }
@@ -408,8 +409,12 @@ FaxModem::recvPageDLEData(TIFF* tif, bool checkQuality,
                    if (params.df == DF_JBIG) {
                        flushRawData(tif, 0, (const u_char*) buf, cc);
                    } else {
-                       memcpy(recvRow, (const char*) buf, cc);
-                       recvRow += cc;
+                       /* We don't support reception of a JPEG page bigger than COLORBUFSIZ. */
+                       if (recvRow + cc - recvPageStart > COLORBUFSIZ) cc = recvPageStart + COLORBUFSIZ - recvRow;
+                       if (cc > 0) {
+                           memcpy(recvRow, (const char*) buf, cc);
+                           recvRow += cc;
+                       }
                    }
                } while (!fin);
                if (params.df == DF_JBIG) clearSDNORMCount();
@@ -987,7 +992,7 @@ FaxModem::writeECMData(TIFF* tif, u_char* buf, u_int cc, const Class2Params& par
            case JP_GREY+4:
            case JP_COLOR+4:
                recvEOLCount = 0;
-               recvRow = (u_char*) malloc(1024*1000);    // 1M should do it?
+               recvRow = (u_char*) malloc(COLORBUFSIZ);
                fxAssert(recvRow != NULL, ""page buffering error (JPEG page)."");
                recvPageStart = recvRow;
                setupStartPage(tif, params);
@@ -1039,14 +1044,20 @@ FaxModem::writeECMData(TIFF* tif, u_char* buf, u_int cc, const Class2Params& par
            }
            break;
     }
-    if (params.jp != JP_GREY && params.jp != JP_COLOR) {
-       flushRawData(tif, 0, (const u_char*) buf, cc);
-    } else {
-       memcpy(recvRow, (const char*) buf, cc);
-       recvRow += cc;
-    }
-    if (seq & 2 && (params.jp == JP_GREY || params.jp == JP_COLOR)) {
-       fixupJPEG(tif);
+    switch (dataform) {
+       case JP_GREY+4:
+       case JP_COLOR+4:
+           /* We don't support reception of a JPEG page bigger than COLORBUFSIZ. */
+           if (recvRow + cc - recvPageStart > COLORBUFSIZ) cc = recvPageStart + COLORBUFSIZ - recvRow;
+           if (cc > 0) {
+               memcpy(recvRow, (const char*) buf, cc);
+               recvRow += cc;
+           }
+           if (seq & 2) fixupJPEG(tif);
+           break;
+       default:
+           flushRawData(tif, 0, (const u_char*) buf, cc);
+           break;
     }
 }",http://git.hylafax.org/HylaFAX?a=blob;f=faxd/CopyQuality.c%2B%2B;h=6ebc93658af43dfd5dcbfabd90354c3f137b6a1a;hb=dfc8a6ffe5a6031c6df716186681f92dac0d07cb,http://git.hylafax.org/HylaFAX?a=blob;f=faxd/CopyQuality.c%2B%2B;h=d1f2d0f5143bcf9dff1c58757e94df7bd77ebce4;hb=c6cac8d8cd0dbe313689ba77023e12bc5b3027be,,
CVE-2018-17141,https://www.cvedetails.com/cve/CVE-2018-17141/,CWE-20,,Exec Code,2018-09-21,2018-11-15,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"HylaFAX 6.0.6 and HylaFAX+ 5.6.0 allow remote attackers to execute arbitrary code via a dial-in session that provides a FAX page with the JPEG bit enabled, which is mishandled in FaxModem::writeECMData() in the faxd/CopyQuality.c++ file.",C++,hylafax,http://git.hylafax.org/HylaFAX?a=commit;h=c6cac8d8cd0dbe313689ba77023e12bc5b3027be,c6cac8d8cd0dbe313689ba77023e12bc5b3027be,dfc8a6ffe5a6031c6df716186681f92dac0d07cb,"@@ -303,6 +303,15 @@ Class2Params::setFromDCS(FaxParams& dcs_caps)
     if (dcs_caps.isBitEnabled(FaxParams::BITNUM_FULLCOLOR)) {
        if (jp == JP_GREY) jp = JP_COLOR;
     }
+    /*
+     * ITU T.30 does not specify that bits 16 (MR) or 31 (MMR) must be set to zero if color fax is used;
+     * and ITU T.32 Table 21 provides a data field, ""JP"", for JPEG support separate from ""DF"" for data
+     * format and does not specify that DF is meaningless in DCS when JP is used; but because T.4/T.6
+     * (MH/MR/MMR), JBIG, and JPEG are distinct formats from each other, we must conclude that any
+     * indication of JPEG in DCS must, therefore, invalidate any indication in DCS of MH/MR/MMR/JBIG.
+     * Otherwise, having both df and jp be non-zero will be confusing and possibly cause problems.
+     */
+    if (jp != JP_NONE) df = 0; // Yes, this is DF_1DMH, but there is no ""DF_NONE"".
     if (ec == EC_DISABLE &&
        (df == DF_2DMMR || df == DF_JBIG || jp == JP_GREY || jp == JP_COLOR)) {
        // MMR, JBIG, and JPEG require ECM... we've seen cases where fax",http://git.hylafax.org/HylaFAX?a=blob;f=libhylafax/Class2Params.c%2B%2B;h=0409cbdf33992c380bf0e44394237bfa3a045279;hb=dfc8a6ffe5a6031c6df716186681f92dac0d07cb,http://git.hylafax.org/HylaFAX?a=blob;f=libhylafax/Class2Params.c%2B%2B;h=81b9a22bcd45e4a12b6e263967159b48c71147bf;hb=c6cac8d8cd0dbe313689ba77023e12bc5b3027be,,
CVE-2018-16863,https://www.cvedetails.com/cve/CVE-2018-16863/,CWE-78,,Exec Code Bypass,2018-12-03,2019-10-09,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=78911a01b67d\,,,,,,,
CVE-2018-16863,https://www.cvedetails.com/cve/CVE-2018-16863/,CWE-78,,Exec Code Bypass,2018-12-03,2019-10-09,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=79cccf641486,,,,,,,
CVE-2018-16863,https://www.cvedetails.com/cve/CVE-2018-16863/,CWE-78,,Exec Code Bypass,2018-12-03,2019-10-09,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=5516c614dc33,,,,,,,
CVE-2018-16863,https://www.cvedetails.com/cve/CVE-2018-16863/,CWE-78,,Exec Code Bypass,2018-12-03,2019-10-09,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=520bb0ea7519,,,,,,,
CVE-2018-16854,https://www.cvedetails.com/cve/CVE-2018-16854/,CWE-352,,CSRF,2018-11-26,2019-10-09,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"A flaw was found in moodle versions 3.5 to 3.5.2, 3.4 to 3.4.5, 3.3 to 3.3.8, 3.1 to 3.1.14 and earlier. The login form is not protected by a token to prevent login cross-site request forgery. Fixed versions include 3.6, 3.5.3, 3.4.6, 3.3.9 and 3.1.15.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-63183,,,,,,,
CVE-2011-1943,https://www.cvedetails.com/cve/CVE-2011-1943/,CWE-200,,+Info,2011-06-14,2017-08-16,2.1,None,Local,Low,Not required,Partial,None,None,"The destroy_one_secret function in nm-setting-vpn.c in libnm-util in the NetworkManager package 0.8.999-3.git20110526 in Fedora 15 creates a log entry containing a certificate password, which allows local users to obtain sensitive information by reading a log file.",,NetworkManager,https://cgit.freedesktop.org/NetworkManager/NetworkManager/commit/?id=78ce088843d59d4494965bfc40b30a2e63d065f6,,,,,,,
CVE-2018-16802,https://www.cvedetails.com/cve/CVE-2018-16802/,,,Exec Code,2018-09-10,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"An issue was discovered in Artifex Ghostscript before 9.25. Incorrect ""restoration of privilege"" checking when running out of stack during exception handling could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction. This is due to an incomplete fix for CVE-2018-16509.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3e5d316b72e3965b7968bb1d96baa137cd063ac6,,,,,,,
CVE-2018-16802,https://www.cvedetails.com/cve/CVE-2018-16802/,,,Exec Code,2018-09-10,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"An issue was discovered in Artifex Ghostscript before 9.25. Incorrect ""restoration of privilege"" checking when running out of stack during exception handling could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction. This is due to an incomplete fix for CVE-2018-16509.",,ghostscript,https://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=5812b1b78fc4d36fdc293b7859de69241140d590,,,,,,,
CVE-2018-16802,https://www.cvedetails.com/cve/CVE-2018-16802/,,,Exec Code,2018-09-10,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"An issue was discovered in Artifex Ghostscript before 9.25. Incorrect ""restoration of privilege"" checking when running out of stack during exception handling could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction. This is due to an incomplete fix for CVE-2018-16509.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=643b24dbd002fb9c131313253c307cf3951b3d47,,,,,,,
CVE-2009-1932,https://www.cvedetails.com/cve/CVE-2009-1932/,CWE-189,,DoS Exec Code Overflow,2009-06-04,2017-09-28,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the (1) user_info_callback, (2) user_endrow_callback, and (3) gst_pngdec_task functions (ext/libpng/gstpngdec.c) in GStreamer Good Plug-ins (aka gst-plugins-good or gstreamer-plugins-good) 0.10.15 allow remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted PNG file, which triggers a buffer overflow.",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=d9544bcc44adcef769cbdf7f6453e140058a3adc,,,,,,,
CVE-2017-13723,https://www.cvedetails.com/cve/CVE-2017-13723/,CWE-119,,Overflow,2017-10-09,2018-02-03,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"In X.Org Server (aka xserver and xorg-server) before 1.19.4, a local attacker authenticated to the X server could overflow a global buffer, causing crashes of the X server or potentially other problems by injecting large or malformed XKB related atoms and accessing them via xkbcomp.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=94f11ca5cf011ef123bd222cabeaef6f424d76ac,,,,,,,
CVE-2017-13722,https://www.cvedetails.com/cve/CVE-2017-13722/,CWE-125,,,2017-10-11,2017-11-12,3.6,None,Local,Low,Not required,Partial,None,Partial,"In the pcfGetProperties function in bitmap/pcfread.c in libXfont through 1.5.2 and 2.x before 2.0.2, a missing boundary check (for PCF files) could be used by local attackers authenticated to an Xserver for a buffer over-read, for information disclosure or a crash of the X server.",,libxfont,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=672bb944311392e2415b39c0d63b1e1902905bcd,,,,,,,
CVE-2017-13721,https://www.cvedetails.com/cve/CVE-2017-13721/,CWE-269,,,2017-10-09,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"In X.Org Server (aka xserver and xorg-server) before 1.19.4, an attacker authenticated to an X server with the X shared memory extension enabled can cause aborts of the X server or replace shared memory segments of other X clients in the same session.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=b95f25af141d33a65f6f821ea9c003f66a01e1f1,,,,,,,
CVE-2017-13720,https://www.cvedetails.com/cve/CVE-2017-13720/,CWE-125,,DoS,2017-10-11,2017-11-12,3.6,None,Local,Low,Not required,Partial,None,Partial,"In the PatternMatch function in fontfile/fontdir.c in libXfont through 1.5.2 and 2.x before 2.0.2, an attacker with access to an X connection can cause a buffer over-read during pattern matching of fonts, leading to information disclosure or a crash (denial of service). This occurs because '\0' characters are incorrectly skipped in situations involving ? characters.",,libxfont,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d1e670a4a8704b8708e493ab6155589bcd570608,,,,,,,
CVE-2018-16597,https://www.cvedetails.com/cve/CVE-2018-16597/,CWE-863,,,2018-09-21,2019-10-02,4.9,None,Local,Low,Not required,None,Complete,None,An issue was discovered in the Linux kernel before 4.8. Incorrect access checking in overlayfs mounts could be used by local attackers to modify or truncate files in the underlying filesystem.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c0ca3d70e8d3cf81e2255a217f7ca402f5ed0862,,,,,,,
CVE-2018-16585,https://www.cvedetails.com/cve/CVE-2018-16585/,CWE-119,,Overflow Mem. Corr.,2018-09-06,2019-10-09,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"** DISPUTED ** An issue was discovered in Artifex Ghostscript before 9.24. The .setdistillerkeys PostScript command is accepted even though it is not intended for use during document processing (e.g., after the startup phase). This leads to memory corruption, allowing remote attackers able to supply crafted PostScript to crash the interpreter or possibly have unspecified other impact. Note: A reputable source believes that the CVE is potentially a duplicate of CVE-2018-15910 as explained in Red Hat bugzilla (https://bugzilla.redhat.com/show_bug.cgi?id=1626193).",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=971472c83a345a16dac9f90f91258bb22dd77f22,,,,,,,
CVE-2018-16585,https://www.cvedetails.com/cve/CVE-2018-16585/,CWE-119,,Overflow Mem. Corr.,2018-09-06,2019-10-09,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"** DISPUTED ** An issue was discovered in Artifex Ghostscript before 9.24. The .setdistillerkeys PostScript command is accepted even though it is not intended for use during document processing (e.g., after the startup phase). This leads to memory corruption, allowing remote attackers able to supply crafted PostScript to crash the interpreter or possibly have unspecified other impact. Note: A reputable source believes that the CVE is potentially a duplicate of CVE-2018-15910 as explained in Red Hat bugzilla (https://bugzilla.redhat.com/show_bug.cgi?id=1626193).",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=1497d65039885a52b598b137dd8622bd4672f9be,,,,,,,
CVE-2018-16543,https://www.cvedetails.com/cve/CVE-2018-16543/,,,,2018-09-05,2018-11-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript before 9.24, gssetresolution and gsgetresolution allow attackers to have an unspecified impact.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=5b5536fa88a9e885032bc0df3852c3439399a5c0,,,,,,,
CVE-2018-16542,https://www.cvedetails.com/cve/CVE-2018-16542/,CWE-388,,,2018-09-05,2018-11-25,4.3,None,Remote,Medium,Not required,None,None,Partial,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use insufficient interpreter stack-size checking during error handling to crash the interpreter.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=b575e1ec42cc86f6a58c603f2a88fcc2af699cc8,,,,,,,
CVE-2018-16541,https://www.cvedetails.com/cve/CVE-2018-16541/,CWE-416,,,2018-09-05,2018-12-18,4.3,None,Remote,Medium,Not required,None,None,Partial,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use incorrect free logic in pagedevice replacement to crash the interpreter.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=241d91112771a6104de10b3948c3f350d6690c1d,,,,,,,
CVE-2018-16540,https://www.cvedetails.com/cve/CVE-2018-16540/,CWE-416,,,2018-09-05,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files to the builtin PDF14 converter could use a use-after-free in copydevice handling to crash the interpreter or possibly have unspecified other impact.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c432131c3fdb2143e148e8ba88555f7f7a63b25e,,,,,,,
CVE-2018-16539,https://www.cvedetails.com/cve/CVE-2018-16539/,CWE-200,,+Info,2018-09-05,2018-11-27,4.3,None,Remote,Medium,Not required,Partial,None,None,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use incorrect access checking in temp file handling to disclose contents of files on the system otherwise not readable.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=a054156d425b4dbdaaa9fda4b5f1182b27598c2b,,,,,,,
CVE-2017-13673,https://www.cvedetails.com/cve/CVE-2017-13673/,CWE-617,,DoS,2017-08-29,2019-10-02,4.0,None,Remote,Low,Single system,None,None,Partial,The vga display update in mis-calculated the region for the dirty bitmap snapshot in case split screen mode is used causing a denial of service (assertion failure) in the cpu_physical_memory_snapshot_get_dirty function.,,qemu,https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d,,,,,,,
CVE-2018-16513,https://www.cvedetails.com/cve/CVE-2018-16513/,CWE-704,,,2018-09-05,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the setcolor function to crash the interpreter or possibly have unspecified other impact.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=b326a71659b7837d3acde954b18bda1a6f5e9498,,,,,,,
CVE-2018-16511,https://www.cvedetails.com/cve/CVE-2018-16511/,CWE-704,,,2018-09-05,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"An issue was discovered in Artifex Ghostscript before 9.24. A type confusion in ""ztype"" could be used by remote attackers able to supply crafted PostScript to crash the interpreter or possibly have unspecified other impact.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=0edd3d6c634a577db261615a9dc2719bca7f6e01,,,,,,,
CVE-2018-16510,https://www.cvedetails.com/cve/CVE-2018-16510/,CWE-119,,Overflow,2018-09-05,2018-11-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"An issue was discovered in Artifex Ghostscript before 9.24. Incorrect exec stack handling in the ""CS"" and ""SC"" PDF primitives could be used by remote attackers able to supply crafted PDFs to crash the interpreter or possibly have unspecified other impact.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=ea735ba37dc0fd5f5622d031830b9a559dec1cc9,,,,,,,
CVE-2018-16509,https://www.cvedetails.com/cve/CVE-2018-16509/,,,Exec Code,2018-09-05,2019-10-02,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"An issue was discovered in Artifex Ghostscript before 9.24. Incorrect ""restoration of privilege"" checking during handling of /invalidaccess exceptions could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=78911a01b67d590b4a91afac2e8417360b934156,,,,,,,
CVE-2018-16509,https://www.cvedetails.com/cve/CVE-2018-16509/,,,Exec Code,2018-09-05,2019-10-02,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"An issue was discovered in Artifex Ghostscript before 9.24. Incorrect ""restoration of privilege"" checking during handling of /invalidaccess exceptions could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=5516c614dc33662a2afdc377159f70218e67bde5,,,,,,,
CVE-2018-16509,https://www.cvedetails.com/cve/CVE-2018-16509/,,,Exec Code,2018-09-05,2019-10-02,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"An issue was discovered in Artifex Ghostscript before 9.24. Incorrect ""restoration of privilege"" checking during handling of /invalidaccess exceptions could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=520bb0ea7519aa3e79db78aaf0589dae02103764,,,,,,,
CVE-2018-16509,https://www.cvedetails.com/cve/CVE-2018-16509/,,,Exec Code,2018-09-05,2019-10-02,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"An issue was discovered in Artifex Ghostscript before 9.24. Incorrect ""restoration of privilege"" checking during handling of /invalidaccess exceptions could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=79cccf641486a6595c43f1de1cd7ade696020a31,,,,,,,
CVE-2017-13090,https://www.cvedetails.com/cve/CVE-2017-13090/,CWE-119,,Overflow,2017-10-27,2017-12-29,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"The retr.c:fd_read_body() function is called when processing OK responses. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to read the chunk in pieces of 8192 bytes by using the MIN() macro, but ends up passing the negative chunk length to retr.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument. The attacker can corrupt malloc metadata after the allocated buffer.",,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=ba6b44f6745b14dce414761a8e4b35d31b176bba,,,,,,,
CVE-2019-12817,https://www.cvedetails.com/cve/CVE-2019-12817/,CWE-119,,Overflow,2019-06-25,2019-06-28,6.9,None,Local,Medium,Not required,Complete,Complete,Complete,arch/powerpc/mm/mmu_context_book3s64.c in the Linux kernel before 5.1.15 for powerpc has a bug where unrelated processes may be able to read/write to one another's virtual memory under certain conditions via an mmap above 512 TB. Only a subset of powerpc systems are affected.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ca72d88378b2f2444d3ec145dd442d449d3fefbc,,,,,,,
CVE-2019-12615,https://www.cvedetails.com/cve/CVE-2019-12615/,CWE-476,,DoS,2019-06-03,2019-07-10,7.8,None,Remote,Low,Not required,None,None,Complete,"An issue was discovered in get_vdev_port_node_info in arch/sparc/kernel/mdesc.c in the Linux kernel through 5.1.6. There is an unchecked kstrdup_const of node_info->vdev_port.name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc.git/commit/?id=80caf43549e7e41a695c6d1e11066286538b336f,,,,,,,
CVE-2019-12614,https://www.cvedetails.com/cve/CVE-2019-12614/,CWE-476,,DoS,2019-06-03,2019-06-13,7.8,None,Remote,Low,Not required,None,None,Complete,"An issue was discovered in dlpar_parse_cc_property in arch/powerpc/platforms/pseries/dlpar.c in the Linux kernel through 5.1.6. There is an unchecked kstrdup of prop->name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux.git/commit/?id=efa9ace68e487ddd29c2b4d6dd23242158f1f607,,,,,,,
CVE-2017-12865,https://www.cvedetails.com/cve/CVE-2017-12865/,CWE-119,,DoS Exec Code Overflow,2017-08-29,2018-12-03,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Stack-based buffer overflow in ""dnsproxy.c"" in connman 1.34 and earlier allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a crafted response query string passed to the ""name"" variable.",,linux kernel,https://git.kernel.org/pub/scm/network/connman/connman.git/commit/?id=5c281d182ecdd0a424b64f7698f32467f8f67b71,,,,,,,
CVE-2018-15911,https://www.cvedetails.com/cve/CVE-2018-15911/,CWE-119,,Exec Code Overflow,2018-08-28,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript 9.23 before 2018-08-24, attackers able to supply crafted PostScript could use uninitialized memory access in the aesdecode operator to crash the interpreter or potentially execute code.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=8e9ce5016db968b40e4ec255a3005f2786cce45f,,,,,,,
CVE-2018-15910,https://www.cvedetails.com/cve/CVE-2018-15910/,CWE-704,,Exec Code,2018-08-27,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the LockDistillerParams parameter to crash the interpreter or execute code.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c3476dde7743761a4e1d39a631716199b696b880,,,,,,,
CVE-2015-3456,https://www.cvedetails.com/cve/CVE-2015-3456/,CWE-119,,DoS Exec Code Overflow,2015-05-13,2019-04-22,7.7,None,Local Network,Low,Single system,Complete,Complete,Complete,"The Floppy Disk Controller (FDC) in QEMU, as used in Xen 4.5.x and earlier and KVM, allows local guest users to cause a denial of service (out-of-bounds write and guest crash) or possibly execute arbitrary code via the (1) FD_CMD_READ_ID, (2) FD_CMD_DRIVE_SPECIFICATION_COMMAND, or other unspecified commands, aka VENOM.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c,,,,,,,
CVE-2018-15909,https://www.cvedetails.com/cve/CVE-2018-15909/,CWE-704,,Exec Code,2018-08-27,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript 9.23 before 2018-08-24, a type confusion using the .shfill operator could be used by attackers able to supply crafted PostScript files to crash the interpreter or potentially execute code.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=0b6cd1918e1ec4ffd087400a754a845180a4522b,,,,,,,
CVE-2018-15909,https://www.cvedetails.com/cve/CVE-2018-15909/,CWE-704,,Exec Code,2018-08-27,2019-04-25,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript 9.23 before 2018-08-24, a type confusion using the .shfill operator could be used by attackers able to supply crafted PostScript files to crash the interpreter or potentially execute code.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=e01e77a36cbb2e0277bc3a63852244bec41be0f6,,,,,,,
CVE-2018-15908,https://www.cvedetails.com/cve/CVE-2018-15908/,,,Bypass,2018-08-27,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In Artifex Ghostscript 9.23 before 2018-08-23, attackers are able to supply malicious PostScript files to bypass .tempfile restrictions and write files.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=0d3901189f245232f0161addf215d7268c4d05a3,,,,,,,
CVE-2019-12454,https://www.cvedetails.com/cve/CVE-2019-12454/,CWE-20,,,2019-05-30,2019-06-09,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"An issue was discovered in wcd9335_codec_enable_dec in sound/soc/codecs/wcd9335.c in the Linux kernel through 5.1.5. It uses kstrndup instead of kmemdup_nul, which allows attackers to have an unspecified impact via unknown vectors.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound.git/commit/?h=for-5.3&id=a54988113985ca22e414e132054f234fc8a92604,,,,,,,
CVE-2019-12382,https://www.cvedetails.com/cve/CVE-2019-12382/,CWE-476,,DoS,2019-05-27,2019-06-09,4.9,None,Local,Low,Not required,None,None,Complete,"An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).",,drm,https://cgit.freedesktop.org/drm/drm-misc/commit/?id=9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f,,,,,,,
CVE-2019-12380,https://www.cvedetails.com/cve/CVE-2019-12380/,CWE-388,,,2019-05-27,2019-10-10,2.1,None,Local,Low,Not required,None,None,Partial,"**DISPUTED** An issue was discovered in the efi subsystem in the Linux kernel through 5.1.5. phys_efi_set_virtual_address_map in arch/x86/platform/efi/efi.c and efi_call_phys_prolog in arch/x86/platform/efi/efi_64.c mishandle memory allocation failures. NOTE: This id is disputed as not being an issue because ?All the code touched by the referenced commit runs only at boot, before any user processes are started. Therefore, there is no possibility for an unprivileged user to control it.?.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=4e78921ba4dd0aca1cc89168f45039add4183f8e,,,,,,,
CVE-2019-12379,https://www.cvedetails.com/cve/CVE-2019-12379/,CWE-399,,,2019-05-27,2019-07-02,4.9,None,Local,Low,Not required,None,None,Complete,** DISPUTED ** An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty.git/commit/?h=tty-testing&id=15b3cd8ef46ad1b100e0d3c7e38774f330726820,,,,,,,
CVE-2019-12379,https://www.cvedetails.com/cve/CVE-2019-12379/,CWE-399,,,2019-05-27,2019-07-02,4.9,None,Local,Low,Not required,None,None,Complete,** DISPUTED ** An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty.git/commit/?h=tty-next&id=84ecc2f6eb1cb12e6d44818f94fa49b50f06e6ac,,,,,,,
CVE-2015-3330,https://www.cvedetails.com/cve/CVE-2015-3330/,CWE-20,,DoS Exec Code,2015-06-09,2019-04-22,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The php_handler function in sapi/apache2handler/sapi_apache2.c in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8, when the Apache HTTP Server 2.4.x is used, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via pipelined HTTP requests that result in a ""deconfigured interpreter.""",,php,https://git.php.net/?p=php-src.git;a=commit;h=809610f5ea38a83b284e1125d1fff129bdd615e7,,,,,,,
CVE-2015-3329,https://www.cvedetails.com/cve/CVE-2015-3329/,CWE-119,,Exec Code Overflow,2015-06-09,2019-04-22,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple stack-based buffer overflows in the phar_set_inode function in phar_internal.h in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 allow remote attackers to execute arbitrary code via a crafted length value in a (1) tar, (2) phar, or (3) ZIP archive.",,php,https://git.php.net/?p=php-src.git;a=commit;h=f59b67ae50064560d7bfcdb0d6a8ab284179053c,,,,,,,
CVE-2011-1428,https://www.cvedetails.com/cve/CVE-2011-1428/,CWE-20,,,2011-03-16,2011-03-22,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"Wee Enhanced Environment for Chat (aka WeeChat) 0.3.4 and earlier does not properly verify that the server hostname matches the domain name of the subject of an X.509 certificate, which allows man-in-the-middle attackers to spoof an SSL chat server via an arbitrary certificate, related to incorrect use of the GnuTLS API.",,savannah,https://git.savannah.gnu.org/gitweb/?p=weechat.git;a=commit;h=c265cad1c95b84abfd4e8d861f25926ef13b5d91,,,,,,,
CVE-2015-3281,https://www.cvedetails.com/cve/CVE-2015-3281/,CWE-119,,Overflow +Info,2015-07-06,2016-12-27,5.0,None,Remote,Low,Not required,Partial,None,None,"The buffer_slow_realign function in HAProxy 1.5.x before 1.5.14 and 1.6-dev does not properly realign a buffer that is used for pending outgoing data, which allows remote attackers to obtain sensitive information (uninitialized memory contents of previous requests) via a crafted request.",,haproxy,https://git.haproxy.org/?p=haproxy-1.5.git;a=commit;h=7ec765568883b2d4e5a2796adbeb492a22ec9bd4,,,,,,,
CVE-2015-3239,https://www.cvedetails.com/cve/CVE-2015-3239/,CWE-189,,,2015-08-26,2016-12-21,3.3,None,Local,Medium,Not required,Partial,Partial,None,Off-by-one error in the dwarf_to_unw_regnum function in include/dwarf_i.h in libunwind 1.1 allows local users to have unspecified impact via invalid dwarf opcodes.,,savannah,https://git.savannah.gnu.org/cgit/libunwind.git/commit/?id=396b6c7ab737e2bff244d640601c436a26260ca1,,,,,,,
CVE-2013-2246,https://www.cvedetails.com/cve/CVE-2013-2246/,CWE-264,,+Info,2013-07-29,2013-07-29,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/feedback/lib.php in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, and 2.5.x before 2.5.1 does not consider the mod/feedback:view capability before displaying recent feedback, which allows remote authenticated users to obtain sensitive information via a request for all course feedback that has occurred since a specified time.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39570,,,,,,,
CVE-2013-2245,https://www.cvedetails.com/cve/CVE-2013-2245/,CWE-287,,+Info,2013-07-29,2013-07-29,4.0,None,Remote,Low,Single system,Partial,None,None,"rss/file.php in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, and 2.5.x before 2.5.1 does not properly implement the use of RSS tokens for impersonation, which allows remote authenticated users to obtain sensitive block information by reading an RSS feed.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37818,,,,,,,
CVE-2013-2244,https://www.cvedetails.com/cve/CVE-2013-2244/,CWE-79,,XSS,2013-07-29,2013-07-29,4.3,None,Remote,Medium,Not required,None,Partial,None,Multiple cross-site scripting (XSS) vulnerabilities in lib/conditionlib.php in Moodle 2.4.x before 2.4.5 and 2.5.x before 2.5.1 allow remote attackers to inject arbitrary web script or HTML via the conditional access rule value of a user field.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37516,,,,,,,
CVE-2013-2243,https://www.cvedetails.com/cve/CVE-2013-2243/,CWE-200,,+Info,2013-07-29,2013-07-29,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/lesson/pagetypes/matching.php in Moodle through 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, and 2.5.x before 2.5.1 allows remote authenticated users to obtain sensitive answer information by reading the HTML source code of a document.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39546,,,,,,,
CVE-2015-3228,https://www.cvedetails.com/cve/CVE-2015-3228/,CWE-189,,DoS Overflow,2015-08-11,2017-09-20,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer overflow in the gs_heap_alloc_bytes function in base/gsmalloc.c in Ghostscript 9.15 and earlier allows remote attackers to cause a denial of service (crash) via a crafted Postscript (ps) file, as demonstrated by using the ps2pdf command, which triggers an out-of-bounds read or write.",,moodle,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=0c0b0859,,,,,,,
CVE-2013-2242,https://www.cvedetails.com/cve/CVE-2013-2242/,CWE-264,,Bypass,2013-07-29,2013-07-29,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/chat/gui_sockets/index.php in Moodle through 2.1.10, 2.2.x before 2.2.11, 2.3.x before 2.3.8, 2.4.x before 2.4.5, and 2.5.x before 2.5.1 does not consider the mod/chat:chat capability before authorizing daemon-mode chat, which allows remote authenticated users to bypass intended access restrictions via an HTTP session to a chat server.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39628,,,,,,,
CVE-2015-3223,https://www.cvedetails.com/cve/CVE-2015-3223/,CWE-189,,DoS,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The ldb_wildcard_compare function in ldb_match.c in ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles certain zero values, which allows remote attackers to cause a denial of service (infinite loop) via crafted packets.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=ec504dbf69636a554add1f3d5703dd6c3ad450b8,,,,,,,
CVE-2015-3223,https://www.cvedetails.com/cve/CVE-2015-3223/,CWE-189,,DoS,2015-12-29,2016-12-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The ldb_wildcard_compare function in ldb_match.c in ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles certain zero values, which allows remote attackers to cause a denial of service (infinite loop) via crafted packets.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=aa6c27148b9d3f8c1e4fdd5dd46bfecbbd0ca465,,,,,,,
CVE-2013-2236,https://www.cvedetails.com/cve/CVE-2013-2236/,CWE-119,,DoS Overflow,2013-10-23,2018-01-04,2.6,None,Remote,High,Not required,None,None,Partial,"Stack-based buffer overflow in the new_msg_lsa_change_notify function in the OSPFD API (ospf_api.c) in Quagga before 0.99.22.2, when --enable-opaque-lsa and the -a command line option are used, allows remote attackers to cause a denial of service (crash) via a large LSA.",,savannah,https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=3f872fe60463a931c5c766dbf8c36870c0023e88,,,,,,,
CVE-2015-3196,https://www.cvedetails.com/cve/CVE-2015-3196/,CWE-362,,DoS,2015-12-06,2019-06-13,4.3,None,Remote,Medium,Not required,None,None,Partial,"ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=3c66a669dfc7b3792f7af0758ea26fe8502ce70c,,,,,,,
CVE-2015-3195,https://www.cvedetails.com/cve/CVE-2015-3195/,CWE-200,,+Info,2015-12-06,2019-06-14,5.0,None,Remote,Low,Not required,None,None,Partial,"The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=cc598f321fbac9c04da5766243ed55d55948637d,,,,,,,
CVE-2015-3194,https://www.cvedetails.com/cve/CVE-2015-3194/,,,DoS,2015-12-06,2018-01-04,5.0,None,Remote,Low,Not required,None,None,Partial,crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=d8541d7e9e63bf5f343af24644046c8d96498c17,,,,,,,
CVE-2015-3194,https://www.cvedetails.com/cve/CVE-2015-3194/,,,DoS,2015-12-06,2018-01-04,5.0,None,Remote,Low,Not required,None,None,Partial,crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=c394a488942387246653833359a5c94b5832674e,,,,,,,
CVE-2015-3193,https://www.cvedetails.com/cve/CVE-2015-3193/,CWE-200,,+Info,2015-12-06,2017-11-29,5.0,None,Remote,Low,Not required,Partial,None,None,"The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=d73cc256c8e256c32ed959456101b73ba9842f72,,,,,,,
CVE-2015-3181,https://www.cvedetails.com/cve/CVE-2015-3181/,CWE-264,,Bypass,2015-06-01,2016-12-30,4.0,None,Remote,Low,Single system,None,Partial,None,"files/externallib.php in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 does not consider the moodle/user:manageownfiles capability before approving a private-file upload, which allows remote authenticated users to bypass intended file-management restrictions by using web services to perform uploads after this capability has been revoked.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49994,,,,,,,
CVE-2015-3180,https://www.cvedetails.com/cve/CVE-2015-3180/,CWE-200,,+Info,2015-06-01,2016-12-30,4.0,None,Remote,Low,Single system,Partial,None,None,"lib/navigationlib.php in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 allows remote authenticated users to obtain sensitive course-structure information by leveraging access to a student account with a suspended enrolment.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49788,,,,,,,
CVE-2015-3179,https://www.cvedetails.com/cve/CVE-2015-3179/,CWE-264,,Bypass,2015-06-01,2016-12-30,3.5,None,Remote,Medium,Single system,None,Partial,None,"login/confirm.php in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 allows remote authenticated users to bypass intended login restrictions by leveraging access to an unconfirmed suspended account.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50090,,,,,,,
CVE-2015-3178,https://www.cvedetails.com/cve/CVE-2015-3178/,CWE-79,,XSS,2015-06-01,2016-12-30,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the external_format_text function in lib/externallib.php in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 allows remote authenticated users to inject arbitrary web script or HTML into an external application via a crafted string that is visible to web services.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49718,,,,,,,
CVE-2015-3177,https://www.cvedetails.com/cve/CVE-2015-3177/,CWE-17,,+Info,2015-06-01,2016-12-30,3.5,None,Remote,Medium,Single system,Partial,None,None,"Moodle 2.8.x before 2.8.6 does not consider the tool/monitor:subscribe capability before entering subscriptions to site-wide event-monitor rules, which allows remote authenticated users to obtain sensitive information via a subscription request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50039,,,,,,,
CVE-2019-12068,https://www.cvedetails.com/cve/CVE-2019-12068/,CWE-835,,Exec Code,2019-09-24,2019-09-26,5.0,None,Remote,Low,Not required,None,None,Partial,"In QEMU 1:4.1-1, 1:2.1+dfsg-12+deb8u6, 1:2.8+dfsg-6+deb9u8, 1:3.1+dfsg-8~deb10u1, 1:3.1+dfsg-8+deb10u2, and 1:2.1+dfsg-12+deb8u12 (fixed), when executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08,,,,,,,
CVE-2015-3176,https://www.cvedetails.com/cve/CVE-2015-3176/,CWE-200,,+Info,2015-06-01,2016-12-30,4.3,None,Remote,Medium,Not required,Partial,None,None,"The account-confirmation feature in login/confirm.php in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 allows remote attackers to obtain sensitive full-name information by attempting to self-register.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50099,,,,,,,
CVE-2015-3175,https://www.cvedetails.com/cve/CVE-2015-3175/,,,,2015-06-01,2016-12-30,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"Multiple open redirect vulnerabilities in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via vectors involving an error page that links to a URL from an HTTP Referer header.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49179,,,,,,,
CVE-2013-2179,https://www.cvedetails.com/cve/CVE-2013-2179/,CWE-310,,DoS,2013-12-26,2013-12-27,4.3,None,Remote,Medium,Not required,None,None,Partial,"X.Org xdm 1.1.10, 1.1.11, and possibly other versions, when performing authentication using certain implementations of the crypt API function that can return NULL, allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by attempting to log into an account whose password field contains invalid characters, as demonstrated using the crypt function from glibc 2.17 and later with (1) the ""!"" character in the salt portion of a password field or (2) a password that has been encrypted using DES or MD5 in FIPS-140 mode.",,xdm,https://cgit.freedesktop.org/xorg/app/xdm/commit/?id=8d1eb5c74413e4c9a21f689fc106949b121c0117,,,,,,,
CVE-2015-3174,https://www.cvedetails.com/cve/CVE-2015-3174/,CWE-79,,XSS,2015-06-01,2016-12-30,3.5,None,Remote,Medium,Single system,None,Partial,None,"mod/quiz/db/access.php in Moodle through 2.5.9, 2.6.x before 2.6.11, 2.7.x before 2.7.8, and 2.8.x before 2.8.6 does not set the RISK_XSS bit for graders, which allows remote authenticated users to conduct cross-site scripting (XSS) attacks via crafted gradebook feedback during manual quiz grading.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49941,,,,,,,
CVE-2013-2168,https://www.cvedetails.com/cve/CVE-2013-2168/,CWE-20,,DoS,2013-07-03,2018-10-30,1.9,None,Local,Medium,Not required,None,None,Partial,"The _dbus_printf_string_upper_bound function in dbus/dbus-sysdeps-unix.c in D-Bus (aka DBus) 1.4.x before 1.4.26, 1.6.x before 1.6.12, and 1.7.x before 1.7.4 allows local users to cause a denial of service (service crash) via a crafted message.",,dbus,https://cgit.freedesktop.org/dbus/dbus/commit/?id=954d75b2b64e4799f360d2a6bf9cff6d9fee37e7,,,,,,,
CVE-2013-2083,https://www.cvedetails.com/cve/CVE-2013-2083/,CWE-20,,Bypass,2013-05-24,2013-11-24,5.0,None,Remote,Low,Not required,None,Partial,None,"The MoodleQuickForm class in lib/formslib.php in Moodle through 2.1.10, 2.2.x before 2.2.10, 2.3.x before 2.3.7, and 2.4.x before 2.4.4 does not properly handle a certain array-element syntax, which allows remote attackers to bypass intended form-data filtering via a crafted request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-38885,,,,,,,
CVE-2013-2082,https://www.cvedetails.com/cve/CVE-2013-2082/,CWE-264,,+Info,2013-05-24,2013-11-24,5.0,None,Remote,Low,Not required,Partial,None,None,"Moodle through 2.1.10, 2.2.x before 2.2.10, 2.3.x before 2.3.7, and 2.4.x before 2.4.4 does not enforce capability requirements for reading blog comments, which allows remote attackers to obtain sensitive information via a crafted request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37245,,,,,,,
CVE-2013-2081,https://www.cvedetails.com/cve/CVE-2013-2081/,CWE-264,,+Info,2013-05-24,2013-11-24,4.3,None,Remote,Medium,Not required,Partial,None,None,"Moodle through 2.1.10, 2.2.x before 2.2.10, 2.3.x before 2.3.7, and 2.4.x before 2.4.4 does not consider ""don't send"" attributes during hub registration, which allows remote hubs to obtain sensitive site information by reading form data.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37822,,,,,,,
CVE-2013-2080,https://www.cvedetails.com/cve/CVE-2013-2080/,CWE-264,,+Info,2013-05-24,2013-11-24,4.0,None,Remote,Low,Single system,Partial,None,None,"The core_grade component in Moodle through 2.2.10, 2.3.x before 2.3.7, and 2.4.x before 2.4.4 does not properly consider the existence of hidden grades, which allows remote authenticated users to obtain sensitive information by leveraging the student role and reading the Gradebook Overview report.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37475,,,,,,,
CVE-2013-2079,https://www.cvedetails.com/cve/CVE-2013-2079/,CWE-264,,,2013-05-24,2013-11-24,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/assign/locallib.php in the assignment module in Moodle 2.3.x before 2.3.7 and 2.4.x before 2.4.4 does not consider capability requirements during the processing of ZIP assignment-archive download (aka downloadall) requests, which allows remote authenticated users to read other users' assignments by leveraging the student role.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-38443,,,,,,,
CVE-2013-2007,https://www.cvedetails.com/cve/CVE-2013-2007/,CWE-264,,,2013-05-21,2017-08-28,6.9,None,Local,Medium,Not required,Complete,Complete,Complete,"The qemu guest agent in Qemu 1.4.1 and earlier, as used by Xen, when started in daemon mode, uses weak permissions for certain files, which allows local users to read and write to these files.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,,,,,,,
CVE-2017-12153,https://www.cvedetails.com/cve/CVE-2017-12153/,CWE-476,,,2017-09-21,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,A security flaw was discovered in the nl80211_set_rekey_data() function in net/wireless/nl80211.c in the Linux kernel through 4.13.3. This function does not check whether the required attributes are present in a Netlink request. This request can be issued by a user with the CAP_NET_ADMIN capability and may result in a NULL pointer dereference and system crash.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211.git/commit/?id=e785fa0a164aa11001cba931367c7f94ffaff888,,,,,,,
CVE-2013-1950,https://www.cvedetails.com/cve/CVE-2013-1950/,CWE-399,,DoS,2013-07-09,2013-10-11,4.3,None,Remote,Medium,Not required,None,None,Partial,The svc_dg_getargs function in libtirpc 0.2.3 and earlier allows remote attackers to cause a denial of service (rpcbind crash) via a Sun RPC request with crafted arguments that trigger a free of an invalid pointer.,,infradead,http://git.infradead.org/users/steved/libtirpc.git/commitdiff/a9f437119d79a438cb12e510f3cadd4060102c9f,,,,,,,
CVE-2013-1836,https://www.cvedetails.com/cve/CVE-2013-1836/,CWE-264,,,2013-03-25,2013-12-05,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"Moodle 2.x through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 does not properly manage privileges for WebDAV repositories, which allows remote authenticated users to read, modify, or delete arbitrary site-wide repositories by leveraging certain read access.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37852,,,,,,,
CVE-2013-1835,https://www.cvedetails.com/cve/CVE-2013-1835/,CWE-200,,+Info,2013-03-25,2013-12-05,3.5,None,Remote,Medium,Single system,Partial,None,None,"Moodle 2.x through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 allows remote authenticated administrators to obtain sensitive information from the external repositories of arbitrary users by leveraging the login_as feature.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36426,,,,,,,
CVE-2013-1834,https://www.cvedetails.com/cve/CVE-2013-1834/,CWE-264,,,2013-03-25,2013-12-05,4.0,None,Remote,Low,Single system,None,Partial,None,"notes/edit.php in Moodle 1.9.x through 1.9.19, 2.x through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 allows remote authenticated users to reassign notes via a modified (1) userid or (2) courseid field.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37411,,,,,,,
CVE-2013-1833,https://www.cvedetails.com/cve/CVE-2013-1833/,CWE-79,,XSS,2013-03-25,2013-12-05,3.5,None,Remote,Medium,Single system,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in the File Picker module in Moodle 2.x through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 allow remote authenticated users to inject arbitrary web script or HTML via a crafted filename.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37507,,,,,,,
CVE-2013-1832,https://www.cvedetails.com/cve/CVE-2013-1832/,CWE-200,,+Info,2013-03-25,2013-12-05,4.0,None,Remote,Low,Single system,Partial,None,None,"repository/webdav/lib.php in Moodle 2.x through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 includes the WebDAV password in the configuration form, which allows remote authenticated administrators to obtain sensitive information by configuring an instance.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37681,,,,,,,
CVE-2013-1831,https://www.cvedetails.com/cve/CVE-2013-1831/,CWE-200,,+Info,2013-03-25,2013-12-05,5.0,None,Remote,Low,Not required,Partial,None,None,"lib/setuplib.php in Moodle through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 allows remote attackers to obtain sensitive information via an invalid request, which reveals the absolute path in an exception message.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36901,,,,,,,
CVE-2013-1830,https://www.cvedetails.com/cve/CVE-2013-1830/,CWE-264,,+Info,2013-03-25,2016-10-03,5.0,None,Remote,Low,Not required,Partial,None,None,"user/view.php in Moodle through 2.1.10, 2.2.x before 2.2.8, 2.3.x before 2.3.5, and 2.4.x before 2.4.2 does not enforce the forceloginforprofiles setting, which allows remote attackers to obtain sensitive course-profile information by leveraging the guest role, as demonstrated by a Google search.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37481,,,,,,,
CVE-2013-1829,https://www.cvedetails.com/cve/CVE-2013-1829/,CWE-200,,+Info,2013-03-25,2013-03-26,4.0,None,Remote,Low,Single system,Partial,None,None,"calendar/managesubscriptions.php in Moodle 2.4.x before 2.4.2 does not consider capability requirements before displaying calendar subscriptions, which allows remote authenticated users to obtain potentially sensitive information by leveraging the student role.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37338,,,,,,,
CVE-2013-1824,https://www.cvedetails.com/cve/CVE-2013-1824/,CWE-200,,+Info,2013-09-16,2019-04-22,4.3,None,Remote,Medium,Not required,Partial,None,None,"The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",,php,https://git.php.net/?p=php-src.git;a=commit;h=188c196d4da60bdde9190d2fc532650d17f7af2d,,,,,,,
CVE-2013-1824,https://www.cvedetails.com/cve/CVE-2013-1824/,CWE-200,,+Info,2013-09-16,2019-04-22,4.3,None,Remote,Medium,Not required,Partial,None,None,"The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",,php,https://git.php.net/?p=php-src.git;a=commit;h=afe98b7829d50806559acac9b530acb8283c3bf4,,,,,,,
CVE-2013-1813,https://www.cvedetails.com/cve/CVE-2013-1813/,CWE-264,,,2013-11-23,2019-06-13,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"util-linux/mdev.c in BusyBox before 1.21.0 uses 0777 permissions for parent directories when creating nested directories under /dev/, which allows local users to have unknown impact and attack vectors.",,busybox,https://git.busybox.net/busybox/commit/?id=4609f477c7e043a4f6147dfe6e86b775da2ef784,,,,,,,
CVE-2015-2806,https://www.cvedetails.com/cve/CVE-2015-2806/,CWE-119,,Overflow,2015-04-10,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,Stack-based buffer overflow in asn1_der_decoding in libtasn1 before 4.4 allows remote attackers to have unspecified impact via unknown vectors.,,savannah,https://git.savannah.gnu.org/gitweb/?p=libtasn1.git;a=commit;h=4d4f992826a4962790ecd0cce6fbba4a415ce149,,,,,,,
CVE-2013-1790,https://www.cvedetails.com/cve/CVE-2013-1790/,CWE-119,,Overflow,2013-04-09,2014-01-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,poppler/Stream.cc in poppler before 0.22.1 allows context-dependent attackers to have an unspecified impact via vectors that trigger a read of uninitialized memory by the CCITTFaxStream::lookChar function.,,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=b1026b5978c385328f2a15a2185c599a563edf91,,,,,,,
CVE-2013-1789,https://www.cvedetails.com/cve/CVE-2013-1789/,,,DoS,2013-04-09,2013-04-10,4.3,None,Remote,Medium,Not required,None,None,Partial,"splash/Splash.cc in poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (NULL pointer dereference and crash) via vectors related to the (1) Splash::arbitraryTransformMask, (2) Splash::blitMask, and (3) Splash::scaleMaskYuXu functions.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=a9b8ab4657dec65b8b86c225d12c533ad7e984e2,,,,,,,
CVE-2013-1789,https://www.cvedetails.com/cve/CVE-2013-1789/,,,DoS,2013-04-09,2013-04-10,4.3,None,Remote,Medium,Not required,None,None,Partial,"splash/Splash.cc in poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (NULL pointer dereference and crash) via vectors related to the (1) Splash::arbitraryTransformMask, (2) Splash::blitMask, and (3) Splash::scaleMaskYuXu functions.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=a205e71a2dbe0c8d4f4905a76a3f79ec522eacec,,,,,,,
CVE-2013-1788,https://www.cvedetails.com/cve/CVE-2013-1788/,CWE-119,,DoS Exec Code Overflow,2013-04-09,2014-01-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors that trigger an ""invalid memory access"" in (1) splash/Splash.cc, (2) poppler/Function.cc, and (3) poppler/Stream.cc.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=e14b6e9c13d35c9bd1e0c50906ace8e707816888,,,,,,,
CVE-2013-1788,https://www.cvedetails.com/cve/CVE-2013-1788/,CWE-119,,DoS Exec Code Overflow,2013-04-09,2014-01-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors that trigger an ""invalid memory access"" in (1) splash/Splash.cc, (2) poppler/Function.cc, and (3) poppler/Stream.cc.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=0388837f01bc467045164f9ddaff787000a8caaa,,,,,,,
CVE-2013-1788,https://www.cvedetails.com/cve/CVE-2013-1788/,CWE-119,,DoS Exec Code Overflow,2013-04-09,2014-01-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors that trigger an ""invalid memory access"" in (1) splash/Splash.cc, (2) poppler/Function.cc, and (3) poppler/Stream.cc.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=8b6dc55e530b2f5ede6b9dfb64aafdd1d5836492,,,,,,,
CVE-2013-1788,https://www.cvedetails.com/cve/CVE-2013-1788/,CWE-119,,DoS Exec Code Overflow,2013-04-09,2014-01-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors that trigger an ""invalid memory access"" in (1) splash/Splash.cc, (2) poppler/Function.cc, and (3) poppler/Stream.cc.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=bbc2d8918fe234b7ef2c480eb148943922cc0959,,,,,,,
CVE-2013-1788,https://www.cvedetails.com/cve/CVE-2013-1788/,CWE-119,,DoS Exec Code Overflow,2013-04-09,2014-01-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"poppler before 0.22.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors that trigger an ""invalid memory access"" in (1) splash/Splash.cc, (2) poppler/Function.cc, and (3) poppler/Stream.cc.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=957aa252912cde85d76c41e9710b33425a82b696,,,,,,,
CVE-2017-11714,https://www.cvedetails.com/cve/CVE-2017-11714/,CWE-125,,DoS,2017-07-28,2019-04-17,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"psi/ztoken.c in Artifex Ghostscript 9.21 mishandles references to the scanner state structure, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PostScript document, related to an out-of-bounds read in the igc_reloc_struct_ptr function in psi/igc.c.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=671fd59eb657743aa86fbc1895cb15872a317caa,,,,,,,
CVE-2009-0946,https://www.cvedetails.com/cve/CVE-2009-0946/,CWE-189,,Exec Code Overflow,2009-04-16,2017-09-28,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=a18788b14db60ae3673f932249cd02d33a227c4e,,,,,,,
CVE-2009-0946,https://www.cvedetails.com/cve/CVE-2009-0946/,CWE-189,,Exec Code Overflow,2009-04-16,2017-09-28,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=79972af4f0485a11dcb19551356c45245749fc5b,,,,,,,
CVE-2009-0946,https://www.cvedetails.com/cve/CVE-2009-0946/,CWE-189,,Exec Code Overflow,2009-04-16,2017-09-28,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0545ec1ca36b27cb928128870a83e5f668980bc5,,,,,,,
CVE-2017-11628,https://www.cvedetails.com/cve/CVE-2017-11628/,CWE-119,,DoS Overflow,2017-07-25,2018-05-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, a stack-based buffer overflow in the zend_ini_do_op() function in Zend/zend_ini_parser.c could cause a denial of service or potentially allow executing code. NOTE: this is only relevant for PHP applications that accept untrusted input (instead of the system's php.ini file) for the parse_ini_string or parse_ini_file function, e.g., a web application for syntax validation of php.ini directives.",,php,https://git.php.net/?p=php-src.git;a=commit;h=5f8380d33e648964d2d5140f329cf2d4c443033c,,,,,,,
CVE-2017-11628,https://www.cvedetails.com/cve/CVE-2017-11628/,CWE-119,,DoS Overflow,2017-07-25,2018-05-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, a stack-based buffer overflow in the zend_ini_do_op() function in Zend/zend_ini_parser.c could cause a denial of service or potentially allow executing code. NOTE: this is only relevant for PHP applications that accept untrusted input (instead of the system's php.ini file) for the parse_ini_string or parse_ini_file function, e.g., a web application for syntax validation of php.ini directives.",,php,https://git.php.net/?p=php-src.git;a=commit;h=05255749139b3686c8a6a58ee01131ac0047465e,,,,,,,
CVE-2013-1643,https://www.cvedetails.com/cve/CVE-2013-1643/,CWE-200,,+Info,2013-03-06,2014-01-27,5.0,None,Remote,Low,Not required,Partial,None,None,"The SOAP parser in PHP before 5.3.23 and 5.4.x before 5.4.13 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-1824.",,php,https://git.php.net/?p=php-src.git;a=commit;h=8e76d0404b7f664ee6719fd98f0483f0ac4669d6,,,,,,,
CVE-2013-1635,https://www.cvedetails.com/cve/CVE-2013-1635/,CWE-264,,Bypass,2013-03-06,2014-01-27,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"ext/soap/soap.c in PHP before 5.3.22 and 5.4.x before 5.4.13 does not validate the relationship between the soap.wsdl_cache_dir directive and the open_basedir directive, which allows remote attackers to bypass intended access restrictions by triggering the creation of cached SOAP WSDL files in an arbitrary directory.",,php,https://git.php.net/?p=php-src.git;a=commitdiff;h=702b436ef470cc02f8e2cc21f2fadeee42103c74,,,,,,,
CVE-2018-14656,https://www.cvedetails.com/cve/CVE-2018-14656/,CWE-20,,,2018-10-08,2019-10-09,2.1,None,Local,Low,Not required,Partial,None,None,A missing address check in the callers of the show_opcodes() in the Linux kernel allows an attacker to dump the kernel memory at an arbitrary kernel address into the dmesg log.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=342db04ae71273322f0011384a9ed414df8bdae4,,,,,,,
CVE-2018-14646,https://www.cvedetails.com/cve/CVE-2018-14646/,CWE-476,,DoS,2018-11-26,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,The Linux kernel before 4.15-rc8 was found to be vulnerable to a NULL pointer dereference bug in the __netlink_ns_capable() function in the net/netlink/af_netlink.c file. A local attacker could exploit this when a net namespace with a netnsid is assigned to cause a kernel panic and a denial of service.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f428fe4a04cc339166c8bbd489789760de3a0cee,,,,,,,
CVE-2018-14641,https://www.cvedetails.com/cve/CVE-2018-14641/,CWE-20,,,2018-09-18,2019-10-09,7.1,None,Remote,Medium,Not required,None,None,Complete,"A security flaw was found in the ip_frag_reasm() function in net/ipv4/ip_fragment.c in the Linux kernel from 4.19-rc1 to 4.19-rc3 inclusive, which can cause a later system crash in ip_do_fragment(). With certain non-default, but non-rare, configuration of a victim host, an attacker can trigger this crash remotely, thus leading to a remote denial-of-service.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5d407b071dc369c26a38398326ee2be53651cfe4,,,,,,,
CVE-2013-1591,https://www.cvedetails.com/cve/CVE-2013-1591/,CWE-189,,Overflow,2013-01-31,2019-05-22,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"Stack-based buffer overflow in libpixman, as used in Pale Moon before 15.4 and possibly other products, has unspecified impact and context-dependent attack vectors.  NOTE: this issue might be resultant from an integer overflow in the fast_composite_scaled_bilinear function in pixman-inlines.h, which triggers an infinite loop.",,pixman,https://cgit.freedesktop.org/pixman/commit/?id=de60e2e0e3eb6084f8f14b63f25b3cbfb012943f,,,,,,,
CVE-2018-14633,https://www.cvedetails.com/cve/CVE-2018-14633/,CWE-119,,Overflow,2018-09-24,2018-11-27,8.3,None,Remote,Medium,Not required,Partial,Partial,Complete,"A security flaw was found in the chap_server_compute_md5() function in the ISCSI target code in the Linux kernel in a way an authentication request from an ISCSI initiator is processed. An unauthenticated remote attacker can cause a stack buffer overflow and smash up to 17 bytes of the stack. The attack requires the iSCSI target to be enabled on the victim host. Depending on how the target's code was built (i.e. depending on a compiler, compile flags and hardware architecture) an attack may lead to a system crash and thus to a denial-of-service or possibly to a non-authorized access to data exported by an iSCSI target. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although we believe it is highly unlikely. Kernel versions 4.18.x, 4.14.x and 3.10.x are believed to be vulnerable.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git/commit/?h=4.19/scsi-fixes&id=1816494330a83f2a064499d8ed2797045641f92c,,,,,,,
CVE-2018-14633,https://www.cvedetails.com/cve/CVE-2018-14633/,CWE-119,,Overflow,2018-09-24,2018-11-27,8.3,None,Remote,Medium,Not required,Partial,Partial,Complete,"A security flaw was found in the chap_server_compute_md5() function in the ISCSI target code in the Linux kernel in a way an authentication request from an ISCSI initiator is processed. An unauthenticated remote attacker can cause a stack buffer overflow and smash up to 17 bytes of the stack. The attack requires the iSCSI target to be enabled on the victim host. Depending on how the target's code was built (i.e. depending on a compiler, compile flags and hardware architecture) an attack may lead to a system crash and thus to a denial-of-service or possibly to a non-authorized access to data exported by an iSCSI target. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although we believe it is highly unlikely. Kernel versions 4.18.x, 4.14.x and 3.10.x are believed to be vulnerable.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git/commit/?h=4.19/scsi-fixes&id=8c39e2699f8acb2e29782a834e56306da24937fe,,,,,,,
CVE-2018-14631,https://www.cvedetails.com/cve/CVE-2018-14631/,CWE-79,,XSS,2018-09-17,2019-10-09,4.3,None,Remote,Medium,Not required,None,Partial,None,"moodle before versions 3.5.2, 3.4.5, 3.3.8 is vulnerable to a boost theme - blog search GET parameter insufficiently filtered. The breadcrumb navigation provided by Boost theme when displaying search results of a blog were insufficiently filtered, which could result in reflected XSS if a user followed a malicious link containing JavaScript in the search parameter.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-62857,,,,,,,
CVE-2018-14630,https://www.cvedetails.com/cve/CVE-2018-14630/,CWE-94,,Exec Code,2018-09-17,2019-10-09,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"moodle before versions 3.5.2, 3.4.5, 3.3.8, 3.1.14 is vulnerable to an XML import of ddwtos could lead to intentional remote code execution. When importing legacy 'drag and drop into text' (ddwtos) type quiz questions, it was possible to inject and execute PHP code from within the imported questions, either intentionally or by importing questions from an untrusted source.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-62880,,,,,,,
CVE-2018-14622,https://www.cvedetails.com/cve/CVE-2018-14622/,CWE-769,,,2018-08-30,2019-10-09,5.0,None,Remote,Low,Not required,None,None,Partial,"A null-pointer dereference vulnerability was found in libtirpc before version 0.3.3-rc3. The return value of makefd_xprt() was not checked in all instances, which could lead to a crash when the server exhausted the maximum number of available file descriptors. A remote attacker could cause an rpc-based application to crash by flooding it with new connections.",C,linux-nfs,http://git.linux-nfs.org/?p=steved/libtirpc.git;a=commit;h=1c77f7a869bdea2a34799d774460d1f9983d45f0,1c77f7a869bdea2a34799d774460d1f9983d45f0,56ac97c7e9b4ae541b2d0cfdb0845b409d09d7e7,"@@ -337,6 +337,8 @@ again:
         */
 
        newxprt = makefd_xprt(sock, r->sendsize, r->recvsize);
+       if (!newxprt)
+               return (FALSE);
 
        if (!__rpc_set_netbuf(&newxprt->xp_rtaddr, &addr, len))
                return (FALSE);",http://git.linux-nfs.org/?p=steved/libtirpc.git;a=blob;f=src/svc_vc.c;h=6848c098f055b927f6db6dc06ef7cf277d283b51;hb=6848c098f055b927f6db6dc06ef7cf277d283b51,http://git.linux-nfs.org/?p=steved/libtirpc.git;a=blob;f=src/svc_vc.c;h=3cddcbceebaef9122aca51bb7b27a3f72b5ae16e;hb=3cddcbceebaef9122aca51bb7b27a3f72b5ae16e,,
CVE-2018-14621,https://www.cvedetails.com/cve/CVE-2018-14621/,CWE-835,,,2018-08-30,2019-10-09,7.8,None,Remote,Low,Not required,None,None,Complete,"An infinite loop vulnerability was found in libtirpc before version 1.0.2-rc2. With the port to using poll rather than select, exhaustion of file descriptors would cause the server to enter an infinite loop, consuming a large amount of CPU time and denying service to other clients until restarted.",,linux-nfs,http://git.linux-nfs.org/?p=steved/libtirpc.git;a=commit;h=fce98161d9815ea016855d9f00274276452c2c4b,,,,,,,
CVE-2018-14619,https://www.cvedetails.com/cve/CVE-2018-14619/,CWE-20,,,2018-08-30,2019-10-09,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"A flaw was found in the crypto subsystem of the Linux kernel before version kernel-4.15-rc4. The ""null skcipher"" was being dropped when each af_alg_ctx was freed instead of when the aead_tfm was freed. This can cause the null skcipher to be freed while it is still in use leading to a local user being able to crash the system or possibly escalate privileges.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b32a7dc8aef1882fbf983eb354837488cc9d54dc,,,,,,,
CVE-2018-14600,https://www.cvedetails.com/cve/CVE-2018-14600/,CWE-787,,Exec Code,2018-08-24,2019-08-06,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c interprets a variable as signed instead of unsigned, resulting in an out-of-bounds write (of up to 128 bytes), leading to DoS or remote code execution.",,libx11,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,,,,,,,
CVE-2018-14599,https://www.cvedetails.com/cve/CVE-2018-14599/,CWE-682,,,2018-08-24,2019-08-06,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c is vulnerable to an off-by-one error caused by malicious server responses, leading to DoS or possibly unspecified other impact.",,libx11,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b469da1430cdcee06e31c6251b83aede072a1ff0,,,,,,,
CVE-2018-14598,https://www.cvedetails.com/cve/CVE-2018-14598/,CWE-20,,Overflow,2018-08-24,2019-08-06,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in XListExtensions in ListExt.c in libX11 through 1.6.5. A malicious server can send a reply in which the first string overflows, causing a variable to be set to NULL that will be freed later on, leading to DoS (segmentation fault).",,libx11,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=e83722768fd5c467ef61fa159e8c6278770b45c2,,,,,,,
CVE-2019-11360,https://www.cvedetails.com/cve/CVE-2019-11360/,CWE-119,,Exec Code Overflow,2019-07-12,2019-07-15,4.3,None,Remote,Medium,Not required,None,None,Partial,A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.,,netfilter,https://git.netfilter.org/iptables/commit/iptables/xshared.c?id=2ae1099a42e6a0f06de305ca13a842ac83d4683e,,,,,,,
CVE-2019-11323,https://www.cvedetails.com/cve/CVE-2019-11323/,CWE-310,,,2019-05-09,2019-05-10,4.3,None,Remote,Medium,Not required,Partial,None,None,"HAProxy before 1.9.7 mishandles a reload with rotated keys, which triggers use of uninitialized, and very predictable, HMAC keys. This is related to an include/types/ssl_sock.h error.",,haproxy,https://git.haproxy.org/?p=haproxy.git;a=commit;h=8ef706502aa2000531d36e4ac56dbdc7c30f718d,,,,,,,
CVE-2015-2348,https://www.cvedetails.com/cve/CVE-2015-2348/,CWE-264,,Bypass,2015-03-30,2018-10-30,5.0,None,Remote,Low,Not required,None,Partial,None,"The move_uploaded_file implementation in ext/standard/basic_functions.c in PHP before 5.4.39, 5.5.x before 5.5.23, and 5.6.x before 5.6.7 truncates a pathname upon encountering a \x00 character, which allows remote attackers to bypass intended extension restrictions and create files with unexpected names via a crafted second argument.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",,php,https://git.php.net/?p=php-src.git;a=commit;h=1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,,,,,,,
CVE-2015-2331,https://www.cvedetails.com/cve/CVE-2015-2331/,CWE-189,,DoS Exec Code Overflow,2015-03-30,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in the _zip_cdir_new function in zip_dirent.c in libzip 0.11.2 and earlier, as used in the ZIP extension in PHP before 5.4.39, 5.5.x before 5.5.23, and 5.6.x before 5.6.7 and other products, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a ZIP archive that contains many entries, leading to a heap-based buffer overflow.",,php,https://git.php.net/?p=php-src.git;a=commit;h=ef8fc4b53d92fbfcd8ef1abbd6f2f5fe2c4a11e5,,,,,,,
CVE-2015-2301,https://www.cvedetails.com/cve/CVE-2015-2301/,,,DoS,2015-03-30,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Use-after-free vulnerability in the phar_rename_archive function in phar_object.c in PHP before 5.5.22 and 5.6.x before 5.6.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an attempted renaming of a Phar archive to the name of an existing file.,,php,https://git.php.net/?p=php-src.git;a=commit;h=b2cf3f064b8f5efef89bb084521b61318c71781b,,,,,,,
CVE-2015-2273,https://www.cvedetails.com/cve/CVE-2015-2273/,CWE-79,,XSS,2015-06-01,2015-06-02,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in mod/quiz/report/statistics/statistics_question_table.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 allows remote authenticated users to inject arbitrary web script or HTML by leveraging the student role for a crafted quiz response.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49364,,,,,,,
CVE-2015-2272,https://www.cvedetails.com/cve/CVE-2015-2272/,CWE-264,,Bypass,2015-06-01,2017-03-23,4.0,None,Remote,Low,Single system,None,Partial,None,"login/token.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 allows remote authenticated users to bypass a forced-password-change requirement by creating a web-services token.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48691,,,,,,,
CVE-2015-2271,https://www.cvedetails.com/cve/CVE-2015-2271/,CWE-264,,Bypass,2015-06-01,2015-06-02,4.0,None,Remote,Low,Single system,None,Partial,None,"tag/user.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 does not consider the moodle/tag:flag capability before proceeding with a flaginappropriate action, which allows remote authenticated users to bypass intended access restrictions via the ""Flag as inappropriate"" feature.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49084,,,,,,,
CVE-2015-2270,https://www.cvedetails.com/cve/CVE-2015-2270/,CWE-17,,+Info,2015-06-01,2015-06-02,4.3,None,Remote,Medium,Not required,Partial,None,None,"lib/moodlelib.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4, when the theme uses the blocks-regions feature, establishes the course state at an incorrect point in the login-validation process, which allows remote attackers to obtain sensitive course information via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48804,,,,,,,
CVE-2015-2269,https://www.cvedetails.com/cve/CVE-2015-2269/,CWE-79,,XSS,2015-06-01,2015-06-02,3.5,None,Remote,Medium,Single system,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in lib/javascript-static.js in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 allow remote authenticated users to inject arbitrary web script or HTML via a (1) alt or (2) title attribute in an IMG element.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49144,,,,,,,
CVE-2015-2268,https://www.cvedetails.com/cve/CVE-2015-2268/,CWE-399,,DoS,2015-06-01,2015-06-02,6.8,None,Remote,Low,Single system,None,None,Complete,"filter/urltolink/filter.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 allows remote authenticated users to cause a denial of service (CPU consumption or partial outage) via a crafted string that is matched against an improper regular expression.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-38466,,,,,,,
CVE-2015-2267,https://www.cvedetails.com/cve/CVE-2015-2267/,CWE-284,,Bypass,2015-06-01,2015-06-02,4.0,None,Remote,Low,Single system,None,Partial,None,"mdeploy.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 allows remote authenticated users to bypass intended access restrictions and extract archives to arbitrary directories via a crafted dataroot value.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49087,,,,,,,
CVE-2015-2266,https://www.cvedetails.com/cve/CVE-2015-2266/,CWE-200,,+Info,2015-06-01,2015-06-02,4.0,None,Remote,Low,Single system,Partial,None,None,"message/index.php in Moodle through 2.5.9, 2.6.x before 2.6.9, 2.7.x before 2.7.6, and 2.8.x before 2.8.4 does not consider the moodle/site:readallmessages capability before accessing arbitrary conversations, which allows remote authenticated users to obtain sensitive personal-contact and unread-message-count information via a modified URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49204,,,,,,,
CVE-2009-0586,https://www.cvedetails.com/cve/CVE-2009-0586/,CWE-189,,Exec Code Overflow,2009-03-14,2018-10-10,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in the gst_vorbis_tag_add_coverart function (gst-libs/gst/tag/gstvorbistag.c) in vorbistag in gst-plugins-base (aka gstreamer-plugins-base) before 0.10.23 in GStreamer allows context-dependent attackers to execute arbitrary code via a crafted COVERART tag that is converted from a base64 representation, which triggers a heap-based buffer overflow.",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-base/commit/?id=566583e87147f774e7fc4c78b5f7e61d427e40a9,,,,,,,
CVE-2019-11190,https://www.cvedetails.com/cve/CVE-2019-11190/,CWE-362,,Bypass,2019-04-11,2019-06-07,4.7,None,Local,Medium,Not required,Complete,None,None,"The Linux kernel before 4.8 allows local users to bypass ASLR on setuid programs (such as /bin/su) because install_exec_creds() is called too late in load_elf_binary() in fs/binfmt_elf.c, and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/stable/stable-queue.git/commit/?id=e1676b55d874a43646e8b2c46d87f2f3e45516ff,,,,,,,
CVE-2019-11190,https://www.cvedetails.com/cve/CVE-2019-11190/,CWE-362,,Bypass,2019-04-11,2019-06-07,4.7,None,Local,Medium,Not required,Complete,None,None,"The Linux kernel before 4.8 allows local users to bypass ASLR on setuid programs (such as /bin/su) because install_exec_creds() is called too late in load_elf_binary() in fs/binfmt_elf.c, and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/stable/stable-queue.git/commit/?id=a5b5352558f6808db0589644ea5401b3e3148a0d,,,,,,,
CVE-2017-11147,https://www.cvedetails.com/cve/CVE-2017-11147/,CWE-125,,,2017-07-10,2019-10-02,6.4,None,Remote,Low,Not required,Partial,None,Partial,"In PHP before 5.6.30 and 7.x before 7.0.15, the PHAR archive handler could be used by attackers supplying malicious archive files to crash the PHP interpreter or potentially disclose information due to a buffer over-read in the phar_parse_pharfile function in ext/phar/phar.c.",,php,https://git.php.net/?p=php-src.git;a=commit;h=e5246580a85f031e1a3b8064edbaa55c1643a451,,,,,,,
CVE-2017-11145,https://www.cvedetails.com/cve/CVE-2017-11145/,CWE-200,,+Info,2017-07-10,2018-05-03,5.0,None,Remote,Low,Not required,Partial,None,None,"In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, an error in the date extension's timelib_meridian parsing code could be used by attackers able to supply date strings to leak information from the interpreter, related to ext/date/lib/parse_date.c out-of-bounds reads affecting the php_parse_date function. NOTE: the correct fix is in the e8b7698f5ee757ce2c8bd10a192a491a498f891c commit, not the bd77ac90d3bdf31ce2a5251ad92e9e75 gist.",,php,https://git.php.net/?p=php-src.git;a=commit;h=e8b7698f5ee757ce2c8bd10a192a491a498f891c,,,,,,,
CVE-2017-11144,https://www.cvedetails.com/cve/CVE-2017-11144/,CWE-754,,,2017-07-10,2018-05-03,5.0,None,Remote,Low,Not required,None,None,Partial,"In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, the openssl extension PEM sealing code did not check the return value of the OpenSSL sealing function, which could lead to a crash of the PHP interpreter, related to an interpretation conflict for a negative number in ext/openssl/openssl.c, and an OpenSSL documentation omission.",,php,https://git.php.net/?p=php-src.git;a=commit;h=73cabfedf519298e1a11192699f44d53c529315e,,,,,,,
CVE-2017-11144,https://www.cvedetails.com/cve/CVE-2017-11144/,CWE-754,,,2017-07-10,2018-05-03,5.0,None,Remote,Low,Not required,None,None,Partial,"In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, the openssl extension PEM sealing code did not check the return value of the OpenSSL sealing function, which could lead to a crash of the PHP interpreter, related to an interpretation conflict for a negative number in ext/openssl/openssl.c, and an OpenSSL documentation omission.",,php,https://git.php.net/?p=php-src.git;a=commit;h=91826a311dd37f4c4e5d605fa7af331e80ddd4c3,,,,,,,
CVE-2017-11144,https://www.cvedetails.com/cve/CVE-2017-11144/,CWE-754,,,2017-07-10,2018-05-03,5.0,None,Remote,Low,Not required,None,None,Partial,"In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, the openssl extension PEM sealing code did not check the return value of the OpenSSL sealing function, which could lead to a crash of the PHP interpreter, related to an interpretation conflict for a negative number in ext/openssl/openssl.c, and an OpenSSL documentation omission.",,php,https://git.php.net/?p=php-src.git;a=commit;h=89637c6b41b510c20d262c17483f582f115c66d6,,,,,,,
CVE-2017-11143,https://www.cvedetails.com/cve/CVE-2017-11143/,CWE-502,,,2017-07-10,2018-05-03,5.0,None,Remote,Low,Not required,None,None,Partial,"In PHP before 5.6.31, an invalid free in the WDDX deserialization of boolean parameters could be used by attackers able to inject XML for deserialization to crash the PHP interpreter, related to an invalid free for an empty boolean element in ext/wddx/wddx.c.",,php,https://git.php.net/?p=php-src.git;a=commit;h=2aae60461c2ff7b7fbcdd194c789ac841d0747d7,,,,,,,
CVE-2018-14036,https://www.cvedetails.com/cve/CVE-2018-14036/,CWE-22,,Dir. Trav.,2018-07-13,2018-09-06,4.0,None,Remote,Low,Single system,Partial,None,None,Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.,,accountsservice,https://cgit.freedesktop.org/accountsservice/commit/?id=f9abd359f71a5bce421b9ae23432f539a067847a,,,,,,,
CVE-2015-2059,https://www.cvedetails.com/cve/CVE-2015-2059/,CWE-119,,Overflow,2015-08-12,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The stringprep_utf8_to_ucs4 function in libin before 1.31, as used in jabberd2, allows context-dependent attackers to read system memory and possibly have other unspecified impact via invalid UTF-8 characters in a string, which triggers an out-of-bounds read.",,savannah,https://git.savannah.gnu.org/cgit/libidn.git/commit/?id=2e97c279,,,,,,,
CVE-2018-13988,https://www.cvedetails.com/cve/CVE-2018-13988/,CWE-125,,DoS Mem. Corr.,2018-07-25,2019-04-25,4.3,None,Remote,Medium,Not required,None,None,Partial,"Poppler through 0.62 contains an out of bounds read vulnerability due to an incorrect memory access that is not mapped in its memory space, as demonstrated by pdfunite. This can result in memory corruption and denial of service. This may be exploitable when a victim opens a specially crafted PDF file.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=004e3c10df0abda214f0c293f9e269fdd979c5ee,,,,,,,
CVE-2017-10972,https://www.cvedetails.com/cve/CVE-2017-10972/,CWE-665,,,2017-07-06,2019-10-02,4.0,None,Remote,Low,Single system,Partial,None,None,Uninitialized data in endianness conversion in the XEvent handling of the X.Org X Server before 2017-06-19 allowed authenticated malicious users to access potentially privileged data from the X server.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=05442de962d3dc624f79fc1a00eca3ffc5489ced,,,,,,,
CVE-2017-10971,https://www.cvedetails.com/cve/CVE-2017-10971/,CWE-119,,Exec Code Overflow,2017-07-06,2017-11-03,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=215f894965df5fb0bb45b107d84524e700d2073c,,,,,,,
CVE-2017-10971,https://www.cvedetails.com/cve/CVE-2017-10971/,CWE-119,,Exec Code Overflow,2017-07-06,2017-11-03,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=8caed4df36b1f802b4992edcfd282cbeeec35d9d,,,,,,,
CVE-2017-10971,https://www.cvedetails.com/cve/CVE-2017-10971/,CWE-119,,Exec Code Overflow,2017-07-06,2017-11-03,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=ba336b24052122b136486961c82deac76bbde455,,,,,,,
CVE-2009-0397,https://www.cvedetails.com/cve/CVE-2009-0397/,CWE-119,,Exec Code Overflow,2009-02-03,2018-10-11,9.3,Admin,Remote,Medium,Not required,Complete,Complete,Complete,"Heap-based buffer overflow in the qtdemux_parse_samples function in gst/qtdemux/qtdemux.c in GStreamer Good Plug-ins (aka gst-plugins-good) 0.10.9 through 0.10.11, and GStreamer Plug-ins (aka gstreamer-plugins) 0.8.5, might allow remote attackers to execute arbitrary code via crafted Time-to-sample (aka stts) atom data in a malformed QuickTime media .mov file.",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=bdc20b9baf13564d9a061343416395f8f9a92b53,,,,,,,
CVE-2009-0387,https://www.cvedetails.com/cve/CVE-2009-0387/,CWE-119,,DoS Exec Code Overflow,2009-02-02,2018-10-11,9.3,Admin,Remote,Medium,Not required,Complete,Complete,Complete,"Array index error in the qtdemux_parse_samples function in gst/qtdemux/qtdemux.c in GStreamer Good Plug-ins (aka gst-plugins-good) 0.10.9 through 0.10.11 allows remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via crafted Sync Sample (aka stss) atom data in a malformed QuickTime media .mov file, related to ""mark keyframes.""",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=bdc20b9baf13564d9a061343416395f8f9a92b53,,,,,,,
CVE-2009-0386,https://www.cvedetails.com/cve/CVE-2009-0386/,CWE-119,,Exec Code Overflow,2009-02-02,2018-10-11,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,Heap-based buffer overflow in the qtdemux_parse_samples function in gst/qtdemux/qtdemux.c in GStreamer Good Plug-ins (aka gst-plugins-good) 0.10.9 through 0.10.11 might allow remote attackers to execute arbitrary code via crafted Composition Time To Sample (ctts) atom data in a malformed QuickTime media .mov file.,,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=bdc20b9baf13564d9a061343416395f8f9a92b53,,,,,,,
CVE-2015-1794,https://www.cvedetails.com/cve/CVE-2015-1794/,CWE-189,,DoS,2015-12-06,2017-09-13,5.0,None,Remote,Low,Not required,None,None,Partial,The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=ada57746b6b80beae73111fe1291bf8dd89af91c,,,,,,,
CVE-2015-1793,https://www.cvedetails.com/cve/CVE-2015-1793/,CWE-254,,,2015-07-09,2018-11-30,6.4,None,Remote,Low,Not required,Partial,Partial,None,"The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=9a0db453ba017ebcaccbee933ee6511a9ae4d1c8,,,,,,,
CVE-2015-1787,https://www.cvedetails.com/cve/CVE-2015-1787/,CWE-20,,DoS,2015-03-19,2018-11-29,2.6,None,Remote,High,Not required,None,None,Partial,"The ssl3_get_client_key_exchange function in s3_srvr.c in OpenSSL 1.0.2 before 1.0.2a, when client authentication and an ephemeral Diffie-Hellman ciphersuite are enabled, allows remote attackers to cause a denial of service (daemon crash) via a ClientKeyExchange message with a length of zero.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=b19d8143212ae5fbc9cebfd51c01f802fabccd33,,,,,,,
CVE-2011-0465,https://www.cvedetails.com/cve/CVE-2011-0465/,CWE-20,,Exec Code,2011-04-08,2017-08-16,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,xrdb.c in xrdb before 1.0.9 in X.Org X11R7.6 and earlier allows remote attackers to execute arbitrary commands via shell metacharacters in a hostname obtained from a (1) DHCP or (2) XDMCP message.,,xrdb,https://cgit.freedesktop.org/xorg/app/xrdb/commit/?id=1027d5df07398c1507fb1fe3a9981aa6b4bc3a56,,,,,,,
CVE-2015-1493,https://www.cvedetails.com/cve/CVE-2015-1493/,CWE-22,,Dir. Trav.,2015-06-01,2015-06-02,6.8,None,Remote,Low,Single system,Complete,None,None,"Directory traversal vulnerability in the min_get_slash_argument function in lib/configonlylib.php in Moodle through 2.5.9, 2.6.x before 2.6.8, 2.7.x before 2.7.5, and 2.8.x before 2.8.3 allows remote authenticated users to read arbitrary files via a .. (dot dot) in the file parameter, as demonstrated by reading PHP scripts.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48980,,,,,,,
CVE-2015-1493,https://www.cvedetails.com/cve/CVE-2015-1493/,CWE-22,,Dir. Trav.,2015-06-01,2015-06-02,6.8,None,Remote,Low,Single system,Complete,None,None,"Directory traversal vulnerability in the min_get_slash_argument function in lib/configonlylib.php in Moodle through 2.5.9, 2.6.x before 2.6.8, 2.7.x before 2.7.5, and 2.8.x before 2.8.3 allows remote authenticated users to read arbitrary files via a .. (dot dot) in the file parameter, as demonstrated by reading PHP scripts.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=af9a7937cc085f96bdbc4724cadec6eeae0242fc,,,,,,,
CVE-2015-1352,https://www.cvedetails.com/cve/CVE-2015-1352/,,,DoS,2015-03-30,2019-10-09,5.0,None,Remote,Low,Not required,None,None,Partial,"The build_tablename function in pgsql.c in the PostgreSQL (aka pgsql) extension in PHP through 5.6.7 does not validate token extraction for table names, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted name.",,php,https://git.php.net/?p=php-src.git;a=commit;h=124fb22a13fafa3648e4e15b4f207c7096d8155e,,,,,,,
CVE-2015-1351,https://www.cvedetails.com/cve/CVE-2015-1351/,CWE-416,,DoS,2015-03-30,2016-12-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Use-after-free vulnerability in the _zend_shared_memdup function in zend_shared_alloc.c in the OPcache extension in PHP through 5.6.7 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,,php,https://git.php.net/?p=php-src.git;a=commit;h=777c39f4042327eac4b63c7ee87dc1c7a09a3115,,,,,,,
CVE-2015-1345,https://www.cvedetails.com/cve/CVE-2015-1345/,CWE-119,,DoS Overflow,2015-02-12,2018-10-30,2.1,None,Local,Low,Not required,None,None,Partial,The bmexec_trans function in kwset.c in grep 2.19 through 2.21 allows local users to cause a denial of service (out-of-bounds heap read and crash) via crafted input when using the -F option.,,savannah,https://git.savannah.gnu.org/cgit/grep.git/commit/?id=83a95bd8c8561875b948cadd417c653dbe7ef2e2,,,,,,,
CVE-2015-1196,https://www.cvedetails.com/cve/CVE-2015-1196/,CWE-59,,,2015-01-21,2018-10-30,4.3,None,Remote,Medium,Not required,None,Partial,None,GNU patch 2.7.1 allows remote attackers to write to arbitrary files via a symlink attack in a patch file.,,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=4e9269a5fc1fe80a1095a92593dd85db871e1fd3,,,,,,,
CVE-2018-13095,https://www.cvedetails.com/cve/CVE-2018-13095/,CWE-476,,DoS Mem. Corr.,2018-07-03,2019-06-04,4.3,None,Remote,Medium,Not required,None,None,Partial,"An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork.",,linux kernel,https://git.kernel.org/pub/scm/fs/xfs/xfs-linux.git/commit/?h=for-next&id=23fcb3340d033d9f081e21e6c12c2db7eaa541d3,,,,,,,
CVE-2018-13093,https://www.cvedetails.com/cve/CVE-2018-13093/,CWE-476,,,2018-07-03,2019-08-06,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in fs/xfs/xfs_icache.c in the Linux kernel through 4.17.3. There is a NULL pointer dereference and panic in lookup_slow() on a NULL inode->i_ops pointer when doing pathwalks on a corrupted xfs image. This occurs because of a lack of proper validation that cached inodes are free during allocation.,,linux kernel,https://git.kernel.org/pub/scm/fs/xfs/xfs-linux.git/commit/?h=for-next&id=afca6c5b2595fc44383919fba740c194b0b76aff,,,,,,,
CVE-2011-0064,https://www.cvedetails.com/cve/CVE-2011-0064/,,,DoS Exec Code,2011-03-07,2017-08-16,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The hb_buffer_ensure function in hb-buffer.c in HarfBuzz, as used in Pango 1.28.3, Firefox, and other products, does not verify that memory reallocations succeed, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly execute arbitrary code via crafted OpenType font data that triggers use of an incorrect index.",,harfbuzz,https://cgit.freedesktop.org/harfbuzz/commit/?id=a6a79df5fe2ed2cd307e7a991346faee164e70d9,,,,,,,
CVE-2018-13053,https://www.cvedetails.com/cve/CVE-2018-13053/,CWE-190,,Overflow,2018-07-02,2019-04-23,2.1,None,Local,Low,Not required,None,None,Partial,The alarm_timer_nsleep function in kernel/time/alarmtimer.c in the Linux kernel through 4.17.3 has an integer overflow via a large relative timeout because ktime_add_safe is not used.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=5f936e19cc0ef97dbe3a56e9498922ad5ba1edef,,,,,,,
CVE-2019-9923,https://www.cvedetails.com/cve/CVE-2019-9923/,CWE-476,,,2019-03-22,2019-04-24,5.0,None,Remote,Low,Not required,None,None,Partial,pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.,,savannah,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=cb07844454d8cc9fb21f53ace75975f91185a120,,,,,,,
CVE-2019-9857,https://www.cvedetails.com/cve/CVE-2019-9857/,CWE-399,,DoS,2019-03-21,2019-04-09,4.9,None,Local,Low,Not required,None,None,Complete,"In the Linux kernel through 5.0.2, the function inotify_update_existing_watch() in fs/notify/inotify/inotify_user.c neglects to call fsnotify_put_mark() with IN_MASK_CREATE after fsnotify_find_mark(), which will cause a memory leak (aka refcount leak). Finally, this will cause a denial of service.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs.git/commit/?h=fsnotify&id=62c9d2674b31d4c8a674bee86b7edc6da2803aea,,,,,,,
CVE-2017-9835,https://www.cvedetails.com/cve/CVE-2017-9835/,CWE-190,,DoS Overflow,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The gs_alloc_ref_array function in psi/ialloc.c in Artifex Ghostscript 9.21 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted PostScript document. This is related to a lack of an integer overflow check in base/gsalloc.c.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=cfde94be1d4286bc47633c6e6eaf4e659bd78066,,,,,,,
CVE-2015-0851,https://www.cvedetails.com/cve/CVE-2015-0851/,CWE-189,,DoS,2015-08-12,2016-11-28,5.0,None,Remote,Low,Not required,None,None,Partial,"XMLTooling-C before 1.5.5, as used in OpenSAML-C and Shibboleth Service Provider (SP), does not properly handle integer conversion exceptions, which allows remote attackers to cause a denial of service (crash) via schema-invalid XML data.",,shibboleth,https://git.shibboleth.net/view/?p=cpp-xmltooling.git;a=commitdiff;h=2d795c731e6729309044607154978696a87fd900,,,,,,,
CVE-2017-9740,https://www.cvedetails.com/cve/CVE-2017-9740/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The xps_decode_font_char_imp function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=961b10cdd71403072fb99401a45f3bef6ce53626,,,,,,,
CVE-2017-9739,https://www.cvedetails.com/cve/CVE-2017-9739/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The Ins_JMPR function in base/ttinterp.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c501a58f8d5650c8ba21d447c0d6f07eafcb0f15,,,,,,,
CVE-2017-9727,https://www.cvedetails.com/cve/CVE-2017-9727/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The gx_ttfReader__Read function in base/gxttfb.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=937ccd17ac65935633b2ebc06cb7089b91e17e6b,,,,,,,
CVE-2017-9726,https://www.cvedetails.com/cve/CVE-2017-9726/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The Ins_MDRP function in base/ttinterp.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=7755e67116e8973ee0e3b22d653df026a84fa01b,,,,,,,
CVE-2013-0292,https://www.cvedetails.com/cve/CVE-2013-0292/,CWE-20,,+Priv,2013-03-05,2017-08-28,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"The dbus_g_proxy_manager_filter function in dbus-gproxy in Dbus-glib before 0.100.1 does not properly verify the sender of NameOwnerChanged signals, which allows local users to gain privileges via a spoofed signal.",,dbus,https://cgit.freedesktop.org/dbus/dbus-glib/commit/?id=166978a09cf5edff4028e670b6074215a4c75eca,,,,,,,
CVE-2017-9620,https://www.cvedetails.com/cve/CVE-2017-9620/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The xps_select_font_encoding function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document, related to the xps_encode_font_char_imp function.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3ee55637480d5e319a5de0481b01c3346855cbc9,,,,,,,
CVE-2017-9619,https://www.cvedetails.com/cve/CVE-2017-9619/,CWE-119,,DoS Overflow,2017-07-26,2019-04-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The xps_true_callback_glyph_name function in xps/xpsttf.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (Segmentation Violation and application crash) via a crafted file.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c53183d4e7103e87368b7cfa15367a47d559e323,,,,,,,
CVE-2017-9618,https://www.cvedetails.com/cve/CVE-2017-9618/,CWE-119,,DoS Overflow,2017-07-26,2019-04-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The xps_load_sfnt_name function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3c2aebbedd37fab054e80f2e315de07d7e9b5bdb,,,,,,,
CVE-2017-9612,https://www.cvedetails.com/cve/CVE-2017-9612/,CWE-416,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The Ins_IP function in base/ttinterp.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=98f6da60b9d463c617e631fc254cf6d66f2e8e3c,,,,,,,
CVE-2017-9611,https://www.cvedetails.com/cve/CVE-2017-9611/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The Ins_MIRP function in base/ttinterp.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c7c55972758a93350882c32147801a3485b010fe,,,,,,,
CVE-2017-9610,https://www.cvedetails.com/cve/CVE-2017-9610/,CWE-125,,DoS,2017-07-26,2019-10-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The xps_load_sfnt_name function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=d2ab84732936b6e7e5a461dc94344902965e9a06,,,,,,,
CVE-2018-12565,https://www.cvedetails.com/cve/CVE-2018-12565/,CWE-20,,Exec Code,2018-06-19,2019-09-18,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"An issue was discovered in Linaro LAVA before 2018.5.post1. Because of use of yaml.load() instead of yaml.safe_load() when parsing user data, remote code execution can occur.",,linaro,https://git.linaro.org/lava/lava.git/commit/?id=583666c84ea2f12797a3eb71392bcb05782f5b14,,,,,,,
CVE-2018-12564,https://www.cvedetails.com/cve/CVE-2018-12564/,CWE-20,,,2018-06-19,2018-08-10,4.0,None,Remote,Low,Single system,Partial,None,None,"An issue was discovered in Linaro LAVA before 2018.5.post1. Because of support for URLs in the submit page, a user can forge an HTTP request that will force lava-server-gunicorn to return any file on the server that is readable by lavaserver and valid yaml.",,linaro,https://git.linaro.org/lava/lava.git/commit/?id=95a9a77b144ced24d7425d6544ab03ca7f6c75d3,,,,,,,
CVE-2018-12563,https://www.cvedetails.com/cve/CVE-2018-12563/,CWE-20,,,2018-06-19,2018-08-10,4.0,None,Remote,Low,Single system,Partial,None,None,"An issue was discovered in Linaro LAVA before 2018.5.post1. Because of support for file: URLs, a user can force lava-server-gunicorn to download any file from the filesystem if it's readable by lavaserver and valid yaml.",Python,linaro,https://git.linaro.org/lava/lava.git/commit/?id=e24ec39599bc07562ad8bc2a581144b8448cb214,e24ec39599bc07562ad8bc2a581144b8448cb214,95a9a77b144ced24d7425d6544ab03ca7f6c75d3,"@@ -1,4 +1,5 @@
 import re
+import requests
 import sys
 import yaml
 from voluptuous import (
@@ -14,16 +15,6 @@ from voluptuous import (
     Schema
 )
 
-if sys.version_info[0] == 2:
-    # Python 2.x
-    from urllib2 import urlopen
-    from urllib2 import URLError
-elif sys.version_info[0] == 3:
-    # For Python 3.0 and later
-    from urllib.request import urlopen
-    from urllib.error import URLError
-
-
 INVALID_CHARACTER_ERROR_MSG = ""Invalid character""
 INCLUDE_URL_TIMEOUT = 10
 
@@ -444,12 +435,10 @@ def _validate_vcs_parameters(data_objects):
 
 def _download_raw_yaml(url):
     try:
-        data = yaml.load(
-            urlopen(url, timeout=INCLUDE_URL_TIMEOUT).read())
-        return data
-    except URLError as e:
+        return yaml.load(requests.get(url, timeout=INCLUDE_URL_TIMEOUT).content)
+    except requests.RequestException as exc:
         raise SubmissionException(
-            ""Section 'include' must contain valid URL: %s"" % e)
+            ""Section 'include' must contain valid URL: %s"" % exc)
     except yaml.YAMLError as e:
         raise SubmissionException(""Section 'include' must contain URL to a raw file in valid YAML format: %s"" % e)",https://git.linaro.org/lava/lava.git/tree/lava_scheduler_app/schema.py?id=95a9a77b144ced24d7425d6544ab03ca7f6c75d3,https://git.linaro.org/lava/lava.git/tree/lava_scheduler_app/schema.py?id=e24ec39599bc07562ad8bc2a581144b8448cb214,,
CVE-2010-4707,https://www.cvedetails.com/cve/CVE-2010-4707/,CWE-399,,DoS,2011-01-24,2019-01-03,4.9,None,Local,Low,Not required,Complete,None,None,"The check_acl function in pam_xauth.c in the pam_xauth module in Linux-PAM (aka pam) 1.1.2 and earlier does not verify that a certain ACL file is a regular file, which might allow local users to cause a denial of service (resource consumption) via a special file.",,altlinux,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=commit;h=Linux-PAM-1_1_2-2-gffe7058c70253d574b1963c7c93002bd410fddc9,ffe7058c70253d574b1963c7c93002bd410fddc9,4e8357e4609be470ee5214be01e2d1d0e688f580,"@@ -37,6 +37,9 @@
 #include <sys/types.h>
 #include <sys/fsuid.h>
 #include <sys/wait.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
 #include <errno.h>
 #include <fnmatch.h>
 #include <grp.h>
@@ -232,9 +235,10 @@ check_acl(pam_handle_t *pamh,
 {
        char path[PATH_MAX];
        struct passwd *pwd;
-       FILE *fp;
-       int i, save_errno;
+       FILE *fp = NULL;
+       int i, fd = -1, save_errno;
        uid_t fsuid;
+       struct stat st;
        /* Check this user's <sense> file. */
        pwd = pam_modutil_getpwnam(pamh, this_user);
        if (pwd == NULL) {
@@ -251,10 +255,27 @@ check_acl(pam_handle_t *pamh,
                return PAM_SESSION_ERR;
        }
        fsuid = setfsuid(pwd->pw_uid);
-       fp = fopen(path, ""r"");
+       if (!stat(path, &st)) {
+               if (!S_ISREG(st.st_mode))
+                       errno = EINVAL;
+               else
+                       fd = open(path, O_RDONLY | O_NOCTTY);
+       }
        save_errno = errno;
        setfsuid(fsuid);
-       if (fp != NULL) {
+       if (fd >= 0) {
+               if (!fstat(fd, &st)) {
+                       if (!S_ISREG(st.st_mode))
+                               errno = EINVAL;
+                       else
+                               fp = fdopen(fd, ""r"");
+               }
+               if (!fp) {
+                       save_errno = errno;
+                       close(fd);
+               }
+       }
+       if (fp) {
                char buf[LINE_MAX], *tmp;
                /* Scan the file for a list of specs of users to ""trust"". */
                while (fgets(buf, sizeof(buf), fp) != NULL) {",http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=blob;f=Linux-PAM/modules/pam_xauth/pam_xauth.c;h=05ed6ee944377e95b1140dd1fee11bc5e54fb635;hb=05ed6ee944377e95b1140dd1fee11bc5e54fb635,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=blob;f=Linux-PAM/modules/pam_xauth/pam_xauth.c;h=591dc85dc1a125ca9c50d2a56fb8d6b6acc56217;hb=591dc85dc1a125ca9c50d2a56fb8d6b6acc56217,,
CVE-2010-4706,https://www.cvedetails.com/cve/CVE-2010-4706/,,,,2011-01-24,2019-01-03,4.9,None,Local,Low,Not required,None,None,Complete,"The pam_sm_close_session function in pam_xauth.c in the pam_xauth module in Linux-PAM (aka pam) 1.1.2 and earlier does not properly handle a failure to determine a certain target uid, which might allow local users to delete unintended files by executing a program that relies on the pam_xauth PAM check.",,altlinux,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=commit;h=Linux-PAM-1_1_2-3-g05dafc06cd3dfeb7c4b24942e4e1ae33ff75a123,,,,,,,
CVE-2017-9526,https://www.cvedetails.com/cve/CVE-2017-9526/,CWE-200,,+Info,2017-06-10,2019-01-16,4.3,None,Remote,Medium,Not required,Partial,None,None,"In Libgcrypt before 1.7.7, an attacker who learns the EdDSA session key (from side-channel observation during the signing process) can easily recover the long-term secret key. 1.7.7 makes a cipher/ecc-eddsa.c change to store this session key in secure memory, to ensure that constant-time point operations are used in the MPI library.",C,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=5a22de904a0a366ae79f03ff1e13a1232a89e26b,5a22de904a0a366ae79f03ff1e13a1232a89e26b,45c39340c9926c2c5801dbab7609687c41e9ff1f,"@@ -603,7 +603,7 @@ _gcry_ecc_eddsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
   a = mpi_snew (0);
   x = mpi_new (0);
   y = mpi_new (0);
-  r = mpi_new (0);
+  r = mpi_snew (0);
   ctx = _gcry_mpi_ec_p_internal_new (skey->E.model, skey->E.dialect, 0,
                                      skey->E.p, skey->E.a, skey->E.b);
   b = (ctx->nbits+7)/8;",https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/ecc-eddsa.c;h=f91f8489b1a970ef18aa76c346943fb297d4c24e;hb=f91f8489b1a970ef18aa76c346943fb297d4c24e,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/ecc-eddsa.c;h=813e030dc3086d70babb443b1ac423e23e48bc4f;hb=813e030dc3086d70babb443b1ac423e23e48bc4f,,
CVE-2017-9526,https://www.cvedetails.com/cve/CVE-2017-9526/,CWE-200,,+Info,2017-06-10,2019-01-16,4.3,None,Remote,Medium,Not required,Partial,None,None,"In Libgcrypt before 1.7.7, an attacker who learns the EdDSA session key (from side-channel observation during the signing process) can easily recover the long-term secret key. 1.7.7 makes a cipher/ecc-eddsa.c change to store this session key in secure memory, to ensure that constant-time point operations are used in the MPI library.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=f9494b3f258e01b6af8bd3941ce436bcc00afc56,,,,,,,
CVE-2013-0166,https://www.cvedetails.com/cve/CVE-2013-0166/,CWE-310,,DoS,2013-02-08,2018-08-08,5.0,None,Remote,Low,Not required,None,None,Partial,"OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=62e4506a7d4cec1c8e1ff687f6b220f6a62a57c7,,,,,,,
CVE-2013-0166,https://www.cvedetails.com/cve/CVE-2013-0166/,CWE-310,,DoS,2013-02-08,2018-08-08,5.0,None,Remote,Low,Not required,None,None,Partial,"OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=66e8211c0b1347970096e04b18aa52567c325200,,,,,,,
CVE-2013-0166,https://www.cvedetails.com/cve/CVE-2013-0166/,CWE-310,,DoS,2013-02-08,2018-08-08,5.0,None,Remote,Low,Not required,None,None,Partial,"OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ebc71865f0506a293242bd4aec97cdc7a8ef24b0,,,,,,,
CVE-2017-9461,https://www.cvedetails.com/cve/CVE-2017-9461/,CWE-835,,DoS,2017-06-06,2019-10-02,6.8,None,Remote,Low,Single system,None,None,Complete,smbd in Samba before 4.4.10 and 4.5.x before 4.5.6 has a denial of service vulnerability (fd_open_atomic infinite loop with high CPU usage and memory consumption) due to wrongly handling dangling symlinks.,,samba,https://git.samba.org/?p=samba.git;a=commit;h=10c3e3923022485c720f322ca4f0aca5d7501310,,,,,,,
CVE-2010-4651,https://www.cvedetails.com/cve/CVE-2010-4651/,CWE-22,,Dir. Trav.,2011-03-11,2016-11-28,5.8,None,Remote,Medium,Not required,None,Partial,Partial,"Directory traversal vulnerability in util.c in GNU patch 2.6.1 and earlier allows user-assisted remote attackers to create or overwrite arbitrary files via a filename that is specified with a .. (dot dot) or full pathname, a related issue to CVE-2010-1679.",,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=685a78b6052f4df6eac6d625a545cfb54a6ac0e1,,,,,,,
CVE-2017-9375,https://www.cvedetails.com/cve/CVE-2017-9375/,CWE-835,,DoS,2017-06-16,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"QEMU (aka Quick Emulator), when built with USB xHCI controller emulator support, allows local guest OS privileged users to cause a denial of service (infinite recursive call) via vectors involving control transfer descriptors sequencing.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c,,,,,,,
CVE-2017-9374,https://www.cvedetails.com/cve/CVE-2017-9374/,CWE-772,,DoS,2017-06-16,2019-10-02,2.1,None,Local,Low,Not required,None,None,Partial,"Memory leak in QEMU (aka Quick Emulator), when built with USB EHCI Emulation support, allows local guest OS privileged users to cause a denial of service (memory consumption) by repeatedly hot-unplugging the device.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0,,,,,,,
CVE-2017-9373,https://www.cvedetails.com/cve/CVE-2017-9373/,CWE-772,,DoS,2017-06-16,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"Memory leak in QEMU (aka Quick Emulator), when built with IDE AHCI Emulation support, allows local guest OS privileged users to cause a denial of service (memory consumption) by repeatedly hot-unplugging the AHCI device.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04,,,,,,,
CVE-2017-9330,https://www.cvedetails.com/cve/CVE-2017-9330/,CWE-835,,DoS,2017-06-08,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"QEMU (aka Quick Emulator) before 2.9.0, when built with the USB OHCI Emulation support, allows local guest OS users to cause a denial of service (infinite loop) by leveraging an incorrect return value, a different vulnerability than CVE-2017-6505.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d,,,,,,,
CVE-2017-9310,https://www.cvedetails.com/cve/CVE-2017-9310/,CWE-835,,DoS,2017-06-08,2019-10-02,1.9,None,Local,Medium,Not required,None,None,Partial,"QEMU (aka Quick Emulator), when built with the e1000e NIC emulation support, allows local guest OS privileged users to cause a denial of service (infinite loop) via vectors related to setting the initial receive / transmit descriptor head (TDH/RDH) outside the allocated descriptor buffer.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7,,,,,,,
CVE-2015-0293,https://www.cvedetails.com/cve/CVE-2015-0293/,CWE-20,,DoS,2015-03-19,2018-01-18,5.0,None,Remote,Low,Not required,None,None,Partial,"The SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a allows remote attackers to cause a denial of service (s2_lib.c assertion failure and daemon exit) via a crafted CLIENT-MASTER-KEY message.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=86f8fb0e344d62454f8daf3e15236b2b59210756,,,,,,,
CVE-2012-6128,https://www.cvedetails.com/cve/CVE-2012-6128/,CWE-119,,DoS Overflow,2013-02-24,2017-08-28,5.0,None,Remote,Low,Not required,None,None,Partial,"Multiple stack-based buffer overflows in http.c in OpenConnect before 4.08 allow remote VPN gateways to cause a denial of service (application crash) via a long (1) hostname, (2) path, or (3) cookie list in a response.",,infradead,http://git.infradead.org/users/dwmw2/openconnect.git/commitdiff/26f752c3dbf69227679fc6bebb4ae071aecec491,,,,,,,
CVE-2015-0292,https://www.cvedetails.com/cve/CVE-2015-0292/,CWE-119,,DoS Overflow Mem. Corr.,2015-03-19,2017-11-14,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer underflow in the EVP_DecodeUpdate function in crypto/evp/encode.c in the base64-decoding implementation in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted base64 data that triggers a buffer overflow.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d0666f289ac013094bbbf547bfbcd616199b7d2d,,,,,,,
CVE-2015-0291,https://www.cvedetails.com/cve/CVE-2015-0291/,,,DoS,2015-03-19,2018-11-29,5.0,None,Remote,Low,Not required,None,None,Partial,The sigalgs implementation in t1_lib.c in OpenSSL 1.0.2 before 1.0.2a allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) by using an invalid signature_algorithms extension in the ClientHello message during a renegotiation.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=76343947ada960b6269090638f5391068daee88d,,,,,,,
CVE-2012-6113,https://www.cvedetails.com/cve/CVE-2012-6113/,CWE-200,,+Info,2013-01-19,2013-02-02,5.0,None,Remote,Low,Not required,Partial,None,None,"The openssl_encrypt function in ext/openssl/openssl.c in PHP 5.3.9 through 5.3.13 does not initialize a certain variable, which allows remote attackers to obtain sensitive information from process memory by providing zero bytes of input data.",,php,https://git.php.net/?p=php-src.git;a=commit;h=270a406ac94b5fc5cc9ef59fc61e3b4b95648a3e,,,,,,,
CVE-2015-0290,https://www.cvedetails.com/cve/CVE-2015-0290/,CWE-17,,DoS,2015-03-19,2018-11-29,5.0,None,Remote,Low,Not required,None,None,Partial,"The multi-block feature in the ssl3_write_bytes function in s3_pkt.c in OpenSSL 1.0.2 before 1.0.2a on 64-bit x86 platforms with AES NI support does not properly handle certain non-blocking I/O cases, which allows remote attackers to cause a denial of service (pointer corruption and application crash) via unspecified vectors.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=77c77f0a1b9f15b869ca3342186dfbedd1119d0e,,,,,,,
CVE-2012-6112,https://www.cvedetails.com/cve/CVE-2012-6112/,CWE-264,,,2013-01-27,2013-01-30,5.0,None,Remote,Low,Not required,None,Partial,None,"classes/GoogleSpell.php in the PHP Spellchecker (aka Google Spellchecker) addon before 2.0.6.1 for TinyMCE, as used in Moodle 2.1.x before 2.1.10, 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 and other products, does not properly handle control characters, which allows remote attackers to trigger arbitrary outbound HTTP requests via a crafted string.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37283,,,,,,,
CVE-2015-0289,https://www.cvedetails.com/cve/CVE-2015-0289/,,,DoS,2015-03-19,2017-10-19,5.0,None,Remote,Low,Not required,None,None,Partial,"The PKCS#7 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly handle a lack of outer ContentInfo, which allows attackers to cause a denial of service (NULL pointer dereference and application crash) by leveraging an application that processes arbitrary PKCS#7 data and providing malformed data with ASN.1 encoding, related to crypto/pkcs7/pk7_doit.c and crypto/pkcs7/pk7_lib.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=c0334c2c92dd1bc3ad8138ba6e74006c3631b0f9,,,,,,,
CVE-2012-6106,https://www.cvedetails.com/cve/CVE-2012-6106/,CWE-264,,,2013-01-27,2013-01-30,5.5,None,Remote,Low,Single system,None,Partial,Partial,"calendar/managesubscriptions.php in the Manage Subscriptions implementation in Moodle 2.4.x before 2.4.1 omits a capability check, which allows remote authenticated users to remove course-level calendar subscriptions by leveraging the student role and sending an iCalendar object.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37106,,,,,,,
CVE-2012-6105,https://www.cvedetails.com/cve/CVE-2012-6105/,CWE-200,,+Info,2013-01-27,2013-01-28,5.0,None,Remote,Low,Not required,Partial,None,None,"blog/rsslib.php in Moodle 2.1.x before 2.1.10, 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 continues to provide a blog RSS feed after blogging is disabled, which allows remote attackers to obtain sensitive information by reading this feed.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37467,,,,,,,
CVE-2015-0288,https://www.cvedetails.com/cve/CVE-2015-0288/,,,DoS,2015-03-19,2017-11-14,5.0,None,Remote,Low,Not required,None,None,Partial,"The X509_to_X509_REQ function in crypto/x509/x509_req.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a might allow attackers to cause a denial of service (NULL pointer dereference and application crash) via an invalid certificate key.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=28a00bcd8e318da18031b2ac8778c64147cd54f9,,,,,,,
CVE-2012-6104,https://www.cvedetails.com/cve/CVE-2012-6104/,CWE-200,,+Info,2013-01-27,2013-01-30,5.0,None,Remote,Low,Not required,Partial,None,None,"blog/rsslib.php in Moodle 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 allows remote attackers to obtain sensitive information from site-level blogs by leveraging the guest role and reading an RSS feed.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36620,,,,,,,
CVE-2015-0287,https://www.cvedetails.com/cve/CVE-2015-0287/,CWE-17,,DoS Mem. Corr.,2015-03-19,2017-11-14,5.0,None,Remote,Low,Not required,None,None,Partial,"The ASN1_item_ex_d2i function in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not reinitialize CHOICE and ADB data structures, which might allow attackers to cause a denial of service (invalid write operation and memory corruption) by leveraging an application that relies on ASN.1 structure reuse.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=b717b083073b6cacc0a5e2397b661678aff7ae7f,,,,,,,
CVE-2012-6103,https://www.cvedetails.com/cve/CVE-2012-6103/,CWE-352,,CSRF,2013-01-27,2013-01-28,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in user/messageselect.php in the messaging system in Moodle 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 allow remote attackers to hijack the authentication of arbitrary users for requests that send course messages.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36600,,,,,,,
CVE-2015-0286,https://www.cvedetails.com/cve/CVE-2015-0286/,CWE-17,,DoS,2015-03-19,2018-01-04,5.0,None,Remote,Low,Not required,None,None,Partial,"The ASN1_TYPE_cmp function in crypto/asn1/a_type.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly perform boolean-type comparisons, which allows remote attackers to cause a denial of service (invalid read operation and application crash) via a crafted X.509 certificate to an endpoint that uses the certificate-verification feature.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=c3c7fb07dc975dc3c9de0eddb7d8fd79fc9c67c1,,,,,,,
CVE-2015-0285,https://www.cvedetails.com/cve/CVE-2015-0285/,CWE-310,,,2015-03-19,2018-11-29,4.3,None,Remote,Medium,Not required,Partial,None,None,"The ssl3_client_hello function in s3_clnt.c in OpenSSL 1.0.2 before 1.0.2a does not ensure that the PRNG is seeded before proceeding with a handshake, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by sniffing the network and then conducting a brute-force attack.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=e1b568dd2462f7cacf98f3d117936c34e2849a6b,,,,,,,
CVE-2012-6102,https://www.cvedetails.com/cve/CVE-2012-6102/,CWE-264,,,2013-01-27,2013-01-28,6.4,None,Remote,Low,Not required,Partial,Partial,None,lib.php in the Submission comments plugin in the Assignment module in Moodle 2.3.x before 2.3.4 and 2.4.x before 2.4.1 allows remote attackers to read or modify the submission comments (aka feedback comments) of arbitrary users via a crafted URI.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-37244,,,,,,,
CVE-2017-9060,https://www.cvedetails.com/cve/CVE-2017-9060/,CWE-772,,DoS,2017-06-01,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,"Memory leak in the virtio_gpu_set_scanout function in hw/display/virtio-gpu.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (memory consumption) via a large number of ""VIRTIO_GPU_CMD_SET_SCANOUT:"" commands.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d,,,,,,,
CVE-2012-6101,https://www.cvedetails.com/cve/CVE-2012-6101/,CWE-20,,,2013-01-27,2013-01-28,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"Multiple open redirect vulnerabilities in Moodle 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via vectors related to (1) backup/backupfilesedit.php, (2) comment/comment_post.php, (3) course/switchrole.php, (4) mod/wiki/filesedit.php, (5) tag/coursetags_add.php, or (6) user/files.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-35991,,,,,,,
CVE-2012-6100,https://www.cvedetails.com/cve/CVE-2012-6100/,CWE-264,,,2013-01-27,2013-01-28,4.0,None,Remote,Low,Single system,Partial,None,None,"report/outline/index.php in Moodle 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 does not properly enforce the moodle/user:viewhiddendetails capability requirement, which allows remote authenticated users to discover a hidden lastaccess value by reading an activity report.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-33340,,,,,,,
CVE-2012-6099,https://www.cvedetails.com/cve/CVE-2012-6099/,CWE-20,,,2013-01-27,2013-01-28,4.0,None,Remote,Low,Single system,Partial,None,None,"The moodle1 backup converter in backup/converter/moodle1/lib.php in Moodle 2.1.x before 2.1.10, 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 does not properly validate pathnames, which allows remote authenticated users to read arbitrary files by leveraging the backup-restoration feature.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36977,,,,,,,
CVE-2012-6098,https://www.cvedetails.com/cve/CVE-2012-6098/,CWE-264,,,2013-01-27,2013-01-30,4.0,None,Remote,Low,Single system,None,Partial,None,"grade/edit/outcome/edit_form.php in Moodle 1.9.x through 1.9.19, 2.1.x before 2.1.10, 2.2.x before 2.2.7, 2.3.x before 2.3.4, and 2.4.x before 2.4.1 does not properly enforce the moodle/grade:manage capability requirement, which allows remote authenticated users to convert custom outcomes into standard site-wide outcomes by leveraging the teacher role and using the re-editing feature.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-27619,,,,,,,
CVE-2015-0273,https://www.cvedetails.com/cve/CVE-2015-0273/,,,Exec Code,2015-03-30,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple use-after-free vulnerabilities in ext/date/php_date.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 allow remote attackers to execute arbitrary code via crafted serialized input containing a (1) R or (2) r type specifier in (a) DateTimeZone data handled by the php_date_timezone_initialize_from_hash function or (b) DateTime data handled by the php_date_initialize_from_hash function.",,php,https://git.php.net/?p=php-src.git;a=commit;h=71335e6ebabc1b12c057d8017fd811892ecdfd24,,,,,,,
CVE-2015-0272,https://www.cvedetails.com/cve/CVE-2015-0272/,CWE-20,,DoS,2015-11-17,2016-12-06,5.0,None,Remote,Low,Not required,None,None,Partial,"GNOME NetworkManager allows remote attackers to cause a denial of service (IPv6 traffic disruption) via a crafted MTU value in an IPv6 Router Advertisement (RA) message, a different vulnerability than CVE-2015-8215.",,NetworkManager,https://cgit.freedesktop.org/NetworkManager/NetworkManager/commit/?id=d5fc88e573fa58b93034b04d35a2454f5d28cad9,,,,,,,
CVE-2012-6087,https://www.cvedetails.com/cve/CVE-2012-6087/,CWE-20,,,2013-09-16,2014-01-31,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"repository/s3/S3.php in the Amazon S3 library in Moodle through 2.2.11, 2.3.x before 2.3.9, 2.4.x before 2.4.6, and 2.5.x before 2.5.2 does not verify that the server hostname matches a domain name in the subject's Common Name (CN) or subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate, related to an incorrect CURLOPT_SSL_VERIFYHOST value.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-40615,,,,,,,
CVE-2012-6085,https://www.cvedetails.com/cve/CVE-2012-6085/,CWE-20,,DoS,2013-01-23,2017-08-28,5.8,None,Remote,Medium,Not required,None,Partial,Partial,"The read_block function in g10/import.c in GnuPG 1.4.x before 1.4.13 and 2.0.x through 2.0.19, when importing a key, allows remote attackers to corrupt the public keyring database or cause a denial of service (application crash) via a crafted length field of an OpenPGP packet.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=commitdiff;h=f0b33b6fb8e0586e9584a7a409dcc31263776a67,,,,,,,
CVE-2017-9031,https://www.cvedetails.com/cve/CVE-2017-9031/,CWE-22,,Dir. Trav.,2017-05-17,2017-11-03,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,The WebUI component in Deluge before 1.3.15 contains a directory traversal vulnerability involving a request in which the name of the render file is not associated with any template file.,Python,deluge-torrent,https://git.deluge-torrent.org/deluge/commit/?h=1.3-stable&id=41acade01ae88f7b7bbdba308a0886771aa582fd,41acade01ae88f7b7bbdba308a0886771aa582fd,9bec5142c72a386a3cb40d3b3169b1ad68a1d969,"@@ -174,6 +174,10 @@ class Upload(resource.Resource):
         }), request)
 
 class Render(resource.Resource):
+    def __init__(self):
+        resource.Resource.__init__(self)
+        # Make a list of all the template files to check requests against.
+        self.template_files = fnmatch.filter(os.listdir(rpath('render')), '*.html')
 
     def getChild(self, path, request):
         request.render_file = path
@@ -184,6 +188,10 @@ class Render(resource.Resource):
             request.setResponseCode(http.INTERNAL_SERVER_ERROR)
             return """"
 
+        if request.render_file not in self.template_files:
+            request.setResponseCode(http.NOT_FOUND)
+            return ""<h1>404 - Not Found</h1>""
+
         filename = os.path.join(""render"", request.render_file)
         template = Template(filename=rpath(filename))
         request.setHeader(""content-type"", ""text/html"")",https://git.deluge-torrent.org/deluge/tree/deluge/ui/web/server.py?h=1.3-stable&id=9bec5142c72a386a3cb40d3b3169b1ad68a1d969,https://git.deluge-torrent.org/deluge/tree/deluge/ui/web/server.py?h=1.3-stable&id=41acade01ae88f7b7bbdba308a0886771aa582fd,,
CVE-2012-6075,https://www.cvedetails.com/cve/CVE-2012-6075/,CWE-119,,DoS Exec Code Overflow,2013-02-12,2014-04-19,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"Buffer overflow in the e1000_receive function in the e1000 device driver (hw/e1000.c) in QEMU 1.3.0-rc2 and other versions, when the SBP and LPE flags are disabled, allows remote attackers to cause a denial of service (guest OS crash) and possibly execute arbitrary guest code via a large packet.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb,,,,,,,
CVE-2015-0232,https://www.cvedetails.com/cve/CVE-2015-0232/,,,DoS Exec Code,2015-01-27,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The exif_process_unicode function in ext/exif/exif.c in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5 allows remote attackers to execute arbitrary code or cause a denial of service (uninitialized pointer free and application crash) via crafted EXIF data in a JPEG image.",,php,https://git.php.net/?p=php-src.git;a=commit;h=2fc178cf448d8e1b95d1314e47eeef610729e0df,,,,,,,
CVE-2015-0232,https://www.cvedetails.com/cve/CVE-2015-0232/,,,DoS Exec Code,2015-01-27,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The exif_process_unicode function in ext/exif/exif.c in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5 allows remote attackers to execute arbitrary code or cause a denial of service (uninitialized pointer free and application crash) via crafted EXIF data in a JPEG image.",,php,https://git.php.net/?p=php-src.git;a=commit;h=55001de6d8c6ed2aada870a76de1e4b4558737bf,,,,,,,
CVE-2015-0232,https://www.cvedetails.com/cve/CVE-2015-0232/,,,DoS Exec Code,2015-01-27,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The exif_process_unicode function in ext/exif/exif.c in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5 allows remote attackers to execute arbitrary code or cause a denial of service (uninitialized pointer free and application crash) via crafted EXIF data in a JPEG image.",,php,https://git.php.net/?p=php-src.git;a=commit;h=21bc7464f454fec18a9ec024c738f195602fee2a,,,,,,,
CVE-2017-8934,https://www.cvedetails.com/cve/CVE-2017-8934/,CWE-20,,DoS,2017-05-15,2017-05-22,2.1,None,Local,Low,Not required,None,None,Partial,"PCManFM 1.2.5 insecurely uses /tmp for a socket file, allowing a local user to cause a denial of service (application unavailability).",C,lxde,https://git.lxde.org/gitweb/?p=lxde/pcmanfm.git;a=commit;h=bc8c3d871e9ecc67c47ff002b68cf049793faf08,bc8c3d871e9ecc67c47ff002b68cf049793faf08,43fcebfc71d7d5d07ab45539536694c27b87df9e,"@@ -2,7 +2,7 @@
  *      single-inst.c: simple IPC mechanism for single instance app
  *
  *      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
- *      Copyright 2012 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
+ *      Copyright 2012-2017 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
  *
  *      This program is free software; you can redistribute it and/or modify
  *      it under the terms of the GNU General Public License as published by
@@ -404,11 +404,16 @@ static void get_socket_name(SingleInstData* data, char* buf, int len)
     }
     else
         dpynum = 0;
+#if GLIB_CHECK_VERSION(2, 28, 0)
+    g_snprintf(buf, len, ""%s/%s-socket-%s-%d"", g_get_user_runtime_dir(),
+               data->prog_name, host ? host : """", dpynum);
+#else
     g_snprintf(buf, len, ""%s/.%s-socket-%s-%d-%s"",
                 g_get_tmp_dir(),
                 data->prog_name,
                 host ? host : """",
                 dpynum,
                 g_get_user_name());
+#endif
 }",https://git.lxde.org/gitweb/?p=lxde/pcmanfm.git;a=blob;f=src/single-inst.c;h=62c37b30bb7cc209203d076a0b7a99dd13c351ba;hb=62c37b30bb7cc209203d076a0b7a99dd13c351ba,https://git.lxde.org/gitweb/?p=lxde/pcmanfm.git;a=blob;f=src/single-inst.c;h=aaf84abc4a528ceaebb420cc96d52486baf4924b;hb=aaf84abc4a528ceaebb420cc96d52486baf4924b,,
CVE-2010-3435,https://www.cvedetails.com/cve/CVE-2010-3435/,,,+Info,2011-01-24,2019-01-03,4.7,None,Local,Medium,Not required,Complete,None,None,"The (1) pam_env and (2) pam_mail modules in Linux-PAM (aka pam) before 1.1.2 use root privileges during read access to files and directories that belong to arbitrary user accounts, which might allow local users to obtain sensitive information by leveraging this filesystem activity, as demonstrated by a symlink attack on the .pam_environment file in a user's home directory.",,altlinux,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=commit;h=06f882f30092a39a1db867c9744b2ca8d60e4ad6,,,,,,,
CVE-2017-8933,https://www.cvedetails.com/cve/CVE-2017-8933/,CWE-20,,DoS,2017-05-15,2017-05-22,2.1,None,Local,Low,Not required,None,None,Partial,"Libmenu-cache 1.0.2 insecurely uses /tmp for a socket file, allowing a local user to cause a denial of service (menu unavailability).",,lxde,https://git.lxde.org/gitweb/?p=lxde/menu-cache.git;a=commit;h=56f66684592abf257c4004e6e1fff041c64a12ce,,,,,,,
CVE-2010-3431,https://www.cvedetails.com/cve/CVE-2010-3431/,,,+Info,2011-01-24,2019-01-03,1.9,None,Local,Medium,Not required,Partial,None,None,"The privilege-dropping implementation in the (1) pam_env and (2) pam_mail modules in Linux-PAM (aka pam) 1.1.2 does not check the return value of the setfsuid system call, which might allow local users to obtain sensitive information by leveraging an unintended uid, as demonstrated by a symlink attack on the .pam_environment file in a user's home directory.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2010-3435.",,altlinux,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=commit;h=843807a3a90f52e7538be756616510730a24739a,,,,,,,
CVE-2010-3430,https://www.cvedetails.com/cve/CVE-2010-3430/,,,+Info,2011-01-24,2019-01-03,4.7,None,Local,Medium,Not required,Complete,None,None,"The privilege-dropping implementation in the (1) pam_env and (2) pam_mail modules in Linux-PAM (aka pam) 1.1.2 does not perform the required setfsgid and setgroups system calls, which might allow local users to obtain sensitive information by leveraging unintended group permissions, as demonstrated by a symlink attack on the .pam_environment file in a user's home directory.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2010-3435.",,altlinux,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=commit;h=843807a3a90f52e7538be756616510730a24739a,,,,,,,
CVE-2010-3316,https://www.cvedetails.com/cve/CVE-2010-3316/,,,,2011-01-24,2019-01-03,3.3,None,Local,Medium,Not required,Partial,Partial,None,"The run_coprocess function in pam_xauth.c in the pam_xauth module in Linux-PAM (aka pam) before 1.1.2 does not check the return values of the setuid, setgid, and setgroups system calls, which might allow local users to read arbitrary files by executing a program that relies on the pam_xauth PAM check.",,altlinux,http://git.altlinux.org/people/ldv/packages/?p=pam.git;a=commit;h=06f882f30092a39a1db867c9744b2ca8d60e4ad6,,,,,,,
CVE-2015-0218,https://www.cvedetails.com/cve/CVE-2015-0218/,CWE-352,,CSRF,2015-06-01,2015-06-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Cross-site request forgery (CSRF) vulnerability in auth/shibboleth/logout.php in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 allows remote attackers to hijack the authentication of arbitrary users for requests that trigger a logout.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47964,,,,,,,
CVE-2015-0217,https://www.cvedetails.com/cve/CVE-2015-0217/,CWE-399,,DoS,2015-06-01,2015-06-02,6.8,None,Remote,Low,Single system,None,None,Complete,"filter/mediaplugin/filter.php in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 allows remote authenticated users to cause a denial of service (CPU consumption or partial outage) via a crafted string that is matched against an improper regular expression.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48546,,,,,,,
CVE-2015-0216,https://www.cvedetails.com/cve/CVE-2015-0216/,CWE-79,,XSS,2015-06-01,2015-06-02,3.5,None,Remote,Medium,Single system,None,Partial,None,"access.php in the Lesson module in Moodle 2.8.x before 2.8.2 does not set the RISK_XSS bit for graders, which allows remote authenticated users to conduct cross-site scripting (XSS) attacks via crafted essay feedback.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48034,,,,,,,
CVE-2015-0215,https://www.cvedetails.com/cve/CVE-2015-0215/,CWE-200,,+Info,2015-06-01,2015-06-02,4.0,None,Remote,Low,Single system,Partial,None,None,"calendar/externallib.php in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 allows remote authenticated users to obtain sensitive calendar-event information via a web-services request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48017,,,,,,,
CVE-2015-0214,https://www.cvedetails.com/cve/CVE-2015-0214/,CWE-264,,Bypass,2015-06-01,2015-06-02,4.0,None,Remote,Low,Single system,None,Partial,None,"message/externallib.php in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 allows remote authenticated users to bypass a messaging-disabled setting via a web-services request, as demonstrated by a people-search request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48329,,,,,,,
CVE-2015-0213,https://www.cvedetails.com/cve/CVE-2015-0213/,CWE-352,,CSRF,2015-06-01,2015-06-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in (1) editcategories.html and (2) editcategories.php in the Glossary module in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 allow remote attackers to hijack the authentication of unspecified victims.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48106,,,,,,,
CVE-2015-0212,https://www.cvedetails.com/cve/CVE-2015-0212/,CWE-79,,XSS,2015-06-01,2015-06-02,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in course/pending.php in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 allows remote authenticated users to inject arbitrary web script or HTML via a crafted course summary.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48368,,,,,,,
CVE-2015-0211,https://www.cvedetails.com/cve/CVE-2015-0211/,CWE-200,,+Info,2015-06-01,2015-06-02,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/lti/ajax.php in Moodle through 2.5.9, 2.6.x before 2.6.7, 2.7.x before 2.7.4, and 2.8.x before 2.8.2 does not consider the moodle/course:manageactivities and mod/lti:addinstance capabilities before proceeding with registered-tool list searches, which allows remote authenticated users to obtain sensitive information via requests to the LTI Ajax service.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47920,,,,,,,
CVE-2015-0209,https://www.cvedetails.com/cve/CVE-2015-0209/,,,DoS Mem. Corr.,2015-03-19,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Use-after-free vulnerability in the d2i_ECPrivateKey function in crypto/ec/ec_asn1.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a might allow remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via a malformed Elliptic Curve (EC) private-key file that is improperly handled during import.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1b4a8df38fc9ab3c089ca5765075ee53ec5bd66a,,,,,,,
CVE-2015-0208,https://www.cvedetails.com/cve/CVE-2015-0208/,,,DoS,2015-03-19,2018-11-29,4.3,None,Remote,Medium,Not required,None,None,Partial,The ASN.1 signature-verification implementation in the rsa_item_verify function in crypto/rsa/rsa_ameth.c in OpenSSL 1.0.2 before 1.0.2a allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via crafted RSA PSS parameters to an endpoint that uses the certificate-verification feature.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=4b22cce3812052fe64fc3f6d58d8cc884e3cb834,,,,,,,
CVE-2015-0207,https://www.cvedetails.com/cve/CVE-2015-0207/,,,DoS,2015-03-19,2018-11-29,5.0,None,Remote,Low,Not required,None,None,Partial,"The dtls1_listen function in d1_lib.c in OpenSSL 1.0.2 before 1.0.2a does not properly isolate the state information of independent data streams, which allows remote attackers to cause a denial of service (application crash) via crafted DTLS traffic, as demonstrated by DTLS 1.0 traffic to a DTLS 1.2 server.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=819418110b6fff4a7b96f01a5d68f71df3e3b736,,,,,,,
CVE-2012-5670,https://www.cvedetails.com/cve/CVE-2012-5670/,CWE-119,,DoS Overflow,2013-01-24,2016-12-06,4.3,None,Remote,Medium,Not required,None,None,Partial,The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) via vectors related to BDF fonts and an ENCODING field with a negative value.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7f2e4f4f553f6836be7683f66226afac3fa979b8,,,,,,,
CVE-2012-5669,https://www.cvedetails.com/cve/CVE-2012-5669/,CWE-119,,DoS Exec Code Overflow,2013-01-24,2016-12-06,4.3,None,Remote,Medium,Not required,None,None,Partial,The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to BDF fonts and an incorrect calculation that triggers an out-of-bounds read.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=07bdb6e289c7954e2a533039dc93c1c136099d2d,,,,,,,
CVE-2012-5668,https://www.cvedetails.com/cve/CVE-2012-5668/,CWE-119,,DoS Overflow,2013-01-24,2016-12-06,4.3,None,Remote,Medium,Not required,None,None,Partial,"FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (NULL pointer dereference and crash) via vectors related to BDF fonts and the improper handling of an ""allocation error"" in the bdf_free_font function.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=9b6b5754b57c12b820e01305eb69b8863a161e5a,,,,,,,
CVE-2012-5667,https://www.cvedetails.com/cve/CVE-2012-5667/,CWE-189,,Exec Code Overflow,2013-01-03,2016-12-23,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,Multiple integer overflows in GNU Grep before 2.11 might allow context-dependent attackers to execute arbitrary code via vectors involving a long input line that triggers a heap-based buffer overflow.,,savannah,https://git.savannah.gnu.org/cgit/grep.git/commit/?id=cbbc1a45b9f843c811905c97c90a5d31f8e6c189,,,,,,,
CVE-2012-5667,https://www.cvedetails.com/cve/CVE-2012-5667/,CWE-189,,Exec Code Overflow,2013-01-03,2016-12-23,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,Multiple integer overflows in GNU Grep before 2.11 might allow context-dependent attackers to execute arbitrary code via vectors involving a long input line that triggers a heap-based buffer overflow.,,savannah,https://git.savannah.gnu.org/cgit/grep.git/commit/?id=8fcf61523644df42e1905c81bed26838e0b04f91,,,,,,,
CVE-2017-8849,https://www.cvedetails.com/cve/CVE-2017-8849/,CWE-20,,+Priv,2017-05-17,2017-11-04,7.2,None,Local,Low,Not required,Complete,Complete,Complete,smb4k before 2.0.1 allows local users to gain root privileges by leveraging failure to verify arguments to the mount helper DBUS service.,,kde,https://cgit.kde.org/smb4k.git/commit/?id=71554140bdaede27b95dbe4c9b5a028a83c83cce,,,,,,,
CVE-2017-8849,https://www.cvedetails.com/cve/CVE-2017-8849/,CWE-20,,+Priv,2017-05-17,2017-11-04,7.2,None,Local,Low,Not required,Complete,Complete,Complete,smb4k before 2.0.1 allows local users to gain root privileges by leveraging failure to verify arguments to the mount helper DBUS service.,,kde,https://cgit.kde.org/smb4k.git/commit/?id=a90289b0962663bc1d247bbbd31b9e65b2ca000e,,,,,,,
CVE-2018-11645,https://www.cvedetails.com/cve/CVE-2018-11645/,CWE-200,,+Info,2018-06-01,2018-11-11,5.0,None,Remote,Low,Not required,Partial,None,None,"psi/zfile.c in Artifex Ghostscript before 9.21rc1 permits the status command even if -dSAFER is used, which might allow remote attackers to determine the existence and size of arbitrary files, a similar issue to CVE-2016-7977.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=b60d50b7567369ad856cebe1efb6cd7dd2284219,,,,,,,
CVE-2012-4462,https://www.cvedetails.com/cve/CVE-2012-4462/,CWE-20,,DoS,2013-03-13,2013-03-19,4.3,None,Remote,Medium,Not required,None,None,Partial,"aviary/jobcontrol.py in Condor, as used in Red Hat Enterprise MRG 2.3, when removing a job, allows remote attackers to cause a denial of service (condor_schedd restart) via square brackets in the cproc option.",CPP,htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,95bcdf1d9a253d44a0bb9ab0d8c4743725c2b489,"@@ -268,7 +268,7 @@ AviaryScheddPlugin::processJob(const char *key,
 //     dprintf(D_FULLDEBUG, ""Processing: %s\n"", key);
 
        id = getProcByString(key);
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Failed to parse key: %s - skipping\n"", key);
                return false;
        }",https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp;h=981a2ef7cc7f749eca7702bd309a7cbf10bdffe8,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp;h=9f7325eb12c102e04079cc26d8adc0cacd914112;hb=8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,,
CVE-2012-4462,https://www.cvedetails.com/cve/CVE-2012-4462/,CWE-20,,DoS,2013-03-13,2013-03-19,4.3,None,Remote,Medium,Not required,None,None,Partial,"aviary/jobcontrol.py in Condor, as used in Red Hat Enterprise MRG 2.3, when removing a job, allows remote attackers to cause a denial of service (condor_schedd restart) via square brackets in the cproc option.",CPP,htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,95bcdf1d9a253d44a0bb9ab0d8c4743725c2b489,"@@ -263,7 +263,7 @@ SchedulerObject::setAttribute(std::string key,
                                                          std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""SetAttribute: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -303,7 +303,7 @@ bool
 SchedulerObject::hold(std::string key, std::string &reason, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Hold: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -329,7 +329,7 @@ bool
 SchedulerObject::release(std::string key, std::string &reason, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Release: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -353,7 +353,7 @@ bool
 SchedulerObject::remove(std::string key, std::string &reason, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -375,7 +375,7 @@ bool
 SchedulerObject::suspend(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
@@ -390,7 +390,7 @@ bool
 SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
-       if (id.cluster < 0 || id.proc < 0) {
+       if (id.cluster <= 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
",https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_contrib/aviary/src/SchedulerObject.cpp;h=89d4a859b76cb70dd225dfa0dbeba110d30aae2c,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_contrib/aviary/src/SchedulerObject.cpp;h=4d00667469e89dcb9149e22f2043289f4f16f91c;hb=8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84,,
CVE-2014-9745,https://www.cvedetails.com/cve/CVE-2014-9745/,CWE-399,,DoS,2015-09-14,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The parse_encoding function in type1/t1load.c in FreeType before 2.5.3 allows remote attackers to cause a denial of service (infinite loop) via a ""broken number-with-base"" in a Postscript stream, as demonstrated by 8#garbage.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=df14e6c0b9592cbb24d5381dfc6106b14f915e75,,,,,,,
CVE-2014-9718,https://www.cvedetails.com/cve/CVE-2014-9718/,CWE-399,,DoS,2015-04-21,2016-06-23,4.9,None,Local,Low,Not required,None,None,Complete,"The (1) BMDMA and (2) AHCI HBA interfaces in the IDE functionality in QEMU 1.0 through 2.1.3 have multiple interpretations of a function's return value, which allows guest OS users to cause a host OS denial of service (memory consumption or infinite loop, and system crash) via a PRDT with zero complete sectors, related to the bmdma_prepare_buf and ahci_dma_prepare_buf functions.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8,,,,,,,
CVE-2014-9706,https://www.cvedetails.com/cve/CVE-2014-9706/,CWE-19,,Exec Code,2015-03-31,2015-04-14,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The build_index_from_tree function in index.py in Dulwich before 0.9.9 allows remote attackers to execute arbitrary code via a commit with a directory path starting with .git/, which is not properly handled when checking out a working tree.",,samba,https://git.samba.org/?p=jelmer/dulwich.git;a=commitdiff;h=091638be3c89f46f42c3b1d57dc1504af5729176,,,,,,,
CVE-2014-9675,https://www.cvedetails.com/cve/CVE-2014-9675/,CWE-264,,Bypass,2015-02-08,2018-10-30,5.0,None,Remote,Low,Not required,Partial,None,None,"bdf/bdflib.c in FreeType before 2.5.4 identifies property names by only verifying that an initial substring is present, which allows remote attackers to discover heap pointer values and bypass the ASLR protection mechanism via a crafted BDF font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=2c4832d30939b45c05757f0a05128ce64c4cacc7,,,,,,,
CVE-2018-11469,https://www.cvedetails.com/cve/CVE-2018-11469/,CWE-200,,+Info,2018-05-25,2019-06-11,4.3,None,Remote,Medium,Not required,Partial,None,None,"Incorrect caching of responses to requests including an Authorization header in HAProxy 1.8.0 through 1.8.9 (if cache enabled) allows attackers to achieve information disclosure via an unauthenticated remote request, related to the proto_http.c check_request_for_cacheability function.",,haproxy,https://git.haproxy.org/?p=haproxy-1.8.git;a=commit;h=17514045e5d934dede62116216c1b016fe23dd06,,,,,,,
CVE-2014-9674,https://www.cvedetails.com/cve/CVE-2014-9674/,,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.5.4 proceeds with adding to length values without validating the original values, which allows remote attackers to cause a denial of service (integer overflow and heap-based buffer overflow) or possibly have unspecified other impact via a crafted Mac font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=cd4a5a26e591d01494567df9dec7f72d59551f6e,,,,,,,
CVE-2014-9674,https://www.cvedetails.com/cve/CVE-2014-9674/,,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.5.4 proceeds with adding to length values without validating the original values, which allows remote attackers to cause a denial of service (integer overflow and heap-based buffer overflow) or possibly have unspecified other impact via a crafted Mac font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=240c94a185cd8dae7d03059abec8a5662c35ecd3,,,,,,,
CVE-2014-9673,https://www.cvedetails.com/cve/CVE-2014-9673/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Integer signedness error in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted Mac font.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=35252ae9aa1dd9343e9f4884e9ddb1fee10ef415,,,,,,,
CVE-2014-9672,https://www.cvedetails.com/cve/CVE-2014-9672/,CWE-119,,DoS Overflow +Info,2015-02-08,2018-10-30,5.8,None,Remote,Medium,Not required,Partial,None,Partial,Array index error in the parse_fond function in base/ftmac.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (out-of-bounds read) or obtain sensitive information from process memory via a crafted FOND resource in a Mac font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=18a8f0d9943369449bc4de92d411c78fb08d616c,,,,,,,
CVE-2014-9671,https://www.cvedetails.com/cve/CVE-2014-9671/,,,DoS,2015-02-08,2018-10-30,4.3,None,Remote,Medium,Not required,None,None,Partial,Off-by-one error in the pcf_get_properties function in pcf/pcfread.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PCF file with a 0xffffffff size value that is improperly incremented.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0e2f5d518c60e2978f26400d110eff178fa7e3c3,,,,,,,
CVE-2014-9670,https://www.cvedetails.com/cve/CVE-2014-9670/,CWE-189,,DoS Overflow,2015-02-08,2018-10-30,4.3,None,Remote,Medium,Not required,None,None,Partial,"Multiple integer signedness errors in the pcf_get_encodings function in pcf/pcfread.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (integer overflow, NULL pointer dereference, and application crash) via a crafted PCF file that specifies negative values for the first column and first row.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=ef1eba75187adfac750f326b563fe543dd5ff4e6,,,,,,,
CVE-2014-9669,https://www.cvedetails.com/cve/CVE-2014-9669/,CWE-125,,DoS Overflow Mem. Corr.,2015-02-08,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Multiple integer overflows in sfnt/ttcmap.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (out-of-bounds read or memory corruption) or possibly have unspecified other impact via a crafted cmap SFNT table.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=602040b1112c9f94d68e200be59ea7ac3d104565,,,,,,,
CVE-2012-3363,https://www.cvedetails.com/cve/CVE-2012-3363/,,,,2013-02-13,2013-12-05,6.4,None,Remote,Low,Not required,Partial,Partial,None,"Zend_XmlRpc in Zend Framework 1.x before 1.11.12 and 1.12.x before 1.12.0 does not properly handle SimpleXMLElement classes, which allows remote attackers to read arbitrary files or create TCP connections via an external entity reference in a DOCTYPE element in an XML-RPC request, aka an XML external entity (XXE) injection attack.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-34284,,,,,,,
CVE-2014-9668,https://www.cvedetails.com/cve/CVE-2014-9668/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The woff_open_font function in sfnt/sfobjs.c in FreeType before 2.5.4 proceeds with offset+length calculations without restricting length values, which allows remote attackers to cause a denial of service (integer overflow and heap-based buffer overflow) or possibly have unspecified other impact via a crafted Web Open Font Format (WOFF) file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f46add13895337ece929b18bb8f036431b3fb538,,,,,,,
CVE-2014-9667,https://www.cvedetails.com/cve/CVE-2014-9667/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"sfnt/ttload.c in FreeType before 2.5.4 proceeds with offset+length calculations without restricting the values, which allows remote attackers to cause a denial of service (integer overflow and out-of-bounds read) or possibly have unspecified other impact via a crafted SFNT table.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=677ddf4f1dc1b36cef7c7ddd59a14c508f4b1891,,,,,,,
CVE-2014-9666,https://www.cvedetails.com/cve/CVE-2014-9666/,CWE-189,,DoS Overflow,2015-02-08,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The tt_sbit_decoder_init function in sfnt/ttsbit.c in FreeType before 2.5.4 proceeds with a count-to-size association without restricting the count value, which allows remote attackers to cause a denial of service (integer overflow and out-of-bounds read) or possibly have unspecified other impact via a crafted embedded bitmap.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=257c270bd25e15890190a28a1456e7623bba4439,,,,,,,
CVE-2014-9665,https://www.cvedetails.com/cve/CVE-2014-9665/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The Load_SBit_Png function in sfnt/pngshim.c in FreeType before 2.5.4 does not restrict the rows and pitch values of PNG data, which allows remote attackers to cause a denial of service (integer overflow and heap-based buffer overflow) or possibly have unspecified other impact by embedding a PNG file in a .ttf font file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=b3500af717010137046ec4076d1e1c0641e33727,,,,,,,
CVE-2014-9665,https://www.cvedetails.com/cve/CVE-2014-9665/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The Load_SBit_Png function in sfnt/pngshim.c in FreeType before 2.5.4 does not restrict the rows and pitch values of PNG data, which allows remote attackers to cause a denial of service (integer overflow and heap-based buffer overflow) or possibly have unspecified other impact by embedding a PNG file in a .ttf font file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=54abd22891bd51ef8b533b24df53b3019b5cee81,,,,,,,
CVE-2014-9664,https://www.cvedetails.com/cve/CVE-2014-9664/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"FreeType before 2.5.4 does not check for the end of the data during certain parsing actions, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted Type42 font, related to type42/t42parse.c and type1/t1load.c.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=dd89710f0f643eb0f99a3830e0712d26c7642acd,,,,,,,
CVE-2014-9664,https://www.cvedetails.com/cve/CVE-2014-9664/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"FreeType before 2.5.4 does not check for the end of the data during certain parsing actions, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted Type42 font, related to type42/t42parse.c and type1/t1load.c.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=73be9f9ab67842cfbec36ee99e8d2301434c84ca,,,,,,,
CVE-2014-9663,https://www.cvedetails.com/cve/CVE-2014-9663/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The tt_cmap4_validate function in sfnt/ttcmap.c in FreeType before 2.5.4 validates a certain length field before that field's value is completely calculated, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted cmap SFNT table.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=9bd20b7304aae61de5d50ac359cf27132bafd4c1,,,,,,,
CVE-2014-9662,https://www.cvedetails.com/cve/CVE-2014-9662/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"cff/cf2ft.c in FreeType before 2.5.4 does not validate the return values of point-allocation functions, which allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted OTF font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=5f201ab5c24cb69bc96b724fd66e739928d6c5e2,,,,,,,
CVE-2014-9661,https://www.cvedetails.com/cve/CVE-2014-9661/,,,DoS,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"type42/t42parse.c in FreeType before 2.5.4 does not consider that scanning can be incomplete without triggering an error, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted Type42 font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=42fcd6693ec7bd6ffc65ddc63e74287a65dda669,,,,,,,
CVE-2014-9661,https://www.cvedetails.com/cve/CVE-2014-9661/,,,DoS,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"type42/t42parse.c in FreeType before 2.5.4 does not consider that scanning can be incomplete without triggering an error, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted Type42 font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3788187e0c396952cd7d905c6c61f3ff8e84b2b4,,,,,,,
CVE-2014-9660,https://www.cvedetails.com/cve/CVE-2014-9660/,CWE-476,,DoS,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The _bdf_parse_glyphs function in bdf/bdflib.c in FreeType before 2.5.4 does not properly handle a missing ENDCHAR record, which allows remote attackers to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via a crafted BDF font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=af8346172a7b573715134f7a51e6c5c60fa7f2ab,,,,,,,
CVE-2014-9659,https://www.cvedetails.com/cve/CVE-2014-9659/,CWE-119,,DoS Exec Code Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"cff/cf2intrp.c in the CFF CharString interpreter in FreeType before 2.5.4 proceeds with additional hints after the hint mask has been computed, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted OpenType font.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-2240.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=2cdc4562f873237f1c77d43540537c7a721d3fd8,,,,,,,
CVE-2014-9658,https://www.cvedetails.com/cve/CVE-2014-9658/,CWE-125,,DoS,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The tt_face_load_kern function in sfnt/ttkern.c in FreeType before 2.5.4 enforces an incorrect minimum table length, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted TrueType font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f70d9342e65cd2cb44e9f26b6d7edeedf191fc6c,,,,,,,
CVE-2014-9657,https://www.cvedetails.com/cve/CVE-2014-9657/,CWE-125,,DoS,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The tt_face_load_hdmx function in truetype/ttpload.c in FreeType before 2.5.4 does not establish a minimum record size, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted TrueType font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=eca0f067068020870a429fe91f6329e499390d55,,,,,,,
CVE-2014-9656,https://www.cvedetails.com/cve/CVE-2014-9656/,CWE-119,,DoS Overflow,2015-02-08,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The tt_sbit_decoder_load_image function in sfnt/ttsbit.c in FreeType before 2.5.4 does not properly check for an integer overflow, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted OpenType font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f0292bb9920aa1dbfed5f53861e7c7a89b35833a,,,,,,,
CVE-2012-2686,https://www.cvedetails.com/cve/CVE-2012-2686/,CWE-310,,DoS,2013-02-08,2018-08-08,5.0,None,Remote,Low,Not required,None,None,Partial,crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=125093b59f3c2a2d33785b5563d929d0472f1721,,,,,,,
CVE-2017-8422,https://www.cvedetails.com/cve/CVE-2017-8422/,CWE-290,,+Priv,2017-05-17,2019-10-02,7.2,None,Local,Low,Not required,Complete,Complete,Complete,KDE kdelibs before 4.14.32 and KAuth before 5.34 allow local users to gain root privileges by spoofing a callerID and leveraging a privileged helper app.,,kde,https://cgit.kde.org/kauth.git/commit/?id=df875f725293af53399f5146362eb158b4f9216a,,,,,,,
CVE-2017-8422,https://www.cvedetails.com/cve/CVE-2017-8422/,CWE-290,,+Priv,2017-05-17,2019-10-02,7.2,None,Local,Low,Not required,Complete,Complete,Complete,KDE kdelibs before 4.14.32 and KAuth before 5.34 allow local users to gain root privileges by spoofing a callerID and leveraging a privileged helper app.,,kde,https://cgit.kde.org/kdelibs.git/commit/?id=264e97625abe2e0334f97de17f6ffb52582888ab,,,,,,,
CVE-2011-4718,https://www.cvedetails.com/cve/CVE-2011-4718/,CWE-264,,,2013-08-13,2013-08-13,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Session fixation vulnerability in the Sessions subsystem in PHP before 5.5.2 allows remote attackers to hijack web sessions by specifying a session ID.,,php,https://git.php.net/?p=php-src.git;a=commit;h=25e8fcc88fa20dc9d4c47184471003f436927cde,,,,,,,
CVE-2011-4718,https://www.cvedetails.com/cve/CVE-2011-4718/,CWE-264,,,2013-08-13,2013-08-13,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Session fixation vulnerability in the Sessions subsystem in PHP before 5.5.2 allows remote attackers to hijack web sessions by specifying a session ID.,,php,https://git.php.net/?p=php-src.git;a=commit;h=169b78eb79b0e080b67f9798708eb3771c6d0b2f,,,,,,,
CVE-2014-9427,https://www.cvedetails.com/cve/CVE-2014-9427/,CWE-119,,Exec Code Overflow +Info,2015-01-02,2016-12-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"sapi/cgi/cgi_main.c in the CGI component in PHP through 5.4.36, 5.5.x through 5.5.20, and 5.6.x through 5.6.4, when mmap is used to read a .php file, does not properly consider the mapping's length during processing of an invalid file that begins with a # character and lacks a newline character, which causes an out-of-bounds read and might (1) allow remote attackers to obtain sensitive information from php-cgi process memory by leveraging the ability to upload a .php file or (2) trigger unexpected code execution if a valid PHP script is present in memory locations adjacent to the mapping.",,php,https://git.php.net/?p=php-src.git;a=commit;h=f9ad3086693fce680fbe246e4a45aa92edd2ac35,,,,,,,
CVE-2012-5534,https://www.cvedetails.com/cve/CVE-2012-5534/,CWE-20,,Exec Code,2012-12-03,2014-02-06,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The hook_process function in the plugin API for WeeChat 0.3.0 through 0.3.9.1 allows remote attackers to execute arbitrary commands via shell metacharacters in a command from a plugin, related to ""shell expansion.""",,savannah,https://git.savannah.gnu.org/gitweb/?p=weechat.git;a=commitdiff_plain;h=efb795c74fe954b9544074aafcebb1be4452b03a,,,,,,,
CVE-2017-8291,https://www.cvedetails.com/cve/CVE-2017-8291/,CWE-704,,Exec Code Bypass,2017-04-26,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Artifex Ghostscript through 2017-04-26 allows -dSAFER bypass and remote command execution via .rsdparams type confusion with a ""/OutputFile (%pipe%"" substring in a crafted .eps document that is an input to the gs program, as exploited in the wild in April 2017.",,ghostscript,https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=04b37bbce174eed24edec7ad5b920eb93db4d47d,,,,,,,
CVE-2017-8287,https://www.cvedetails.com/cve/CVE-2017-8287/,CWE-119,,Overflow,2017-04-26,2019-04-23,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,FreeType 2 before 2017-03-26 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_builder_close_contour function in psaux/psobjs.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3774fc08b502c3e685afca098b6e8a195aded6a0,,,,,,,
CVE-2012-5481,https://www.cvedetails.com/cve/CVE-2012-5481/,CWE-264,,Bypass,2012-11-21,2013-06-20,4.0,None,Remote,Low,Single system,Partial,None,None,Moodle 2.3.x before 2.3.3 allows remote authenticated users to bypass the moodle/role:manage capability requirement and read all capability data by visiting the Check Permissions page.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-35381,,,,,,,
CVE-2012-5480,https://www.cvedetails.com/cve/CVE-2012-5480/,CWE-264,,Bypass,2012-11-21,2013-06-20,6.4,None,Remote,Low,Not required,Partial,None,Partial,"The Database activity module in Moodle 2.1.x before 2.1.9, 2.2.x before 2.2.6, and 2.3.x before 2.3.3 allows remote attackers to bypass intended restrictions on reading other participants' entries via an advanced search.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-35558,,,,,,,
CVE-2012-5479,https://www.cvedetails.com/cve/CVE-2012-5479/,CWE-264,,,2012-11-21,2013-06-20,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"The Portfolio plugin in Moodle 2.1.x before 2.1.9, 2.2.x before 2.2.6, and 2.3.x before 2.3.3 allows remote authenticated users to upload and execute files via a modified Portfolio API callback.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-33791,,,,,,,
CVE-2012-5479,https://www.cvedetails.com/cve/CVE-2012-5479/,CWE-264,,,2012-11-21,2013-06-20,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"The Portfolio plugin in Moodle 2.1.x before 2.1.9, 2.2.x before 2.2.6, and 2.3.x before 2.3.3 allows remote authenticated users to upload and execute files via a modified Portfolio API callback.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36346,,,,,,,
CVE-2012-5473,https://www.cvedetails.com/cve/CVE-2012-5473/,CWE-200,,+Info,2012-11-21,2013-06-20,4.0,None,Remote,Low,Single system,Partial,None,None,"The Database activity module in Moodle 2.1.x before 2.1.9, 2.2.x before 2.2.6, and 2.3.x before 2.3.3 allows remote authenticated users to read activity entries of a different group's users via an advanced search.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-34448,,,,,,,
CVE-2012-5472,https://www.cvedetails.com/cve/CVE-2012-5472/,CWE-264,,Bypass,2012-11-21,2013-06-20,4.0,None,Remote,Low,Single system,None,Partial,None,lib/formslib.php in Moodle 2.2.x before 2.2.6 and 2.3.x before 2.3.3 allows remote authenticated users to bypass intended access restrictions via a modified value of a frozen form field.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-32785,,,,,,,
CVE-2012-5471,https://www.cvedetails.com/cve/CVE-2012-5471/,CWE-264,,,2012-11-21,2013-06-20,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"The Dropbox Repository File Picker in Moodle 2.1.x before 2.1.9, 2.2.x before 2.2.6, and 2.3.x before 2.3.3 allows remote authenticated users to access the Dropbox of a different user by leveraging an unattended workstation after a logout.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-29872,,,,,,,
CVE-2010-3443,https://www.cvedetails.com/cve/CVE-2010-3443/,CWE-399,,DoS,2013-11-23,2014-03-05,5.0,None,Remote,Low,Not required,None,None,Partial,ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.,CPP,quassel,https://git.quassel-irc.org/?p=quassel.git;a=commitdiff;h=a4ca568cdf68cf4a0343eb161518dc8e50cea87d,a4ca568cdf68cf4a0343eb161518dc8e50cea87d,6e02e38993d9b2d3c5e36359dcb6f6969e4caf39,"@@ -129,6 +129,7 @@ void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const
   int xdelimPos = -1;
   int xdelimEndPos = -1;
   int spacePos = -1;
+  QList<QByteArray> replies;
   while((xdelimPos = dequotedMessage.indexOf(XDELIM)) != -1) {
     if(xdelimPos > 0)
       displayMsg(messageType, target, userDecode(target, dequotedMessage.left(xdelimPos)), prefix, flags);
@@ -154,7 +155,16 @@ void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const
       ctcpparam = QString();
     }
 
-    handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam));
+    if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ctcpcmd.toUpper())) {
+      QString reply_;
+      handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam), Q_ARG(QString, reply_));
+      if(ctcptype == CtcpQuery && !reply_.isNull()) {
+        replies << lowLevelQuote(pack(serverEncode(ctcpcmd), userEncode(nickFromMask(prefix), reply_)));
+      }
+    }
+  }
+  if(ctcptype == CtcpQuery && !replies.isEmpty()) {
+    packedReply(nickFromMask(prefix), replies);
   }
 
   if(!dequotedMessage.isEmpty())
@@ -180,20 +190,39 @@ void CtcpHandler::reply(const QString &bufname, const QString &ctcpTag, const QS
   emit putCmd(""NOTICE"", params);
 }
 
+void CtcpHandler::packedReply(const QString &bufname, const QList<QByteArray> &replies) {
+  QList<QByteArray> params;
+
+  int answerSize = 0;
+  for(int i = 0; i < replies.count(); i++) {
+    answerSize += replies.at(i).size();
+  }
+
+  QByteArray quotedReply(answerSize, 0);
+  int nextPos = 0;
+  QByteArray &reply = quotedReply;
+  for(int i = 0; i < replies.count(); i++) {
+    reply = replies.at(i);
+    quotedReply.replace(nextPos, reply.size(), reply);
+    nextPos += reply.size();
+  }
+
+  params << serverEncode(bufname) << quotedReply;
+  emit putCmd(""NOTICE"", params);
+}
+
 //******************************/
 // CTCP HANDLER
 //******************************/
-void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
+void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &/*reply*/) {
   Q_UNUSED(ctcptype)
   emit displayMsg(Message::Action, typeByTarget(target), target, param, prefix);
 }
 
-void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
+void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
   Q_UNUSED(target)
   if(ctcptype == CtcpQuery) {
-    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ""PING""))
-      return;
-    reply(nickFromMask(prefix), ""PING"", param);
+    reply = param;
     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP PING request from %1"").arg(prefix));
   } else {
     // display ping answer
@@ -204,14 +233,10 @@ void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QSt
   }
 }
 
-void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
+void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
   Q_UNUSED(target)
   if(ctcptype == CtcpQuery) {
-    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ""VERSION""))
-      return;
-    reply(nickFromMask(prefix), ""VERSION"", QString(""Quassel IRC %1 (built on %2) -- http://www.quassel-irc.org"")
-          .arg(Quassel::buildInfo().plainVersionString)
-          .arg(Quassel::buildInfo().buildDate));
+    reply = QString(""Quassel IRC %1 (built on %2) -- http://www.quassel-irc.org"").arg(Quassel::buildInfo().plainVersionString).arg(Quassel::buildInfo().buildDate);
     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP VERSION request by %1"").arg(prefix));
   } else {
     // display Version answer
@@ -220,28 +245,24 @@ void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const
   }
 }
 
-void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
+void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
   Q_UNUSED(target)
   if(ctcptype == CtcpQuery) {
-    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ""TIME""))
-      return;
-    reply(nickFromMask(prefix), ""TIME"", QDateTime::currentDateTime().toString());
+    reply = QDateTime::currentDateTime().toString();
     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP TIME request by %1"").arg(prefix));
-  }
-  else {
+  } else {
     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP TIME answer from %1: %2"")
                     .arg(nickFromMask(prefix)).arg(param));
   }
 }
 
-void CtcpHandler::defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
+void CtcpHandler::defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
   Q_UNUSED(ctcptype);
   Q_UNUSED(target);
-  if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName())) {
-    QString str = tr(""Received unknown CTCP %1 by %2"").arg(cmd).arg(prefix);
-    if(!param.isEmpty())
-      str.append(tr("" with arguments: %1"").arg(param));
-    emit displayMsg(Message::Error, BufferInfo::StatusBuffer, """", str);
-  }
+  Q_UNUSED(reply);
+  QString str = tr(""Received unknown CTCP %1 by %2"").arg(cmd).arg(prefix);
+  if(!param.isEmpty())
+    str.append(tr("" with arguments: %1"").arg(param));
+  emit displayMsg(Message::Error, BufferInfo::StatusBuffer, """", str);
 }",https://git.quassel-irc.org/?p=quassel.git;a=blob;f=src/core/ctcphandler.cpp;h=655f1700408189af13cf3f9cd81b36b10b8cc1b1,https://git.quassel-irc.org/?p=quassel.git;a=blob;f=src/core/ctcphandler.cpp;h=758d2ef1458a0a7b9c82dfd9f65ec59dea8fceaf;hb=a4ca568cdf68cf4a0343eb161518dc8e50cea87d,,
CVE-2010-3443,https://www.cvedetails.com/cve/CVE-2010-3443/,CWE-399,,DoS,2013-11-23,2014-03-05,5.0,None,Remote,Low,Not required,None,None,Partial,ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.,H,quassel,https://git.quassel-irc.org/?p=quassel.git;a=commitdiff;h=a4ca568cdf68cf4a0343eb161518dc8e50cea87d,a4ca568cdf68cf4a0343eb161518dc8e50cea87d,6e02e38993d9b2d3c5e36359dcb6f6969e4caf39,"@@ -48,14 +48,16 @@ public:
   void reply(const QString &bufname, const QString &ctcpTag, const QString &message);
 
 public slots:
-  void handleAction(CtcpType, const QString &prefix, const QString &target, const QString &param);
-  void handlePing(CtcpType, const QString &prefix, const QString &target, const QString &param);
-  void handleTime(CtcpType, const QString &prefix, const QString &target, const QString &param);
-  void handleVersion(CtcpType, const QString &prefix, const QString &target, const QString &param);
+  void handleAction(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);
+  void handlePing(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);
+  void handleTime(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);
+  void handleVersion(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);
 
-  void defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param);
+  void defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply);
 
 private:
+  void packedReply(const QString &bufname, const QList<QByteArray> &replies);
+
   QByteArray XDELIM;
   QHash<QByteArray, QByteArray> ctcpMDequoteHash;
   QHash<QByteArray, QByteArray> ctcpXDelimDequoteHash;",https://git.quassel-irc.org/?p=quassel.git;a=blob;f=src/core/ctcphandler.h;h=169ec16f4f133fccf0dafee4c1de43463e1f2cc2,https://git.quassel-irc.org/?p=quassel.git;a=blob;f=src/core/ctcphandler.h;h=e2f43a582331373a50adf2d319ce8a79abd99aa4;hb=a4ca568cdf68cf4a0343eb161518dc8e50cea87d,,
CVE-2014-9426,https://www.cvedetails.com/cve/CVE-2014-9426/,CWE-17,,DoS Mem. Corr.,2014-12-30,2015-03-16,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"** DISPUTED ** The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable.",,php,https://git.php.net/?p=php-src.git;a=commit;h=a72cd07f2983dc43a6bb35209dc4687852e53c09,,,,,,,
CVE-2014-9426,https://www.cvedetails.com/cve/CVE-2014-9426/,CWE-17,,DoS Mem. Corr.,2014-12-30,2015-03-16,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"** DISPUTED ** The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable.",,php,https://git.php.net/?p=php-src.git;a=commit;h=ef89ab2f99fbd9b7b714556d4f1f50644eb54191,,,,,,,
CVE-2014-9425,https://www.cvedetails.com/cve/CVE-2014-9425/,,,DoS,2014-12-30,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Double free vulnerability in the zend_ts_hash_graceful_destroy function in zend_ts_hash.c in the Zend Engine in PHP through 5.5.20 and 5.6.x through 5.6.4 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,,php,https://git.php.net/?p=php-src.git;a=commit;h=2bcf69d073190e4f032d883f3416dea1b027a39e,,,,,,,
CVE-2014-9425,https://www.cvedetails.com/cve/CVE-2014-9425/,,,DoS,2014-12-30,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Double free vulnerability in the zend_ts_hash_graceful_destroy function in zend_ts_hash.c in the Zend Engine in PHP through 5.5.20 and 5.6.x through 5.6.4 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,,php,https://git.php.net/?p=php-src.git;a=commit;h=fbf3a6bc1abcc8a5b5226b0ad9464c37f11ddbd6,,,,,,,
CVE-2014-9425,https://www.cvedetails.com/cve/CVE-2014-9425/,,,DoS,2014-12-30,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Double free vulnerability in the zend_ts_hash_graceful_destroy function in zend_ts_hash.c in the Zend Engine in PHP through 5.5.20 and 5.6.x through 5.6.4 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,,php,https://git.php.net/?p=php-src.git;a=commit;h=24125f0f26f3787c006e4a51611ba33ee3b841cb,,,,,,,
CVE-2019-7443,https://www.cvedetails.com/cve/CVE-2019-7443/,CWE-20,,,2019-05-07,2019-05-10,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"KDE KAuth before 5.55 allows the passing of parameters with arbitrary types to helpers running as root over DBus via DBusHelperProxy.cpp. Certain types can cause crashes, and trigger the decoding of arbitrary images with dynamically loaded plugins. In other words, KAuth unintentionally causes this plugin code to run as root, which increases the severity of any possible exploitation of a plugin vulnerability.",,kde,https://cgit.kde.org/kauth.git/commit/?id=fc70fb0161c1b9144d26389434d34dd135cd3f4a,,,,,,,
CVE-2017-8105,https://www.cvedetails.com/cve/CVE-2017-8105/,CWE-787,,Overflow,2017-04-24,2019-04-23,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,FreeType 2 before 2017-03-24 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_decoder_parse_charstrings function in psaux/t1decode.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f958c48ee431bef8d4d466b40c9cb2d4dbcb7791,,,,,,,
CVE-2017-8086,https://www.cvedetails.com/cve/CVE-2017-8086/,CWE-772,,DoS,2017-05-02,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the v9fs_list_xattr function in hw/9pfs/9p-xattr.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (memory consumption) via vectors involving the orig_value variable.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2,,,,,,,
CVE-2019-7222,https://www.cvedetails.com/cve/CVE-2019-7222/,CWE-200,,+Info,2019-03-21,2019-08-06,2.1,None,Local,Low,Not required,Partial,None,None,The KVM implementation in the Linux kernel through 4.20.5 has an Information Leak.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=353c0956a618a07ba4bbe7ad00ff29fe70e8412a,,,,,,,
CVE-2019-7221,https://www.cvedetails.com/cve/CVE-2019-7221/,CWE-416,,,2019-03-21,2019-06-14,4.6,None,Local,Low,Not required,Partial,Partial,Partial,The KVM implementation in the Linux kernel through 4.20.5 has a Use-after-Free.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ecec76885bcfe3294685dc363fd1273df0d5d65f,,,,,,,
CVE-2017-8070,https://www.cvedetails.com/cve/CVE-2017-8070/,CWE-119,,DoS Overflow Mem. Corr.,2017-04-23,2017-04-28,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"drivers/net/usb/catc.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478,,,,,,,
CVE-2017-8068,https://www.cvedetails.com/cve/CVE-2017-8068/,CWE-119,,DoS Overflow Mem. Corr.,2017-04-23,2017-04-27,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5593523f968bc86d42a035c6df47d5e0979b5ace,,,,,,,
CVE-2017-8064,https://www.cvedetails.com/cve/CVE-2017-8064/,CWE-119,,DoS Overflow Mem. Corr.,2017-04-23,2017-11-03,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"drivers/media/usb/dvb-usb-v2/dvb_usb_core.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=005145378c9ad7575a01b6ce1ba118fb427f583a,,,,,,,
CVE-2017-8063,https://www.cvedetails.com/cve/CVE-2017-8063/,CWE-119,,DoS Overflow,2017-04-23,2017-04-27,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"drivers/media/usb/dvb-usb/cxusb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3f190e3aec212fc8c61e202c51400afa7384d4bc,,,,,,,
CVE-2017-8062,https://www.cvedetails.com/cve/CVE-2017-8062/,CWE-119,,DoS Overflow Mem. Corr.,2017-04-23,2017-04-27,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=606142af57dad981b78707234cfbd15f9f7b7125,,,,,,,
CVE-2017-8061,https://www.cvedetails.com/cve/CVE-2017-8061/,CWE-119,,DoS Overflow Mem. Corr.,2017-04-23,2017-04-27,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"drivers/media/usb/dvb-usb/dvb-usb-firmware.c in the Linux kernel 4.9.x and 4.10.x before 4.10.7 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=67b0503db9c29b04eadfeede6bebbfe5ddad94ef,,,,,,,
CVE-2018-10938,https://www.cvedetails.com/cve/CVE-2018-10938/,CWE-835,,,2018-08-27,2019-10-02,7.1,None,Remote,Medium,Not required,None,None,Complete,A flaw was found in the Linux kernel present since v4.0-rc1 and through v4.13-rc4. A crafted network packet sent remotely by an attacker may force the kernel to enter an infinite loop in the cipso_v4_optptr() function in net/ipv4/cipso_ipv4.c leading to a denial-of-service. A certain non-default configuration of LSM (Linux Security Module) and NetLabel should be set up on a system before an attacker could leverage this flaw.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=40413955ee265a5e42f710940ec78f5450d49149,,,,,,,
CVE-2018-10902,https://www.cvedetails.com/cve/CVE-2018-10902/,CWE-415,,+Priv,2018-08-21,2019-10-09,4.6,None,Local,Low,Not required,Partial,Partial,Partial,It was found that the raw midi kernel driver does not protect against concurrent access which leads to a double realloc (double free) in snd_rawmidi_input_params() and snd_rawmidi_output_status() which are part of snd_rawmidi_ioctl() handler in rawmidi.c file. A malicious local attacker could possibly use this for privilege escalation.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=39675f7a7c7e7702f7d5341f1e0d01db746543a0,,,,,,,
CVE-2018-10901,https://www.cvedetails.com/cve/CVE-2018-10901/,,,,2018-07-26,2019-10-02,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"A flaw was found in Linux kernel's KVM virtualization subsystem. The VMX code does not restore the GDT.LIMIT to the previous host value, but instead sets it to 64KB. With a corrupted GDT limit a host's userspace code has an ability to place malicious entries in the GDT, particularly to the per-cpu variables. An attacker can use this to escalate their privileges.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3444d7da1839b851eefedd372978d8a982316c36,,,,,,,
CVE-2014-9060,https://www.cvedetails.com/cve/CVE-2014-9060/,CWE-20,,,2014-11-24,2015-09-03,5.0,None,Remote,Low,Not required,Partial,None,None,"The LTI module in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 does not properly restrict the parameters used in a return URL, which allows remote attackers to trigger the generation of arbitrary messages via a modified URL, related to mod/lti/locallib.php and mod/lti/return.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47927,,,,,,,
CVE-2014-9059,https://www.cvedetails.com/cve/CVE-2014-9059/,CWE-79,,XSS,2014-11-24,2015-09-03,4.3,None,Remote,Medium,Not required,None,Partial,None,"lib/setup.php in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 does not provide charset information in HTTP headers, which might allow remote attackers to conduct cross-site scripting (XSS) attacks via UTF-7 characters during interaction with AJAX scripts.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47966,,,,,,,
CVE-2010-4352,https://www.cvedetails.com/cve/CVE-2010-4352/,CWE-399,,DoS,2010-12-30,2016-12-07,2.1,None,Local,Low,Not required,None,None,Partial,Stack consumption vulnerability in D-Bus (aka DBus) before 1.4.1 allows local users to cause a denial of service (daemon crash) via a message containing many nested variants.,,dbus,https://cgit.freedesktop.org/dbus/dbus/commit/?id=7d65a3a6ed8815e34a99c680ac3869fde49dbbd4,,,,,,,
CVE-2018-10883,https://www.cvedetails.com/cve/CVE-2018-10883/,CWE-787,,DoS,2018-07-30,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write in jbd2_journal_dirty_metadata(), a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8bc1379b82b8e809eef77a9fedbb75c6c297be19,,,,,,,
CVE-2018-10883,https://www.cvedetails.com/cve/CVE-2018-10883/,CWE-787,,DoS,2018-07-30,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write in jbd2_journal_dirty_metadata(), a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e09463f220ca9a1a1ecfda84fcda658f99a1f12a,,,,,,,
CVE-2018-10882,https://www.cvedetails.com/cve/CVE-2018-10882/,CWE-787,,DoS,2018-07-27,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bound write in in fs/jbd2/transaction.c code, a denial of service, and a system crash by unmounting a crafted ext4 filesystem image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c37e9e013469521d9adb932d17a1795c139b36db,,,,,,,
CVE-2018-10881,https://www.cvedetails.com/cve/CVE-2018-10881/,CWE-119,,DoS Overflow,2018-07-26,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bound access in ext4_get_group_info function, a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e8ab72a812396996035a37e5ca4b3b99b5d214b,,,,,,,
CVE-2018-10880,https://www.cvedetails.com/cve/CVE-2018-10880/,CWE-787,,DoS,2018-07-25,2019-04-01,7.1,None,Remote,Medium,Not required,None,None,Complete,Linux kernel is vulnerable to a stack-out-of-bounds write in the ext4 filesystem code when mounting and writing to a crafted ext4 image in ext4_update_inline_data(). An attacker could use this to cause a system crash and a denial of service.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8cdb5240ec5928b20490a2bb34cb87e9a5f40226,,,,,,,
CVE-2014-9028,https://www.cvedetails.com/cve/CVE-2014-9028/,CWE-119,,Exec Code Overflow,2014-11-26,2018-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Heap-based buffer overflow in stream_decoder.c in libFLAC before 1.3.1 allows remote attackers to execute arbitrary code via a crafted .flac file.,,xiph,https://git.xiph.org/?p=flac.git;a=commit;h=fcf0ba06ae12ccd7c67cee3c8d948df15f946b85,,,,,,,
CVE-2018-10879,https://www.cvedetails.com/cve/CVE-2018-10879/,CWE-416,,DoS,2018-07-26,2019-10-09,6.1,None,Local,Low,Not required,Partial,Partial,Complete,A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause a use-after-free in ext4_xattr_set_entry function and a denial of service or unspecified other impact may occur by renaming a file in a crafted ext4 filesystem image.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=513f86d73855ce556ea9522b6bfd79f87356dc3a,,,,,,,
CVE-2018-10879,https://www.cvedetails.com/cve/CVE-2018-10879/,CWE-416,,DoS,2018-07-26,2019-10-09,6.1,None,Local,Low,Not required,Partial,Partial,Complete,A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause a use-after-free in ext4_xattr_set_entry function and a denial of service or unspecified other impact may occur by renaming a file in a crafted ext4 filesystem image.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5369a762c882c0b6e9599e4ebbb3a9ba9eee7e2d,,,,,,,
CVE-2018-10878,https://www.cvedetails.com/cve/CVE-2018-10878/,CWE-787,,DoS,2018-07-26,2019-10-09,6.1,None,Local,Low,Not required,Partial,Partial,Complete,A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write and a denial of service or unspecified other impact is possible by mounting and operating a crafted ext4 filesystem image.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=819b23f1c501b17b9694325471789e6b5cc2d0d2,,,,,,,
CVE-2018-10878,https://www.cvedetails.com/cve/CVE-2018-10878/,CWE-787,,DoS,2018-07-26,2019-10-09,6.1,None,Local,Low,Not required,Partial,Partial,Complete,A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write and a denial of service or unspecified other impact is possible by mounting and operating a crafted ext4 filesystem image.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=77260807d1170a8cf35dbb06e07461a655f67eee,,,,,,,
CVE-2018-10876,https://www.cvedetails.com/cve/CVE-2018-10876/,CWE-416,,,2018-07-26,2019-04-01,4.9,None,Local,Low,Not required,None,None,Complete,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8844618d8aa7a9973e7b527d038a2a589665002c,,,,,,,
CVE-2014-8962,https://www.cvedetails.com/cve/CVE-2014-8962/,CWE-119,,Exec Code Overflow,2014-11-26,2018-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Stack-based buffer overflow in stream_decoder.c in libFLAC before 1.3.1 allows remote attackers to execute arbitrary code via a crafted .flac file.,,xiph,https://git.xiph.org/?p=flac.git;a=commit;h=5b3033a2b355068c11fe637e14ac742d273f076e,,,,,,,
CVE-2018-10853,https://www.cvedetails.com/cve/CVE-2018-10853/,CWE-269,,,2018-09-11,2019-10-02,4.6,None,Local,Low,Not required,Partial,Partial,Partial,A flaw was found in the way Linux kernel KVM hypervisor before 4.18 emulated instructions such as sgdt/sidt/fxsave/fxrstor. It did not check current privilege(CPL) level while emulating unprivileged instructions. An unprivileged guest user/process could use this flaw to potentially escalate privileges inside guest.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=129a72a0d3c8e139a04512325384fe5ac119e74,,,,,,,
CVE-2018-10853,https://www.cvedetails.com/cve/CVE-2018-10853/,CWE-269,,,2018-09-11,2019-10-02,4.6,None,Local,Low,Not required,Partial,Partial,Partial,A flaw was found in the way Linux kernel KVM hypervisor before 4.18 emulated instructions such as sgdt/sidt/fxsave/fxrstor. It did not check current privilege(CPL) level while emulating unprivileged instructions. An unprivileged guest user/process could use this flaw to potentially escalate privileges inside guest.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3c9fa24ca7c9c47605672916491f79e8ccacb9e6,,,,,,,
CVE-2017-7864,https://www.cvedetails.com/cve/CVE-2017-7864/,CWE-787,,Overflow,2017-04-14,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,FreeType 2 before 2017-02-02 has an out-of-bounds write caused by a heap-based buffer overflow related to the tt_size_reset function in truetype/ttobjs.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=e6699596af5c5d6f0ae0ea06e19df87dce088df8,,,,,,,
CVE-2017-7858,https://www.cvedetails.com/cve/CVE-2017-7858/,CWE-787,,,2017-04-14,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,FreeType 2 before 2017-03-07 has an out-of-bounds write related to the TT_Get_MM_Var function in truetype/ttgxvar.c and the sfnt_init_face function in sfnt/sfobjs.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=779309744222a736eba0f1731e8162fce6288d4e,,,,,,,
CVE-2017-7857,https://www.cvedetails.com/cve/CVE-2017-7857/,CWE-787,,Overflow,2017-04-14,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,FreeType 2 before 2017-03-08 has an out-of-bounds write caused by a heap-based buffer overflow related to the TT_Get_MM_Var function in truetype/ttgxvar.c and the sfnt_init_face function in sfnt/sfobjs.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7bbb91fbf47fc0775cc9705673caf0c47a81f94b,,,,,,,
CVE-2018-10689,https://www.cvedetails.com/cve/CVE-2018-10689/,CWE-119,,Overflow,2018-05-03,2019-08-06,4.3,None,Remote,Medium,Not required,None,None,Partial,"blktrace (aka Block IO Tracing) 1.2.0, as used with the Linux kernel and Android, has a buffer overflow in the dev_map_read function in btt/devmap.c because the device and devno arrays are too small, as demonstrated by an invalid free when using the btt program with a crafted file.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/axboe/blktrace.git/commit/?id=d61ff409cb4dda31386373d706ea0cfb1aaac5b7,,,,,,,
CVE-2014-8626,https://www.cvedetails.com/cve/CVE-2014-8626/,CWE-119,,DoS Exec Code Overflow,2014-11-22,2015-04-29,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Stack-based buffer overflow in the date_from_ISO8601 function in ext/xmlrpc/libxmlrpc/xmlrpc.c in PHP before 5.2.7 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code by including a timezone field in a date, leading to improper XML-RPC encoding.",,php,https://git.php.net/?p=php-src.git;a=commit;h=c818d0d01341907fee82bdb81cab07b7d93bb9db,,,,,,,
CVE-2017-7511,https://www.cvedetails.com/cve/CVE-2017-7511/,CWE-476,,,2017-05-30,2018-01-18,4.3,None,Remote,Medium,Not required,None,None,Partial,poppler since version 0.17.3 has been vulnerable to NULL pointer dereference in pdfunite triggered by specially crafted documents.,,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=5c9b08a875b07853be6c44e43ff5f7f059df666a,,,,,,,
CVE-2017-7476,https://www.cvedetails.com/cve/CVE-2017-7476/,CWE-119,,Overflow,2017-05-02,2017-05-15,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Gnulib before 2017-04-26 has a heap-based buffer overflow with the TZ environment variable. The error is in the save_abbr function in time_rz.c.,,savannah,https://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commit;h=94e01571507835ff59dd8ce2a0b56a4b566965a4,,,,,,,
CVE-2012-4575,https://www.cvedetails.com/cve/CVE-2012-4575/,CWE-119,,DoS Overflow,2012-11-18,2013-03-01,5.0,None,Remote,Low,Not required,None,None,Partial,The add_database function in objects.c in the pgbouncer pooler 1.5.2 for PostgreSQL allows remote attackers to cause a denial of service (daemon outage) via a long database name in a request.,,postgresql,https://git.postgresql.org/gitweb/?p=pgbouncer.git;a=commit;h=4b92112b820830b30cd7bc91bef3dd8f35305525,,,,,,,
CVE-2014-8142,https://www.cvedetails.com/cve/CVE-2014-8142/,,,Exec Code,2014-12-20,2016-12-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Use-after-free vulnerability in the process_nested_data function in ext/standard/var_unserializer.re in PHP before 5.4.36, 5.5.x before 5.5.20, and 5.6.x before 5.6.4 allows remote attackers to execute arbitrary code via a crafted unserialize call that leverages improper handling of duplicate keys within the serialized properties of an object, a different vulnerability than CVE-2004-1019.",,php,https://git.php.net/?p=php-src.git;a=commit;h=630f9c33c23639de85c3fd306b209b538b73b4c9,,,,,,,
CVE-2014-8106,https://www.cvedetails.com/cve/CVE-2014-8106/,CWE-119,,Exec Code Overflow,2014-12-08,2017-09-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the Cirrus VGA emulator (hw/display/cirrus_vga.c) in QEMU before 2.2.0 allows local guest users to execute arbitrary code via vectors related to blit regions. NOTE: this vulnerability exists because an incomplete fix for CVE-2007-1320.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a,,,,,,,
CVE-2014-8106,https://www.cvedetails.com/cve/CVE-2014-8106/,CWE-119,,Exec Code Overflow,2014-12-08,2017-09-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the Cirrus VGA emulator (hw/display/cirrus_vga.c) in QEMU before 2.2.0 allows local guest users to execute arbitrary code via vectors related to blit regions. NOTE: this vulnerability exists because an incomplete fix for CVE-2007-1320.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=d3532a0db02296e687711b8cdc7791924efccea0,,,,,,,
CVE-2016-9916,https://www.cvedetails.com/cve/CVE-2016-9916/,CWE-400,,DoS,2016-12-29,2018-09-07,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in hw/9pfs/9p-proxy.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in the proxy backend.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68,,,,,,,
CVE-2016-9915,https://www.cvedetails.com/cve/CVE-2016-9915/,CWE-400,,DoS,2016-12-29,2018-09-07,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in hw/9pfs/9p-handle.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in the handle backend.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30,,,,,,,
CVE-2016-9914,https://www.cvedetails.com/cve/CVE-2016-9914/,CWE-400,,DoS,2016-12-29,2018-09-07,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in FileOperations.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=702dbcc274e2ca43be20ba64c758c0ca57dab91d,,,,,,,
CVE-2016-9913,https://www.cvedetails.com/cve/CVE-2016-9913/,CWE-400,,DoS,2016-12-29,2017-06-30,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the v9fs_device_unrealize_common function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) via vectors involving the order of resource cleanup.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42,,,,,,,
CVE-2012-4408,https://www.cvedetails.com/cve/CVE-2012-4408/,CWE-264,,Bypass,2012-09-19,2012-09-19,5.5,None,Remote,Low,Single system,Partial,Partial,None,"course/reset.php in Moodle 2.1.x before 2.1.8, 2.2.x before 2.2.5, and 2.3.x before 2.3.2 checks an update capability instead of a reset capability, which allows remote authenticated users to bypass intended access restrictions via a reset operation.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-34519,,,,,,,
CVE-2012-4407,https://www.cvedetails.com/cve/CVE-2012-4407/,CWE-200,,+Info,2012-09-19,2012-09-20,5.0,None,Remote,Low,Not required,Partial,None,None,"lib/filelib.php in Moodle 2.1.x before 2.1.8, 2.2.x before 2.2.5, and 2.3.x before 2.3.2 does not properly check the publication state of blog files, which allows remote attackers to obtain sensitive information by reading a blog entry that references a non-public file.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-34585,,,,,,,
CVE-2012-4403,https://www.cvedetails.com/cve/CVE-2012-4403/,CWE-200,,+Info,2012-09-19,2012-09-19,5.0,None,Remote,Low,Not required,Partial,None,None,"theme/yui_combo.php in Moodle 2.3.x before 2.3.2 does not properly construct error responses for the drag-and-drop script, which allows remote attackers to obtain the installation path by sending a request for a nonexistent resource and then reading the response.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-35168,,,,,,,
CVE-2012-4402,https://www.cvedetails.com/cve/CVE-2012-4402/,CWE-264,,,2012-09-19,2012-10-26,4.9,None,Remote,Medium,Single system,Partial,Partial,None,"webservice/lib.php in Moodle 2.1.x before 2.1.8, 2.2.x before 2.2.5, and 2.3.x before 2.3.2 does not properly restrict the use of web-service tokens, which allows remote authenticated users to run arbitrary external-service functions via a token intended for only one service.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-34368,,,,,,,
CVE-2012-4401,https://www.cvedetails.com/cve/CVE-2012-4401/,CWE-264,,Bypass,2012-09-19,2012-09-19,4.0,None,Remote,Low,Single system,None,Partial,None,Moodle 2.2.x before 2.2.5 and 2.3.x before 2.3.2 allows remote authenticated users to bypass intended capability restrictions and perform certain topic changes by leveraging course-editing capabilities.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-28207,,,,,,,
CVE-2012-4400,https://www.cvedetails.com/cve/CVE-2012-4400/,CWE-264,,Bypass,2012-09-19,2012-10-26,4.0,None,Remote,Low,Single system,None,Partial,None,repository/repository_ajax.php in Moodle 2.2.x before 2.2.5 and 2.3.x before 2.3.2 allows remote authenticated users to bypass intended upload-size restrictions via a -1 value in the maxbytes field.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-30792,,,,,,,
CVE-2010-3855,https://www.cvedetails.com/cve/CVE-2010-3855/,CWE-119,,DoS Exec Code Overflow,2010-11-26,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Buffer overflow in the ft_var_readpackedpoints function in truetype/ttgxvar.c in FreeType 2.4.3 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted TrueType GX font.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=59eb9f8cfe7d1df379a2318316d1f04f80fba54a,,,,,,,
CVE-2018-10194,https://www.cvedetails.com/cve/CVE-2018-10194/,CWE-119,,DoS Overflow,2018-04-18,2019-07-24,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The set_text_distance function in devices/vector/gdevpdts.c in the pdfwrite component in Artifex Ghostscript through 9.22 does not prevent overflows in text-positioning calculation, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PDF document.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=39b1e54b2968620723bf32e96764c88797714879,,,,,,,
CVE-2018-10184,https://www.cvedetails.com/cve/CVE-2018-10184/,CWE-119,,Exec Code Overflow,2018-05-09,2018-06-18,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in HAProxy before 1.8.8. The incoming H2 frame length was checked against the max_frame_size setting instead of being checked against the bufsize. The max_frame_size only applies to outgoing traffic and not to incoming, so if a large enough frame size is advertised in the SETTINGS frame, a wrapped frame will be defragmented into a temporary allocated buffer where the second fragment may overflow the heap by up to 16 kB. It is very unlikely that this can be exploited for code execution given that buffers are very short lived and their addresses not realistically predictable in production, but the likelihood of an immediate crash is absolutely certain.",,haproxy,https://git.haproxy.org/?p=haproxy-1.8.git;a=commit;h=cd117685f0cff4f2f5577ef6a21eaae96ebd9f28,,,,,,,
CVE-2018-10184,https://www.cvedetails.com/cve/CVE-2018-10184/,CWE-119,,Exec Code Overflow,2018-05-09,2018-06-18,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in HAProxy before 1.8.8. The incoming H2 frame length was checked against the max_frame_size setting instead of being checked against the bufsize. The max_frame_size only applies to outgoing traffic and not to incoming, so if a large enough frame size is advertised in the SETTINGS frame, a wrapped frame will be defragmented into a temporary allocated buffer where the second fragment may overflow the heap by up to 16 kB. It is very unlikely that this can be exploited for code execution given that buffers are very short lived and their addresses not realistically predictable in production, but the likelihood of an immediate crash is absolutely certain.",,haproxy,https://git.haproxy.org/?p=haproxy.git;a=commit;h=3f0e1ec70173593f4c2b3681b26c04a4ed5fc588,,,,,,,
CVE-2017-7187,https://www.cvedetails.com/cve/CVE-2017-7187/,CWE-119,,DoS Overflow,2017-03-20,2018-01-04,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"The sg_ioctl function in drivers/scsi/sg.c in the Linux kernel through 4.10.4 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a large command size in an SG_NEXT_CMD_LEN ioctl call, leading to out-of-bounds write access in the sg_write function.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git/commit/?h=4.11/scsi-fixes&id=bf33f87dd04c371ea33feb821b60d63d754e3124,,,,,,,
CVE-2017-7178,https://www.cvedetails.com/cve/CVE-2017-7178/,CWE-352,,CSRF,2017-03-18,2017-11-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"CSRF was discovered in the web UI in Deluge before 1.3.14. The exploitation methodology involves (1) hosting a crafted plugin that executes an arbitrary program from its __init__.py file and (2) causing the victim to download, install, and enable this plugin.",,deluge-torrent,https://git.deluge-torrent.org/deluge/commit/?h=develop&id=11e8957deaf0c76fdfbac62d99c8b6c61cfdddf9,,,,,,,
CVE-2017-7178,https://www.cvedetails.com/cve/CVE-2017-7178/,CWE-352,,CSRF,2017-03-18,2017-11-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"CSRF was discovered in the web UI in Deluge before 1.3.14. The exploitation methodology involves (1) hosting a crafted plugin that executes an arbitrary program from its __init__.py file and (2) causing the victim to download, install, and enable this plugin.",,deluge-torrent,https://git.deluge-torrent.org/deluge/commit/?h=1.3-stable&id=318ab179865e0707d7945edc3a13a464a108d583,,,,,,,
CVE-2010-3814,https://www.cvedetails.com/cve/CVE-2010-3814/,CWE-119,,DoS Exec Code Overflow,2010-11-26,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Heap-based buffer overflow in the Ins_SHZ function in ttinterp.c in FreeType 2.4.3 and earlier allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted SHZ bytecode instruction, related to TrueType opcodes, as demonstrated by a PDF document with a crafted embedded font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0edf0986f3be570f5bf90ff245a85c1675f5c9a4,,,,,,,
CVE-2014-7848,https://www.cvedetails.com/cve/CVE-2014-7848/,CWE-200,,+Info,2014-11-24,2015-09-03,5.0,None,Remote,Low,Not required,Partial,None,None,"lib/phpunit/bootstrap.php in Moodle 2.6.x before 2.6.6 and 2.7.x before 2.7.3 allows remote attackers to obtain sensitive information via a direct request, which reveals the full path in an error message.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47287,,,,,,,
CVE-2014-7847,https://www.cvedetails.com/cve/CVE-2014-7847/,CWE-399,,DoS,2014-11-24,2015-09-03,5.0,None,Remote,Low,Not required,None,None,Partial,"iplookup/index.php in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 allows remote attackers to cause a denial of service (resource consumption) by triggering the calculation of an estimated latitude and longitude for an IP address.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47321,,,,,,,
CVE-2014-7846,https://www.cvedetails.com/cve/CVE-2014-7846/,CWE-264,,Bypass,2014-11-24,2015-09-03,4.0,None,Remote,Low,Single system,Partial,None,None,"tag/tag_autocomplete.php in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 does not consider the moodle/tag:edit capability before adding a tag, which allows remote authenticated users to bypass intended access restrictions via an AJAX request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47965,,,,,,,
CVE-2014-7845,https://www.cvedetails.com/cve/CVE-2014-7845/,CWE-255,,,2014-11-24,2015-09-03,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The generate_password function in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 does not provide a sufficient number of possible temporary passwords, which allows remote attackers to obtain access via a brute-force attack.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47050,,,,,,,
CVE-2014-7840,https://www.cvedetails.com/cve/CVE-2014-7840/,CWE-20,,Exec Code,2014-12-12,2017-09-07,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The host_from_stream_offset function in arch_init.c in QEMU, when loading RAM during migration, allows remote attackers to execute arbitrary code via a crafted (1) offset or (2) length value in savevm data.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08,,,,,,,
CVE-2014-7838,https://www.cvedetails.com/cve/CVE-2014-7838/,CWE-352,,CSRF,2014-11-24,2015-09-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in the Forum module in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 allow remote attackers to hijack the authentication of arbitrary users for requests that set a tracking preference within (1) mod/forum/deprecatedlib.php, (2) mod/forum/forum.js, (3) mod/forum/index.php, or (4) mod/forum/lib.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48019,,,,,,,
CVE-2014-7837,https://www.cvedetails.com/cve/CVE-2014-7837/,CWE-264,,,2014-11-24,2015-09-03,5.5,None,Remote,Low,Single system,None,Partial,Partial,"mod/wiki/admin.php in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 allows remote authenticated users to remove wiki pages by leveraging delete access within a different subwiki.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47949,,,,,,,
CVE-2014-7836,https://www.cvedetails.com/cve/CVE-2014-7836/,CWE-352,,CSRF,2014-11-24,2015-09-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in the LTI module in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 allow remote attackers to hijack the authentication of arbitrary users for a (1) mod/lti/request_tool.php or (2) mod/lti/instructor_edit_tool_type.php request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47924,,,,,,,
CVE-2014-7835,https://www.cvedetails.com/cve/CVE-2014-7835/,CWE-79,,XSS,2014-11-24,2015-09-03,2.1,None,Remote,High,Single system,None,Partial,None,"webservice/upload.php in Moodle 2.6.x before 2.6.6 and 2.7.x before 2.7.3 does not ensure that a file upload is for a private or draft area, which allows remote authenticated users to upload files containing JavaScript, and consequently conduct cross-site scripting (XSS) attacks, by specifying the profile-picture area.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47868,,,,,,,
CVE-2014-7834,https://www.cvedetails.com/cve/CVE-2014-7834/,CWE-264,,,2014-11-24,2015-09-03,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/forum/externallib.php in Moodle 2.6.x before 2.6.6 and 2.7.x before 2.7.3 does not verify group permissions, which allows remote authenticated users to access a forum via the forum_get_discussions web service.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45303,,,,,,,
CVE-2014-7833,https://www.cvedetails.com/cve/CVE-2014-7833/,CWE-200,,+Info,2014-11-24,2015-10-05,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/data/edit.php in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 sets a certain group ID to zero upon a database-entry change, which allows remote authenticated users to obtain sensitive information by accessing the database after an edit by a teacher.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47697,,,,,,,
CVE-2014-7832,https://www.cvedetails.com/cve/CVE-2014-7832/,CWE-264,,Bypass,2014-11-24,2015-10-05,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/lti/launch.php in the LTI module in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 performs access control at the course level rather than at the activity level, which allows remote authenticated users to bypass the mod/lti:view capability requirement by viewing an activity instance.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47921,,,,,,,
CVE-2014-7831,https://www.cvedetails.com/cve/CVE-2014-7831/,CWE-200,,+Info,2014-11-24,2015-09-08,4.0,None,Remote,Low,Single system,Partial,None,None,"lib/classes/grades_external.php in Moodle 2.7.x before 2.7.3 does not consider the moodle/grade:viewhidden capability before displaying hidden grades, which allows remote authenticated users to obtain sensitive information by leveraging the student role to access the get_grades web service.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47766,,,,,,,
CVE-2014-7830,https://www.cvedetails.com/cve/CVE-2014-7830/,CWE-79,,XSS,2014-11-24,2015-09-08,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in mod/feedback/mapcourse.php in the Feedback module in Moodle through 2.4.11, 2.5.x before 2.5.9, 2.6.x before 2.6.6, and 2.7.x before 2.7.3 allows remote authenticated users to inject arbitrary web script or HTML by leveraging the mod/feedback:mapcourse capability to provide a searchcourse parameter.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-47865,,,,,,,
CVE-2016-9294,https://www.cvedetails.com/cve/CVE-2016-9294/,CWE-476,,DoS,2016-11-11,2016-11-29,5.0,None,Remote,Low,Not required,None,None,Partial,"Artifex Software, Inc. MuJS before 5008105780c0b0182ea6eda83ad5598f225be3ee allows context-dependent attackers to conduct ""denial of service (application crash)"" attacks by using the ""malformed labeled break/continue in JavaScript"" approach, related to a ""NULL pointer dereference"" issue affecting the jscompile.c component.",,ghostscript,http://git.ghostscript.com/?p=mujs.git;a=commit;h=5008105780c0b0182ea6eda83ad5598f225be3ee,,,,,,,
CVE-2014-7815,https://www.cvedetails.com/cve/CVE-2014-7815/,CWE-264,,DoS,2014-11-14,2017-12-27,5.0,None,Remote,Low,Not required,None,None,Partial,The set_pixel_format function in ui/vnc.c in QEMU allows remote attackers to cause a denial of service (crash) via a small bytes_per_pixel value.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829,,,,,,,
CVE-2012-4233,https://www.cvedetails.com/cve/CVE-2012-4233/,,,DoS,2012-11-19,2017-08-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"LibreOffice 3.5.x before 3.5.7.2 and 3.6.x before 3.6.1, and OpenOffice.org (OOo), allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted (1) odt file to vcllo.dll, (2) ODG (Drawing document) file to svxcorelo.dll, (3) PolyPolygon record in a .wmf (Window Meta File) file embedded in a ppt (PowerPoint) file to tllo.dll, or (4) xls (Excel) file to scfiltlo.dll.",,libreoffice,https://cgit.freedesktop.org/libreoffice/binfilter/commit/?h=libreoffice-3-5-7&id=7e22ee55ffc9743692f3ddb93e59dd4427029c5b,,,,,,,
CVE-2012-4233,https://www.cvedetails.com/cve/CVE-2012-4233/,,,DoS,2012-11-19,2017-08-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"LibreOffice 3.5.x before 3.5.7.2 and 3.6.x before 3.6.1, and OpenOffice.org (OOo), allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted (1) odt file to vcllo.dll, (2) ODG (Drawing document) file to svxcorelo.dll, (3) PolyPolygon record in a .wmf (Window Meta File) file embedded in a ppt (PowerPoint) file to tllo.dll, or (4) xls (Excel) file to scfiltlo.dll.",,libreoffice,https://cgit.freedesktop.org/libreoffice/core/commit/?h=libreoffice-3-5-7&id=6789ec4c1a9c6af84bd62e650a03226a46365d97,,,,,,,
CVE-2012-4233,https://www.cvedetails.com/cve/CVE-2012-4233/,,,DoS,2012-11-19,2017-08-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"LibreOffice 3.5.x before 3.5.7.2 and 3.6.x before 3.6.1, and OpenOffice.org (OOo), allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted (1) odt file to vcllo.dll, (2) ODG (Drawing document) file to svxcorelo.dll, (3) PolyPolygon record in a .wmf (Window Meta File) file embedded in a ppt (PowerPoint) file to tllo.dll, or (4) xls (Excel) file to scfiltlo.dll.",,libreoffice,https://cgit.freedesktop.org/libreoffice/core/commit/?h=libreoffice-3-5-7&id=8ca9fb05c9967f11670d045886438ddfa3ac02a7,,,,,,,
CVE-2012-4233,https://www.cvedetails.com/cve/CVE-2012-4233/,,,DoS,2012-11-19,2017-08-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"LibreOffice 3.5.x before 3.5.7.2 and 3.6.x before 3.6.1, and OpenOffice.org (OOo), allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted (1) odt file to vcllo.dll, (2) ODG (Drawing document) file to svxcorelo.dll, (3) PolyPolygon record in a .wmf (Window Meta File) file embedded in a ppt (PowerPoint) file to tllo.dll, or (4) xls (Excel) file to scfiltlo.dll.",,libreoffice,https://cgit.freedesktop.org/libreoffice/core/commit/?h=libreoffice-3-5-7&id=44bc6b5cac723b52df40fbef026e99b7119d8a69,,,,,,,
CVE-2010-3704,https://www.cvedetails.com/cve/CVE-2010-3704/,CWE-20,,DoS Exec Code Mem. Corr. Bypass,2010-11-05,2012-11-19,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The FoFiType1::parse function in fofi/FoFiType1.cc in the PDF parser in xpdf before 3.02pl5, poppler 0.8.7 and possibly other versions up to 0.15.1, kdegraphics, and possibly other products allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a PDF file with a crafted PostScript Type1 font that contains a negative array index, which bypasses input validation and triggers memory corruption.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=39d140bfc0b8239bdd96d6a55842034ae5c05473,,,,,,,
CVE-2010-3703,https://www.cvedetails.com/cve/CVE-2010-3703/,CWE-20,,DoS,2010-11-05,2011-01-22,4.3,None,Remote,Medium,Not required,None,None,Partial,"The PostScriptFunction::PostScriptFunction function in poppler/Function.cc in the PDF parser in poppler 0.8.7 and possibly other versions up to 0.15.1, and possibly other products, allows context-dependent attackers to cause a denial of service (crash) via a PDF file that triggers an uninitialized pointer dereference.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=bf2055088a3a2d3bb3d3c37d464954ec1a25771f,,,,,,,
CVE-2010-3702,https://www.cvedetails.com/cve/CVE-2010-3702/,CWE-20,,DoS,2010-11-05,2012-11-19,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The Gfx::getPos function in the PDF parser in xpdf before 3.02pl5, poppler 0.8.7 and possibly other versions up to 0.15.1, CUPS, kdegraphics, and possibly other products allows context-dependent attackers to cause a denial of service (crash) via unknown vectors that trigger an uninitialized pointer dereference.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=e853106b58d6b4b0467dbd6436c9bb1cfbd372cf,,,,,,,
CVE-2016-9106,https://www.cvedetails.com/cve/CVE-2016-9106/,CWE-399,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,Memory leak in the v9fs_write function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) by leveraging failure to free an IO vector.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=fdfcc9aeea1492f4b819a24c94dfb678145b1bf9,,,,,,,
CVE-2016-9105,https://www.cvedetails.com/cve/CVE-2016-9105/,CWE-399,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,Memory leak in the v9fs_link function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via vectors involving a reference to the source fid object.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=4c1586787ff43c9acd18a56c12d720e3e6be9f7c,,,,,,,
CVE-2016-9103,https://www.cvedetails.com/cve/CVE-2016-9103/,CWE-119,,Overflow +Info,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,Partial,None,None,The v9fs_xattrcreate function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to obtain sensitive host heap memory information by reading xattribute values before writing to them.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=eb687602853b4ae656e9236ee4222609f3a6887d,,,,,,,
CVE-2016-9102,https://www.cvedetails.com/cve/CVE-2016-9102/,CWE-399,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,Memory leak in the v9fs_xattrcreate function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption and QEMU process crash) via a large number of Txattrcreate messages with the same fid number.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=ff55e94d23ae94c8628b0115320157c763eb3e06,,,,,,,
CVE-2016-8669,https://www.cvedetails.com/cve/CVE-2016-8669/,CWE-369,,DoS,2016-11-04,2018-09-07,1.9,None,Local,Medium,Not required,None,None,Partial,The serial_update_parameters function in hw/char/serial.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (divide-by-zero error and QEMU process crash) via vectors involving a value of divider greater than baud base.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=3592fe0c919cf27a81d8e9f9b4f269553418bb01,,,,,,,
CVE-2017-6891,https://www.cvedetails.com/cve/CVE-2017-6891/,CWE-119,,Overflow,2017-05-22,2019-06-05,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Two errors in the ""asn1_find_node()"" function (lib/parser_aux.c) within GnuTLS libtasn1 version 4.10 can be exploited to cause a stacked-based buffer overflow by tricking a user into processing a specially crafted assignments file via the e.g. asn1Coding utility.",,savannah,https://git.savannah.gnu.org/gitweb/?p=libtasn1.git;a=commit;h=5520704d075802df25ce4ffccc010ba1641bd484,,,,,,,
CVE-2016-8577,https://www.cvedetails.com/cve/CVE-2016-8577/,CWE-399,,DoS,2016-11-04,2018-12-01,1.9,None,Local,Medium,Not required,None,None,Partial,Memory leak in the v9fs_read function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via vectors related to an I/O read operation.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19,,,,,,,
CVE-2016-8576,https://www.cvedetails.com/cve/CVE-2016-8576/,CWE-399,,DoS,2016-11-04,2018-09-07,1.9,None,Local,Medium,Not required,None,None,Partial,The xhci_ring_fetch function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging failure to limit the number of link Transfer Request Blocks (TRB) to process.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=05f43d44e4bc26611ce25fd7d726e483f73363ce,,,,,,,
CVE-2016-7995,https://www.cvedetails.com/cve/CVE-2016-7995/,CWE-399,,DoS,2016-12-09,2017-01-06,2.1,None,Local,Low,Not required,None,None,Partial,Memory leak in the ehci_process_itd function in hw/usb/hcd-ehci.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via a large number of crafted buffer page select (PG) indexes.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=b16c129daf0fed91febbb88de23dae8271c8898a,,,,,,,
CVE-2016-7953,https://www.cvedetails.com/cve/CVE-2016-7953/,CWE-119,,Overflow,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer underflow in X.org libXvMC before 1.0.10 allows remote X servers to have unspecified impact via an empty string.,,libXvMC,https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb,,,,,,,
CVE-2016-7952,https://www.cvedetails.com/cve/CVE-2016-7952/,CWE-20,,DoS,2016-12-13,2016-12-14,5.0,None,Remote,Low,Not required,None,None,Partial,"X.org libXtst before 1.2.3 allows remote X servers to cause a denial of service (infinite loop) via a reply in the (1) XRecordStartOfData, (2) XRecordEndOfData, or (3) XRecordClientDied category without a client sequence and with attached data.",,libXtst,https://cgit.freedesktop.org/xorg/lib/libXtst/commit/?id=9556ad67af3129ec4a7a4f4b54a0d59701beeae3,,,,,,,
CVE-2016-7951,https://www.cvedetails.com/cve/CVE-2016-7951/,CWE-125,,Overflow,2016-12-13,2016-12-14,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Multiple integer overflows in X.org libXtst before 1.2.3 allow remote X servers to trigger out-of-bounds memory access operations by leveraging the lack of range checks.,,libXtst,https://cgit.freedesktop.org/xorg/lib/libXtst/commit/?id=9556ad67af3129ec4a7a4f4b54a0d59701beeae3,,,,,,,
CVE-2016-7950,https://www.cvedetails.com/cve/CVE-2016-7950/,CWE-787,,,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,The XRenderQueryFilters function in X.org libXrender before 0.9.10 allows remote X servers to trigger out-of-bounds write operations via vectors involving filter name lengths.,,libXrender,https://cgit.freedesktop.org/xorg/lib/libXrender/commit/?id=8fad00b0b647ee662ce4737ca15be033b7a21714,,,,,,,
CVE-2016-7949,https://www.cvedetails.com/cve/CVE-2016-7949/,CWE-787,,Overflow,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Multiple buffer overflows in the (1) XvQueryAdaptors and (2) XvQueryEncodings functions in X.org libXrender before 0.9.10 allow remote X servers to trigger out-of-bounds write operations via vectors involving length fields.,,libXrender,https://cgit.freedesktop.org/xorg/lib/libXrender/commit/?id=9362c7ddd1af3b168953d0737877bc52d79c94f4,,,,,,,
CVE-2016-7948,https://www.cvedetails.com/cve/CVE-2016-7948/,CWE-787,,,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,X.org libXrandr before 1.5.1 allows remote X servers to trigger out-of-bounds write operations by leveraging mishandling of reply data.,,libXrandr,https://cgit.freedesktop.org/xorg/lib/libXrandr/commit/?id=a0df3e1c7728205e5c7650b2e6dce684139254a6,,,,,,,
CVE-2016-7947,https://www.cvedetails.com/cve/CVE-2016-7947/,CWE-787,,Overflow,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Multiple integer overflows in X.org libXrandr before 1.5.1 allow remote X servers to trigger out-of-bounds write operations via a crafted response.,,libXrandr,https://cgit.freedesktop.org/xorg/lib/libXrandr/commit/?id=a0df3e1c7728205e5c7650b2e6dce684139254a6,,,,,,,
CVE-2016-7946,https://www.cvedetails.com/cve/CVE-2016-7946/,CWE-284,,DoS,2016-12-13,2017-06-30,5.0,None,Remote,Low,Not required,None,None,Partial,X.org libXi before 1.7.7 allows remote X servers to cause a denial of service (infinite loop) via vectors involving length fields.,,libXi,https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5,,,,,,,
CVE-2016-7945,https://www.cvedetails.com/cve/CVE-2016-7945/,CWE-125,,DoS Overflow,2016-12-13,2017-06-30,5.0,None,Remote,Low,Not required,None,None,Partial,Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.,,libXi,https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5,,,,,,,
CVE-2016-7944,https://www.cvedetails.com/cve/CVE-2016-7944/,CWE-190,,Overflow +Priv,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in X.org libXfixes before 5.0.3 on 32-bit platforms might allow remote X servers to gain privileges via a length value of INT_MAX, which triggers the client to stop reading data and get out of sync.",,libXfixes,https://cgit.freedesktop.org/xorg/lib/libXfixes/commit/?id=61c1039ee23a2d1de712843bed3480654d7ef42e,,,,,,,
CVE-2016-7943,https://www.cvedetails.com/cve/CVE-2016-7943/,CWE-787,,+Priv,2016-12-13,2018-09-13,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The XListFonts function in X.org libX11 before 1.6.4 might allow remote X servers to gain privileges via vectors involving length fields, which trigger out-of-bounds write operations.",,libx11,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=8c29f1607a31dac0911e45a0dd3d74173822b3c9,,,,,,,
CVE-2016-7942,https://www.cvedetails.com/cve/CVE-2016-7942/,CWE-787,,+Priv,2016-12-13,2018-09-13,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The XGetImage function in X.org libX11 before 1.6.4 might allow remote X servers to gain privileges via vectors involving image type and geometry, which triggers out-of-bounds read operations.",,libx12,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=8ea762f94f4c942d898fdeb590a1630c83235c17,,,,,,,
CVE-2016-7908,https://www.cvedetails.com/cve/CVE-2016-7908/,CWE-399,,DoS,2016-10-05,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,"The mcf_fec_do_tx function in hw/net/mcf_fec.c in QEMU (aka Quick Emulator) does not properly limit the buffer descriptor count when transmitting packets, which allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via vectors involving a buffer descriptor with a length of 0 and crafted values in bd.flags.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=070c4b92b8cd5390889716677a0b92444d6e087a,,,,,,,
CVE-2016-7466,https://www.cvedetails.com/cve/CVE-2016-7466/,CWE-399,,DoS,2016-12-09,2018-01-04,2.1,None,Local,Low,Not required,None,None,Partial,"Memory leak in the usb_xhci_exit function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator), when the xhci uses msix, allows local guest OS administrators to cause a denial of service (memory consumption and possibly QEMU process crash) by repeatedly unplugging a USB device.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=b53dd4495ced2432a0b652ea895e651d07336f7e,,,,,,,
CVE-2016-7424,https://www.cvedetails.com/cve/CVE-2016-7424/,CWE-476,,DoS,2016-10-07,2016-10-11,4.3,None,Remote,Medium,Not required,None,None,Partial,The put_no_rnd_pixels8_xy2_mmx function in x86/rnd_template.c in libav 11.7 and earlier allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted MP3 file.,C,libav,https://git.libav.org/?p=libav.git;a=commit;h=136f55207521f0b03194ef5b55ba70f1635d6aee,136f55207521f0b03194ef5b55ba70f1635d6aee,15fcf6292ed79be274c824fedb099c2665f4cc15,"@@ -210,17 +210,14 @@ static inline int hpel_motion(MpegEncContext *s,
         dxy |= (motion_y & 1) << 1;
     src += src_y * s->linesize + src_x;
 
-    if (s->unrestricted_mv) {
-        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
-            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
-            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
-                                     s->linesize, s->linesize,
-                                     9, 9,
-                                     src_x, src_y, s->h_edge_pos,
-                                     s->v_edge_pos);
-            src = s->sc.edge_emu_buffer;
-            emu = 1;
-        }
+    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
+        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
+                                 s->linesize, s->linesize,
+                                 9, 9, src_x, src_y,
+                                 s->h_edge_pos, s->v_edge_pos);
+        src = s->sc.edge_emu_buffer;
+        emu = 1;
     }
     pix_op[dxy](dest, src, s->linesize, 8);
     return emu;",https://git.libav.org/?p=libav.git;a=blob;f=libavcodec/mpegvideo_motion.c;h=8074dbaa9f74216197b2a2793be5655384da3a29,https://git.libav.org/?p=libav.git;a=blob;f=libavcodec/mpegvideo_motion.c;h=f6d9613b3ca858e5f1c7dd582a9f879831437505;hb=136f55207521f0b03194ef5b55ba70f1635d6aee,,
CVE-2016-7423,https://www.cvedetails.com/cve/CVE-2016-7423/,CWE-787,,DoS,2016-10-10,2017-06-30,2.1,None,Local,Low,Not required,None,None,Partial,"The mptsas_process_scsi_io_request function in QEMU (aka Quick Emulator), when built with LSI SAS1068 Host Bus emulation support, allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors involving MPTSASRequest objects.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5,,,,,,,
CVE-2016-7422,https://www.cvedetails.com/cve/CVE-2016-7422/,CWE-476,,DoS,2016-12-09,2018-01-04,2.1,None,Local,Low,Not required,None,None,Partial,The virtqueue_map_desc function in hw/virtio/virtio.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (NULL pointer dereference and QEMU process crash) via a large I/O descriptor buffer length value.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=973e7170dddefb491a48df5cba33b2ae151013a0,,,,,,,
CVE-2016-7421,https://www.cvedetails.com/cve/CVE-2016-7421/,CWE-399,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,The pvscsi_ring_pop_req_descr function in hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging failure to limit process IO loop to the ring size.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9,,,,,,,
CVE-2006-4192,https://www.cvedetails.com/cve/CVE-2006-4192/,,,Exec Code Overflow,2006-08-16,2018-10-17,5.1,User,Remote,High,Not required,Partial,Partial,Partial,"Multiple buffer overflows in MODPlug Tracker (OpenMPT) 1.17.02.43 and earlier and libmodplug 0.8 and earlier, as used in GStreamer and possibly other products, allow user-assisted remote attackers to execute arbitrary code via (1) long strings in ITP files used by the CSoundFile::ReadITProject function in soundlib/Load_it.cpp and (2) crafted modules used by the CSoundFile::ReadSample function in soundlib/Sndfile.cpp, as demonstrated by crafted AMF files.",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/?id=bc2cdd57d549ab3ba59782e9b395d0cd683fd3ac,,,,,,,
CVE-2017-6542,https://www.cvedetails.com/cve/CVE-2017-6542/,CWE-119,,Overflow,2017-03-27,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow.",C,tartarus,https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=4ff22863d895cb7ebfced4cf923a012a614adaa8,4ff22863d895cb7ebfced4cf923a012a614adaa8,eb2fe29fc975b19a3b3692fced03559e705881d9,"@@ -573,10 +573,7 @@ struct ssh_channel {
     } v;
     union {
        struct ssh_agent_channel {
-           unsigned char *message;
-           unsigned char msglen[4];
-           unsigned lensofar, totallen;
-            int outstanding_requests;
+            bufchain inbuffer;
             agent_pending_query *pending;
        } a;
        struct ssh_x11_channel {
@@ -3780,6 +3777,8 @@ static void ssh_throttle_conn(Ssh ssh, int adjust)
     }
 }
 
+static void ssh_agentf_try_forward(struct ssh_channel *c);
+
 /*
  * Throttle or unthrottle _all_ local data streams (for when sends
  * on the SSH connection itself back up).
@@ -3806,7 +3805,12 @@ static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)
            x11_override_throttle(c->u.x11.xconn, enable);
            break;
          case CHAN_AGENT:
-           /* Agent channels require no buffer management. */
+           /* Agent forwarding channels are buffer-managed by
+             * checking ssh->throttled_all in ssh_agentf_try_forward.
+             * So at the moment we _un_throttle again, we must make an
+             * attempt to do something. */
+            if (!enable)
+                ssh_agentf_try_forward(c);
            break;
          case CHAN_SOCKDATA:
            pfd_override_throttle(c->u.pfd.pf, enable);
@@ -3848,29 +3852,113 @@ static void ssh_dialog_callback(void *sshv, int ret)
     ssh_process_queued_incoming_data(ssh);
 }
 
-static void ssh_agentf_callback(void *cv, void *reply, int replylen)
+static void ssh_agentf_got_response(struct ssh_channel *c,
+                                    void *reply, int replylen)
 {
-    struct ssh_channel *c = (struct ssh_channel *)cv;
-    const void *sentreply = reply;
-
     c->u.a.pending = NULL;
-    c->u.a.outstanding_requests--;
-    if (!sentreply) {
-       /* Fake SSH_AGENT_FAILURE. */
-       sentreply = ""\0\0\0\1\5"";
+
+    if (!reply) {
+       /* The real agent didn't send any kind of reply at all for
+         * some reason, so fake an SSH_AGENT_FAILURE. */
+       reply = ""\0\0\0\1\5"";
        replylen = 5;
     }
-    ssh_send_channel_data(c, sentreply, replylen);
-    if (reply)
-       sfree(reply);
+
+    ssh_send_channel_data(c, reply, replylen);
+}
+
+static void ssh_agentf_callback(void *cv, void *reply, int replylen);
+
+static void ssh_agentf_try_forward(struct ssh_channel *c)
+{
+    unsigned datalen, lengthfield, messagelen;
+    unsigned char *message;
+    unsigned char msglen[4];
+    void *reply;
+    int replylen;
+
     /*
-     * If we've already seen an incoming EOF but haven't sent an
-     * outgoing one, this may be the moment to send it.
+     * Don't try to parallelise agent requests. Wait for each one to
+     * return before attempting the next.
      */
-    if (c->u.a.outstanding_requests == 0 && (c->closes & CLOSES_RCVD_EOF))
+    if (c->u.a.pending)
+        return;
+
+    /*
+     * If the outgoing side of the channel connection is currently
+     * throttled (for any reason, either that channel's window size or
+     * the entire SSH connection being throttled), don't submit any
+     * new forwarded requests to the real agent. This causes the input
+     * side of the agent forwarding not to be emptied, exerting the
+     * required back-pressure on the remote client, and encouraging it
+     * to read our responses before sending too many more requests.
+     */
+    if (c->ssh->throttled_all ||
+        (c->ssh->version == 2 && c->v.v2.remwindow == 0))
+        return;
+
+    while (1) {
+        /*
+         * Try to extract a complete message from the input buffer.
+         */
+        datalen = bufchain_size(&c->u.a.inbuffer);
+        if (datalen < 4)
+            break;         /* not even a length field available yet */
+
+        bufchain_fetch(&c->u.a.inbuffer, msglen, 4);
+        lengthfield = GET_32BIT(msglen);
+        if (lengthfield > datalen - 4)
+            break;          /* a whole message is not yet available */
+
+        messagelen = lengthfield + 4;
+
+        message = snewn(messagelen, unsigned char);
+        bufchain_fetch(&c->u.a.inbuffer, message, messagelen);
+        bufchain_consume(&c->u.a.inbuffer, messagelen);
+        c->u.a.pending = agent_query(
+            message, messagelen, &reply, &replylen, ssh_agentf_callback, c);
+        sfree(message);
+
+        if (c->u.a.pending)
+            return;   /* agent_query promised to reply in due course */
+
+        /*
+         * If the agent gave us an answer immediately, pass it
+         * straight on and go round this loop again.
+         */
+        ssh_agentf_got_response(c, reply, replylen);
+    }
+
+    /*
+     * If we get here (i.e. we left the above while loop via 'break'
+     * rather than 'return'), that means we've determined that the
+     * input buffer for the agent forwarding connection doesn't
+     * contain a complete request.
+     *
+     * So if there's potentially more data to come, we can return now,
+     * and wait for the remote client to send it. But if the remote
+     * has sent EOF, it would be a mistake to do that, because we'd be
+     * waiting a long time. So this is the moment to check for EOF,
+     * and respond appropriately.
+     */
+    if (c->closes & CLOSES_RCVD_EOF)
         sshfwd_write_eof(c);
 }
 
+static void ssh_agentf_callback(void *cv, void *reply, int replylen)
+{
+    struct ssh_channel *c = (struct ssh_channel *)cv;
+
+    ssh_agentf_got_response(c, reply, replylen);
+    sfree(reply);
+
+    /*
+     * Now try to extract and send further messages from the channel's
+     * input-side buffer.
+     */
+    ssh_agentf_try_forward(c);
+}
+
 /*
  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'
  * non-NULL, otherwise just close the connection. `client_reason' == NULL
@@ -5553,10 +5641,8 @@ static void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)
        c->remoteid = remoteid;
        c->halfopen = FALSE;
        c->type = CHAN_AGENT;   /* identify channel type */
-       c->u.a.lensofar = 0;
-       c->u.a.message = NULL;
        c->u.a.pending = NULL;
-       c->u.a.outstanding_requests = 0;
+        bufchain_init(&c->u.a.inbuffer);
        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,
                    PKT_INT, c->remoteid, PKT_INT, c->localid,
                    PKT_END);
@@ -5697,42 +5783,18 @@ static void ssh1_msg_channel_close(Ssh ssh, struct Packet *pktin)
 static int ssh_agent_channel_data(struct ssh_channel *c, char *data,
                                  int length)
 {
-    while (length > 0) {
-       if (c->u.a.lensofar < 4) {
-           unsigned int l = min(4 - c->u.a.lensofar, (unsigned)length);
-           memcpy(c->u.a.msglen + c->u.a.lensofar, data, l);
-           data += l;
-           length -= l;
-           c->u.a.lensofar += l;
-       }
-       if (c->u.a.lensofar == 4) {
-           c->u.a.totallen = 4 + GET_32BIT(c->u.a.msglen);
-           c->u.a.message = snewn(c->u.a.totallen, unsigned char);
-           memcpy(c->u.a.message, c->u.a.msglen, 4);
-       }
-       if (c->u.a.lensofar >= 4 && length > 0) {
-           unsigned int l = min(c->u.a.totallen - c->u.a.lensofar,
-                                (unsigned)length);
-           memcpy(c->u.a.message + c->u.a.lensofar, data, l);
-           data += l;
-           length -= l;
-           c->u.a.lensofar += l;
-       }
-       if (c->u.a.lensofar == c->u.a.totallen) {
-           void *reply;
-           int replylen;
-            c->u.a.outstanding_requests++;
-            c->u.a.pending = agent_query(
-                c->u.a.message, c->u.a.totallen, &reply, &replylen,
-                ssh_agentf_callback, c);
-            if (!c->u.a.pending)
-                ssh_agentf_callback(c, reply, replylen);
-           sfree(c->u.a.message);
-            c->u.a.message = NULL;
-           c->u.a.lensofar = 0;
-       }
-    }
-    return 0;   /* agent channels never back up */
+    bufchain_add(&c->u.a.inbuffer, data, length);
+    ssh_agentf_try_forward(c);
+
+    /*
+     * We exert back-pressure on an agent forwarding client if and
+     * only if we're waiting for the response to an asynchronous agent
+     * request. This prevents the client running out of window while
+     * receiving the _first_ message, but means that if any message
+     * takes time to process, the client will be discouraged from
+     * sending an endless stream of further ones after it.
+     */
+    return (c->u.a.pending ? bufchain_size(&c->u.a.inbuffer) : 0);
 }
 
 static int ssh_channel_data(struct ssh_channel *c, int is_stderr,
@@ -7733,8 +7795,9 @@ static void ssh2_try_send_and_unthrottle(Ssh ssh, struct ssh_channel *c)
            x11_unthrottle(c->u.x11.xconn);
            break;
          case CHAN_AGENT:
-           /* agent sockets are request/response and need no
-            * buffer management */
+            /* Now that we've successfully sent all the outgoing
+             * replies we had, try to process more incoming data. */
+            ssh_agentf_try_forward(c);
            break;
          case CHAN_SOCKDATA:
            pfd_unthrottle(c->u.pfd.pf);
@@ -8160,7 +8223,8 @@ static void ssh_channel_close_local(struct ssh_channel *c, char const *reason)
       case CHAN_AGENT:
         if (c->u.a.pending)
             agent_cancel_query(c->u.a.pending);
-        sfree(c->u.a.message);
+        bufchain_clear(&c->u.a.inbuffer);
+       msg = ""Agent-forwarding connection closed"";
         break;
       case CHAN_SOCKDATA:
         assert(c->u.pfd.pf != NULL);
@@ -8248,10 +8312,10 @@ static void ssh_channel_got_eof(struct ssh_channel *c)
        assert(c->u.x11.xconn != NULL);
        x11_send_eof(c->u.x11.xconn);
     } else if (c->type == CHAN_AGENT) {
-        if (c->u.a.outstanding_requests == 0) {
-            /* Manufacture an outgoing EOF in response to the incoming one. */
-            sshfwd_write_eof(c);
-        }
+        /* Just call try_forward, which will respond to the EOF now if
+         * appropriate, or wait until the queue of outstanding
+         * requests is dealt with if not */
+        ssh_agentf_try_forward(c);
     } else if (c->type == CHAN_SOCKDATA) {
        assert(c->u.pfd.pf != NULL);
        pfd_send_eof(c->u.pfd.pf);
@@ -8805,10 +8869,8 @@ static void ssh2_msg_channel_open(Ssh ssh, struct Packet *pktin)
            error = ""Agent forwarding is not enabled"";
        else {
            c->type = CHAN_AGENT;       /* identify channel type */
-           c->u.a.lensofar = 0;
-            c->u.a.message = NULL;
+            bufchain_init(&c->u.a.inbuffer);
             c->u.a.pending = NULL;
-            c->u.a.outstanding_requests = 0;
        }
     } else {
        error = ""Unsupported channel type requested"";",https://git.tartarus.org/?p=simon/putty.git;a=blob;f=ssh.c;h=2212c2b77764cc55505363352fa054ba239ab846,https://git.tartarus.org/?p=simon/putty.git;a=blob;f=ssh.c;h=a214aa1f9b7985f16eee25168d8c3d0874b2eca7;hb=4ff22863d895cb7ebfced4cf923a012a614adaa8,,
CVE-2017-6542,https://www.cvedetails.com/cve/CVE-2017-6542/,CWE-119,,Overflow,2017-03-27,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow.",C,tartarus,https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=4ff22863d895cb7ebfced4cf923a012a614adaa8,4ff22863d895cb7ebfced4cf923a012a614adaa8,eb2fe29fc975b19a3b3692fced03559e705881d9,"@@ -4,6 +4,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <assert.h>
 
 #include ""putty.h""",https://git.tartarus.org/?p=simon/putty.git;a=blob;f=windows/winpgntc.c;h=af2abb6fb5a667025e33ebd003bfa1de4b68a065,https://git.tartarus.org/?p=simon/putty.git;a=blob;f=windows/winpgntc.c;h=1136ec76e76337f95a03c6263dbf5179e6b22960;hb=4ff22863d895cb7ebfced4cf923a012a614adaa8,,
CVE-2016-7170,https://www.cvedetails.com/cve/CVE-2016-7170/,CWE-787,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,The vmsvga_fifo_run function in hw/display/vmware_vga.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors related to cursor.mask[] and cursor.image[] array sizes when processing a DEFINE_CURSOR svga command.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db,,,,,,,
CVE-2016-7161,https://www.cvedetails.com/cve/CVE-2016-7161/,CWE-119,,Exec Code Overflow,2016-10-05,2018-12-01,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,Heap-based buffer overflow in the .receive callback of xlnx.xps-ethernetlite in QEMU (aka Quick Emulator) allows attackers to execute arbitrary code on the QEMU host via a large ethlite packet.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=a0d1cbdacff5df4ded16b753b38fdd9da6092968,,,,,,,
CVE-2016-7157,https://www.cvedetails.com/cve/CVE-2016-7157/,CWE-20,,DoS,2016-12-09,2017-06-30,2.1,None,Local,Low,Not required,None,None,Partial,The (1) mptsas_config_manufacturing_1 and (2) mptsas_config_ioc_0 functions in hw/scsi/mptconfig.c in QEMU (aka Quick Emulator) allow local guest OS administrators to cause a denial of service (QEMU process crash) via vectors involving MPTSAS_CONFIG_PACK.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d,,,,,,,
CVE-2016-7156,https://www.cvedetails.com/cve/CVE-2016-7156/,CWE-399,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,The pvscsi_convert_sglist function in hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging an incorrect cast.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8,,,,,,,
CVE-2017-6508,https://www.cvedetails.com/cve/CVE-2017-6508/,CWE-93,,,2017-03-07,2017-06-30,4.3,None,Remote,Medium,Not required,None,Partial,None,CRLF injection vulnerability in the url_parse function in url.c in Wget through 1.19.1 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in the host subcomponent of a URL.,,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=4d729e322fae359a1aefaafec1144764a54e8ad4,,,,,,,
CVE-2016-7155,https://www.cvedetails.com/cve/CVE-2016-7155/,CWE-125,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,"hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (out-of-bounds access or infinite loop, and QEMU process crash) via a crafted page count for descriptor rings.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=7f61f4690dd153be98900a2a508b88989e692753,,,,,,,
CVE-2016-7116,https://www.cvedetails.com/cve/CVE-2016-7116/,CWE-22,,Dir. Trav.,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,Partial,None,None,Directory traversal vulnerability in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to access host files outside the export path via a .. (dot dot) in an unspecified string.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=56f101ecce0eafd09e2daf1c4eeb1377d6959261,,,,,,,
CVE-2016-7052,https://www.cvedetails.com/cve/CVE-2016-7052/,CWE-476,,DoS,2016-09-26,2018-07-11,5.0,None,Remote,Low,Not required,None,None,Partial,crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=6e629b5be45face20b4ca71c4fcbfed78b864a2e,,,,,,,
CVE-2017-6414,https://www.cvedetails.com/cve/CVE-2017-6414/,CWE-772,,DoS,2017-03-15,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the vcard_apdu_new function in card_7816.c in libcacard before 2.5.3 allows local guest OS users to cause a denial of service (host memory consumption) via vectors related to allocating a new APDU object.,,spice,https://cgit.freedesktop.org/spice/libcacard/commit/?id=9113dc6a303604a2d9812ac70c17d076ef11886c,,,,,,,
CVE-2019-5747,https://www.cvedetails.com/cve/CVE-2019-5747/,CWE-125,,+Info,2019-01-09,2019-09-04,5.0,None,Remote,Low,Not required,Partial,None,None,"An issue was discovered in BusyBox through 1.30.0. An out of bounds read in udhcp components (consumed by the DHCP server, client, and/or relay) might allow a remote attacker to leak sensitive information from the stack by sending a crafted DHCP message. This is related to assurance of a 4-byte length when decoding DHCP_SUBNET. NOTE: this issue exists because of an incomplete fix for CVE-2018-20679.",,busybox,https://git.busybox.net/busybox/commit/?id=74d9f1ba37010face4bd1449df4d60dd84450b06,,,,,,,
CVE-2017-6386,https://www.cvedetails.com/cve/CVE-2017-6386/,CWE-772,,DoS,2017-03-15,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_OBJECT_VERTEX_ELEMENTS commands.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=737c3350850ca4dbc5633b3bdb4118176ce59920,,,,,,,
CVE-2017-6355,https://www.cvedetails.com/cve/CVE-2017-6355/,CWE-190,,DoS Overflow,2017-03-09,2017-07-10,2.1,None,Local,Low,Not required,None,None,Partial,"Integer overflow in the vrend_create_shader function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (process crash) via crafted pkt_length and offlen values, which trigger an out-of-bounds access.",,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=93761787b29f37fa627dea9082cdfc1a1ec608d6,,,,,,,
CVE-2017-6317,https://www.cvedetails.com/cve/CVE-2017-6317/,CWE-772,,DoS,2017-03-15,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the add_shader_program function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via vectors involving the sprog variable.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=a2f12a1b0f95b13b6f8dc3d05d7b74b4386394e4,,,,,,,
CVE-2016-6888,https://www.cvedetails.com/cve/CVE-2016-6888/,CWE-190,,DoS Overflow,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,"Integer overflow in the net_tx_pkt_init function in hw/net/net_tx_pkt.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (QEMU process crash) via the maximum fragmentation count, which triggers an unchecked multiplication and NULL pointer dereference.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c,,,,,,,
CVE-2016-6836,https://www.cvedetails.com/cve/CVE-2016-6836/,CWE-200,,+Info,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,Partial,None,None,The vmxnet3_complete_packet function in hw/net/vmxnet3.c in QEMU (aka Quick Emulator) allows local guest OS administrators to obtain sensitive host memory information by leveraging failure to initialize the txcq_descr object.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf,,,,,,,
CVE-2017-6210,https://www.cvedetails.com/cve/CVE-2017-6210/,CWE-476,,DoS,2017-03-15,2017-07-10,2.1,None,Local,Low,Not required,None,None,Partial,The vrend_decode_reset function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (NULL pointer dereference and QEMU process crash) by destroying context 0 (zero).,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=0a5dff15912207b83018485f83e067474e818bab,,,,,,,
CVE-2016-6835,https://www.cvedetails.com/cve/CVE-2016-6835/,CWE-119,,DoS Overflow,2016-12-09,2018-09-07,2.1,None,Local,Low,Not required,None,None,Partial,The vmxnet_tx_pkt_parse_headers function in hw/net/vmxnet_tx_pkt.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (buffer over-read) by leveraging failure to check IP header length.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=93060258ae748573ca7197204125a2670047896d,,,,,,,
CVE-2017-6209,https://www.cvedetails.com/cve/CVE-2017-6209/,CWE-119,,DoS Overflow,2017-03-15,2017-07-10,2.1,None,Local,Low,Not required,None,None,Partial,Stack-based buffer overflow in the parse_identifier function in tgsi_text.c in the TGSI auxiliary module in the Gallium driver in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to parsing properties.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=e534b51ca3c3cd25f3990589932a9ed711c59b27,,,,,,,
CVE-2016-6834,https://www.cvedetails.com/cve/CVE-2016-6834/,CWE-399,,DoS,2016-12-09,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,The net_tx_pkt_do_sw_fragmentation function in hw/net/net_tx_pkt.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via a zero length for the current fragment length.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=ead315e43ea0c2ca3491209c6c8db8ce3f2bbe05,,,,,,,
CVE-2016-6833,https://www.cvedetails.com/cve/CVE-2016-6833/,CWE-416,,DoS,2016-12-09,2018-09-07,2.1,None,Local,Low,Not required,None,None,Partial,Use-after-free vulnerability in the vmxnet3_io_bar0_write function in hw/net/vmxnet3.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (QEMU instance crash) by leveraging failure to check if the device is active.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8,,,,,,,
CVE-2017-5994,https://www.cvedetails.com/cve/CVE-2017-5994/,CWE-119,,DoS Overflow,2017-03-15,2017-07-10,2.1,None,Local,Low,Not required,None,None,Partial,Heap-based buffer overflow in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and crash) via the num_elements parameter.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=114688c526fe45f341d75ccd1d85473c3b08f7a7,,,,,,,
CVE-2017-5993,https://www.cvedetails.com/cve/CVE-2017-5993/,CWE-772,,DoS,2017-03-15,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the vrend_renderer_init_blit_ctx function in vrend_blitter.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_CCMD_BLIT commands.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22,,,,,,,
CVE-2016-6490,https://www.cvedetails.com/cve/CVE-2016-6490/,CWE-20,,DoS,2016-12-09,2017-06-30,2.1,None,Local,Low,Not required,None,None,Partial,The virtqueue_map_desc function in hw/virtio/virtio.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via a zero length for the descriptor buffer.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f,,,,,,,
CVE-2017-5957,https://www.cvedetails.com/cve/CVE-2017-5957/,CWE-119,,DoS Overflow,2017-03-14,2019-07-19,2.1,None,Local,Low,Not required,None,None,Partial,"Stack-based buffer overflow in the vrend_decode_set_framebuffer_state function in vrend_decode.c in virglrenderer before 926b9b3460a48f6454d8bbe9e44313d86a65447f, as used in Quick Emulator (QEMU), allows a local guest users to cause a denial of service (application crash) via the ""nr_cbufs"" argument.",,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=926b9b3460a48f6454d8bbe9e44313d86a65447f,,,,,,,
CVE-2017-5956,https://www.cvedetails.com/cve/CVE-2017-5956/,CWE-125,,DoS,2017-03-20,2017-07-10,2.1,None,Local,Low,Not required,None,None,Partial,The vrend_draw_vbo function in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors involving vertext_buffer_index.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=a5ac49940c40ae415eac0cf912eac7070b4ba95d,,,,,,,
CVE-2017-5937,https://www.cvedetails.com/cve/CVE-2017-5937/,CWE-476,,DoS,2017-03-15,2017-03-17,2.1,None,Local,Low,Not required,None,None,Partial,The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=48f67f60967f963b698ec8df57ec6912a43d6282,,,,,,,
CVE-2017-5932,https://www.cvedetails.com/cve/CVE-2017-5932/,CWE-20,,+Priv,2017-03-27,2017-03-31,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"The path autocompletion feature in Bash 4.4 allows local users to gain privileges via a crafted filename starting with a "" (double quote) character and a command substitution metacharacter.",,savannah,https://git.savannah.gnu.org/cgit/bash.git/commit/?id=4f747edc625815f449048579f6e65869914dd715,,,,,,,
CVE-2012-3398,https://www.cvedetails.com/cve/CVE-2012-3398/,,,DoS,2012-07-23,2017-11-30,4.0,None,Remote,Low,Single system,None,None,Partial,"Algorithmic complexity vulnerability in Moodle 1.9.x before 1.9.19, 2.0.x before 2.0.10, 2.1.x before 2.1.7, and 2.2.x before 2.2.4 allows remote authenticated users to cause a denial of service (CPU consumption) by using the advanced-search feature on a database activity that has many records.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=refs%2Fheads%2FMOODLE_22_STABLE&st=commit&s=MDL-32126,,,,,,,
CVE-2012-3397,https://www.cvedetails.com/cve/CVE-2012-3397/,CWE-264,,Bypass,2012-07-23,2017-11-30,4.0,None,Remote,Low,Single system,None,Partial,None,"lib/modinfolib.php in Moodle 2.0.x before 2.0.10, 2.1.x before 2.1.7, 2.2.x before 2.2.4, and 2.3.x before 2.3.1 does not check for a group-membership requirement when determining whether an activity is unavailable or hidden, which allows remote authenticated users to bypass intended access restrictions by selecting an activity that is configured for a group of other users.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-33466,,,,,,,
CVE-2012-3396,https://www.cvedetails.com/cve/CVE-2012-3396/,CWE-79,,XSS,2012-07-23,2017-11-30,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in cohort/edit_form.php in Moodle 2.0.x before 2.0.10, 2.1.x before 2.1.7, 2.2.x before 2.2.4, and 2.3.x before 2.3.1 allows remote authenticated administrators to inject arbitrary web script or HTML via the idnumber field.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2012-2365.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-34045,,,,,,,
CVE-2012-3395,https://www.cvedetails.com/cve/CVE-2012-3395/,CWE-89,,Exec Code Sql,2012-07-23,2017-11-30,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"SQL injection vulnerability in mod/feedback/complete.php in Moodle 2.0.x before 2.0.10, 2.1.x before 2.1.7, and 2.2.x before 2.2.4 allows remote authenticated users to execute arbitrary SQL commands via crafted form data.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=9d8d2ee6192e8b7ebb6713bd6215e06f94e2a9f7&st=commit&s=MDL-27675,,,,,,,
CVE-2012-3394,https://www.cvedetails.com/cve/CVE-2012-3394/,CWE-200,,+Info,2012-07-23,2017-11-30,5.0,None,Remote,Low,Not required,Partial,None,None,"auth/ldap/ntlmsso_attempt.php in Moodle 2.0.x before 2.0.10, 2.1.x before 2.1.7, 2.2.x before 2.2.4, and 2.3.x before 2.3.1 redirects users from an https LDAP login URL to an http URL, which allows remote attackers to obtain sensitive information by sniffing the network.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=9d8d2ee6192e8b7ebb6713bd6215e06f94e2a9f7,,,,,,,
CVE-2012-3393,https://www.cvedetails.com/cve/CVE-2012-3393/,CWE-79,,XSS,2012-07-23,2017-11-30,3.5,None,Remote,Medium,Single system,None,Partial,None,Cross-site scripting (XSS) vulnerability in repository/lib.php in Moodle 2.1.x before 2.1.7 and 2.2.x before 2.2.4 allows remote authenticated administrators to inject arbitrary web script or HTML by renaming a repository.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=refs%2Fheads%2FMOODLE_22_STABLE&st=commit&s=MDL-33808,,,,,,,
CVE-2012-3392,https://www.cvedetails.com/cve/CVE-2012-3392/,CWE-16,,Bypass,2012-07-23,2017-11-30,5.5,None,Remote,Low,Single system,None,Partial,Partial,"mod/forum/unsubscribeall.php in Moodle 2.1.x before 2.1.7 and 2.2.x before 2.2.4 does not consider whether a forum is optional, which allows remote authenticated users to bypass forum-subscription requirements by leveraging the student role and unsubscribing from all forums.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=refs%2Fheads%2FMOODLE_22_STABLE&st=commit&s=MDL-31460,,,,,,,
CVE-2012-3391,https://www.cvedetails.com/cve/CVE-2012-3391/,CWE-264,,Bypass,2012-07-23,2017-11-30,4.0,None,Remote,Low,Single system,Partial,None,None,"mod/forum/rsslib.php in Moodle 2.1.x before 2.1.7 and 2.2.x before 2.2.4 does not properly implement the requirement for posting before reading a Q&A forum, which allows remote authenticated users to bypass intended access restrictions by leveraging the student role and reading the RSS feed for a forum.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=refs%2Fheads%2FMOODLE_22_STABLE&st=commit&s=MDL-32199,,,,,,,
CVE-2012-3390,https://www.cvedetails.com/cve/CVE-2012-3390/,CWE-264,,+Info,2012-07-23,2017-11-30,3.5,None,Remote,Medium,Single system,Partial,None,None,"lib/filelib.php in Moodle 2.1.x before 2.1.7 and 2.2.x before 2.2.4 does not properly restrict file access after a block has been hidden, which allows remote authenticated users to obtain sensitive information by reading a file that is embedded in a block.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=c58c05ad4f22c6ee1e136a7d4caaddd809a7134d,,,,,,,
CVE-2012-3389,https://www.cvedetails.com/cve/CVE-2012-3389/,CWE-79,,XSS,2012-07-23,2017-11-30,4.3,None,Remote,Medium,Not required,None,Partial,None,Multiple cross-site scripting (XSS) vulnerabilities in mod/lti/typessettings.php in Moodle 2.2.x before 2.2.4 and 2.3.x before 2.3.1 allow remote attackers to inject arbitrary web script or HTML via the (1) lti_typename or (2) lti_toolurl parameter.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-31692,,,,,,,
CVE-2012-3388,https://www.cvedetails.com/cve/CVE-2012-3388/,CWE-264,,Bypass,2012-07-23,2017-11-30,4.0,None,Remote,Low,Single system,None,Partial,None,"The is_enrolled function in lib/accesslib.php in Moodle 2.2.x before 2.2.4 and 2.3.x before 2.3.1 does not properly interact with the caching feature, which might allow remote authenticated users to bypass an intended capability check via unspecified vectors that trigger caching of a user record.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-33916,,,,,,,
CVE-2012-3387,https://www.cvedetails.com/cve/CVE-2012-3387/,CWE-264,,Bypass,2012-07-23,2017-11-30,4.0,None,Remote,Low,Single system,None,Partial,None,"Moodle 2.3.x before 2.3.1 uses only a client-side check for whether references are permitted in a file upload, which allows remote authenticated users to bypass intended alias (aka shortcut) restrictions via a client that omits this check.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-33948,,,,,,,
CVE-2012-3386,https://www.cvedetails.com/cve/CVE-2012-3386/,CWE-264,,Exec Code,2012-08-07,2013-04-04,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"The ""make distcheck"" rule in GNU Automake before 1.11.6 and 1.12.x before 1.12.2 grants world-writable permissions to the extraction directory, which introduces a race condition that allows local users to execute arbitrary code via unspecified vectors.",,savannah,https://git.savannah.gnu.org/cgit/automake.git/commit/?id=784b3e6ccc7c72a1c95c340cbbe8897d6b689d76,,,,,,,
CVE-2012-3291,https://www.cvedetails.com/cve/CVE-2012-3291/,CWE-119,,DoS Overflow,2012-06-07,2018-01-04,7.8,None,Remote,Low,Not required,None,None,Complete,Heap-based buffer overflow in OpenConnect 3.18 allows remote servers to cause a denial of service via a crafted greeting banner.,,infradead,http://git.infradead.org/users/dwmw2/openconnect.git/commitdiff/14cae65318d3ef1f7d449e463b72b6934e82f1c2,,,,,,,
CVE-2016-6351,https://www.cvedetails.com/cve/CVE-2016-6351/,CWE-787,,DoS Exec Code,2016-09-07,2018-12-01,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"The esp_do_dma function in hw/scsi/esp.c in QEMU (aka Quick Emulator), when built with ESP/NCR53C9x controller emulation support, allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) or execute arbitrary code on the QEMU host via vectors involving DMA read into ESP command buffer.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11,,,,,,,
CVE-2016-6351,https://www.cvedetails.com/cve/CVE-2016-6351/,CWE-787,,DoS Exec Code,2016-09-07,2018-12-01,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"The esp_do_dma function in hw/scsi/esp.c in QEMU (aka Quick Emulator), when built with ESP/NCR53C9x controller emulation support, allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) or execute arbitrary code on the QEMU host via vectors involving DMA read into ESP command buffer.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3,,,,,,,
CVE-2016-6321,https://www.cvedetails.com/cve/CVE-2016-6321/,CWE-22,,Dir. Trav. Bypass,2016-12-09,2017-06-30,5.0,None,Remote,Low,Not required,None,Partial,None,"Directory traversal vulnerability in the safer_name_suffix function in GNU tar 1.14 through 1.29 might allow remote attackers to bypass an intended protection mechanism and write to arbitrary files via vectors related to improper sanitization of the file_name parameter, aka POINTYFEATHER.",,savannah,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=7340f67b9860ea0531c1450e5aa261c50f67165d,,,,,,,
CVE-2016-6309,https://www.cvedetails.com/cve/CVE-2016-6309/,CWE-416,,DoS Exec Code,2016-09-26,2018-07-11,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"statem/statem.c in OpenSSL 1.1.0a does not consider memory-block movement after a realloc call, which allows remote attackers to cause a denial of service (use-after-free) or possibly execute arbitrary code via a crafted TLS session.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=acacbfa7565c78d2273c0b2a2e5e803f44afefeb,,,,,,,
CVE-2016-6308,https://www.cvedetails.com/cve/CVE-2016-6308/,CWE-399,,DoS,2016-09-26,2018-04-19,7.1,None,Remote,Medium,Not required,None,None,Complete,"statem/statem_dtls.c in the DTLS implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted DTLS messages.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e,,,,,,,
CVE-2016-6307,https://www.cvedetails.com/cve/CVE-2016-6307/,CWE-400,,DoS,2016-09-26,2018-04-19,4.3,None,Remote,Medium,Not required,None,None,Partial,"The state-machine implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted TLS messages, related to statem/statem.c and statem/statem_lib.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,,,,,,,
CVE-2016-6306,https://www.cvedetails.com/cve/CVE-2016-6306/,CWE-125,,DoS,2016-09-26,2018-07-13,4.3,None,Remote,Medium,Not required,None,None,Partial,"The certificate parser in OpenSSL before 1.0.1u and 1.0.2 before 1.0.2i might allow remote attackers to cause a denial of service (out-of-bounds read) via crafted certificate operations, related to s3_clnt.c and s3_srvr.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=52e623c4cb06fffa9d5e75c60b34b4bc130b12e9,,,,,,,
CVE-2016-6304,https://www.cvedetails.com/cve/CVE-2016-6304/,CWE-399,,DoS,2016-09-26,2018-04-19,7.8,None,Remote,Low,Not required,None,None,Complete,"Multiple memory leaks in t1_lib.c in OpenSSL before 1.0.1u, 1.0.2 before 1.0.2i, and 1.1.0 before 1.1.0a allow remote attackers to cause a denial of service (memory consumption) via large OCSP Status Request extensions.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=2c0d295e26306e15a92eb23a84a1802005c1c137,,,,,,,
CVE-2016-6303,https://www.cvedetails.com/cve/CVE-2016-6303/,CWE-787,,DoS Overflow,2016-09-16,2018-04-19,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Integer overflow in the MDC2_Update function in crypto/mdc2/mdc2dgst.c in OpenSSL before 1.1.0 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=55d83bf7c10c7b205fffa23fa7c3977491e56c07,,,,,,,
CVE-2016-6302,https://www.cvedetails.com/cve/CVE-2016-6302/,CWE-20,,DoS,2016-09-16,2018-07-13,5.0,None,Remote,Low,Not required,None,None,Partial,"The tls_decrypt_ticket function in ssl/t1_lib.c in OpenSSL before 1.1.0 does not consider the HMAC size during validation of the ticket length, which allows remote attackers to cause a denial of service via a ticket that is too short.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=e97763c92c655dcf4af2860b3abd2bc4c8a267f9,,,,,,,
CVE-2016-6301,https://www.cvedetails.com/cve/CVE-2016-6301/,CWE-399,,DoS,2016-12-09,2019-06-13,7.8,None,Remote,Low,Not required,None,None,Complete,"The recv_and_process_client_pkt function in networking/ntpd.c in busybox allows remote attackers to cause a denial of service (CPU and bandwidth consumption) via a forged NTP packet, which triggers a communication loop.",,busybox,https://git.busybox.net/busybox/commit/?id=150dc7a2b483b8338a3e185c478b4b23ee884e71,,,,,,,
CVE-2016-6297,https://www.cvedetails.com/cve/CVE-2016-6297/,CWE-119,,DoS Overflow,2016-07-25,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer overflow in the php_stream_zip_opener function in ext/zip/zip_stream.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted zip:// URL.",,php,https://git.php.net/?p=php-src.git;a=commit;h=81406c0c1d45f75fcc7972ed974d2597abb0b9e9,,,,,,,
CVE-2016-6296,https://www.cvedetails.com/cve/CVE-2016-6296/,CWE-119,,DoS Overflow,2016-07-25,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer signedness error in the simplestring_addn function in simplestring.c in xmlrpc-epi through 0.54.2, as used in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a long first argument to the PHP xmlrpc_encode_request function.",,php,https://git.php.net/?p=php-src.git;a=commit;h=e6c48213c22ed50b2b987b479fcc1ac709394caa,,,,,,,
CVE-2016-6295,https://www.cvedetails.com/cve/CVE-2016-6295/,CWE-416,,DoS,2016-07-25,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"ext/snmp/snmp.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact via crafted serialized data, a related issue to CVE-2016-5773.",,php,https://git.php.net/?p=php-src.git;a=commit;h=cab1c3b3708eead315e033359d07049b23b147a3,,,,,,,
CVE-2016-6294,https://www.cvedetails.com/cve/CVE-2016-6294/,CWE-125,,DoS,2016-07-25,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The locale_accept_from_http function in ext/intl/locale/locale_methods.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 does not properly restrict calls to the ICU uloc_acceptLanguageFromHTTP function, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a call with a long argument.",,php,https://git.php.net/?p=php-src.git;a=commit;h=aa82e99ed8003c01f1ef4f0940e56b85c5b032d4,,,,,,,
CVE-2016-6293,https://www.cvedetails.com/cve/CVE-2016-6293/,CWE-119,,DoS Overflow,2016-07-25,2019-04-23,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The uloc_acceptLanguageFromHTTP function in common/uloc.cpp in International Components for Unicode (ICU) through 57.1 for C/C++ does not ensure that there is a '\0' character at the end of a certain temporary array, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a call with a long httpAcceptLanguage argument.",,php,https://git.php.net/?p=php-src.git;a=commit;h=aa82e99ed8003c01f1ef4f0940e56b85c5b032d4,,,,,,,
CVE-2016-6292,https://www.cvedetails.com/cve/CVE-2016-6292/,CWE-476,,DoS,2016-07-25,2018-01-04,4.3,None,Remote,Medium,Not required,None,None,Partial,"The exif_process_user_comment function in ext/exif/exif.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted JPEG image.",,php,https://git.php.net/?p=php-src.git;a=commit;h=41131cd41d2fd2e0c2f332a27988df75659c42e4,,,,,,,
CVE-2016-6291,https://www.cvedetails.com/cve/CVE-2016-6291/,CWE-119,,DoS Overflow Mem. Corr. +Info,2016-07-25,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The exif_process_IFD_in_MAKERNOTE function in ext/exif/exif.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 allows remote attackers to cause a denial of service (out-of-bounds array access and memory corruption), obtain sensitive information from process memory, or possibly have unspecified other impact via a crafted JPEG image.",,php,https://git.php.net/?p=php-src.git;a=commit;h=eebcbd5de38a0f1c2876035402cb770e37476519,,,,,,,
CVE-2016-6290,https://www.cvedetails.com/cve/CVE-2016-6290/,CWE-416,,DoS,2016-07-25,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"ext/session/session.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 does not properly maintain a certain hash data structure, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors related to session deserialization.",,php,https://git.php.net/?p=php-src.git;a=commit;h=3798eb6fd5dddb211b01d41495072fd9858d4e32,,,,,,,
CVE-2016-6289,https://www.cvedetails.com/cve/CVE-2016-6289/,CWE-190,,DoS Overflow,2016-07-25,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer overflow in the virtual_file_ex function in TSRM/tsrm_virtual_cwd.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted extract operation on a ZIP archive.",,php,https://git.php.net/?p=php-src.git;a=commit;h=0218acb7e756a469099c4ccfb22bce6c2bd1ef87,,,,,,,
CVE-2016-6288,https://www.cvedetails.com/cve/CVE-2016-6288/,CWE-119,,DoS Overflow,2016-07-25,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,The php_url_parse_ex function in ext/standard/url.c in PHP before 5.5.38 allows remote attackers to cause a denial of service (buffer over-read) or possibly have unspecified other impact via vectors involving the smart_str data type.,,php,https://git.php.net/?p=php-src.git;a=commit;h=629e4da7cc8b174acdeab84969cbfc606a019b31,,,,,,,
CVE-2016-6263,https://www.cvedetails.com/cve/CVE-2016-6263/,CWE-125,,DoS,2016-09-07,2016-11-28,5.0,None,Remote,Low,Not required,None,None,Partial,The stringprep_utf8_nfkc_normalize function in lib/nfkc.c in libidn before 1.33 allows context-dependent attackers to cause a denial of service (out-of-bounds read and crash) via crafted UTF-8 data.,,savannah,https://git.savannah.gnu.org/cgit/libidn.git/commit/?id=1fbee57ef3c72db2206dd87e4162108b2f425555,,,,,,,
CVE-2016-6262,https://www.cvedetails.com/cve/CVE-2016-6262/,CWE-125,,+Info,2016-09-07,2018-10-30,5.0,None,Remote,Low,Not required,Partial,None,None,"idn in libidn before 1.33 might allow remote attackers to obtain sensitive memory information by reading a zero byte as input, which triggers an out-of-bounds read, a different vulnerability than CVE-2015-8948.",,savannah,https://git.savannah.gnu.org/cgit/libidn.git/commit/?id=5e3cb9c7b5bf0ce665b9d68f5ddf095af5c9ba60,,,,,,,
CVE-2010-2808,https://www.cvedetails.com/cve/CVE-2010-2808/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2010-08-19,2011-01-12,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.2 allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly execute arbitrary code via a crafted Adobe Type 1 Mac Font File (aka LWFN) font.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=81f3472c0ba7b8f6466e2e214fa8c1c17fade975,,,,,,,
CVE-2016-6261,https://www.cvedetails.com/cve/CVE-2016-6261/,CWE-125,,DoS,2016-09-07,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,The idna_to_ascii_4i function in lib/idna.c in libidn before 1.33 allows context-dependent attackers to cause a denial of service (out-of-bounds read and crash) via 64 bytes of input.,,savannah,https://git.savannah.gnu.org/cgit/libidn.git/commit/?id=f20ce1128fb7f4d33297eee307dddaf0f92ac72d,,,,,,,
CVE-2010-2807,https://www.cvedetails.com/cve/CVE-2010-2807/,CWE-189,,DoS Exec Code,2010-08-19,2010-12-10,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"FreeType before 2.4.2 uses incorrect integer data types during bounds checking, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=346f1867fd32dae8f56e5b482d1af98f626804ac,,,,,,,
CVE-2010-2806,https://www.cvedetails.com/cve/CVE-2010-2806/,CWE-399,,DoS Exec Code Overflow,2010-08-19,2011-01-12,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Array index error in the t42_parse_sfnts function in type42/t42parse.c in FreeType before 2.4.2 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via negative size values for certain strings in FontType42 font files, leading to a heap-based buffer overflow.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c06da1ad34663da7b6fc39b030dc3ae185b96557,,,,,,,
CVE-2010-2805,https://www.cvedetails.com/cve/CVE-2010-2805/,CWE-20,,DoS Exec Code,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The FT_Stream_EnterFrame function in base/ftstream.c in FreeType before 2.4.2 does not properly validate certain position values, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=45a3c76b547511fa9d97aca34b150a0663257375,,,,,,,
CVE-2017-5580,https://www.cvedetails.com/cve/CVE-2017-5580/,CWE-119,,DoS Overflow,2017-03-15,2017-07-10,2.1,None,Local,Low,Not required,None,None,Partial,The parse_instruction function in gallium/auxiliary/tgsi/tgsi_text.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and process crash) via a crafted texture instruction.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/src/gallium/auxiliary/tgsi/tgsi_text.c?id=28894a30a17a84529be102b21118e55d6c9f23fa,,,,,,,
CVE-2017-5578,https://www.cvedetails.com/cve/CVE-2017-5578/,CWE-772,,DoS,2017-03-15,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the virtio_gpu_resource_attach_backing function in hw/display/virtio-gpu.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING commands.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=204f01b30975923c64006f8067f0937b91eea68b,,,,,,,
CVE-2017-5552,https://www.cvedetails.com/cve/CVE-2017-5552/,CWE-772,,DoS,2017-03-15,2019-10-02,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the virgl_resource_attach_backing function in hw/display/virtio-gpu-3d.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING commands.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=33243031dad02d161225ba99d782616da133f689,,,,,,,
CVE-2014-6269,https://www.cvedetails.com/cve/CVE-2014-6269/,CWE-189,,DoS Overflow,2014-09-30,2014-10-02,5.0,None,Remote,Low,Not required,None,None,Partial,"Multiple integer overflows in the http_request_forward_body function in proto_http.c in HAProxy 1.5-dev23 before 1.5.4 allow remote attackers to cause a denial of service (crash) via a large stream of data, which triggers a buffer overflow and an out-of-bounds read.",,haproxy,https://git.haproxy.org/?p=haproxy-1.5.git;a=commitdiff;h=b4d05093bc89f71377230228007e69a1434c1a0c,,,,,,,
CVE-2018-7995,https://www.cvedetails.com/cve/CVE-2018-7995/,CWE-362,,DoS,2018-03-09,2018-05-23,4.7,None,Local,Medium,Not required,None,None,Complete,** DISPUTED ** Race condition in the store_int_with_restart() function in arch/x86/kernel/cpu/mcheck/mce.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (panic) by leveraging root access to write to the check_interval file in a /sys/devices/system/machinecheck/machinecheck<cpu number> directory. NOTE: a third party has indicated that this report is not security relevant.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=b3b7c4795ccab5be71f080774c45bbbcc75c2aaf,,,,,,,
CVE-2017-5330,https://www.cvedetails.com/cve/CVE-2017-5330/,CWE-78,,Exec Code,2017-03-27,2017-03-31,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"ark before 16.12.1 might allow remote attackers to execute arbitrary code via an executable in an archive, related to associated applications.",,kde,https://cgit.kde.org/ark.git/commit/?id=82fdfd24d46966a117fa625b68784735a40f9065,,,,,,,
CVE-2018-7731,https://www.cvedetails.com/cve/CVE-2018-7731/,CWE-476,,,2018-03-06,2018-06-05,4.3,None,Remote,Medium,Not required,None,None,Partial,"An issue was discovered in Exempi through 2.4.4. XMPFiles/source/FormatSupport/WEBP_Support.cpp does not check whether a bitstream has a NULL value, leading to a NULL pointer dereference in the WEBP::VP8XChunk class.",,exempi,https://cgit.freedesktop.org/exempi/commit/?id=aabedb5e749dd59112a3fe1e8e08f2d934f56666,,,,,,,
CVE-2018-7730,https://www.cvedetails.com/cve/CVE-2018-7730/,CWE-125,,,2018-03-06,2019-08-06,4.3,None,Remote,Medium,Not required,None,None,Partial,"An issue was discovered in Exempi through 2.4.4. A certain case of a 0xffffffff length is mishandled in XMPFiles/source/FormatSupport/PSIR_FileWriter.cpp, leading to a heap-based buffer over-read in the PSD_MetaHandler::CacheFileData() function.",,exempi,https://cgit.freedesktop.org/exempi/commit/?id=6cbd34025e5fd3ba47b29b602096e456507ce83b,,,,,,,
CVE-2018-7729,https://www.cvedetails.com/cve/CVE-2018-7729/,CWE-125,,,2018-03-06,2018-06-05,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in Exempi through 2.4.4. There is a stack-based buffer over-read in the PostScript_MetaHandler::ParsePSFile() function in XMPFiles/source/FileHandlers/PostScript_Handler.cpp.,,exempi,https://cgit.freedesktop.org/exempi/commit/?id=baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c,,,,,,,
CVE-2019-3839,https://www.cvedetails.com/cve/CVE-2019-3839/,CWE-264,,,2019-05-16,2019-05-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"It was found that in ghostscript some privileged operators remained accessible from various places after the CVE-2019-6116 fix. A specially crafted PostScript file could use this flaw in order to, for example, have access to the file system outside of the constrains imposed by -dSAFER. Ghostscript versions before 9.27 are vulnerable.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=4ec9ca74bed49f2a82acb4bf430eae0d8b3b75c9,,,,,,,
CVE-2018-7728,https://www.cvedetails.com/cve/CVE-2018-7728/,CWE-125,,,2018-03-06,2018-06-05,4.3,None,Remote,Medium,Not required,None,None,Partial,"An issue was discovered in Exempi through 2.4.4. XMPFiles/source/FileHandlers/TIFF_Handler.cpp mishandles a case of a zero length, leading to a heap-based buffer over-read in the MD5Update() function in third-party/zuid/interfaces/MD5.cpp.",,exempi,https://cgit.freedesktop.org/exempi/commit/?id=e163667a06a9b656a047b0ec660b871f29a83c9f,,,,,,,
CVE-2010-2527,https://www.cvedetails.com/cve/CVE-2010-2527/,CWE-119,,DoS Exec Code Overflow,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Multiple buffer overflows in demo programs in FreeType before 2.4.0 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2-demos.git/commit/?id=b995299b73ba4cd259f221f500d4e63095508bec,,,,,,,
CVE-2019-3810,https://www.cvedetails.com/cve/CVE-2019-3810/,CWE-200,,+Info,2019-03-25,2019-10-09,5.0,None,Remote,Low,Not required,Partial,None,None,"A flaw was found in moodle versions 3.6 to 3.6.1, 3.5 to 3.5.3, 3.4 to 3.4.6, 3.1 to 3.1.15 and earlier unsupported versions. The /userpix/ page did not escape users' full names, which are included as text when hovering over profile images. Note this page is not linked to by default and its access is restricted.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-64372,,,,,,,
CVE-2019-3809,https://www.cvedetails.com/cve/CVE-2019-3809/,CWE-918,,,2019-03-25,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"A flaw was found in Moodle versions 3.1 to 3.1.15 and earlier unsupported versions. The mybackpack functionality allowed setting the URL of badges, when it should be restricted to the Mozilla Open Badges backpack URL. This resulted in the possibility of blind SSRF via requests made by the page.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-64222,,,,,,,
CVE-2019-3808,https://www.cvedetails.com/cve/CVE-2019-3808/,CWE-254,,XSS,2019-03-25,2019-10-09,4.0,None,Remote,Low,Single system,None,Partial,None,"A flaw was found in Moodle versions 3.6 to 3.6.1, 3.5 to 3.5.3, 3.4 to 3.4.6, 3.1 to 3.1.15 and earlier unsupported versions. The 'manage groups' capability did not have the 'XSS risk' flag assigned to it, but does have that access in certain places. Note that the capability is intended for use by trusted users, and is only assigned to teachers and managers by default.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-64395,,,,,,,
CVE-2010-2520,https://www.cvedetails.com/cve/CVE-2010-2520/,CWE-119,,DoS Exec Code Overflow,2010-08-19,2012-12-18,5.1,None,Remote,High,Not required,Partial,Partial,Partial,"Heap-based buffer overflow in the Ins_IUP function in truetype/ttinterp.c in FreeType before 2.4.0, when TrueType bytecode support is enabled, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=888cd1843e935fe675cf2ac303116d4ed5b9d54b,,,,,,,
CVE-2010-2519,https://www.cvedetails.com/cve/CVE-2010-2519/,CWE-119,,DoS Exec Code Overflow,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted length value in a POST fragment header in a font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=5ef20c8c1d4de12a84b50ba497c2a358c90ec44b,,,,,,,
CVE-2010-2519,https://www.cvedetails.com/cve/CVE-2010-2519/,CWE-119,,DoS Exec Code Overflow,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted length value in a POST fragment header in a font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=b2ea64bcc6c385a8e8318f9c759450a07df58b6d,,,,,,,
CVE-2010-2500,https://www.cvedetails.com/cve/CVE-2010-2500/,CWE-189,,DoS Exec Code Overflow,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=6305b869d86ff415a33576df6d43729673c66eee,,,,,,,
CVE-2010-2499,https://www.cvedetails.com/cve/CVE-2010-2499/,CWE-119,,DoS Exec Code Overflow,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted LaserWriter PS font file with an embedded PFB fragment.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f29f741efbba0a5ce2f16464f648fb8d026ed4c8,,,,,,,
CVE-2010-2499,https://www.cvedetails.com/cve/CVE-2010-2499/,CWE-119,,DoS Exec Code Overflow,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted LaserWriter PS font file with an embedded PFB fragment.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c69891a1345640096fbf396e8dd567fe879ce233,,,,,,,
CVE-2010-2498,https://www.cvedetails.com/cve/CVE-2010-2498/,CWE-399,,DoS Exec Code Mem. Corr.,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The psh_glyph_find_strong_points function in pshinter/pshalgo.c in FreeType before 2.4.0 does not properly implement hinting masks, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) or possibly execute arbitrary code via a crafted font file that triggers an invalid free operation.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=8d22746c9e5af80ff4304aef440986403a5072e2,,,,,,,
CVE-2010-2497,https://www.cvedetails.com/cve/CVE-2010-2497/,CWE-189,,DoS Exec Code,2010-08-19,2012-12-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Integer underflow in glyph handling in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7d3d2cc4fef72c6be9c454b3809c387e12b44cfc,,,,,,,
CVE-2018-7566,https://www.cvedetails.com/cve/CVE-2018-7566/,CWE-119,,Overflow,2018-03-30,2019-06-17,4.6,None,Local,Low,Not required,Partial,Partial,Partial,The Linux kernel 4.15 has a Buffer Overflow via an SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ioctl write operation to /dev/snd/seq by a local user.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d15d662e89fc667b90cd294b0eb45694e33144da,,,,,,,
CVE-2016-5407,https://www.cvedetails.com/cve/CVE-2016-5407/,CWE-125,,,2016-12-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,The (1) XvQueryAdaptors and (2) XvQueryEncodings functions in X.org libXv before 1.0.11 allow remote X servers to trigger out-of-bounds memory access operations via vectors involving length specifications in received data.,,libXv,https://cgit.freedesktop.org/xorg/lib/libXv/commit/?id=d9da580b46a28ab497de2e94fdc7b9ff953dab17,,,,,,,
CVE-2012-2737,https://www.cvedetails.com/cve/CVE-2012-2737/,CWE-362,,,2012-07-22,2017-08-28,1.9,None,Local,Medium,Not required,Partial,None,None,"The user_change_icon_file_authorized_cb function in /usr/libexec/accounts-daemon in AccountsService before 0.6.22 does not properly check the UID when copying an icon file to the system cache directory, which allows local users to read arbitrary files via a race condition.",,accountsservice,https://cgit.freedesktop.org/accountsservice/commit/?id=bd51aa4cdac380f55d607f4ffdf2ab3c00d08721,,,,,,,
CVE-2012-2737,https://www.cvedetails.com/cve/CVE-2012-2737/,CWE-362,,,2012-07-22,2017-08-28,1.9,None,Local,Medium,Not required,Partial,None,None,"The user_change_icon_file_authorized_cb function in /usr/libexec/accounts-daemon in AccountsService before 0.6.22 does not properly check the UID when copying an icon file to the system cache directory, which allows local users to read arbitrary files via a race condition.",,accountsservice,https://cgit.freedesktop.org/accountsservice/commit/?id=26213aa0e0d8dca5f36cc23f6942525224cbe9f5,,,,,,,
CVE-2012-2737,https://www.cvedetails.com/cve/CVE-2012-2737/,CWE-362,,,2012-07-22,2017-08-28,1.9,None,Local,Medium,Not required,Partial,None,None,"The user_change_icon_file_authorized_cb function in /usr/libexec/accounts-daemon in AccountsService before 0.6.22 does not properly check the UID when copying an icon file to the system cache directory, which allows local users to read arbitrary files via a race condition.",,accountsservice,https://cgit.freedesktop.org/accountsservice/commit/?id=4c5b12e363410e490e776e4b4a86dcce157a543d,,,,,,,
CVE-2012-2737,https://www.cvedetails.com/cve/CVE-2012-2737/,CWE-362,,,2012-07-22,2017-08-28,1.9,None,Local,Medium,Not required,Partial,None,None,"The user_change_icon_file_authorized_cb function in /usr/libexec/accounts-daemon in AccountsService before 0.6.22 does not properly check the UID when copying an icon file to the system cache directory, which allows local users to read arbitrary files via a race condition.",,accountsservice,https://cgit.freedesktop.org/accountsservice/commit/?id=27f3d93a82fde4f6c7ab54f3f008af04f93f9c69,,,,,,,
CVE-2016-5384,https://www.cvedetails.com/cve/CVE-2016-5384/,CWE-415,,Exec Code,2016-08-12,2017-01-17,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"fontconfig before 2.12.1 does not validate offsets, which allows local users to trigger arbitrary free calls and consequently conduct double free attacks and execute arbitrary code via a crafted cache file.",,fontconfig,https://cgit.freedesktop.org/fontconfig/commit/?id=7a4a5bd7897d216f0794ca9dbce0a4a5c9d14940,,,,,,,
CVE-2016-5338,https://www.cvedetails.com/cve/CVE-2016-5338/,CWE-20,,DoS Exec Code,2016-06-14,2018-12-01,4.6,None,Local,Low,Not required,Partial,Partial,Partial,The (1) esp_reg_read and (2) esp_reg_write functions in hw/scsi/esp.c in QEMU allow local guest OS administrators to cause a denial of service (QEMU process crash) or execute arbitrary code on the QEMU host via vectors related to the information transfer buffer.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=ff589551c8e8e9e95e211b9d8daafb4ed39f1aec,,,,,,,
CVE-2016-5337,https://www.cvedetails.com/cve/CVE-2016-5337/,CWE-200,,+Info,2016-06-14,2018-12-01,2.1,None,Local,Low,Not required,Partial,None,None,The megasas_ctrl_get_info function in hw/scsi/megasas.c in QEMU allows local guest OS administrators to obtain sensitive host memory information via vectors related to reading device control information.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6,,,,,,,
CVE-2016-5126,https://www.cvedetails.com/cve/CVE-2016-5126/,CWE-119,,DoS Exec Code Overflow,2016-06-01,2017-06-30,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the iscsi_aio_ioctl function in block/iscsi.c in QEMU allows local guest OS users to cause a denial of service (QEMU process crash) or possibly execute arbitrary code via a crafted iSCSI asynchronous I/O ioctl call.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196,,,,,,,
CVE-2016-4971,https://www.cvedetails.com/cve/CVE-2016-4971/,CWE-254,,,2016-06-30,2018-01-04,4.3,None,Remote,Medium,Not required,None,Partial,None,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,,,,,,,
CVE-2016-4964,https://www.cvedetails.com/cve/CVE-2016-4964/,CWE-20,,DoS,2016-12-09,2017-06-30,4.9,None,Local,Low,Not required,None,None,Complete,"The mptsas_fetch_requests function in hw/scsi/mptsas.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop, and CPU consumption or QEMU process crash) via vectors involving s->state.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=06630554ccbdd25780aa03c3548aaff1eb56dffd,,,,,,,
CVE-2012-2386,https://www.cvedetails.com/cve/CVE-2012-2386/,CWE-189,,DoS Exec Code Overflow,2012-07-07,2012-09-21,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.,,php,https://git.php.net/?p=php-src.git;a=commit;h=158d8a6b088662ce9d31e0c777c6ebe90efdc854,,,,,,,
CVE-2012-2367,https://www.cvedetails.com/cve/CVE-2012-2367/,CWE-264,,Bypass,2012-07-20,2012-10-30,4.0,None,Remote,Low,Single system,None,Partial,None,"Moodle 1.9.x before 1.9.18, 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to bypass the moodle/calendar:manageownentries capability requirement and add a calendar entry via a New Entry action.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-18335,,,,,,,
CVE-2012-2366,https://www.cvedetails.com/cve/CVE-2012-2366/,,,,2012-07-20,2012-07-23,5.5,None,Remote,Low,Single system,None,Partial,Partial,"mod/data/preset.php in Moodle 2.1.x before 2.1.6 and 2.2.x before 2.2.3 does not properly iterate through an array, which allows remote authenticated users to overwrite arbitrary database activity presets via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-31763,,,,,,,
CVE-2012-2365,https://www.cvedetails.com/cve/CVE-2012-2365/,CWE-79,,XSS,2012-07-20,2012-10-30,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in Moodle 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to inject arbitrary web script or HTML via the idnumber field to cohort/edit.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-31691,,,,,,,
CVE-2012-2364,https://www.cvedetails.com/cve/CVE-2012-2364/,CWE-79,,XSS,2012-07-20,2012-07-23,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in lib/filelib.php in Moodle 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to inject arbitrary web script or HTML via an assignment submission with zip compression, leading to text/html rendering during a ""download all"" action.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=ce4126c7a9e07dd0514f7ac297b5e60cad0b8d20,,,,,,,
CVE-2012-2363,https://www.cvedetails.com/cve/CVE-2012-2363/,CWE-89,,Exec Code Sql,2012-07-20,2012-07-23,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,SQL injection vulnerability in calendar/event.php in the calendar implementation in Moodle 1.9.x before 1.9.18 allows remote authenticated users to execute arbitrary SQL commands via a crafted calendar event.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=refs%2Fheads%2FMOODLE_19_STABLE&st=commit&s=MDL-31746,,,,,,,
CVE-2012-2362,https://www.cvedetails.com/cve/CVE-2012-2362/,CWE-79,,XSS,2012-07-20,2012-11-06,2.6,None,Remote,High,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in blog/lib.php in the blog implementation in Moodle 1.9.x before 1.9.18, when Internet Explorer is used, allows remote attackers to inject arbitrary web script or HTML via a crafted parameter to blog/index.php.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=038131c8b5614f18c14d964dc53b6960ae6c30d8,,,,,,,
CVE-2014-5388,https://www.cvedetails.com/cve/CVE-2014-5388/,CWE-119,,Overflow Mem. Corr. +Info,2014-11-15,2014-11-17,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Off-by-one error in the pci_read function in the ACPI PCI hotplug interface (hw/acpi/pcihp.c) in QEMU allows local guest users to obtain sensitive information and have other unspecified impact related to a crafted PCI device that triggers memory corruption.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=fa365d7cd11185237471823a5a33d36765454e16,,,,,,,
CVE-2012-2361,https://www.cvedetails.com/cve/CVE-2012-2361/,CWE-79,,XSS,2012-07-20,2012-07-23,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in admin/webservice/forms.php in the web services implementation in Moodle 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to inject arbitrary web script or HTML via the name field (aka the service name) to admin/webservice/service.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-31694,,,,,,,
CVE-2012-2360,https://www.cvedetails.com/cve/CVE-2012-2360/,CWE-79,,XSS,2012-07-20,2012-07-23,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the Wiki subsystem in Moodle 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to inject arbitrary web script or HTML via a crafted string that is inserted into a page title.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-32018,,,,,,,
CVE-2012-2359,https://www.cvedetails.com/cve/CVE-2012-2359/,CWE-264,,+Priv,2012-07-20,2012-07-23,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"admin/roles/override.php in Moodle 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to gain privileges by leveraging the teacher role and modifying their own capabilities, as demonstrated by obtaining the backup:userinfo capability.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=0f75e1e6272db0303abc8e27362e5c3a1344b82f,,,,,,,
CVE-2012-2358,https://www.cvedetails.com/cve/CVE-2012-2358/,CWE-264,,Bypass,2012-07-20,2012-07-23,5.5,None,Remote,Low,Single system,None,Partial,Partial,"Moodle 2.0.x before 2.0.9, 2.1.x before 2.1.6, and 2.2.x before 2.2.3 allows remote authenticated users to bypass an activity's read-only state and modify the database by leveraging the student role and editing database activity entries that already exist.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-31811,,,,,,,
CVE-2012-2357,https://www.cvedetails.com/cve/CVE-2012-2357/,CWE-200,,+Info,2012-07-20,2012-07-23,5.0,None,Remote,Low,Not required,Partial,None,None,"The Multi-Authentication feature in the Central Authentication Service (CAS) functionality in auth/cas/cas_form.html in Moodle 2.1.x before 2.1.6 and 2.2.x before 2.2.3 does not use HTTPS, which allows remote attackers to obtain credentials by sniffing the network.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=895e76ea51c462c18ad66e0761ad76cd26a63ecf,,,,,,,
CVE-2012-2356,https://www.cvedetails.com/cve/CVE-2012-2356/,CWE-264,,Bypass,2012-07-20,2012-07-23,4.0,None,Remote,Low,Single system,None,Partial,None,The question-bank functionality in Moodle 2.1.x before 2.1.6 and 2.2.x before 2.2.3 allows remote authenticated users to bypass intended capability requirements and save questions via a save_question action.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-32239,,,,,,,
CVE-2012-2355,https://www.cvedetails.com/cve/CVE-2012-2355/,CWE-264,,Bypass,2012-07-20,2012-07-23,4.0,None,Remote,Low,Single system,None,Partial,None,Moodle 2.1.x before 2.1.6 and 2.2.x before 2.2.3 allows remote authenticated users to bypass question:use* capability requirements and add arbitrary questions to a quiz via the questions feature.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-32240,,,,,,,
CVE-2012-2354,https://www.cvedetails.com/cve/CVE-2012-2354/,CWE-264,,Bypass,2012-07-20,2012-07-23,4.0,None,Remote,Low,Single system,Partial,None,None,"Moodle 2.1.x before 2.1.6 and 2.2.x before 2.2.3 allows remote authenticated users to bypass the moodle/site:readallmessages capability requirement and read arbitrary messages by using the ""Recent conversations"" feature with a modified parameter in a URL.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=48e03792ca8faa2d781f9ef74606f3b3f0d3baec,,,,,,,
CVE-2012-2353,https://www.cvedetails.com/cve/CVE-2012-2353/,CWE-200,,+Info,2012-07-20,2012-08-09,4.0,None,Remote,Low,Single system,Partial,None,None,"Moodle 2.1.x before 2.1.6 and 2.2.x before 2.2.3 allows remote authenticated users to obtain sensitive user information from hidden fields by leveraging the teacher role and navigating to ""Enrolled users"" under the Users Settings section.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-31923,,,,,,,
CVE-2012-2334,https://www.cvedetails.com/cve/CVE-2012-2334/,CWE-189,,DoS Exec Code Overflow,2012-06-19,2017-08-28,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",,libreoffice,https://cgit.freedesktop.org/libreoffice/core/commit/?id=512401decb286ba0fc3031939b8f7de8649c502e,,,,,,,
CVE-2012-2334,https://www.cvedetails.com/cve/CVE-2012-2334/,CWE-189,,DoS Exec Code Overflow,2012-06-19,2017-08-28,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",,libreoffice,https://cgit.freedesktop.org/libreoffice/core/commit/?id=28a6558f9d3ca2dda3191f8b5b3f2378ee2533da,,,,,,,
CVE-2018-6951,https://www.cvedetails.com/cve/CVE-2018-6951/,CWE-476,,DoS,2018-02-13,2019-04-17,5.0,None,Remote,Low,Not required,None,None,Partial,"An issue was discovered in GNU patch through 2.7.6. There is a segmentation fault, associated with a NULL pointer dereference, leading to a denial of service in the intuit_diff_type function in pch.c, aka a ""mangled rename"" issue.",,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=f290f48a621867084884bfff87f8093c15195e6a,,,,,,,
CVE-2018-6942,https://www.cvedetails.com/cve/CVE-2018-6942/,CWE-476,,,2018-02-13,2018-03-16,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in FreeType 2 through 2.9. A NULL pointer dereference in the Ins_GETVARIATION() function within ttinterp.c could lead to DoS via a crafted font file.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=29c759284e305ec428703c9a5831d0b1fc3497ef,,,,,,,
CVE-2014-5263,https://www.cvedetails.com/cve/CVE-2014-5263/,CWE-119,,DoS Overflow +Priv Mem. Corr.,2014-08-26,2014-11-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"vmstate_xhci_event in hw/usb/hcd-xhci.c in QEMU 1.6.0 does not terminate the list with the VMSTATE_END_OF_LIST macro, which allows attackers to cause a denial of service (out-of-bounds access, infinite loop, and memory corruption) and possibly gain privileges via unspecified vectors.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3afca1d6d413592c2b78cf28f52fa24a586d8f56,,,,,,,
CVE-2014-5247,https://www.cvedetails.com/cve/CVE-2014-5247/,CWE-264,,+Info,2014-08-29,2018-10-09,2.1,None,Local,Low,Not required,Partial,None,None,"The _UpgradeBeforeConfigurationChange function in lib/client/gnt_cluster.py in Ganeti 2.10.0 before 2.10.7 and 2.11.0 before 2.11.5 uses world-readable permissions for the configuration backup file, which allows local users to obtain SSL keys, remote API credentials, and other sensitive information by reading the file, related to the upgrade command.",,ganeti,http://git.ganeti.org/?p=ganeti.git;a=commit;h=a89f62e2db9ccf715d64d1a6322474b54d2d9ae0,,,,,,,
CVE-2014-5139,https://www.cvedetails.com/cve/CVE-2014-5139/,,,DoS,2014-08-13,2017-01-06,4.3,None,Remote,Medium,Not required,None,None,Partial,The ssl_set_client_disabled function in t1_lib.c in OpenSSL 1.0.1 before 1.0.1i allows remote SSL servers to cause a denial of service (NULL pointer dereference and client application crash) via a ServerHello message that includes an SRP ciphersuite without the required negotiation of that ciphersuite with the client.,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=83764a989dcc87fbea337da5f8f86806fe767b7e,,,,,,,
CVE-2014-5139,https://www.cvedetails.com/cve/CVE-2014-5139/,,,DoS,2014-08-13,2017-01-06,4.3,None,Remote,Medium,Not required,None,None,Partial,The ssl_set_client_disabled function in t1_lib.c in OpenSSL 1.0.1 before 1.0.1i allows remote SSL servers to cause a denial of service (NULL pointer dereference and client application crash) via a ServerHello message that includes an SRP ciphersuite without the required negotiation of that ciphersuite with the client.,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=80bd7b41b30af6ee96f519e629463583318de3b0,,,,,,,
CVE-2018-6791,https://www.cvedetails.com/cve/CVE-2018-6791/,CWE-78,,Exec Code,2018-02-06,2019-10-02,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"An issue was discovered in soliduiserver/deviceserviceaction.cpp in KDE Plasma Workspace before 5.12.0. When a vfat thumbdrive that contains `` or $() in its volume label is plugged in and mounted through the device notifier, it's interpreted as a shell command, leading to a possibility of arbitrary command execution. An example of an offending volume label is ""$(touch b)"" -- this will create a file called b in the home folder.",,kde,https://cgit.kde.org/plasma-workspace.git/commit/?id=9db872df82c258315c6ebad800af59e81ffb9212,,,,,,,
CVE-2018-6790,https://www.cvedetails.com/cve/CVE-2018-6790/,CWE-200,,+Info,2018-02-06,2019-08-06,5.0,None,Remote,Low,Not required,Partial,None,None,"An issue was discovered in KDE Plasma Workspace before 5.12.0. dataengines/notifications/notificationsengine.cpp allows remote attackers to discover client IP addresses via a URL in a notification, as demonstrated by the src attribute of an IMG element.",,kde,https://cgit.kde.org/plasma-workspace.git/commit/?id=8164beac15ea34ec0d1564f0557fe3e742bdd938,,,,,,,
CVE-2018-6790,https://www.cvedetails.com/cve/CVE-2018-6790/,CWE-200,,+Info,2018-02-06,2019-08-06,5.0,None,Remote,Low,Not required,Partial,None,None,"An issue was discovered in KDE Plasma Workspace before 5.12.0. dataengines/notifications/notificationsengine.cpp allows remote attackers to discover client IP addresses via a URL in a notification, as demonstrated by the src attribute of an IMG element.",,kde,https://cgit.kde.org/plasma-workspace.git/commit/?id=5bc696b5abcdb460c1017592e80b2d7f6ed3107c,,,,,,,
CVE-2012-2143,https://www.cvedetails.com/cve/CVE-2012-2143/,CWE-310,,,2012-07-05,2016-12-07,4.3,None,Remote,Medium,Not required,None,Partial,None,"The crypt_des (aka DES-based crypt) function in FreeBSD before 9.0-RELEASE-p2, as used in PHP, PostgreSQL, and other products, does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.",,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git&a=commit&h=932ded2ed51e8333852e370c7a6dad75d9f236f9,,,,,,,
CVE-2012-2143,https://www.cvedetails.com/cve/CVE-2012-2143/,CWE-310,,,2012-07-05,2016-12-07,4.3,None,Remote,Medium,Not required,None,Partial,None,"The crypt_des (aka DES-based crypt) function in FreeBSD before 9.0-RELEASE-p2, as used in PHP, PostgreSQL, and other products, does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.",,php,https://git.php.net/?p=php-src.git;a=commit;h=aab49e934de1fff046e659cbec46e3d053b41c34,,,,,,,
CVE-2016-4579,https://www.cvedetails.com/cve/CVE-2016-4579/,CWE-20,,DoS,2016-06-13,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"Libksba before 1.3.4 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via unspecified vectors, related to the ""returned length of the object from _ksba_ber_parse_tl.""",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=a7eed17a0b2a1c09ef986f3b4b323cd31cea2b64,,,,,,,
CVE-2016-4574,https://www.cvedetails.com/cve/CVE-2016-4574/,CWE-189,,DoS,2016-06-13,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,Off-by-one error in the append_utf8_value function in the DN decoder (dn.c) in Libksba before 1.3.4 allows remote attackers to cause a denial of service (out-of-bounds read) via invalid utf-8 encoded data. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-4356.,,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=6be61daac047d8e6aa941eb103f8e71a1d4e3c75,,,,,,,
CVE-2016-4544,https://www.cvedetails.com/cve/CVE-2016-4544/,CWE-119,,DoS Overflow,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The exif_process_TIFF_in_JPEG function in ext/exif/exif.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 does not validate TIFF start data, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via crafted header data.",,php,https://git.php.net/?p=php-src.git;a=commit;h=082aecfc3a753ad03be82cf14f03ac065723ec92,,,,,,,
CVE-2016-4543,https://www.cvedetails.com/cve/CVE-2016-4543/,CWE-119,,DoS Overflow,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The exif_process_IFD_in_JPEG function in ext/exif/exif.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 does not validate IFD sizes, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via crafted header data.",,php,https://git.php.net/?p=php-src.git;a=commit;h=082aecfc3a753ad03be82cf14f03ac065723ec92,,,,,,,
CVE-2016-4542,https://www.cvedetails.com/cve/CVE-2016-4542/,CWE-119,,DoS Overflow,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The exif_process_IFD_TAG function in ext/exif/exif.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 does not properly construct spprintf arguments, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via crafted header data.",,php,https://git.php.net/?p=php-src.git;a=commit;h=082aecfc3a753ad03be82cf14f03ac065723ec92,,,,,,,
CVE-2016-4541,https://www.cvedetails.com/cve/CVE-2016-4541/,,,DoS,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The grapheme_strpos function in ext/intl/grapheme/grapheme_string.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a negative offset.",,php,https://git.php.net/?p=php-src.git;a=commit;h=fd9689745c44341b1bd6af4756f324be8abba2fb,,,,,,,
CVE-2016-4540,https://www.cvedetails.com/cve/CVE-2016-4540/,,,DoS,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The grapheme_stripos function in ext/intl/grapheme/grapheme_string.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a negative offset.",,php,https://git.php.net/?p=php-src.git;a=commit;h=fd9689745c44341b1bd6af4756f324be8abba2fb,,,,,,,
CVE-2016-4539,https://www.cvedetails.com/cve/CVE-2016-4539/,CWE-119,,DoS Overflow,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The xml_parse_into_struct function in ext/xml/xml.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 allows remote attackers to cause a denial of service (buffer under-read and segmentation fault) or possibly have unspecified other impact via crafted XML data in the second argument, leading to a parser level of zero.",,php,https://git.php.net/?p=php-src.git;a=commit;h=dccda88f27a084bcbbb30198ace12b4e7ae961cc,,,,,,,
CVE-2016-4538,https://www.cvedetails.com/cve/CVE-2016-4538/,CWE-20,,DoS,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The bcpowmod function in ext/bcmath/bcmath.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 modifies certain data structures without considering whether they are copies of the _zero_, _one_, or _two_ global variable, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted call.",,php,https://git.php.net/?p=php-src.git;a=commit;h=d650063a0457aec56364e4005a636dc6c401f9cd,,,,,,,
CVE-2016-4537,https://www.cvedetails.com/cve/CVE-2016-4537/,CWE-20,,DoS,2016-05-21,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The bcpowmod function in ext/bcmath/bcmath.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 accepts a negative integer for the scale argument, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted call.",,php,https://git.php.net/?p=php-src.git;a=commit;h=d650063a0457aec56364e4005a636dc6c401f9cd,,,,,,,
CVE-2014-4883,https://www.cvedetails.com/cve/CVE-2014-4883/,CWE-345,,,2014-11-27,2015-01-08,4.3,None,Remote,Medium,Not required,None,Partial,None,"resolv.c in the DNS resolver in uIP, and dns.c in the DNS resolver in lwIP 1.4.1 and earlier, does not use random values for ID fields and source ports of DNS query packets, which makes it easier for man-in-the-middle attackers to conduct cache-poisoning attacks via spoofed reply packets.",,savannah,https://git.savannah.gnu.org/cgit/lwip.git/commit/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a,,,,,,,
CVE-2016-4356,https://www.cvedetails.com/cve/CVE-2016-4356/,CWE-119,,DoS Overflow,2016-06-13,2016-06-14,5.0,None,Remote,Low,Not required,None,None,Partial,The append_utf8_value function in the DN decoder (dn.c) in Libksba before 1.3.3 allows remote attackers to cause a denial of service (out-of-bounds read) by clearing the high bit of the byte after invalid utf-8 encoded data.,,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=243d12fdec66a4360fbb3e307a046b39b5b4ffc3,,,,,,,
CVE-2016-4355,https://www.cvedetails.com/cve/CVE-2016-4355/,CWE-119,,DoS Overflow,2016-06-13,2016-06-14,5.0,None,Remote,Low,Not required,None,None,Partial,"Multiple integer overflows in ber-decoder.c in Libksba before 1.3.3 allow remote attackers to cause a denial of service (crash) via crafted BER data, which leads to a buffer overflow.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=aea7b6032865740478ca4b706850a5217f1c3887,,,,,,,
CVE-2016-4354,https://www.cvedetails.com/cve/CVE-2016-4354/,CWE-119,,DoS Overflow,2016-06-13,2016-06-14,5.0,None,Remote,Low,Not required,None,None,Partial,"ber-decoder.c in Libksba before 1.3.3 uses an incorrect integer data type, which allows remote attackers to cause a denial of service (crash) via crafted BER data, which leads to a buffer overflow.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=aea7b6032865740478ca4b706850a5217f1c3887,,,,,,,
CVE-2016-4353,https://www.cvedetails.com/cve/CVE-2016-4353/,CWE-20,,DoS Overflow,2016-06-13,2016-06-14,5.0,None,Remote,Low,Not required,None,None,Partial,"ber-decoder.c in Libksba before 1.3.3 does not properly handle decoder stack overflows, which allows remote attackers to cause a denial of service (abort) via crafted BER data.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=07116a314f4dcd4d96990bbd74db95a03a9f650a,,,,,,,
CVE-2010-1797,https://www.cvedetails.com/cve/CVE-2010-1797/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2010-08-16,2019-09-26,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"Multiple stack-based buffer overflows in the cff_decoder_parse_charstrings function in the CFF Type2 CharStrings interpreter in cff/cffgload.c in FreeType before 2.4.2, as used in Apple iOS before 4.0.2 on the iPhone and iPod touch and before 3.2.2 on the iPad, allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via crafted CFF opcodes in embedded fonts in a PDF document, as demonstrated by JailbreakMe. NOTE: some of these details are obtained from third party information.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=11d65e8a1f1f14e56148fd991965424d9bd1cdbc,,,,,,,
CVE-2010-1797,https://www.cvedetails.com/cve/CVE-2010-1797/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2010-08-16,2019-09-26,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"Multiple stack-based buffer overflows in the cff_decoder_parse_charstrings function in the CFF Type2 CharStrings interpreter in cff/cffgload.c in FreeType before 2.4.2, as used in Apple iOS before 4.0.2 on the iPhone and iPod touch and before 3.2.2 on the iPad, allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via crafted CFF opcodes in embedded fonts in a PDF document, as demonstrated by JailbreakMe. NOTE: some of these details are obtained from third party information.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=018f5c27813dd7eef4648fe254632ecea0c85a50,,,,,,,
CVE-2014-4617,https://www.cvedetails.com/cve/CVE-2014-4617/,CWE-20,,DoS,2014-06-25,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The do_uncompress function in g10/compress.c in GnuPG 1.x before 1.4.17 and 2.x before 2.0.24 allows context-dependent attackers to cause a denial of service (infinite loop) via malformed compressed packets, as demonstrated by an a3 01 5b ff byte sequence.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=commit;h=11fdfcf82bd8d2b5bc38292a29876e10770f4b0a,,,,,,,
CVE-2014-4617,https://www.cvedetails.com/cve/CVE-2014-4617/,CWE-20,,DoS,2014-06-25,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The do_uncompress function in g10/compress.c in GnuPG 1.x before 1.4.17 and 2.x before 2.0.24 allows context-dependent attackers to cause a denial of service (infinite loop) via malformed compressed packets, as demonstrated by an a3 01 5b ff byte sequence.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=commit;h=014b2103fcb12f261135e3954f26e9e07b39e342,,,,,,,
CVE-2010-1642,https://www.cvedetails.com/cve/CVE-2010-1642/,CWE-119,,DoS Overflow,2010-06-17,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"The reply_sesssetup_and_X_spnego function in sesssetup.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to trigger an out-of-bounds read, and cause a denial of service (process crash), via a \xff\xff security blob length in a Session Setup AndX request.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=9280051bfba337458722fb157f3082f93cbd9f2b,,,,,,,
CVE-2010-1635,https://www.cvedetails.com/cve/CVE-2010-1635/,,,DoS,2010-06-17,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,The chain_reply function in process.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to cause a denial of service (NULL pointer dereference and process crash) via a Negotiate Protocol request with a certain 0x0003 field value followed by a Session Setup AndX request with a certain 0x8003 field value.,,samba,https://git.samba.org/?p=samba.git;a=commit;h=25452a2268ac7013da28125f3df22085139af12d,,,,,,,
CVE-2018-6191,https://www.cvedetails.com/cve/CVE-2018-6191/,CWE-190,,Overflow,2018-01-24,2018-02-09,4.3,None,Remote,Medium,Not required,None,None,Partial,The js_strtod function in jsdtoa.c in Artifex MuJS through 1.0.2 has an integer overflow because of incorrect exponent validation.,,ghostscript,http://git.ghostscript.com/?p=mujs.git;a=commit;h=25821e6d74fab5fcc200fe5e818362e03e114428,,,,,,,
CVE-2016-4072,https://www.cvedetails.com/cve/CVE-2016-4072/,CWE-20,,Exec Code,2016-05-20,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The Phar extension in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to execute arbitrary code via a crafted filename, as demonstrated by mishandling of \0 characters by the phar_analyze_path function in ext/phar/phar.c.",,php,https://git.php.net/?p=php-src.git;a=commit;h=1e9b175204e3286d64dfd6c9f09151c31b5e099a,,,,,,,
CVE-2016-4071,https://www.cvedetails.com/cve/CVE-2016-4071/,CWE-20,,Exec Code,2016-05-20,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Format string vulnerability in the php_snmp_error function in ext/snmp/snmp.c in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to execute arbitrary code via format string specifiers in an SNMP::get call.",,php,https://git.php.net/?p=php-src.git;a=commit;h=6e25966544fb1d2f3d7596e060ce9c9269bbdcf8,,,,,,,
CVE-2016-4070,https://www.cvedetails.com/cve/CVE-2016-4070/,CWE-189,,DoS Overflow,2016-05-20,2018-01-04,5.0,None,Remote,Low,Not required,None,None,Partial,"** DISPUTED ** Integer overflow in the php_raw_url_encode function in ext/standard/url.c in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to cause a denial of service (application crash) via a long string to the rawurlencode function. NOTE: the vendor says ""Not sure if this qualifies as security issue (probably not).""",,php,https://git.php.net/?p=php-src.git;a=commit;h=95433e8e339dbb6b5d5541473c1661db6ba2c451,,,,,,,
CVE-2016-4037,https://www.cvedetails.com/cve/CVE-2016-4037/,CWE-20,,DoS,2016-05-23,2018-12-01,4.9,None,Local,Low,Not required,None,None,Complete,"The ehci_advance_state function in hw/usb/hcd-ehci.c in QEMU allows local guest OS administrators to cause a denial of service (infinite loop and CPU consumption) via a circular split isochronous transfer descriptor (siTD) list, a related issue to CVE-2015-8558.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=1ae3f2f178087711f9591350abad133525ba93f2,,,,,,,
CVE-2016-4024,https://www.cvedetails.com/cve/CVE-2016-4024/,CWE-119,,Exec Code Overflow,2016-05-13,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in imlib2 before 1.4.9 on 32-bit platforms allows remote attackers to execute arbitrary code via large dimensions in an image, which triggers an out-of-bounds heap memory write operation.",,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?id=7eba2e4c8ac0e20838947f10f29d0efe1add8227,,,,,,,
CVE-2016-4020,https://www.cvedetails.com/cve/CVE-2016-4020/,CWE-200,,+Info,2016-05-25,2018-12-01,2.1,None,Local,Low,Not required,Partial,None,None,"The patch_instruction function in hw/i386/kvmvapic.c in QEMU does not initialize the imm32 variable, which allows local guest OS administrators to obtain sensitive information from host stack memory by accessing the Task Priority Register (TPR).",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0,,,,,,,
CVE-2016-4008,https://www.cvedetails.com/cve/CVE-2016-4008/,CWE-399,,DoS,2016-05-05,2018-10-30,4.3,None,Remote,Medium,Not required,None,None,Partial,"The _asn1_extract_der_octet function in lib/decoding.c in GNU Libtasn1 before 4.8, when used without the ASN1_DECODE_FLAG_STRICT_DER flag, allows remote attackers to cause a denial of service (infinite recursion) via a crafted certificate.",,savannah,https://git.savannah.gnu.org/gitweb/?p=libtasn1.git;a=commit;h=a6e0a0b58f5cdaf4e9beca5bce69c09808cbb625,,,,,,,
CVE-2016-4008,https://www.cvedetails.com/cve/CVE-2016-4008/,CWE-399,,DoS,2016-05-05,2018-10-30,4.3,None,Remote,Medium,Not required,None,None,Partial,"The _asn1_extract_der_octet function in lib/decoding.c in GNU Libtasn1 before 4.8, when used without the ASN1_DECODE_FLAG_STRICT_DER flag, allows remote attackers to cause a denial of service (infinite recursion) via a crafted certificate.",,savannah,https://git.savannah.gnu.org/gitweb/?p=libtasn1.git;a=commit;h=f435825c0f527a8e52e6ffbc3ad0bc60531d537e,,,,,,,
CVE-2016-4001,https://www.cvedetails.com/cve/CVE-2016-4001/,CWE-20,,DoS Overflow,2016-05-23,2018-12-01,4.3,None,Remote,Medium,Not required,None,None,Partial,"Buffer overflow in the stellaris_enet_receive function in hw/net/stellaris_enet.c in QEMU, when the Stellaris ethernet controller is configured to accept large packets, allows remote attackers to cause a denial of service (QEMU crash) via a large packet.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=3a15cc0e1ee7168db0782133d2607a6bfa422d66,,,,,,,
CVE-2016-3994,https://www.cvedetails.com/cve/CVE-2016-3994/,CWE-119,,DoS Overflow +Info,2016-05-13,2016-11-30,6.4,None,Remote,Low,Not required,Partial,None,Partial,"The GIF loader in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (application crash) or obtain sensitive information via a crafted image, which triggers an out-of-bounds read.",,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?id=37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8,,,,,,,
CVE-2016-3993,https://www.cvedetails.com/cve/CVE-2016-3993/,CWE-119,,DoS Overflow,2016-05-13,2016-11-30,5.0,None,Remote,Low,Not required,None,None,Partial,Off-by-one error in the __imlib_MergeUpdate function in lib/updates.c in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via crafted coordinates.,,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?id=ce94edca1ccfbe314cb7cd9453433fad404ec7ef,,,,,,,
CVE-2012-1573,https://www.cvedetails.com/cve/CVE-2012-1573/,CWE-310,,DoS Mem. Corr.,2012-03-26,2018-01-17,5.0,None,Remote,Low,Not required,None,None,Partial,"gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.",,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=b495740f2ff66550ca9395b3fda3ea32c3acb185,,,,,,,
CVE-2012-1573,https://www.cvedetails.com/cve/CVE-2012-1573/,CWE-310,,DoS Mem. Corr.,2012-03-26,2018-01-17,5.0,None,Remote,Low,Not required,None,None,Partial,"gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.",,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=422214868061370aeeb0ac9cd0f021a5c350a57d,,,,,,,
CVE-2018-6003,https://www.cvedetails.com/cve/CVE-2018-6003/,CWE-674,,,2018-01-22,2019-10-02,5.0,None,Remote,Low,Not required,None,None,Partial,An issue was discovered in the _asn1_decode_simple_ber function in decoding.c in GNU Libtasn1 before 4.13. Unlimited recursion in the BER decoder leads to stack exhaustion and DoS.,,savannah,http://git.savannah.nongnu.org/cgit/libtasn1.git/commit/?id=c593ae84cfcde8fea45787e53950e0ac71e9ca97,,,,,,,
CVE-2014-3981,https://www.cvedetails.com/cve/CVE-2014-3981/,CWE-59,,,2014-06-08,2017-01-06,3.3,None,Local,Medium,Not required,None,Partial,Partial,"acinclude.m4, as used in the configure script in PHP 5.5.13 and earlier, allows local users to overwrite arbitrary files via a symlink attack on the /tmp/phpglibccheck file.",,php,https://git.php.net/?p=php-src.git;a=commit;h=91bcadd85e20e50d3f8c2e9721327681640e6f16,,,,,,,
CVE-2010-1172,https://www.cvedetails.com/cve/CVE-2010-1172/,CWE-264,,DoS Bypass,2010-08-20,2017-08-16,3.6,None,Local,Low,Not required,None,Partial,Partial,"DBus-GLib 0.73 disregards the access flag of exported GObject properties, which allows local users to bypass intended access restrictions and possibly cause a denial of service by modifying properties, as demonstrated by properties of the (1) DeviceKit-Power, (2) NetworkManager, and (3) ModemManager services.",,dbus,https://cgit.freedesktop.org/dbus/dbus-glib/commit/?h=rhel5&id=9a6bce9b615abca6068348c1606ba8eaf13d9ae0,,,,,,,
CVE-2010-1166,https://www.cvedetails.com/cve/CVE-2010-1166/,CWE-189,,DoS Exec Code Mem. Corr.,2010-04-29,2017-09-18,7.1,None,Remote,High,Single system,Complete,Complete,Complete,"The fbComposite function in fbpict.c in the Render extension in the X server in X.Org X11R7.1 allows remote authenticated users to cause a denial of service (memory corruption and daemon crash) or possibly execute arbitrary code via a crafted request, related to an incorrect macro definition.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=d2f813f7db,,,,,,,
CVE-2012-1175,https://www.cvedetails.com/cve/CVE-2012-1175/,CWE-189,,DoS Exec Code Overflow,2012-08-26,2012-08-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer overflow in the GnashImage::size method in libbase/GnashImage.h in GNU Gnash 0.8.10 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted SWF file, which triggers a heap-based buffer overflow.",,savannah,https://git.savannah.gnu.org/cgit/gnash.git/commit/?id=bb4dc77eecb6ed1b967e3ecbce3dac6c5e6f1527,,,,,,,
CVE-2012-1174,https://www.cvedetails.com/cve/CVE-2012-1174/,CWE-362,,,2012-07-12,2012-08-13,3.3,None,Local,Medium,Not required,None,Partial,Partial,"The rm_rf_children function in util.c in the systemd-logind login manager in systemd before 44, when logging out, allows local users to delete arbitrary files via a symlink attack on unspecified files, related to ""particular records related with user session.""",,systemd,https://cgit.freedesktop.org/systemd/systemd/commit/?id=5ebff5337594d690b322078c512eb222d34aaa82,,,,,,,
CVE-2010-1149,https://www.cvedetails.com/cve/CVE-2010-1149/,CWE-200,,+Info,2010-04-12,2010-04-13,2.1,None,Local,Low,Not required,Partial,None,None,"probers/udisks-dm-export.c in udisks before 1.0.1 exports UDISKS_DM_TARGETS_PARAMS information to udev even for a crypt UDISKS_DM_TARGETS_TYPE, which allows local users to discover encryption keys by (1) running a certain udevadm command or (2) reading a certain file under /dev/.udev/db/.",,udisks,https://cgit.freedesktop.org/udisks/commit/?id=0fcc7cb3b66f23fac53ae08647aa0007a2bd56c4,,,,,,,
CVE-2018-5764,https://www.cvedetails.com/cve/CVE-2018-5764/,,,Bypass,2018-01-17,2019-10-02,5.0,None,Remote,Low,Not required,None,Partial,None,"The parse_arguments function in options.c in rsyncd in rsync before 3.1.3 does not prevent multiple --protect-args uses, which allows remote attackers to bypass an argument-sanitization protection mechanism.",,samba,https://git.samba.org/rsync.git/?p=rsync.git;a=commit;h=7706303828fcde524222babb2833864a4bd09e07,,,,,,,
CVE-2018-5759,https://www.cvedetails.com/cve/CVE-2018-5759/,CWE-674,,DoS,2018-01-24,2019-10-02,4.3,None,Remote,Medium,Not required,None,None,Partial,"jsparse.c in Artifex MuJS through 1.0.2 does not properly maintain the AST depth for binary expressions, which allows remote attackers to cause a denial of service (excessive recursion) via a crafted file.",,ghostscript,http://git.ghostscript.com/?p=mujs.git;a=commit;h=4d45a96e57fbabf00a7378b337d0ddcace6f38c1,,,,,,,
CVE-2019-1563,https://www.cvedetails.com/cve/CVE-2019-1563/,CWE-311,,,2019-09-10,2019-09-12,4.3,None,Remote,Medium,Not required,Partial,None,None,"In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=08229ad838c50f644d7e928e2eef147b4308ad64,,,,,,,
CVE-2019-1563,https://www.cvedetails.com/cve/CVE-2019-1563/,CWE-311,,,2019-09-10,2019-09-12,4.3,None,Remote,Medium,Not required,Partial,None,None,"In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=e21f8cf78a125cd3c8c0d1a1a6c8bb0b901f893f,,,,,,,
CVE-2019-1563,https://www.cvedetails.com/cve/CVE-2019-1563/,CWE-311,,,2019-09-10,2019-09-12,4.3,None,Remote,Medium,Not required,Partial,None,None,"In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=631f94db0065c78181ca9ba5546ebc8bb3884b97,,,,,,,
CVE-2019-1559,https://www.cvedetails.com/cve/CVE-2019-1559/,CWE-200,,+Info,2019-02-27,2019-05-21,4.3,None,Remote,Medium,Not required,Partial,None,None,"If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable ""non-stitched"" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=e9bbefbf0f24c57645e7ad6a5a71ae649d18ac8e,,,,,,,
CVE-2019-1552,https://www.cvedetails.com/cve/CVE-2019-1552/,CWE-295,,,2019-07-30,2019-08-23,1.9,None,Local,Medium,Not required,None,Partial,None,"OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=e32bc855a81a2d48d215c506bdeb4f598045f7e9,,,,,,,
CVE-2019-1552,https://www.cvedetails.com/cve/CVE-2019-1552/,CWE-295,,,2019-07-30,2019-08-23,1.9,None,Local,Medium,Not required,None,Partial,None,"OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=b15a19c148384e73338aa7c5b12652138e35ed28,,,,,,,
CVE-2019-1552,https://www.cvedetails.com/cve/CVE-2019-1552/,CWE-295,,,2019-07-30,2019-08-23,1.9,None,Local,Medium,Not required,None,Partial,None,"OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=d333ebaf9c77332754a9d5e111e2f53e1de54fdd,,,,,,,
CVE-2019-1552,https://www.cvedetails.com/cve/CVE-2019-1552/,CWE-295,,,2019-07-30,2019-08-23,1.9,None,Local,Medium,Not required,None,Partial,None,"OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=54aa9d51b09d67e90db443f682cface795f5af9e,,,,,,,
CVE-2019-1549,https://www.cvedetails.com/cve/CVE-2019-1549/,CWE-330,,,2019-09-10,2019-09-19,5.0,None,Remote,Low,Not required,Partial,None,None,OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be,,,,,,,
CVE-2019-1547,https://www.cvedetails.com/cve/CVE-2019-1547/,CWE-311,,,2019-09-10,2019-09-12,1.9,None,Local,Medium,Not required,Partial,None,None,"Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=21c856b75d81eff61aa63b4f036bb64a85bf6d46,,,,,,,
CVE-2019-1547,https://www.cvedetails.com/cve/CVE-2019-1547/,CWE-311,,,2019-09-10,2019-09-12,1.9,None,Local,Medium,Not required,Partial,None,None,"Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=7c1709c2da5414f5b6133d00a03fc8c5bf996c7a,,,,,,,
CVE-2019-1547,https://www.cvedetails.com/cve/CVE-2019-1547/,CWE-311,,,2019-09-10,2019-09-12,1.9,None,Local,Medium,Not required,Partial,None,None,"Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=7c1709c2da5414f5b6133d00a03fc8c5bf996c7a,,,,,,,
CVE-2019-1543,https://www.cvedetails.com/cve/CVE-2019-1543/,CWE-310,,,2019-03-06,2019-06-03,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=f426625b6ae9a7831010750490a5f0ad689c5ba3,,,,,,,
CVE-2019-1543,https://www.cvedetails.com/cve/CVE-2019-1543/,CWE-310,,,2019-03-06,2019-06-03,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ee22257b1418438ebaf54df98af4e24f494d1809,,,,,,,
CVE-2008-1950,https://www.cvedetails.com/cve/CVE-2008-1950/,CWE-189,,DoS,2008-05-21,2018-10-11,5.0,None,Remote,Low,Not required,None,None,Partial,"Integer signedness error in the _gnutls_ciphertext2compressed function in lib/gnutls_cipher.c in libgnutls in GnuTLS before 2.2.4 allows remote attackers to cause a denial of service (buffer over-read and crash) via a certain integer value in the Random field in an encrypted Client Hello message within a TLS record with an invalid Record Length, which leads to an invalid cipher padding length, aka GNUTLS-SA-2008-1-3.",,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b,,,,,,,
CVE-2012-0947,https://www.cvedetails.com/cve/CVE-2012-0947/,CWE-119,,DoS Exec Code Overflow,2012-08-20,2012-11-26,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Heap-based buffer overflow in the vqa_decode_chunk function in the VQA codec (vqavideo.c) in libavcodec in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.6, and 0.8.x before 0.8.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted VQA media file in which the image size is not a multiple of the block size.",,libav,https://git.libav.org/?p=libav.git;a=commit;h=58b2e0f0f2fc96c1158e04f8aba95cbe6157a1a3,,,,,,,
CVE-2008-1949,https://www.cvedetails.com/cve/CVE-2008-1949/,CWE-287,,DoS,2008-05-21,2018-10-11,9.3,Admin,Remote,Medium,Not required,Complete,Complete,Complete,"The _gnutls_recv_client_kx_message function in lib/gnutls_kx.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 continues to process Client Hello messages within a TLS message after one has already been processed, which allows remote attackers to cause a denial of service (NULL dereference and crash) via a TLS message containing multiple Client Hello messages, aka GNUTLS-SA-2008-1-2.",,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b,,,,,,,
CVE-2014-3670,https://www.cvedetails.com/cve/CVE-2014-3670/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2014-10-29,2016-10-17,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The exif_ifd_make_value function in exif.c in the EXIF extension in PHP before 5.4.34, 5.5.x before 5.5.18, and 5.6.x before 5.6.2 operates on floating-point arrays incorrectly, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) or possibly execute arbitrary code via a crafted JPEG image with TIFF thumbnail data that is improperly handled by the exif_thumbnail function.",,php,https://git.php.net/?p=php-src.git;a=commit;h=ddb207e7fa2e9adeba021a1303c3781efda5409b,,,,,,,
CVE-2008-1948,https://www.cvedetails.com/cve/CVE-2008-1948/,CWE-189,,DoS Exec Code Overflow,2008-05-21,2018-10-11,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",,savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b,,,,,,,
CVE-2014-3669,https://www.cvedetails.com/cve/CVE-2014-3669/,CWE-189,,DoS Exec Code Overflow,2014-10-29,2017-01-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in the object_custom function in ext/standard/var_unserializer.c in PHP before 5.4.34, 5.5.x before 5.5.18, and 5.6.x before 5.6.2 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via an argument to the unserialize function that triggers calculation of a large length value.",,php,https://git.php.net/?p=php-src.git;a=commit;h=56754a7f9eba0e4f559b6ca081d9f2a447b3f159,,,,,,,
CVE-2014-3668,https://www.cvedetails.com/cve/CVE-2014-3668/,CWE-119,,DoS Overflow,2014-10-29,2016-10-17,5.0,None,Remote,Low,Not required,None,None,Partial,"Buffer overflow in the date_from_ISO8601 function in the mkgmtime implementation in libxmlrpc/xmlrpc.c in the XMLRPC extension in PHP before 5.4.34, 5.5.x before 5.5.18, and 5.6.x before 5.6.2 allows remote attackers to cause a denial of service (application crash) via (1) a crafted first argument to the xmlrpc_set_type function or (2) a crafted argument to the xmlrpc_decode function, related to an out-of-bounds read operation.",,php,https://git.php.net/?p=php-src.git;a=commit;h=88412772d295ebf7dd34409534507dc9bcac726e,,,,,,,
CVE-2014-3617,https://www.cvedetails.com/cve/CVE-2014-3617/,CWE-264,,Bypass,2014-09-15,2014-09-15,4.0,None,Remote,Low,Single system,Partial,None,None,"The forum_print_latest_discussions function in mod/forum/lib.php in Moodle through 2.4.11, 2.5.x before 2.5.8, 2.6.x before 2.6.5, and 2.7.x before 2.7.2 allows remote authenticated users to bypass the individual answer-posting requirement without the mod/forum:viewqandawithoutposting capability, and discover an author's username, by leveraging the student role and visiting a Q&A forum.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-46619,,,,,,,
CVE-2014-3615,https://www.cvedetails.com/cve/CVE-2014-3615/,CWE-200,,+Info,2014-11-01,2017-11-03,2.1,None,Local,Low,Not required,Partial,None,None,The VGA emulator in QEMU allows local guest users to read host memory by setting the display to a high resolution.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7,,,,,,,
CVE-2014-3615,https://www.cvedetails.com/cve/CVE-2014-3615/,CWE-200,,+Info,2014-11-01,2017-11-03,2.1,None,Local,Low,Not required,Partial,None,None,The VGA emulator in QEMU allows local guest users to read host memory by setting the display to a high resolution.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=c1b886c45dc70f247300f549dce9833f3fa2def5,,,,,,,
CVE-2018-5388,https://www.cvedetails.com/cve/CVE-2018-5388/,CWE-787,,DoS,2018-05-31,2019-10-09,4.0,None,Remote,Low,Single system,None,None,Partial,"In stroke_socket.c in strongSwan before 5.6.3, a missing packet length check could allow a buffer underflow, which may lead to resource exhaustion and denial of service while reading from the socket.",C,strongswan,https://git.strongswan.org/?p=strongswan.git;a=commitdiff;h=0acd1ab4,0acd1ab4d08d53d80393b1a37b8781f6e7b2b996,04ede658c85211e537a2ce379b8f09f33f3d6438,"@@ -627,6 +627,11 @@ static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
                }
                return FALSE;
        }
+       if (len < offsetof(stroke_msg_t, buffer))
+       {
+               DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
+               return FALSE;
+       }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);",https://git.strongswan.org/?p=strongswan.git;a=blob;f=src/libcharon/plugins/stroke/stroke_socket.c;h=c568440b7ae275fac2f832eddfa0563a98d9ee99,https://git.strongswan.org/?p=strongswan.git;a=blob;f=src/libcharon/plugins/stroke/stroke_socket.c;h=1e7f210e940abec158391fe266a03088b5603ea4;hb=0acd1ab4,,
CVE-2014-3569,https://www.cvedetails.com/cve/CVE-2014-3569/,,,DoS,2014-12-24,2017-11-14,5.0,None,Remote,Low,Not required,None,None,Partial,"The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 0.9.8zc, 1.0.0o, and 1.0.1j does not properly handle attempts to use unsupported protocols, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an unexpected handshake, as demonstrated by an SSLv3 handshake to a no-ssl3 application with certain error handling.  NOTE: this issue became relevant after the CVE-2014-3568 fix.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=392fa7a952e97d82eac6958c81ed1e256e6b8ca5,,,,,,,
CVE-2014-3569,https://www.cvedetails.com/cve/CVE-2014-3569/,,,DoS,2014-12-24,2017-11-14,5.0,None,Remote,Low,Not required,None,None,Partial,"The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 0.9.8zc, 1.0.0o, and 1.0.1j does not properly handle attempts to use unsupported protocols, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an unexpected handshake, as demonstrated by an SSLv3 handshake to a no-ssl3 application with certain error handling.  NOTE: this issue became relevant after the CVE-2014-3568 fix.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=6ce9687b5aba5391fc0de50e18779eb676d0e04d,,,,,,,
CVE-2014-3569,https://www.cvedetails.com/cve/CVE-2014-3569/,,,DoS,2014-12-24,2017-11-14,5.0,None,Remote,Low,Not required,None,None,Partial,"The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 0.9.8zc, 1.0.0o, and 1.0.1j does not properly handle attempts to use unsupported protocols, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an unexpected handshake, as demonstrated by an SSLv3 handshake to a no-ssl3 application with certain error handling.  NOTE: this issue became relevant after the CVE-2014-3568 fix.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=b82924741b4bd590da890619be671f4635e46c2b,,,,,,,
CVE-2014-3568,https://www.cvedetails.com/cve/CVE-2014-3568/,CWE-310,,Bypass,2014-10-18,2017-11-14,4.3,None,Remote,Medium,Not required,None,Partial,None,"OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7,,,,,,,
CVE-2014-3567,https://www.cvedetails.com/cve/CVE-2014-3567/,CWE-20,,DoS,2014-10-18,2017-11-14,7.1,None,Remote,Medium,Not required,None,None,Complete,"Memory leak in the tls_decrypt_ticket function in t1_lib.c in OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j allows remote attackers to cause a denial of service (memory consumption) via a crafted session ticket that triggers an integrity-check failure.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=7fd4ce6a997be5f5c9e744ac527725c2850de203,,,,,,,
CVE-2016-3185,https://www.cvedetails.com/cve/CVE-2016-3185/,CWE-20,,DoS +Info,2016-05-16,2016-11-30,6.4,None,Remote,Low,Not required,Partial,None,Partial,"The make_http_soap_request function in ext/soap/php_http.c in PHP before 5.4.44, 5.5.x before 5.5.28, 5.6.x before 5.6.12, and 7.x before 7.0.4 allows remote attackers to obtain sensitive information from process memory or cause a denial of service (type confusion and application crash) via crafted serialized _cookies data, related to the SoapClient::__call method in ext/soap/soap.c.",,php,https://git.php.net/?p=php-src.git;a=commit;h=eaf4e77190d402ea014207e9a7d5da1a4f3727ba,,,,,,,
CVE-2014-3564,https://www.cvedetails.com/cve/CVE-2014-3564/,CWE-119,,DoS Exec Code Overflow,2014-10-20,2016-10-17,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to ""different line lengths in a specific order.""",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77,,,,,,,
CVE-2014-3560,https://www.cvedetails.com/cve/CVE-2014-3560/,CWE-94,,Exec Code,2014-08-06,2019-04-22,7.9,None,Local Network,Medium,Not required,Complete,Complete,Complete,"NetBIOS name services daemon (nmbd) in Samba 4.0.x before 4.0.21 and 4.1.x before 4.1.11 allows remote attackers to execute arbitrary code via unspecified vectors that modify heap memory, involving a sizeof operation on an incorrect variable in the unstrcpy macro in string_wrappers.h.",,samba,https://git.samba.org/?p=samba.git;a=commitdiff;h=fb1d325d96dfe9bc2e9c4ec46ad4c55e8f18f4a2,,,,,,,
CVE-2014-3560,https://www.cvedetails.com/cve/CVE-2014-3560/,CWE-94,,Exec Code,2014-08-06,2019-04-22,7.9,None,Local Network,Medium,Not required,Complete,Complete,Complete,"NetBIOS name services daemon (nmbd) in Samba 4.0.x before 4.0.21 and 4.1.x before 4.1.11 allows remote attackers to execute arbitrary code via unspecified vectors that modify heap memory, involving a sizeof operation on an incorrect variable in the unstrcpy macro in string_wrappers.h.",,samba,https://git.samba.org/?p=samba.git;a=commitdiff;h=e6a848630da3ba958c442438ea131c99fa088605,,,,,,,
CVE-2014-3553,https://www.cvedetails.com/cve/CVE-2014-3553/,CWE-264,,Bypass,2014-07-29,2014-07-29,4.9,None,Remote,Medium,Single system,Partial,Partial,None,"mod/forum/classes/post_form.php in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 does not enforce the moodle/site:accessallgroups capability requirement before proceeding with a post to all groups, which allows remote authenticated users to bypass intended access restrictions by leveraging two or more group memberships.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-38990,,,,,,,
CVE-2014-3552,https://www.cvedetails.com/cve/CVE-2014-3552/,CWE-287,,,2014-07-29,2014-07-29,6.0,None,Remote,Medium,Single system,Partial,Partial,Partial,"The Shibboleth authentication plugin in auth/shibboleth/index.php in Moodle through 2.3.11, 2.4.x before 2.4.11, and 2.5.x before 2.5.7 does not check whether a session ID is empty, which allows remote authenticated users to hijack sessions via crafted plugin interaction.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=refs%2Fheads%2FMOODLE_25_STABLE&st=commit&s=MDL-45485,,,,,,,
CVE-2014-3551,https://www.cvedetails.com/cve/CVE-2014-3551/,CWE-79,,XSS,2014-07-29,2015-10-08,3.5,None,Remote,Medium,Single system,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in the advanced-grading implementation in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allow remote authenticated users to inject arbitrary web script or HTML via a crafted (1) qualification or (2) rating field in a rubric.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-46223,,,,,,,
CVE-2014-3550,https://www.cvedetails.com/cve/CVE-2014-3550/,CWE-79,,XSS,2014-07-29,2015-10-08,4.3,None,Remote,Medium,Not required,None,Partial,None,Multiple cross-site scripting (XSS) vulnerabilities in admin/tool/task/scheduledtasks.php in Moodle 2.7.x before 2.7.1 allow remote attackers to inject arbitrary web script or HTML via vectors that trigger a crafted (1) error or (2) success message for a scheduled task.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-46227,,,,,,,
CVE-2014-3549,https://www.cvedetails.com/cve/CVE-2014-3549/,CWE-79,,XSS,2014-07-29,2015-08-31,4.3,None,Remote,Medium,Not required,None,Partial,None,Cross-site scripting (XSS) vulnerability in the get_description function in lib/classes/event/user_login_failed.php in Moodle 2.7.x before 2.7.1 allows remote attackers to inject arbitrary web script or HTML via a crafted username that is improperly handled during the logging of an invalid login attempt.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-46201,,,,,,,
CVE-2012-0801,https://www.cvedetails.com/cve/CVE-2012-0801/,CWE-20,,,2012-07-17,2012-07-17,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"lib/formslib.php in Moodle 2.1.x before 2.1.4 and 2.2.x before 2.2.1 does not properly handle multiple instances of a form element, which has unspecified impact and remote attack vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=51070abc78b9e1db1db9a44855e8623b22bebd48,,,,,,,
CVE-2012-0800,https://www.cvedetails.com/cve/CVE-2012-0800/,CWE-200,,+Info,2012-07-17,2012-07-17,2.1,None,Local,Low,Not required,Partial,None,None,"The form-autocompletion functionality in Moodle 2.0.x before 2.0.7, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 makes it easier for physically proximate attackers to discover passwords by reading the contents of a non-password field, as demonstrated by accessing a create-groups page with Safari on an iPad device.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=6e9989dbd3f261b2e1586ff77b0bf22fc7091485,,,,,,,
CVE-2014-3548,https://www.cvedetails.com/cve/CVE-2014-3548/,CWE-79,,XSS,2014-07-29,2015-08-31,4.3,None,Remote,Medium,Not required,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allow remote attackers to inject arbitrary web script or HTML via vectors that trigger an AJAX exception dialog.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45471,,,,,,,
CVE-2016-3142,https://www.cvedetails.com/cve/CVE-2016-3142/,CWE-119,,DoS Overflow +Info,2016-03-31,2018-01-04,6.4,None,Remote,Low,Not required,Partial,None,Partial,The phar_parse_zipfile function in zip.c in the PHAR extension in PHP before 5.5.33 and 5.6.x before 5.6.19 allows remote attackers to obtain sensitive information from process memory or cause a denial of service (out-of-bounds read and application crash) by placing a PK\x05\x06 signature at an invalid location.,,php,https://git.php.net/?p=php-src.git;a=commit;h=a6fdc5bb27b20d889de0cd29318b3968aabb57bd,,,,,,,
CVE-2012-0799,https://www.cvedetails.com/cve/CVE-2012-0799/,CWE-200,,+Info,2012-07-17,2012-07-17,4.3,None,Remote,Medium,Not required,Partial,None,None,"Moodle 2.0.x before 2.0.7 and 2.1.x before 2.1.4, when an anonymous front-page forum is enabled, allows remote attackers to obtain session keys for their sessions by visiting the front page.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-27334,,,,,,,
CVE-2016-3141,https://www.cvedetails.com/cve/CVE-2016-3141/,CWE-119,,DoS Overflow Mem. Corr.,2016-03-31,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Use-after-free vulnerability in wddx.c in the WDDX extension in PHP before 5.5.33 and 5.6.x before 5.6.19 allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact by triggering a wddx_deserialize call on XML data containing a crafted var element.,,php,https://git.php.net/?p=php-src.git;a=commit;h=b1bd4119bcafab6f9a8f84d92cd65eec3afeface,,,,,,,
CVE-2014-3547,https://www.cvedetails.com/cve/CVE-2014-3547/,CWE-79,,XSS,2014-07-29,2015-08-31,4.3,None,Remote,Medium,Not required,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in badges/renderer.php in Moodle 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allow remote attackers to inject arbitrary web script or HTML via an external badge.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-46042,,,,,,,
CVE-2012-0798,https://www.cvedetails.com/cve/CVE-2012-0798/,CWE-264,,,2012-07-17,2012-07-17,5.5,None,Remote,Low,Single system,Partial,Partial,None,The self-enrolment functionality in Moodle 2.1.x before 2.1.4 and 2.2.x before 2.2.1 allows remote authenticated users to obtain the manager role by leveraging the teacher role.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-29469,,,,,,,
CVE-2014-3546,https://www.cvedetails.com/cve/CVE-2014-3546/,CWE-264,,+Info,2014-07-29,2014-07-29,5.0,None,Remote,Low,Not required,Partial,None,None,"Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 does not enforce certain capability requirements in (1) notes/index.php and (2) user/edit.php, which allows remote attackers to obtain potentially sensitive username and course information via a modified URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45760,,,,,,,
CVE-2012-0797,https://www.cvedetails.com/cve/CVE-2012-0797/,CWE-16,,Bypass,2012-07-17,2012-09-14,5.5,None,Remote,Low,Single system,Partial,Partial,None,"The webservices functionality in Moodle 2.0.x before 2.0.7, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 allows remote authenticated users to bypass the deleted status and continue using a server via a token.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-28126,,,,,,,
CVE-2014-3545,https://www.cvedetails.com/cve/CVE-2014-3545/,CWE-94,,Exec Code,2014-07-29,2014-07-29,6.0,None,Remote,Medium,Single system,Partial,Partial,Partial,"Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allows remote authenticated users to execute arbitrary code via a calculated question in a quiz.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-46148,,,,,,,
CVE-2012-0796,https://www.cvedetails.com/cve/CVE-2012-0796/,CWE-94,,,2012-07-17,2017-12-21,4.0,None,Remote,Low,Single system,None,Partial,None,"class.phpmailer.php in the PHPMailer library, as used in Moodle 1.9.x before 1.9.16, 2.0.x before 2.0.7, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 and other products, allows remote authenticated users to inject arbitrary e-mail headers via vectors involving a crafted (1) From: or (2) Sender: header.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=62988bf0bbc73df655f51884aaf1f523928abff9,,,,,,,
CVE-2014-3543,https://www.cvedetails.com/cve/CVE-2014-3543/,CWE-200,,+Info,2014-07-29,2014-07-29,4.3,None,Remote,Medium,Not required,Partial,None,None,"mod/imscp/locallib.php in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allows remote attackers to read arbitrary files via a package with a manifest file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue affecting IMSCP resources and the IMSCC format.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45417,,,,,,,
CVE-2012-0795,https://www.cvedetails.com/cve/CVE-2012-0795/,CWE-20,,,2012-07-17,2017-12-21,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"Moodle 1.9.x before 1.9.16, 2.0.x before 2.0.7, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 does not validate e-mail address settings, which allows remote authenticated users to have an unspecified impact via a crafted address.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-13572,,,,,,,
CVE-2012-0794,https://www.cvedetails.com/cve/CVE-2012-0794/,CWE-255,,,2012-07-17,2017-12-21,5.0,None,Remote,Low,Not required,Partial,None,None,"The rc4encrypt function in lib/moodlelib.php in Moodle 1.9.x before 1.9.16, 2.0.x before 2.0.7, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 uses a hardcoded password of nfgjeingjk, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by reading this script's source code within the open-source software distribution.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=98456628a24bba25d336860d38a45b5a4e3895da,,,,,,,
CVE-2014-3542,https://www.cvedetails.com/cve/CVE-2014-3542/,CWE-200,,+Info,2014-07-29,2014-07-29,4.3,None,Remote,Medium,Not required,Partial,None,None,"mod/lti/service.php in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allows remote attackers to read arbitrary files via an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45463,,,,,,,
CVE-2012-0793,https://www.cvedetails.com/cve/CVE-2012-0793/,CWE-264,,,2012-07-17,2017-12-21,5.0,None,Remote,Low,Not required,Partial,None,None,"Moodle 1.9.x before 1.9.16, 2.0.x before 2.0.7, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 allows remote attackers to view the profile images of arbitrary user accounts via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=90911c4ff98dc2078a3acef5ddf5a1a8f7e20ba5,,,,,,,
CVE-2012-0792,https://www.cvedetails.com/cve/CVE-2012-0792/,CWE-200,,+Info,2012-07-17,2017-12-21,4.0,None,Remote,Low,Single system,Partial,None,None,mod/forum/user.php in Moodle 1.9.x before 1.9.16 allows remote authenticated users to obtain the names and other details of arbitrary user accounts by searching for posts.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=36b0ddeed45d0751508dcd9fa50f17fda43bae54,,,,,,,
CVE-2014-3541,https://www.cvedetails.com/cve/CVE-2014-3541/,CWE-94,,Exec Code,2014-07-29,2014-07-29,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The Repositories component in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allows remote attackers to conduct PHP object injection attacks and execute arbitrary code via serialized data associated with an add-on.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45616,,,,,,,
CVE-2014-3515,https://www.cvedetails.com/cve/CVE-2014-3515/,,,Exec Code,2014-07-09,2017-01-06,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The SPL component in PHP before 5.4.30 and 5.5.x before 5.5.14 incorrectly anticipates that certain data structures will have the array data type after unserialization, which allows remote attackers to execute arbitrary code via a crafted string that triggers use of a Hashtable destructor, related to ""type confusion"" issues in (1) ArrayObject and (2) SPLObjectStorage.",,php,https://git.php.net/?p=php-src.git;a=commit;h=88223c5245e9b470e1e6362bfd96829562ffe6ab,,,,,,,
CVE-2010-0787,https://www.cvedetails.com/cve/CVE-2010-0787/,CWE-59,,+Priv,2010-03-02,2017-08-16,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"client/mount.cifs.c in mount.cifs in smbfs in Samba 3.0.22, 3.0.28a, 3.2.3, 3.3.2, 3.4.0, and 3.4.5 allows local users to mount a CIFS share on an arbitrary mountpoint, and gain privileges, via a symlink attack on the mountpoint directory file.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=a0c31ec1c8d1220a5884e40d9ba6b191a04a24d5,,,,,,,
CVE-2010-0787,https://www.cvedetails.com/cve/CVE-2010-0787/,CWE-59,,+Priv,2010-03-02,2017-08-16,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"client/mount.cifs.c in mount.cifs in smbfs in Samba 3.0.22, 3.0.28a, 3.2.3, 3.3.2, 3.4.0, and 3.4.5 allows local users to mount a CIFS share on an arbitrary mountpoint, and gain privileges, via a symlink attack on the mountpoint directory file.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,,,,,,,
CVE-2014-3513,https://www.cvedetails.com/cve/CVE-2014-3513/,CWE-20,,DoS,2014-10-18,2017-01-02,7.1,None,Remote,Medium,Not required,None,None,Complete,Memory leak in d1_srtp.c in the DTLS SRTP extension in OpenSSL 1.0.1 before 1.0.1j allows remote attackers to cause a denial of service (memory consumption) via a crafted handshake message.,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2b0532f3984324ebe1236a63d15893792384328d,,,,,,,
CVE-2014-3512,https://www.cvedetails.com/cve/CVE-2014-3512/,CWE-119,,DoS Overflow,2014-08-13,2017-08-28,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple buffer overflows in crypto/srp/srp_lib.c in the SRP implementation in OpenSSL 1.0.1 before 1.0.1i allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an invalid SRP (1) g, (2) A, or (3) B parameter.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=4a23b12a031860253b58d503f296377ca076427b,,,,,,,
CVE-2014-3511,https://www.cvedetails.com/cve/CVE-2014-3511/,,,,2014-08-13,2017-11-14,4.3,None,Remote,Medium,Not required,None,Partial,None,"The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 1.0.1 before 1.0.1i allows man-in-the-middle attackers to force the use of TLS 1.0 by triggering ClientHello message fragmentation in communication between a client and server that both support later TLS versions, related to a ""protocol downgrade"" issue.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=280b1f1ad12131defcd986676a8fc9717aaa601b,,,,,,,
CVE-2016-3065,https://www.cvedetails.com/cve/CVE-2016-3065/,CWE-264,,DoS Bypass +Info,2016-04-11,2016-04-14,8.5,None,Remote,Low,Not required,Partial,None,Complete,The (1) brin_page_type and (2) brin_metapage_info functions in the pageinspect extension in PostgreSQL before 9.5.x before 9.5.2 allows attackers to bypass intended access restrictions and consequently obtain sensitive server memory information or cause a denial of service (server crash) via a crafted bytea value in a BRIN index page.,,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=bf78a6f107949fdfb513d1b45e30cefe04e09e4f,,,,,,,
CVE-2014-3510,https://www.cvedetails.com/cve/CVE-2014-3510/,,,DoS,2014-08-13,2017-08-28,4.3,None,Remote,Medium,Not required,None,None,Partial,"The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote DTLS servers to cause a denial of service (NULL pointer dereference and client application crash) via a crafted handshake message in conjunction with a (1) anonymous DH or (2) anonymous ECDH ciphersuite.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=17160033765480453be0a41335fa6b833691c049,,,,,,,
CVE-2014-3509,https://www.cvedetails.com/cve/CVE-2014-3509/,CWE-362,,DoS,2014-08-13,2017-11-14,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Race condition in the ssl_parse_serverhello_tlsext function in t1_lib.c in OpenSSL 1.0.0 before 1.0.0n and 1.0.1 before 1.0.1i, when multithreading and session resumption are used, allows remote SSL servers to cause a denial of service (memory overwrite and client application crash) or possibly have unspecified other impact by sending Elliptic Curve (EC) Supported Point Formats Extension data.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=fb0bc2b273bcc2d5401dd883fe869af4fc74bb21,,,,,,,
CVE-2014-3508,https://www.cvedetails.com/cve/CVE-2014-3508/,CWE-200,,+Info,2014-08-13,2017-11-14,4.3,None,Remote,Medium,Not required,Partial,None,None,"The OBJ_obj2txt function in crypto/objects/obj_dat.c in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i, when pretty printing is used, does not ensure the presence of '\0' characters, which allows context-dependent attackers to obtain sensitive information from process stack memory by reading output from X509_name_oneline, X509_name_print_ex, and unspecified other functions.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=0042fb5fd1c9d257d713b15a1f45da05cf5c1c87,,,,,,,
CVE-2014-3507,https://www.cvedetails.com/cve/CVE-2014-3507/,CWE-399,,DoS,2014-08-13,2017-08-28,5.0,None,Remote,Low,Not required,None,None,Partial,"Memory leak in d1_both.c in the DTLS implementation in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote attackers to cause a denial of service (memory consumption) via zero-length DTLS fragments that trigger improper handling of the return value of a certain insert function.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d0a4b7d1a2948fce38515b8d862f43e7ba0ebf74,,,,,,,
CVE-2014-3506,https://www.cvedetails.com/cve/CVE-2014-3506/,CWE-399,,DoS,2014-08-13,2017-08-28,5.0,None,Remote,Low,Not required,None,None,Partial,"d1_both.c in the DTLS implementation in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote attackers to cause a denial of service (memory consumption) via crafted DTLS handshake messages that trigger memory allocations corresponding to large length values.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1250f12613b61758675848f6600ebd914ccd7636,,,,,,,
CVE-2014-3505,https://www.cvedetails.com/cve/CVE-2014-3505/,,,DoS,2014-08-13,2017-01-06,5.0,None,Remote,Low,Not required,None,None,Partial,"Double free vulnerability in d1_both.c in the DTLS implementation in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote attackers to cause a denial of service (application crash) via crafted DTLS packets that trigger an error condition.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bff1ce4e6a1c57c3d0a5f9e4f85ba6385fccfe8b,,,,,,,
CVE-2014-3477,https://www.cvedetails.com/cve/CVE-2014-3477/,,,DoS,2014-07-01,2015-04-14,2.1,None,Local,Low,Not required,None,None,Partial,"The dbus-daemon in D-Bus 1.2.x through 1.4.x, 1.6.x before 1.6.20, and 1.8.x before 1.8.4, sends an AccessDenied error to the service instead of a client when the client is prohibited from accessing the service, which allows local users to cause a denial of service (initialization failure and exit) or possibly conduct a side-channel attack via a D-Bus message to an inactive service.",,dbus,https://cgit.freedesktop.org/dbus/dbus/commit/?h=dbus-1.8&id=24c590703ca47eb71ddef453de43126b90954567,,,,,,,
CVE-2014-3470,https://www.cvedetails.com/cve/CVE-2014-3470/,CWE-310,,DoS,2014-06-05,2019-04-22,4.3,None,Remote,Medium,Not required,None,None,Partial,"The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h, when an anonymous ECDH cipher suite is used, allows remote attackers to cause a denial of service (NULL pointer dereference and client crash) by triggering a NULL certificate value.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=8011cd56e39a433b1837465259a9bd24a38727fb,,,,,,,
CVE-2014-3468,https://www.cvedetails.com/cve/CVE-2014-3468/,CWE-189,,,2014-06-05,2019-04-22,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The asn1_get_bit_der function in GNU Libtasn1 before 3.6 does not properly report an error when a negative bit length is identified, which allows context-dependent attackers to cause out-of-bounds access via crafted ASN.1 data.",,savannah,https://git.savannah.gnu.org/cgit/libtasn1.git/commit/?id=1c3ccb3e040bf13e342ee60bc23b21b97b11923f,,,,,,,
CVE-2016-2860,https://www.cvedetails.com/cve/CVE-2016-2860/,CWE-284,,Bypass,2016-05-13,2016-05-19,4.0,None,Remote,Low,Single system,None,Partial,None,The newEntry function in ptserver/ptprocs.c in OpenAFS before 1.6.17 allows remote authenticated users from foreign Kerberos realms to bypass intended access restrictions and create arbitrary groups as administrators by leveraging mishandling of the creator ID.,C,openafs,http://git.openafs.org/?p=openafs.git;a=commitdiff;h=396240cf070a806b91fea81131d034e1399af1e0,396240cf070a806b91fea81131d034e1399af1e0,be42de4f4f335b86defdac16a491c3b04219f212,"@@ -345,13 +345,19 @@ newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
-    if (code != 2) {           /* 2 specifies that this is a foreign cell request */
-       if (code)
-           ABORT_WITH(tt, PRPERM);
-       admin = IsAMemberOf(tt, *cid, SYSADMINID);
-    } else {
-       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);
-       oid = *cid = SYSADMINID;
+    if (code && code != 2)
+       ABORT_WITH(tt, PRPERM);
+    admin = IsAMemberOf(tt, *cid, SYSADMINID);
+    if (code == 2 /* foreign cell request */) {
+       if (!restricted && (strcmp(aname, cname) == 0)) {
+           /* can't autoregister while providing an owner id */
+           if (oid != 0)
+               ABORT_WITH(tt, PRPERM);
+
+           admin = 1;
+           oid = SYSADMINID;
+           *cid = SYSADMINID;
+       }
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);",http://git.openafs.org/?p=openafs.git;a=blob;f=src/ptserver/ptprocs.c;h=ae1a56292077e765d2d43270b0db1d37506dee74,http://git.openafs.org/?p=openafs.git;a=blob;f=src/ptserver/ptprocs.c;h=f9f48fc6897fa1f379f8ecbb600e85cf1845383b;hb=396240cf070a806b91fea81131d034e1399af1e0,,
CVE-2016-2858,https://www.cvedetails.com/cve/CVE-2016-2858/,CWE-119,,DoS Overflow Mem. Corr.,2016-04-07,2018-12-01,1.9,None,Local,Medium,Not required,None,None,Partial,"QEMU, when built with the Pseudo Random Number Generator (PRNG) back-end support, allows local guest OS users to cause a denial of service (process crash) via an entropy request, which triggers arbitrary stack based allocation and memory corruption.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=60253ed1e6ec6d8e5ef2efe7bf755f475dce9956,,,,,,,
CVE-2016-2857,https://www.cvedetails.com/cve/CVE-2016-2857/,CWE-119,,DoS Overflow,2016-04-11,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,The net_checksum_calculate function in net/checksum.c in QEMU allows local guest OS users to cause a denial of service (out-of-bounds heap read and crash) via the payload length in a crafted packet.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=362786f14a753d8a5256ef97d7c10ed576d6572b,,,,,,,
CVE-2016-2842,https://www.cvedetails.com/cve/CVE-2016-2842/,CWE-119,,DoS Overflow,2016-03-03,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=578b956fe741bf8e84055547b1e83c28dd902c73,,,,,,,
CVE-2016-2841,https://www.cvedetails.com/cve/CVE-2016-2841/,CWE-20,,DoS,2016-06-16,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,"The ne2000_receive function in the NE2000 NIC emulation support (hw/net/ne2000.c) in QEMU before 2.5.1 allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via crafted values for the PSTART and PSTOP registers, involving ring buffer control.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190,,,,,,,
CVE-2016-2538,https://www.cvedetails.com/cve/CVE-2016-2538/,CWE-189,,DoS Overflow +Info,2016-06-16,2018-12-01,3.6,None,Local,Low,Not required,Partial,None,Partial,"Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e,,,,,,,
CVE-2010-0547,https://www.cvedetails.com/cve/CVE-2010-0547/,CWE-20,,DoS,2010-02-04,2013-04-18,2.1,None,Local,Low,Not required,None,None,Partial,"client/mount.cifs.c in mount.cifs in smbfs in Samba 3.4.5 and earlier does not verify that the (1) device name and (2) mountpoint strings are composed of valid characters, which allows local users to cause a denial of service (mtab corruption) via a crafted string.",,samba,https://git.samba.org/?p=samba.git;a=commit;h=a065c177dfc8f968775593ba00dffafeebb2e054,,,,,,,
CVE-2016-2392,https://www.cvedetails.com/cve/CVE-2016-2392/,,,DoS,2016-06-16,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,"The is_rndis function in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 does not properly validate USB configuration descriptor objects, which allows local guest OS administrators to cause a denial of service (NULL pointer dereference and QEMU process crash) via vectors involving a remote NDIS control message packet.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=80eecda8e5d09c442c24307f340840a5b70ea3b9,,,,,,,
CVE-2016-2391,https://www.cvedetails.com/cve/CVE-2016-2391/,,,DoS,2016-06-16,2018-12-01,2.1,None,Local,Low,Not required,None,None,Partial,The ohci_bus_start function in the USB OHCI emulation support (hw/usb/hcd-ohci.c) in QEMU allows local guest OS administrators to cause a denial of service (NULL pointer dereference and QEMU process crash) via vectors related to multiple eof_timers.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=fa1298c2d623522eda7b4f1f721fcb935abb7360,,,,,,,
CVE-2016-2342,https://www.cvedetails.com/cve/CVE-2016-2342/,CWE-119,,DoS Exec Code Overflow,2016-03-17,2018-01-04,7.6,None,Remote,High,Not required,Complete,Complete,Complete,"The bgp_nlri_parse_vpnv4 function in bgp_mplsvpn.c in the VPNv4 NLRI parser in bgpd in Quagga before 1.0.20160309, when a certain VPNv4 configuration is used, relies on a Labeled-VPN SAFI routes-data length field during a data copy, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted packet.",,savannah,https://git.savannah.gnu.org/cgit/quagga.git/commit/?id=a3bc7e9400b214a0f078fdb19596ba54214a1442,,,,,,,
CVE-2017-0861,https://www.cvedetails.com/cve/CVE-2017-0861/,CWE-416,,+Priv,2017-11-16,2019-10-02,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Use-after-free vulnerability in the snd_pcm_info function in the ALSA subsystem in the Linux kernel allows attackers to gain privileges via unspecified vectors.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=362bca57f5d78220f8b5907b875961af9436e229,,,,,,,
CVE-2016-2193,https://www.cvedetails.com/cve/CVE-2016-2193/,CWE-254,,Bypass,2016-04-11,2017-09-02,5.0,None,Remote,Low,Not required,None,Partial,None,"PostgreSQL before 9.5.x before 9.5.2 does not properly maintain row-security status in cached plans, which might allow attackers to bypass intended access restrictions by leveraging a session that performs queries as more than one role.",,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=db69e58a0642ef7fa46d62f6c4cf2460c3a1b41b,,,,,,,
CVE-2016-2190,https://www.cvedetails.com/cve/CVE-2016-2190/,CWE-264,,+Info,2016-05-22,2017-09-06,5.0,None,Remote,Low,Not required,Partial,None,None,"Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 does not properly restrict links, which allows remote attackers to obtain sensitive URL information by reading a Referer log.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52651,,,,,,,
CVE-2014-2972,https://www.cvedetails.com/cve/CVE-2014-2972/,CWE-189,,Exec Code +Priv,2014-09-04,2016-12-02,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"expand.c in Exim before 4.83 expands mathematical comparisons twice, which allows local users to gain privileges and execute arbitrary commands via a crafted lookup value.",C,exim,https://git.exim.org/exim.git/commitdiff/7685ce68148a083d7759e78d01aa5198fc099c44,88a5ee399db9c15c2a94cd95aae6f364afab3249,7685ce68148a083d7759e78d01aa5198fc099c44,"@@ -14,6 +14,7 @@
 /* Recursively called function */
 
 static uschar *expand_string_internal(uschar *, BOOL, uschar **, BOOL, BOOL, BOOL *);
+static int_eximarith_t expanded_string_integer(uschar *, BOOL);
 
 #ifdef STAND_ALONE
 #ifndef SUPPORT_CRYPTEQ
@@ -2445,7 +2446,7 @@ switch(cond_type)
         }
       else
         {
-        num[i] = expand_string_integer(sub[i], FALSE);
+        num[i] = expanded_string_integer(sub[i], FALSE);
         if (expand_string_message != NULL) return NULL;
         }
       }
@@ -6679,7 +6680,7 @@ while (*s != 0)
         int_eximarith_t max;
         uschar *s;
 
-        max = expand_string_integer(sub, TRUE);
+        max = expanded_string_integer(sub, TRUE);
         if (expand_string_message != NULL)
           goto EXPAND_FAILED;
         s = string_sprintf(""%d"", vaguely_random_number((int)max));
@@ -6879,8 +6880,32 @@ Returns:  the integer value, or
 int_eximarith_t
 expand_string_integer(uschar *string, BOOL isplus)
 {
+return expanded_string_integer(expand_string(string), isplus);
+}
+
+
+/*************************************************
+ *         Interpret string as an integer        *
+ *************************************************/
+
+/* Convert a string (that has already been expanded) into an integer.
+
+This function is used inside the expansion code.
+
+Arguments:
+  s       the string to be expanded
+  isplus  TRUE if a non-negative number is expected
+
+Returns:  the integer value, or
+          -1 if string is NULL (which implies an expansion error)
+          -2 for an integer interpretation error
+          expand_string_message is set NULL for an OK integer
+*/
+
+static int_eximarith_t
+expanded_string_integer(uschar *s, BOOL isplus)
+{
 int_eximarith_t value;
-uschar *s = expand_string(string);
 uschar *msg = US""invalid integer \""%s\"""";
 uschar *endptr;",https://git.exim.org/exim.git/blob/7685ce68148a083d7759e78d01aa5198fc099c44:/src/src/expand.c,https://git.exim.org/exim.git/blob/88a5ee399db9c15c2a94cd95aae6f364afab3249?f=src/src/expand.c,,
CVE-2016-2182,https://www.cvedetails.com/cve/CVE-2016-2182/,CWE-787,,DoS,2016-09-16,2018-07-13,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The BN_bn2dec function in crypto/bn/bn_print.c in OpenSSL before 1.1.0 does not properly validate division results, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=07bed46f332fce8c1d157689a2cdf915a982ae34,,,,,,,
CVE-2014-2957,https://www.cvedetails.com/cve/CVE-2014-2957/,CWE-20,,Exec Code,2014-09-04,2014-09-05,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The dmarc_process function in dmarc.c in Exim before 4.82.1, when EXPERIMENTAL_DMARC is enabled, allows remote attackers to execute arbitrary code via the From header in an email, which is passed to the expand_string function.",,exim,https://git.exim.org/exim.git/commitdiff/5b7a7c051c9ab9ee7c924a611f90ef2be03e0ad0,5b7a7c051c9ab9ee7c924a611f90ef2be03e0ad0,6e516525fd6b123625e496f718346a72b566af18,"@@ -168,26 +168,31 @@ int dmarc_process() {
     dmarc_abort = TRUE;
   else
   {
-    /* I strongly encourage anybody who can make this better to contact me directly!
-     * <cannonball> Is this an insane way to extract the email address from the From: header?
-     * <jgh_hm> it's sure a horrid layer-crossing....
-     * <cannonball> I'm not denying that :-/
-     * <jgh_hm> there may well be no better though
-     */
-    header_from_sender = expand_string(
-                           string_sprintf(""${domain:${extract{1}{:}{${addresses:%s}}}}"",
-                             from_header->text) );
-    /* The opendmarc library extracts the domain from the email address, but
-     * only try to store it if it's not empty.  Otherwise, skip out of DMARC. */
-    if (strcmp( CCS header_from_sender, """") == 0)
-      dmarc_abort = TRUE;
-    libdm_status = (dmarc_abort == TRUE) ?
-                  DMARC_PARSE_OKAY :
-                  opendmarc_policy_store_from_domain(dmarc_pctx, header_from_sender);
-    if (libdm_status != DMARC_PARSE_OKAY)
+  uschar * errormsg;
+  int dummy, domain;
+  uschar * p;
+  uschar saveend;
+
+  parse_allow_group = TRUE;
+  p = parse_find_address_end(from_header->text, FALSE);
+  saveend = *p; *p = '\0';
+  if ((header_from_sender = parse_extract_address(from_header->text, &errormsg,
+                              &dummy, &dummy, &domain, FALSE)))
+    header_from_sender += domain;
+  *p = saveend;
+
+  /* The opendmarc library extracts the domain from the email address, but
+   * only try to store it if it's not empty.  Otherwise, skip out of DMARC. */
+  if (!header_from_sender || (strcmp( CCS header_from_sender, """") == 0))
+    dmarc_abort = TRUE;
+  libdm_status = dmarc_abort ?
+    DMARC_PARSE_OKAY :
+    opendmarc_policy_store_from_domain(dmarc_pctx, header_from_sender);
+  if (libdm_status != DMARC_PARSE_OKAY)
     {
-      log_write(0, LOG_MAIN|LOG_PANIC, ""failure to store header From: in DMARC: %s, header was '%s'"",
-                           opendmarc_policy_status_to_str(libdm_status), from_header->text);
+      log_write(0, LOG_MAIN|LOG_PANIC,
+                ""failure to store header From: in DMARC: %s, header was '%s'"",
+                opendmarc_policy_status_to_str(libdm_status), from_header->text);
       dmarc_abort = TRUE;
     }
   }",https://git.exim.org/exim.git/blob/6e516525fd6b123625e496f718346a72b566af18?f=src/src/dmarc.c,https://git.exim.org/exim.git/blob/5b7a7c051c9ab9ee7c924a611f90ef2be03e0ad0:/src/src/dmarc.c,,
CVE-2016-2181,https://www.cvedetails.com/cve/CVE-2016-2181/,CWE-189,,DoS,2016-09-16,2018-04-19,5.0,None,Remote,Low,Not required,None,None,Partial,"The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770,,,,,,,
CVE-2016-2179,https://www.cvedetails.com/cve/CVE-2016-2179/,CWE-399,,DoS,2016-09-16,2018-07-11,5.0,None,Remote,Low,Not required,None,None,Partial,"The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d,,,,,,,
CVE-2016-2178,https://www.cvedetails.com/cve/CVE-2016-2178/,CWE-200,,+Info,2016-06-19,2018-07-11,2.1,None,Local,Low,Not required,Partial,None,None,"The dsa_sign_setup function in crypto/dsa/dsa_ossl.c in OpenSSL through 1.0.2h does not properly ensure the use of constant-time operations, which makes it easier for local users to discover a DSA private key via a timing side-channel attack.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=399944622df7bd81af62e67ea967c470534090e2,,,,,,,
CVE-2016-2177,https://www.cvedetails.com/cve/CVE-2016-2177/,CWE-190,,DoS Overflow,2016-06-19,2018-07-11,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,,,,,,,
CVE-2016-2176,https://www.cvedetails.com/cve/CVE-2016-2176/,CWE-119,,DoS Overflow +Info,2016-05-04,2018-07-18,6.4,None,Remote,Low,Not required,Partial,None,Partial,The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=2919516136a4227d9e6d8f2fe66ef976aaf8c561,,,,,,,
CVE-2016-2159,https://www.cvedetails.com/cve/CVE-2016-2159/,CWE-284,,Bypass,2016-05-22,2017-09-06,4.0,None,Remote,Low,Single system,None,Partial,None,"The save_submission function in mod/assign/externallib.php in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 allows remote authenticated users to bypass intended due-date restrictions by leveraging the student role for a web-service request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52901,,,,,,,
CVE-2016-2158,https://www.cvedetails.com/cve/CVE-2016-2158/,CWE-200,,+Info,2016-05-22,2017-09-06,4.0,None,Remote,Low,Single system,Partial,None,None,"lib/ajax/getnavbranch.php in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3, when the forcelogin feature is enabled, allows remote attackers to obtain sensitive category-detail information from the navigation branch by leveraging the guest role for an Ajax request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52774,,,,,,,
CVE-2016-2157,https://www.cvedetails.com/cve/CVE-2016-2157/,CWE-352,,CSRF,2016-05-22,2017-09-06,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Cross-site request forgery (CSRF) vulnerability in mod/assign/adminmanageplugins.php in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 allows remote attackers to hijack the authentication of administrators for requests that manage Assignment plugins.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-53031,,,,,,,
CVE-2016-2156,https://www.cvedetails.com/cve/CVE-2016-2156/,CWE-200,,+Info,2016-05-22,2017-09-06,4.0,None,Remote,Low,Single system,Partial,None,None,"calendar/externallib.php in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 provides calendar-event data without considering whether an activity is hidden, which allows remote authenticated users to obtain sensitive information via a web-service request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52808,,,,,,,
CVE-2016-2155,https://www.cvedetails.com/cve/CVE-2016-2155/,CWE-264,,,2016-05-22,2017-09-06,4.0,None,Remote,Low,Single system,None,Partial,None,"The grade-reporting feature in Singleview (aka Single View) in Moodle 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 does not consider the moodle/grade:manage capability, which allows remote authenticated users to modify ""Exclude grade"" settings by leveraging the Non-Editing Instructor role.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52378,,,,,,,
CVE-2016-2154,https://www.cvedetails.com/cve/CVE-2016-2154/,CWE-200,,+Info,2016-05-22,2017-09-06,4.0,None,Remote,Low,Single system,Partial,None,None,"admin/tool/monitor/lib.php in Event Monitor in Moodle 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 does not consider the moodle/course:viewhiddencourses capability, which allows remote authenticated users to discover hidden course names by subscribing to a rule.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51167,,,,,,,
CVE-2016-2153,https://www.cvedetails.com/cve/CVE-2016-2153/,CWE-79,,XSS,2016-05-22,2017-09-06,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the advanced-search feature in mod_data in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 allows remote attackers to inject arbitrary web script or HTML via a crafted field in a URL, as demonstrated by a search form field.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52727,,,,,,,
CVE-2016-2152,https://www.cvedetails.com/cve/CVE-2016-2152/,CWE-79,,XSS,2016-05-22,2017-09-06,4.3,None,Remote,Medium,Not required,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in auth/db/auth.php in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 allow remote attackers to inject arbitrary web script or HTML via an external DB profile field.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50705,,,,,,,
CVE-2016-2151,https://www.cvedetails.com/cve/CVE-2016-2151/,CWE-200,,+Info,2016-05-22,2017-09-06,4.0,None,Remote,Low,Single system,Partial,None,None,"user/index.php in Moodle through 2.6.11, 2.7.x before 2.7.13, 2.8.x before 2.8.11, 2.9.x before 2.9.5, and 3.0.x before 3.0.3 grants excessive authorization on the basis of the moodle/course:viewhiddenuserfields capability, which allows remote authenticated users to discover student e-mail addresses by leveraging the teacher role and reading a Participants list.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52433,,,,,,,
CVE-2014-2855,https://www.cvedetails.com/cve/CVE-2014-2855/,CWE-20,,DoS,2014-04-23,2017-12-15,7.8,None,Remote,Low,Not required,None,None,Complete,The check_secret function in authenticate.c in rsync 3.1.0 and earlier allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a user name which does not exist in the secrets file.,,samba,https://git.samba.org/?p=rsync.git;a=commit;h=0dedfbce2c1b851684ba658861fe9d620636c56a,,,,,,,
CVE-2016-2109,https://www.cvedetails.com/cve/CVE-2016-2109/,CWE-399,,DoS,2016-05-04,2018-07-18,7.8,None,Remote,Low,Not required,None,None,Complete,The asn1_d2i_read_bio function in crypto/asn1/a_d2i_fp.c in the ASN.1 BIO implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (memory consumption) via a short invalid encoding.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=c62981390d6cf9e3d612c489b8b77c2913b25807,,,,,,,
CVE-2016-2108,https://www.cvedetails.com/cve/CVE-2016-2108/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2016-05-04,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the ""negative zero"" issue.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=3661bb4e7934668bd99ca777ea8b30eedfafa871,,,,,,,
CVE-2016-2108,https://www.cvedetails.com/cve/CVE-2016-2108/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2016-05-04,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the ""negative zero"" issue.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=f5da52e308a6aeea6d5f3df98c4da295d7e9cc27,,,,,,,
CVE-2016-2107,https://www.cvedetails.com/cve/CVE-2016-2107/,CWE-310,,+Info,2016-05-04,2018-10-30,2.6,None,Remote,High,Not required,Partial,None,None,"The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=68595c0c2886e7942a14f98c17a55a88afb6c292,,,,,,,
CVE-2016-2106,https://www.cvedetails.com/cve/CVE-2016-2106/,CWE-189,,DoS Overflow Mem. Corr.,2016-05-04,2018-07-18,5.0,None,Remote,Low,Not required,None,None,Partial,Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=3f3582139fbb259a1c3cbb0a25236500a409bf26,,,,,,,
CVE-2016-2105,https://www.cvedetails.com/cve/CVE-2016-2105/,CWE-189,,DoS Overflow Mem. Corr.,2016-05-04,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=5b814481f3573fa9677f3a31ee51322e2a22ee6a,,,,,,,
CVE-2018-21008,https://www.cvedetails.com/cve/CVE-2018-21008/,CWE-416,,,2019-09-04,2019-09-24,4.9,None,Local,Low,Not required,None,None,Complete,An issue was discovered in the Linux kernel before 4.16.7. A use-after-free can be caused by the function rsi_mac80211_detach in the file drivers/net/wireless/rsi/rsi_91x_mac80211.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=abd39c6ded9db53aa44c2540092bdd5fb6590fa8,,,,,,,
CVE-2017-0553,https://www.cvedetails.com/cve/CVE-2017-0553/,CWE-190,,Exec Code,2017-04-07,2019-10-02,7.6,None,Remote,High,Not required,Complete,Complete,Complete,"An elevation of privilege vulnerability in libnl could enable a local malicious application to execute arbitrary code within the context of the Wi-Fi service. This issue is rated as Moderate because it first requires compromising a privileged process and is mitigated by current platform configurations. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-32342065. NOTE: this issue also exists in the upstream libnl before 3.3.0 library.",,infradead,http://git.infradead.org/users/tgr/libnl.git/commit/3e18948f17148e6a3c4255bdeaaf01ef6081ceeb,,,,,,,
CVE-2018-20976,https://www.cvedetails.com/cve/CVE-2018-20976/,CWE-416,,,2019-08-18,2019-09-05,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"An issue was discovered in fs/xfs/xfs_super.c in the Linux kernel before 4.18. A use after free exists, related to xfs_fs_fill_super failure.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c9fbd7bbc23dbdd73364be4d045e5d3612cf6e82,,,,,,,
CVE-2014-2572,https://www.cvedetails.com/cve/CVE-2014-2572/,CWE-264,,,2014-03-24,2014-03-24,4.0,None,Remote,Low,Single system,None,Partial,None,"mod/assign/externallib.php in Moodle 2.6.x before 2.6.2 does not properly handle assignment web-service parameters, which might allow remote authenticated users to modify grade metadata via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43468,,,,,,,
CVE-2014-2571,https://www.cvedetails.com/cve/CVE-2014-2571/,CWE-79,,XSS,2014-03-24,2014-03-24,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the quiz_question_tostring function in mod/quiz/editlib.php in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 allows remote authenticated users to inject arbitrary web script or HTML via a quiz question.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43690,,,,,,,
CVE-2016-1907,https://www.cvedetails.com/cve/CVE-2016-1907/,CWE-119,,DoS Overflow,2016-01-19,2017-02-16,5.0,None,Remote,Low,Not required,None,None,Partial,The ssh_packet_read_poll2 function in packet.c in OpenSSH before 7.1p2 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via crafted network traffic.,,mindrot,https://anongit.mindrot.org/openssh.git/commit/?id=2fecfd486bdba9f51b3a789277bb0733ca36e1c0,,,,,,,
CVE-2010-0001,https://www.cvedetails.com/cve/CVE-2010-0001/,CWE-189,,DoS Exec Code,2010-01-29,2017-09-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Integer underflow in the unlzw function in unlzw.c in gzip before 1.4 on 64-bit platforms, as used in ncompress and probably others, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted archive that uses LZW compression, leading to an array index error.",,savannah,https://git.savannah.gnu.org/cgit/gzip.git/commit/?id=a3db5806d012082b9e25cc36d09f19cd736a468f,,,,,,,
CVE-2017-0379,https://www.cvedetails.com/cve/CVE-2017-0379/,CWE-200,,+Info,2017-08-29,2019-01-16,5.0,None,Remote,Low,Not required,Partial,None,None,"Libgcrypt before 1.8.1 does not properly consider Curve25519 side-channel attacks, which makes it easier for attackers to discover a secret key, related to cipher/ecc.c and mpi/ec.c.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=da780c8183cccc8f533c8ace8211ac2cb2bdee7b,,,,,,,
CVE-2014-2241,https://www.cvedetails.com/cve/CVE-2014-2241/,CWE-20,,DoS,2014-03-18,2014-04-01,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The (1) cf2_initLocalRegionBuffer and (2) cf2_initGlobalRegionBuffer functions in cff/cf2ft.c in FreeType before 2.5.3 do not properly check if a subroutine exists, which allows remote attackers to cause a denial of service (assertion failure), as demonstrated by a crafted ttf file.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=135c3faebb96f8f550bd4f318716f2e1e095a969,,,,,,,
CVE-2018-20815,https://www.cvedetails.com/cve/CVE-2018-20815/,CWE-119,,Overflow,2019-05-31,2019-07-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"In QEMU 3.1.0, load_device_tree in device_tree.c calls the deprecated load_image function, which has a buffer overflow risk.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=da885fe1ee8b4589047484bd7fa05a4905b52b17,,,,,,,
CVE-2016-1568,https://www.cvedetails.com/cve/CVE-2016-1568/,,,DoS Exec Code,2016-04-11,2017-11-03,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"Use-after-free vulnerability in hw/ide/ahci.c in QEMU, when built with IDE AHCI Emulation support, allows guest OS users to cause a denial of service (instance crash) or possibly execute arbitrary code via an invalid AHCI Native Command Queuing (NCQ) AIO command.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=4ab0359a8ae182a7ac5c99609667273167703fab,,,,,,,
CVE-2018-20679,https://www.cvedetails.com/cve/CVE-2018-20679/,CWE-125,,+Info,2019-01-09,2019-09-04,5.0,None,Remote,Low,Not required,Partial,None,None,"An issue was discovered in BusyBox before 1.30.0. An out of bounds read in udhcp components (consumed by the DHCP server, client, and relay) allows a remote attacker to leak sensitive information from the stack by sending a crafted DHCP message. This is related to verification in udhcp_get_option() in networking/udhcp/common.c that 4-byte options are indeed 4 bytes.",,busybox,https://git.busybox.net/busybox/commit/?id=6d3b4bb24da9a07c263f3c1acf8df85382ff562c,,,,,,,
CVE-2011-4593,https://www.cvedetails.com/cve/CVE-2011-4593/,CWE-200,,+Info,2012-07-20,2012-07-23,4.0,None,Remote,Low,Single system,Partial,None,None,"Moodle 1.9.x before 1.9.15, 2.0.x before 2.0.6, and 2.1.x before 2.1.3 does not properly handle user/action_redir group messages, which allows remote authenticated users to discover e-mail addresses by visiting the messaging interface.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=e94113a859015a4a80b9397957b8fc4044e2951f,,,,,,,
CVE-2011-4592,https://www.cvedetails.com/cve/CVE-2011-4592/,CWE-264,,Bypass,2012-07-20,2012-07-20,5.0,None,Remote,Low,Not required,None,Partial,None,"The command-line cron implementation in Moodle 2.0.x before 2.0.6 and 2.1.x before 2.1.3 does not properly interact with IP blocking, which might allow remote attackers to bypass intended IP address restrictions by leveraging a configuration in which IP blocking was disabled to restore cron functionality.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=ade30ad3c420ce035a3d68287db701b70e806b3f,,,,,,,
CVE-2011-4591,https://www.cvedetails.com/cve/CVE-2011-4591/,CWE-79,,XSS,2012-07-20,2012-07-20,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the print_object function in lib/datalib.php in Moodle 2.0.x before 2.0.6 and 2.1.x before 2.1.3, when a developer debugging script is enabled, allows remote attackers to inject arbitrary web script or HTML via vectors involving object states.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=187672608ec96659e07f2461b3b83634debd16cb,,,,,,,
CVE-2011-4590,https://www.cvedetails.com/cve/CVE-2011-4590/,CWE-287,,Bypass,2012-07-20,2012-07-23,4.0,None,Remote,Low,Single system,None,Partial,None,"The web services implementation in Moodle 2.0.x before 2.0.6 and 2.1.x before 2.1.3 does not properly consider the maintenance-mode state and account attributes during login attempts, which allows remote authenticated users to bypass intended access restrictions by connecting to a webservice server.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-28629,,,,,,,
CVE-2011-4589,https://www.cvedetails.com/cve/CVE-2011-4589/,CWE-264,,,2012-07-20,2012-07-20,5.5,None,Remote,Low,Single system,None,Partial,Partial,"backup/moodle2/restore_stepslib.php in Moodle 2.0.x before 2.0.6 and 2.1.x before 2.1.3 does not check for the moodle/course:changeidnumber privilege during handling of course ID numbers, which allows remote authenticated users to overwrite ID numbers via a restore action.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-29591,,,,,,,
CVE-2011-4588,https://www.cvedetails.com/cve/CVE-2011-4588/,CWE-264,,Bypass,2012-07-20,2017-12-21,5.0,None,Remote,Low,Not required,None,Partial,None,"The ip_in_range function in mnet/lib.php in MNET in Moodle 1.9.x before 1.9.15 uses an incorrect data type, which allows remote attackers to bypass intended IP address restrictions via an XMLRPC request.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=3ab2851d2a59721445945d0706c58092e07e861e,,,,,,,
CVE-2011-4587,https://www.cvedetails.com/cve/CVE-2011-4587/,CWE-255,,,2012-07-20,2017-12-21,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"lib/moodlelib.php in Moodle 1.9.x before 1.9.15, 2.0.x before 2.0.6, and 2.1.x before 2.1.3 does not properly handle certain zero values in the password policy, which makes it easier for remote attackers to obtain access by leveraging the possible existence of user accounts that have unchangeable blank passwords.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=e079e82c087becf06d902089d14f3f76686bde19,,,,,,,
CVE-2011-4586,https://www.cvedetails.com/cve/CVE-2011-4586/,,,Http R.Spl.,2012-07-20,2017-12-21,5.0,None,Remote,Low,Not required,None,Partial,None,"CRLF injection vulnerability in calendar/set.php in the Calendar subsystem in Moodle 1.9.x before 1.9.15, 2.0.x before 2.0.6, and 2.1.x before 2.1.3 allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=581e8dba387f090d89382115fd850d8b44351526,,,,,,,
CVE-2011-4585,https://www.cvedetails.com/cve/CVE-2011-4585/,CWE-16,,,2012-07-20,2017-12-21,5.0,None,Remote,Low,Not required,Partial,None,None,"login/change_password.php in Moodle 1.9.x before 1.9.15 does not use https for the change-password form even if the httpslogin option is enabled, which allows remote attackers to obtain credentials by sniffing the network.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=01dd64a8c8aa95f793accea371b2392e662663c5,,,,,,,
CVE-2011-4584,https://www.cvedetails.com/cve/CVE-2011-4584/,CWE-264,,,2012-07-20,2017-12-21,4.0,None,Remote,Low,Single system,None,Partial,None,"The MNET authentication functionality in Moodle 1.9.x before 1.9.15, 2.0.x before 2.0.6, and 2.1.x before 2.1.3 allows remote authenticated users to impersonate other user accounts by using the Login As feature in conjunction with a remote MNET single sign-on capability, as demonstrated by a Mahara site.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=10df8657c1c138c0d0ab1d4796c552fcec0c299b,,,,,,,
CVE-2011-4583,https://www.cvedetails.com/cve/CVE-2011-4583/,CWE-264,,,2012-07-20,2013-08-12,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"Moodle 2.0.x before 2.0.6 and 2.1.x before 2.1.3 displays web service tokens associated with (1) disabled services and (2) users who no longer have authorization, which allows remote authenticated users to have an unspecified impact by reading these tokens.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-28670&sr=1,,,,,,,
CVE-2011-4582,https://www.cvedetails.com/cve/CVE-2011-4582/,CWE-20,,,2012-07-20,2012-07-23,4.9,None,Remote,Medium,Single system,Partial,Partial,None,Open redirect vulnerability in the Calendar set page in Moodle 2.1.x before 2.1.3 allows remote authenticated users to redirect users to arbitrary web sites and conduct phishing attacks via a redirection URL.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-28720&sr=1,,,,,,,
CVE-2011-4581,https://www.cvedetails.com/cve/CVE-2011-4581/,CWE-200,,+Info,2012-07-20,2012-07-23,4.0,None,Remote,Low,Single system,Partial,None,None,mod/wiki/pagelib.php in Moodle 2.0.x before 2.0.6 and 2.1.x before 2.1.3 allows remote authenticated users to discover the username of a wiki creator by visiting the history and deletion user interface.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=140af2a0f0a4598bf568b9ae182cb81eb583edeb,,,,,,,
CVE-2014-2013,https://www.cvedetails.com/cve/CVE-2014-2013/,CWE-119,,Exec Code Overflow,2014-03-03,2017-12-28,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Stack-based buffer overflow in the xps_parse_color function in xps/xps-common.c in MuPDF 1.3 and earlier allows remote attackers to execute arbitrary code via a large number of entries in the ContextColor value of the Fill attribute in a Path element.,,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=60dabde18d7fe12b19da8b509bdfee9cc886aafc,,,,,,,
CVE-2016-10397,https://www.cvedetails.com/cve/CVE-2016-10397/,CWE-20,,Bypass,2017-07-10,2018-01-13,5.0,None,Remote,Low,Not required,None,Partial,None,"In PHP before 5.6.28 and 7.x before 7.0.13, incorrect handling of various URI components in the URL parser could be used by attackers to bypass hostname-specific URL checks, as demonstrated by evil.example.com:80#@good.example.com/ and evil.example.com:",,php,https://git.php.net/?p=php-src.git;a=commit;h=b061fa909de77085d3822a89ab901b934d0362c4,,,,,,,
CVE-2016-10369,https://www.cvedetails.com/cve/CVE-2016-10369/,CWE-284,,DoS Bypass,2017-05-08,2017-05-16,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"unixsocket.c in lxterminal through 0.3.0 insecurely uses /tmp for a socket file, allowing a local user to cause a denial of service (preventing terminal launch), or possibly have other impact (bypassing terminal access control).",,lxde,https://git.lxde.org/gitweb/?p=lxde/lxterminal.git;a=commit;h=f99163c6ff8b2f57c5f37b1ce5d62cf7450d4648,,,,,,,
CVE-2011-4328,https://www.cvedetails.com/cve/CVE-2011-4328/,CWE-264,,+Info,2012-06-15,2014-01-07,5.0,None,Remote,Low,Not required,Partial,None,None,"plugin/npapi/plugin.cpp in Gnash before 0.8.10 uses weak permissions (world readable) for cookie files with predictable names in /tmp, which allows local users to obtain sensitive information.",,savannah,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=commitdiff;h=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,,,,,,,
CVE-2011-4309,https://www.cvedetails.com/cve/CVE-2011-4309/,CWE-264,,Bypass,2012-07-11,2012-07-12,5.0,None,Remote,Low,Not required,Partial,None,None,Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 allows remote attackers to bypass intended access restrictions and perform global searches by leveraging the guest role and making a direct request to a URL.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=5eb1cec34f013fdcb559b66bc401f2845ce0bbb7,,,,,,,
CVE-2016-10328,https://www.cvedetails.com/cve/CVE-2016-10328/,CWE-787,,Overflow,2017-04-14,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,FreeType 2 before 2016-12-16 has an out-of-bounds write caused by a heap-based buffer overflow related to the cff_parser_run function in cff/cffparse.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=beecf80a6deecbaf5d264d4f864451bde4fe98b8,,,,,,,
CVE-2011-4307,https://www.cvedetails.com/cve/CVE-2011-4307/,CWE-79,,XSS,2012-07-11,2012-07-11,4.3,None,Remote,Medium,Not required,None,Partial,None,Cross-site scripting (XSS) vulnerability in mod/wiki/lang/en/wiki.php in Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 allows remote attackers to inject arbitrary web script or HTML via the section parameter.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=41017112cff7f5bd7969c72d321320f3090e7c68,,,,,,,
CVE-2011-4306,https://www.cvedetails.com/cve/CVE-2011-4306/,CWE-79,,XSS,2012-07-11,2012-07-11,4.3,None,Remote,Medium,Not required,None,Partial,None,Cross-site scripting (XSS) vulnerability in course/editsection.html in Moodle 1.9.x before 1.9.14 allows remote authenticated users to inject arbitrary web script or HTML via crafted data.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=4a2acd8c7e6c869d5fd5aa686e6e0a3f20c97f15,,,,,,,
CVE-2011-4305,https://www.cvedetails.com/cve/CVE-2011-4305/,CWE-189,,DoS,2012-07-11,2012-07-16,4.0,None,Remote,Low,Single system,None,None,Partial,message/refresh.php in Moodle 1.9.x before 1.9.14 allows remote authenticated users to cause a denial of service (infinite request loop) via a URL that specifies a zero wait time for message refreshing.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=97f258fabb3ebfa7acc7c02cb59de92b01710f99,,,,,,,
CVE-2011-4304,https://www.cvedetails.com/cve/CVE-2011-4304/,CWE-200,,+Info,2012-07-11,2012-07-11,4.0,None,Remote,Low,Single system,Partial,None,None,The chat functionality in Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 allows remote authenticated users to discover the name of any user via a beep operation.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=d0157d827bc254ba386a5e5b41b13be2698ee76e,,,,,,,
CVE-2011-4303,https://www.cvedetails.com/cve/CVE-2011-4303/,CWE-310,,Bypass,2012-07-11,2012-07-16,4.3,None,Remote,Medium,Not required,None,Partial,None,"lib/db/upgrade.php in Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 does not set the correct registration_hubs.secret value during installation, which allows remote attackers to bypass intended access restrictions by leveraging the hubs feature.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=ca896fdfcfcc87846fa91a297d0aa6999a68c48a,,,,,,,
CVE-2011-4302,https://www.cvedetails.com/cve/CVE-2011-4302/,CWE-20,,Bypass,2012-07-11,2012-07-11,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"mnet/xmlrpc/client.php in MNET in Moodle 1.9.x before 1.9.14, 2.0.x before 2.0.5, and 2.1.x before 2.1.2 does not properly process the return value of the openssl_verify function, which allows remote attackers to bypass validation via a crafted certificate.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=54941685e3e86ec085641dcb7ebb1f96f06735b2,,,,,,,
CVE-2011-4301,https://www.cvedetails.com/cve/CVE-2011-4301/,,,,2012-07-11,2012-07-11,5.0,None,Remote,Low,Not required,None,Partial,None,"The MoodleQuickForm class in the Forms Library in lib/formslib.php in Moodle 1.9.x before 1.9.14, 2.0.x before 2.0.5, and 2.1.x before 2.1.2 does not recognize Forms API setConstant operations, which allows remote attackers to submit unexpected form content by modifying the values of constant fields.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=f1f70bd4dde6cd1ea4bdb8ab28fa3d36a53b89d8,,,,,,,
CVE-2011-4300,https://www.cvedetails.com/cve/CVE-2011-4300/,CWE-264,,+Info,2012-07-11,2012-07-11,5.0,None,Remote,Low,Not required,Partial,None,None,"The file_browser component in Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 does not properly restrict access to category and course data, which allows remote attackers to obtain potentially sensitive information via a request for a file.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=f6b07c4da54a9db24723beb147e8a19a3d487e00,,,,,,,
CVE-2011-4299,https://www.cvedetails.com/cve/CVE-2011-4299/,CWE-79,,XSS,2012-07-11,2012-07-11,4.3,None,Remote,Medium,Not required,None,Partial,None,Cross-site scripting (XSS) vulnerability in mod/wiki/pagelib.php in Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 allows remote authenticated users to inject arbitrary web script or HTML via a wiki comment.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=a459fd90625ae44d7b3ac10b65da2dc631a418e7,,,,,,,
CVE-2011-4298,https://www.cvedetails.com/cve/CVE-2011-4298/,CWE-352,,CSRF,2012-07-11,2012-07-17,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Multiple cross-site request forgery (CSRF) vulnerabilities in mod/wiki/ components in Moodle 2.0.x before 2.0.5 and 2.1.x before 2.1.2 allow remote attackers to hijack the authentication of arbitrary users for requests that modify wiki data.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=48346fb11f8ced06a05c0618b02a3a925b34ec59,,,,,,,
CVE-2011-4297,https://www.cvedetails.com/cve/CVE-2011-4297/,CWE-264,,,2012-07-16,2012-07-16,6.4,None,Remote,Low,Not required,None,Partial,Partial,"comment/lib.php in Moodle 2.0.x before 2.0.4 and 2.1.x before 2.1.1 does not properly restrict comment capabilities, which allows remote attackers to post a comment by leveraging the guest role and operating on a front-page activity.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=9da3c2efadcc5f56cb8adc19c67ed16be35780f3,,,,,,,
CVE-2011-4296,https://www.cvedetails.com/cve/CVE-2011-4296/,CWE-264,,,2012-07-16,2012-07-16,5.5,None,Remote,Low,Single system,None,Partial,Partial,"lib/db/access.php in Moodle 2.0.x before 2.0.4 and 2.1.x before 2.1.1 assigns incorrect capabilities to the course-creator role, which allows remote authenticated users to modify course filters by leveraging this role.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=88d823c1f491a3c74f67bbf74306a8d1109dee02,,,,,,,
CVE-2011-4295,https://www.cvedetails.com/cve/CVE-2011-4295/,CWE-264,,+Priv,2012-07-16,2012-07-16,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"The moodle_enrol_external:role_assign function in enrol/externallib.php in Moodle 2.0.x before 2.0.4 and 2.1.x before 2.1.1 does not have an authorization check, which allows remote authenticated users to gain privileges by making a role assignment.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=d20f655d59cd486fd9b3a26ad353af13daafd1d3,,,,,,,
CVE-2011-4294,https://www.cvedetails.com/cve/CVE-2011-4294/,CWE-20,,,2012-07-16,2012-07-16,5.8,None,Remote,Medium,Not required,None,Partial,Partial,"The error-message functionality in Moodle 1.9.x before 1.9.13, 2.0.x before 2.0.4, and 2.1.x before 2.1.1 does not ensure that a continuation link refers to an http or https URL for the local Moodle instance, which might allow attackers to trick users into visiting arbitrary web sites via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=8f9f666c902cb30ef6f519353f38c45a29fdf4a6,,,,,,,
CVE-2011-4293,https://www.cvedetails.com/cve/CVE-2011-4293/,CWE-264,,Bypass,2012-07-16,2012-07-16,6.4,None,Remote,Low,Not required,None,Partial,Partial,"The theme implementation in Moodle 2.0.x before 2.0.4 and 2.1.x before 2.1.1 triggers duplicate caching of Cascading Style Sheets (CSS) and JavaScript content, which allows remote attackers to bypass intended access restrictions and write to an operating-system temporary directory via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=e1c2a211f259821910be2cba23679d4176fb00a3,,,,,,,
CVE-2011-4292,https://www.cvedetails.com/cve/CVE-2011-4292/,CWE-89,,DoS Sql,2012-07-16,2012-07-16,4.0,None,Remote,Low,Single system,None,None,Partial,Moodle 2.0.x before 2.0.3 allows remote authenticated users to cause a denial of service (invalid database records) via a series of crafted comments operations.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=acb4688d29a7cc028803ee3d81edc7f1b6515c64,,,,,,,
CVE-2011-4291,https://www.cvedetails.com/cve/CVE-2011-4291/,,,DoS,2012-07-16,2012-07-16,4.0,None,Remote,Low,Single system,None,None,Partial,Moodle 2.0.x before 2.0.3 allows remote authenticated users to cause a denial of service (invalid database records) via a series of crafted ratings operations.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=34b5e856b0c98aab3f5317119093628df0834957,,,,,,,
CVE-2011-4290,https://www.cvedetails.com/cve/CVE-2011-4290/,CWE-79,,XSS,2012-07-16,2012-07-16,4.3,None,Remote,Medium,Not required,None,Partial,None,Multiple cross-site scripting (XSS) vulnerabilities in lib/weblib.php in Moodle 1.9.x before 1.9.12 allow remote attackers to inject arbitrary web script or HTML via vectors related to URL encoding.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=5a3010310bff0b3946804a72ca2d6bc166a0028f,,,,,,,
CVE-2011-4289,https://www.cvedetails.com/cve/CVE-2011-4289/,CWE-264,,+Info,2012-07-16,2012-07-16,4.0,None,Remote,Low,Single system,Partial,None,None,"Moodle 2.0.x before 2.0.3 does not recognize the configuration setting that makes e-mail addresses visible only to course members, which allows remote authenticated users to obtain sensitive address information by reading a full profile page.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=181991e791a13a3c383234718c26c499e31d3df1,,,,,,,
CVE-2011-4288,https://www.cvedetails.com/cve/CVE-2011-4288/,CWE-264,,,2012-07-16,2012-07-16,4.0,None,Remote,Low,Single system,Partial,None,None,"Moodle 1.9.x before 1.9.12 and 2.0.x before 2.0.3 does not properly implement associations between teachers and groups, which allows remote authenticated users to read quiz reports of arbitrary students by leveraging the teacher role.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=79c6e3a0968ee1fedcf8a1f14f8086fcd9dbd3f6,,,,,,,
CVE-2011-4287,https://www.cvedetails.com/cve/CVE-2011-4287/,CWE-264,,,2012-07-16,2012-07-16,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"admin/uploaduser_form.php in Moodle 2.0.x before 2.0.3 does not force password changes for autosubscribed users, which makes it easier for remote attackers to obtain access by leveraging knowledge of the initial password of a new user.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=22a77963439e00441949440f0517135b3a5418da,,,,,,,
CVE-2011-4286,https://www.cvedetails.com/cve/CVE-2011-4286/,CWE-79,,XSS,2012-07-16,2012-07-16,4.3,None,Remote,Medium,Not required,None,Partial,None,Multiple cross-site scripting (XSS) vulnerabilities in the media-filter implementation in filter/mediaplugin/filter.php in Moodle 1.9.x before 1.9.11 and 2.0.x before 2.0.2 allow remote attackers to inject arbitrary web script or HTML via vectors involving (1) Flash Video (aka FLV) files and (2) YouTube videos.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=8f81bfd412c6b2e93a5b15711727d5cb7cc78336,,,,,,,
CVE-2011-4285,https://www.cvedetails.com/cve/CVE-2011-4285/,CWE-264,,,2012-07-16,2012-07-16,5.5,None,Remote,Low,Single system,None,Partial,Partial,"The default configuration of Moodle 2.0.x before 2.0.2 has an incorrect setting of the moodle/course:delete capability, which allows remote authenticated users to delete arbitrary courses by leveraging the teacher role.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=5cfe8aecb8b78e343ded38ba9e7a0a859887d21c,,,,,,,
CVE-2011-4284,https://www.cvedetails.com/cve/CVE-2011-4284/,CWE-200,,+Info,2012-07-16,2012-07-16,5.0,None,Remote,Low,Not required,Partial,None,None,Moodle 2.0.x before 2.0.2 allows remote attackers to obtain sensitive information from a myprofile (aka My profile) block by visiting a user-context page.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=0ab727fb35e5ae1d8316d96c6752ee9ebec4c185,,,,,,,
CVE-2011-4283,https://www.cvedetails.com/cve/CVE-2011-4283/,CWE-200,,+Info,2012-07-16,2012-07-16,5.0,None,Remote,Low,Not required,Partial,None,None,"Moodle 1.9.x before 1.9.11 and 2.0.x before 2.0.2 places an IMS enterprise enrolment file in the course-files area, which allows remote attackers to obtain sensitive information via a request for imsenterprise-enrol.xml.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=6fde0dac702b3d0954bd1c34d427944e9cd89ae6,,,,,,,
CVE-2011-4282,https://www.cvedetails.com/cve/CVE-2011-4282/,CWE-79,,XSS,2012-07-16,2012-07-16,4.3,None,Remote,Medium,Not required,None,Partial,None,Multiple cross-site scripting (XSS) vulnerabilities in the course-tags functionality in tag/coursetags_more.php in Moodle 2.0.x before 2.0.2 allow remote attackers to inject arbitrary web script or HTML via the (1) sort or (2) show parameter.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=73de6fa06f6923278950a445bd69b3fbc1e518d2,,,,,,,
CVE-2011-4281,https://www.cvedetails.com/cve/CVE-2011-4281/,CWE-352,,CSRF,2012-07-16,2012-07-16,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Multiple cross-site request forgery (CSRF) vulnerabilities in Moodle 2.0.x before 2.0.2 allow remote attackers to hijack the authentication of arbitrary users for requests that mark the completion of (1) an activity or (2) a course.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=9cedb80c5d6318aa17cd66912d37e6ef3dca9455,,,,,,,
CVE-2011-4280,https://www.cvedetails.com/cve/CVE-2011-4280/,CWE-79,,XSS,2012-07-16,2012-07-16,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the Spike PHPCoverage (aka spikephpcoverage) library, as used in Moodle 2.0.x before 2.0.2 and other products, allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=bd654f0ced8af925c27b7c94321f0c299b50b38e,,,,,,,
CVE-2011-4279,https://www.cvedetails.com/cve/CVE-2011-4279/,CWE-200,,+Info,2012-07-16,2012-07-16,5.0,None,Remote,Low,Not required,Partial,None,None,"Moodle 2.0.x before 2.0.2 does not use the forceloginforprofiles setting for course-profiles access control, which makes it easier for remote attackers to obtain potentially sensitive information via vectors involving use of a search engine, as demonstrated by the search functionality of Google, Yahoo!, Wrensoft Zoom, MSN, Yandex, and AltaVista.",,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=81b58cc227cf96a1cd2e002cc210b7b3e376fd17,,,,,,,
CVE-2011-4278,https://www.cvedetails.com/cve/CVE-2011-4278/,CWE-79,,XSS,2012-07-16,2012-07-16,4.3,None,Remote,Medium,Not required,None,Partial,None,Cross-site scripting (XSS) vulnerability in the tag autocomplete functionality in Moodle 1.9.x before 1.9.11 and 2.0.x before 2.0.2 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=fd29b2ad1c20906da00d7e523f39bc8a0358a65b,,,,,,,
CVE-2011-4133,https://www.cvedetails.com/cve/CVE-2011-4133/,CWE-352,,CSRF,2012-07-16,2012-07-16,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,Cross-site request forgery (CSRF) vulnerability in Moodle 1.9.x before 1.9.11 allows remote attackers to hijack the authentication of unspecified victims for requests that modify an RSS feed in an RSS block.,,moodle,http://git.moodle.org/gw?p=moodle.git;a=commit;h=8f031d5431c1204197b1482fd6c63bc87a19a476,,,,,,,
CVE-2016-10218,https://www.cvedetails.com/cve/CVE-2016-10218/,CWE-476,,DoS,2017-04-03,2017-04-10,4.3,None,Remote,Medium,Not required,None,None,Partial,"The pdf14_pop_transparency_group function in base/gdevp14.c in the PDF Transparency module in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted file.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=d621292fb2c8157d9899dcd83fd04dd250e30fe4,,,,,,,
CVE-2016-10217,https://www.cvedetails.com/cve/CVE-2016-10217/,CWE-416,,DoS,2017-04-03,2017-04-10,4.3,None,Remote,Medium,Not required,None,None,Partial,"The pdf14_open function in base/gdevp14.c in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted file that is mishandled in the color management module.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=90fd0c7ca3efc1ddff64a86f4104b13b3ac969eb,,,,,,,
CVE-2016-10214,https://www.cvedetails.com/cve/CVE-2016-10214/,CWE-399,,DoS,2017-03-20,2017-07-10,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the virgl_resource_attach_backing function in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (memory consumption) via a large number of VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING commands.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=40b0e7813325b08077b6f541b3989edb2d86d837,,,,,,,
CVE-2011-4029,https://www.cvedetails.com/cve/CVE-2011-4029/,CWE-362,,DoS,2012-07-03,2012-07-17,1.9,None,Local,Medium,Not required,Partial,None,None,"The LockServer function in os/utils.c in X.Org xserver before 1.11.2 allows local users to change the permissions of arbitrary files to 444, read those files, and possibly cause a denial of service (removed execution permission) via a symlink attack on a temporary lock file.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=b67581cf825940fdf52bf2e0af4330e695d724a4,,,,,,,
CVE-2011-4028,https://www.cvedetails.com/cve/CVE-2011-4028/,CWE-59,,,2012-07-03,2012-07-17,1.2,None,Local,High,Not required,Partial,None,None,"The LockServer function in os/utils.c in X.Org xserver before 1.11.2 allows local users to determine the existence of arbitrary files via a symlink attack on a temporary lock file, which is handled differently if the file exists.",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=6ba44b91e37622ef8c146d8f2ac92d708a18ed34,,,,,,,
CVE-2016-10164,https://www.cvedetails.com/cve/CVE-2016-10164/,CWE-787,,DoS Exec Code Overflow,2017-02-01,2018-01-04,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple integer overflows in libXpm before 3.5.12, when a program requests parsing XPM extensions on a 64-bit platform, allow remote attackers to cause a denial of service (out-of-bounds write) or execute arbitrary code via (1) the number of extensions or (2) their concatenated length in a crafted XPM file, which triggers a heap-based buffer overflow.",,libXpm,https://cgit.freedesktop.org/xorg/lib/libXpm/commit/?id=d1167418f0fd02a27f617ec5afd6db053afbe185,,,,,,,
CVE-2016-10163,https://www.cvedetails.com/cve/CVE-2016-10163/,CWE-399,,DoS,2017-03-15,2017-07-10,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in the vrend_renderer_context_create_internal function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) by repeatedly creating a decode context.,,virglrenderer,https://cgit.freedesktop.org/virglrenderer/commit/?id=747a293ff6055203e529f083896b823e22523fe7,,,,,,,
CVE-2016-10155,https://www.cvedetails.com/cve/CVE-2016-10155/,CWE-399,,DoS,2017-03-15,2018-09-07,4.9,None,Local,Low,Not required,None,None,Complete,Memory leak in hw/watchdog/wdt_i6300esb.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (host memory consumption and QEMU process crash) via a large number of device unplug operations.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=eb7a20a3616085d46aa6b4b4224e15587ec67e6e,,,,,,,
CVE-2018-19478,https://www.cvedetails.com/cve/CVE-2018-19478/,CWE-20,,,2019-01-02,2019-01-11,4.3,None,Remote,Medium,Not required,None,None,Partial,"In Artifex Ghostscript before 9.26, a carefully crafted PDF file can trigger an extremely long running computation when parsing the file.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=0a7e5a1c309fa0911b892fa40996a7d55d90bace,,,,,,,
CVE-2016-10133,https://www.cvedetails.com/cve/CVE-2016-10133/,CWE-119,,Overflow,2017-03-24,2017-03-27,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Heap-based buffer overflow in the js_stackoverflow function in jsrun.c in Artifex Software, Inc. MuJS allows attackers to have unspecified impact by leveraging an error when dropping extra arguments to lightweight functions.",,ghostscript,http://git.ghostscript.com/?p=mujs.git;a=commit;h=77ab465f1c394bb77f00966cd950650f3f53cb24,,,,,,,
CVE-2009-2624,https://www.cvedetails.com/cve/CVE-2009-2624/,CWE-20,,DoS Exec Code,2010-01-29,2010-11-18,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The huft_build function in inflate.c in gzip before 1.3.13 creates a hufts (aka huffman) table that is too small, which allows remote attackers to cause a denial of service (application crash or infinite loop) or possibly execute arbitrary code via a crafted archive.  NOTE: this issue is caused by a CVE-2006-4334 regression.",,savannah,https://git.savannah.gnu.org/cgit/gzip.git/commit/?id=39a362ae9d9b007473381dba5032f4dfc1744cf2,,,,,,,
CVE-2011-3952,https://www.cvedetails.com/cve/CVE-2011-3952/,CWE-20,,DoS Exec Code,2012-08-20,2018-10-30,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The decode_init function in kmvc.c in libavcodec in FFmpeg before 0.10 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.6, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large palette size in a KMVC encoded file.",,libav,https://git.libav.org/?p=libav.git;a=commit;h=386741f887714d3e46c9e8fe577e326a7964037b,,,,,,,
CVE-2011-3951,https://www.cvedetails.com/cve/CVE-2011-3951/,CWE-119,,DoS Exec Code Overflow,2012-08-20,2012-08-21,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The dpcm_decode_frame function in dpcm.c in libavcodec in FFmpeg before 0.10 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.6, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a crafted stereo stream in a media file.",,libav,https://git.libav.org/?p=libav.git;a=commit;h=ce7aee9b733134649a6ce2fa743e51733f33e67e,,,,,,,
CVE-2011-3936,https://www.cvedetails.com/cve/CVE-2011-3936/,CWE-20,,DoS,2012-08-20,2012-10-29,4.3,None,Remote,Medium,Not required,None,None,Partial,"The dv_extract_audio function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted DV file.",,libav,https://git.libav.org/?p=libav.git;a=commitdiff;h=2d1c0dea5f6b91bec7f5fa53ec050913d851e366,,,,,,,
CVE-2011-3936,https://www.cvedetails.com/cve/CVE-2011-3936/,CWE-20,,DoS,2012-08-20,2012-10-29,4.3,None,Remote,Medium,Not required,None,None,Partial,"The dv_extract_audio function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted DV file.",,libav,https://git.libav.org/?p=libav.git;a=commit;h=635bcfccd439480003b74a665b5aa7c872c1ad6b,,,,,,,
CVE-2011-3929,https://www.cvedetails.com/cve/CVE-2011-3929/,CWE-119,,DoS Exec Code Overflow,2012-08-20,2012-10-29,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The avpriv_dv_produce_packet function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) and possibly execute arbitrary code via a crafted DV file.",,libav,https://git.libav.org/?p=libav.git;a=commit;h=635bcfccd439480003b74a665b5aa7c872c1ad6b,,,,,,,
CVE-2011-3929,https://www.cvedetails.com/cve/CVE-2011-3929/,CWE-119,,DoS Exec Code Overflow,2012-08-20,2012-10-29,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The avpriv_dv_produce_packet function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) and possibly execute arbitrary code via a crafted DV file.",,libav,https://git.libav.org/?p=libav.git;a=commitdiff;h=5a396bb3a66a61a68b80f2369d0249729bf85e04,,,,,,,
CVE-2016-9807,https://www.cvedetails.com/cve/CVE-2016-9807/,CWE-125,,DoS,2017-01-13,2018-01-04,4.3,None,Remote,Medium,Not required,None,None,Partial,The flx_decode_chunks function in gst/flx/gstflxdec.c in GStreamer before 1.10.2 allows remote attackers to cause a denial of service (invalid memory read and crash) via a crafted FLIC file.,,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=153a8ae752c90d07190ef45803422a4f71ea8bff,,,,,,,
CVE-2011-3193,https://www.cvedetails.com/cve/CVE-2011-3193/,CWE-119,,DoS Exec Code Overflow,2012-06-15,2017-08-28,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.",,harfbuzz,https://cgit.freedesktop.org/harfbuzz.old/commit/?id=81c8ef785b079980ad5b46be4fe7c7bf156dbf65,,,,,,,
CVE-2011-3193,https://www.cvedetails.com/cve/CVE-2011-3193/,CWE-119,,DoS Exec Code Overflow,2012-06-15,2017-08-28,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,"Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.",,harfbuzz,https://cgit.freedesktop.org/harfbuzz/commit/src/harfbuzz-gpos.c?id=da2c52abcd75d46929b34cad55c4fb2c8892bc08,,,,,,,
CVE-2016-0799,https://www.cvedetails.com/cve/CVE-2016-0799/,CWE-119,,DoS Overflow,2016-03-03,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=578b956fe741bf8e84055547b1e83c28dd902c73,,,,,,,
CVE-2016-0798,https://www.cvedetails.com/cve/CVE-2016-0798/,CWE-399,,DoS,2016-03-03,2017-11-20,7.8,None,Remote,Low,Not required,None,None,Complete,"Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=259b664f950c2ba66fbf4b0fe5281327904ead21,,,,,,,
CVE-2016-0797,https://www.cvedetails.com/cve/CVE-2016-0797/,,,DoS Overflow Mem. Corr.,2016-03-03,2018-01-04,5.0,None,Remote,Low,Not required,None,None,Partial,"Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=c175308407858afff3fc8c2e5e085d94d12edc7d,,,,,,,
CVE-2016-9446,https://www.cvedetails.com/cve/CVE-2016-9446/,CWE-200,,+Info,2017-01-23,2018-01-04,5.0,None,Remote,Low,Not required,Partial,None,None,"The vmnc decoder in the gstreamer does not initialize the render canvas, which allows remote attackers to obtain sensitive information as demonstrated by thumbnailing a simple 1 frame vmnc movie that does not draw to the allocated render canvas.",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe,,,,,,,
CVE-2016-9445,https://www.cvedetails.com/cve/CVE-2016-9445/,CWE-190,,DoS Overflow,2017-01-23,2018-01-04,5.0,None,Remote,Low,Not required,None,None,Partial,"Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.",,gstreamer,https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe,,,,,,,
CVE-2016-0725,https://www.cvedetails.com/cve/CVE-2016-0725/,CWE-79,,XSS,2016-02-22,2017-09-09,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the search_pagination function in course/classes/management_renderer.php in Moodle 2.8.x before 2.8.10, 2.9.x before 2.9.4, and 3.0.x before 3.0.2 allows remote attackers to inject arbitrary web script or HTML via a crafted search string.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52552,,,,,,,
CVE-2016-0724,https://www.cvedetails.com/cve/CVE-2016-0724/,CWE-264,,+Info,2016-02-22,2017-09-09,4.0,None,Remote,Low,Single system,Partial,None,None,"The (1) core_enrol_get_course_enrolment_methods and (2) enrol_self_get_instance_info web services in Moodle through 2.6.11, 2.7.x before 2.7.12, 2.8.x before 2.8.10, 2.9.x before 2.9.4, and 3.0.x before 3.0.2 do not consider the moodle/course:viewhiddencourses capability, which allows remote authenticated users to obtain sensitive information via a web-service request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-52072,,,,,,,
CVE-2016-0705,https://www.cvedetails.com/cve/CVE-2016-0705/,,,DoS Mem. Corr.,2016-03-03,2018-09-18,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=6c88c71b4e4825c7bc0489306d062d017634eb88,,,,,,,
CVE-2016-0704,https://www.cvedetails.com/cve/CVE-2016-0704/,CWE-200,,+Info,2016-03-02,2018-01-18,4.3,None,Remote,Medium,Not required,Partial,None,None,"An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=ae50d8270026edf5b3c7f8aaa0c6677462b33d97,,,,,,,
CVE-2016-0703,https://www.cvedetails.com/cve/CVE-2016-0703/,CWE-200,,+Info,2016-03-02,2018-01-18,4.3,None,Remote,Medium,Not required,Partial,None,None,"The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=ae50d8270026edf5b3c7f8aaa0c6677462b33d97,,,,,,,
CVE-2016-0702,https://www.cvedetails.com/cve/CVE-2016-0702/,CWE-200,,+Info,2016-03-03,2018-01-04,1.9,None,Local,Medium,Not required,Partial,None,None,"The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a ""CacheBleed"" attack.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=708dc2f1291e104fe4eef810bb8ffc1fae5b19c1,,,,,,,
CVE-2016-0701,https://www.cvedetails.com/cve/CVE-2016-0701/,CWE-200,,+Info,2016-02-14,2017-12-12,2.6,None,Remote,High,Not required,Partial,None,None,"The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=c5b831f21d0d29d1e517d139d9d101763f60c9a2,,,,,,,
CVE-2016-0701,https://www.cvedetails.com/cve/CVE-2016-0701/,CWE-200,,+Info,2016-02-14,2017-12-12,2.6,None,Remote,High,Not required,Partial,None,None,"The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=878e2c5b13010329c203f309ed0c8f2113f85648,,,,,,,
CVE-2016-9137,https://www.cvedetails.com/cve/CVE-2016-9137/,CWE-416,,DoS,2017-01-04,2017-11-03,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Use-after-free vulnerability in the CURLFile implementation in ext/curl/curl_file.c in PHP before 5.6.27 and 7.x before 7.0.12 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that is mishandled during __wakeup processing.,,php,https://git.php.net/?p=php-src.git;a=commit;h=0e6fe3a4c96be2d3e88389a5776f878021b4c59f,,,,,,,
CVE-2016-8674,https://www.cvedetails.com/cve/CVE-2016-8674/,CWE-416,,DoS,2017-02-15,2017-11-03,4.3,None,Remote,Medium,Not required,None,None,Partial,The pdf_to_num function in pdf-object.c in MuPDF before 1.10 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted file.,,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=1e03c06456d997435019fb3526fa2d4be7dbc6ec,,,,,,,
CVE-2016-8610,https://www.cvedetails.com/cve/CVE-2016-8610/,CWE-400,,DoS,2017-11-13,2019-07-23,5.0,None,Remote,Low,Not required,None,None,Partial,"A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=af58be768ebb690f78530f796e92b8ae5c9a4401,,,,,,,
CVE-2016-8602,https://www.cvedetails.com/cve/CVE-2016-8602/,CWE-704,,DoS Exec Code,2017-04-14,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The .sethalftone5 function in psi/zht2.c in Ghostscript before 9.21 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted Postscript document that calls .sethalftone5 with an empty operand stack.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=f5c7555c303,,,,,,,
CVE-2011-0523,https://www.cvedetails.com/cve/CVE-2011-0523/,CWE-264,,,2012-08-13,2013-12-12,1.9,None,Local,Medium,Not required,Partial,None,None,"gypsy 0.8 does not properly restrict the files that can be read while running with root privileges, which allows local users to read otherwise restricted files via unspecified vectors.",,gypsy,https://cgit.freedesktop.org/gypsy/commit/?id=40101707cddb319481133b2a137294b6b669bd16,,,,,,,
CVE-2016-7977,https://www.cvedetails.com/cve/CVE-2016-7977/,CWE-200,,Bypass +Info,2017-05-23,2018-01-18,4.3,None,Remote,Medium,Not required,Partial,None,None,Ghostscript before 9.21 might allow remote attackers to bypass the SAFER mode protection mechanism and consequently read arbitrary files via the use of the .libfile operator in a crafted postscript document.,,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=8abd22010eb4db0fb1b10e430d5f5d83e015ef70,,,,,,,
CVE-2016-7976,https://www.cvedetails.com/cve/CVE-2016-7976/,CWE-20,,Exec Code,2017-08-07,2017-11-03,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,The PS Interpreter in Ghostscript 9.18 and 9.20 allows remote attackers to execute arbitrary code via crafted userparams.,,ghostscript,http://git.ghostscript.com/?p=user/chrisl/ghostpdl.git;a=commit;h=6d444c273da5499a4cd72f21cb6d4c9a5256807d,,,,,,,
CVE-2010-4819,https://www.cvedetails.com/cve/CVE-2010-4819/,CWE-20,,DoS,2012-09-05,2012-09-13,3.6,None,Local,Low,Not required,Partial,None,Partial,"The ProcRenderAddGlyphs function in the Render extension (render/render.c) in X.Org xserver 1.7.7 and earlier allows local users to read arbitrary memory and possibly cause a denial of service (server crash) via unspecified vectors related to an ""input sanitization flaw.""",,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/render/render.c?id=5725849a1b427cd4a72b84e57f211edb35838718,,,,,,,
CVE-2015-8948,https://www.cvedetails.com/cve/CVE-2015-8948/,CWE-125,,+Info,2016-09-07,2018-10-30,5.0,None,Remote,Low,Not required,Partial,None,None,"idn in GNU libidn before 1.33 might allow remote attackers to obtain sensitive memory information by reading a zero byte as input, which triggers an out-of-bounds read.",,savannah,https://git.savannah.gnu.org/cgit/libidn.git/commit/?id=570e68886c41c2e765e6218cb317d9a9a447a041,,,,,,,
CVE-2010-4818,https://www.cvedetails.com/cve/CVE-2010-4818/,CWE-20,,DoS Exec Code,2012-09-05,2012-09-06,8.5,None,Remote,Medium,Single system,Complete,Complete,Complete,The GLX extension in X.Org xserver 1.7.7 allows remote authenticated users to cause a denial of service (server crash) and possibly execute arbitrary code via (1) a crafted request that triggers a client swap in glx/glxcmdsswap.c; or (2) a crafted length or (3) a negative value in the screen field in a request to glx/glxcmds.c.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit?id=6c69235a9dfc52e4b4e47630ff4bab1a820eb543,,,,,,,
CVE-2010-4818,https://www.cvedetails.com/cve/CVE-2010-4818/,CWE-20,,DoS Exec Code,2012-09-05,2012-09-06,8.5,None,Remote,Medium,Single system,Complete,Complete,Complete,The GLX extension in X.Org xserver 1.7.7 allows remote authenticated users to cause a denial of service (server crash) and possibly execute arbitrary code via (1) a crafted request that triggers a client swap in glx/glxcmdsswap.c; or (2) a crafted length or (3) a negative value in the screen field in a request to glx/glxcmds.c.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit?id=3f0d3f4d97bce75c1828635c322b6560a45a037f,,,,,,,
CVE-2010-4818,https://www.cvedetails.com/cve/CVE-2010-4818/,CWE-20,,DoS Exec Code,2012-09-05,2012-09-06,8.5,None,Remote,Medium,Single system,Complete,Complete,Complete,The GLX extension in X.Org xserver 1.7.7 allows remote authenticated users to cause a denial of service (server crash) and possibly execute arbitrary code via (1) a crafted request that triggers a client swap in glx/glxcmdsswap.c; or (2) a crafted length or (3) a negative value in the screen field in a request to glx/glxcmds.c.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit?id=ec9c97c6bf70b523bc500bd3adf62176f1bb33a4,,,,,,,
CVE-2016-7837,https://www.cvedetails.com/cve/CVE-2016-7837/,CWE-119,,Exec Code Overflow,2017-06-09,2017-06-16,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Buffer overflow in BlueZ 5.41 and earlier allows an attacker to execute arbitrary code via the parse_line function used in some userland utilities.,,linux kernel,https://git.kernel.org/pub/scm/bluetooth/bluez.git/commit/?id=8514068150759c1d6a46d4605d2351babfde1601,,,,,,,
CVE-2015-8873,https://www.cvedetails.com/cve/CVE-2015-8873/,CWE-20,,DoS,2016-05-16,2018-10-30,5.0,None,Remote,Low,Not required,None,None,Partial,"Stack consumption vulnerability in Zend/zend_exceptions.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to cause a denial of service (segmentation fault) via recursive method calls.",,php,https://git.php.net/?p=php-src.git;a=commit;h=4d2278143a08b7522de9471d0f014d7357c28fea,,,,,,,
CVE-2015-8868,https://www.cvedetails.com/cve/CVE-2015-8868/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2016-05-06,2018-01-04,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,Heap-based buffer overflow in the ExponentialFunction::ExponentialFunction function in Poppler before 0.40.0 allows remote attackers to cause a denial of service (memory corruption and crash) or possibly execute arbitrary code via an invalid blend mode in the ExtGState dictionary in a crafted PDF document.,,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=b3425dd3261679958cd56c0f71995c15d2124433,,,,,,,
CVE-2015-8867,https://www.cvedetails.com/cve/CVE-2015-8867/,CWE-310,,,2016-05-21,2018-01-04,5.0,None,Remote,Low,Not required,Partial,None,None,"The openssl_random_pseudo_bytes function in ext/openssl/openssl.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 incorrectly relies on the deprecated RAND_pseudo_bytes function, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",,php,https://git.php.net/?p=php-src.git;a=commit;h=16023f3e3b9c06cf677c3c980e8d574e4c162827,,,,,,,
CVE-2015-8866,https://www.cvedetails.com/cve/CVE-2015-8866/,,,,2016-05-21,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"ext/libxml/libxml.c in PHP before 5.5.22 and 5.6.x before 5.6.6, when PHP-FPM is used, does not isolate each thread from libxml_disable_entity_loader changes in other threads, which allows remote attackers to conduct XML External Entity (XXE) and XML Entity Expansion (XEE) attacks via a crafted XML document, a related issue to CVE-2015-5161.",,php,https://git.php.net/?p=php-src.git;a=commit;h=de31324c221c1791b26350ba106cc26bad23ace9,,,,,,,
CVE-2015-8838,https://www.cvedetails.com/cve/CVE-2015-8838/,CWE-284,,,2016-05-16,2016-11-30,4.3,None,Remote,Medium,Not required,None,Partial,None,"ext/mysqlnd/mysqlnd.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 uses a client SSL option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.",,php,https://git.php.net/?p=php-src.git;a=commit;h=97aa752fee61fccdec361279adbfb17a3c60f3f4,,,,,,,
CVE-2015-8818,https://www.cvedetails.com/cve/CVE-2015-8818/,CWE-20,,DoS,2016-12-29,2018-01-04,2.1,None,Local,Low,Not required,None,None,Partial,"The cpu_physical_memory_write_rom_internal function in exec.c in QEMU (aka Quick Emulator) does not properly skip MMIO regions, which allows local privileged guest users to cause a denial of service (guest crash) via unspecified vectors.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=b242e0e0e2969c044a318e56f7988bbd84de1f63,,,,,,,
CVE-2015-8817,https://www.cvedetails.com/cve/CVE-2015-8817/,CWE-125,,,2016-12-29,2018-01-04,2.1,None,Local,Low,Not required,None,None,Partial,QEMU (aka Quick Emulator) built to use 'address_space_translate' to map an address to a MemoryRegionSection is vulnerable to an OOB r/w access issue. It could occur while doing pci_dma_read/write calls. Affects QEMU versions >= 1.6.0 and <= 2.3.1. A privileged user inside guest could use this flaw to crash the guest instance resulting in DoS.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=23820dbfc79d1c9dce090b4c555994f2bb6a69b3,,,,,,,
CVE-2015-8817,https://www.cvedetails.com/cve/CVE-2015-8817/,CWE-125,,,2016-12-29,2018-01-04,2.1,None,Local,Low,Not required,None,None,Partial,QEMU (aka Quick Emulator) built to use 'address_space_translate' to map an address to a MemoryRegionSection is vulnerable to an OOB r/w access issue. It could occur while doing pci_dma_read/write calls. Affects QEMU versions >= 1.6.0 and <= 2.3.1. A privileged user inside guest could use this flaw to crash the guest instance resulting in DoS.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=c3c1bb99d1c11978d9ce94d1bdcf0705378c1459,,,,,,,
CVE-2015-8805,https://www.cvedetails.com/cve/CVE-2015-8805/,CWE-310,,,2016-02-23,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The ecc_256_modq function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8803.",C,lysator,https://git.lysator.liu.se/nettle/nettle/commit/c71d2c9d20eeebb985e3872e4550137209e3ce4d,c71d2c9d20eeebb985e3872e4550137209e3ce4d,549f95f88ad80e531569681cb64582c76eea6690,"@@ -113,8 +113,19 @@ ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)
       
      assert (q2 < 2);

      /* We multiply by two low limbs of p, 2^96 - 1, so we could use
         shifts rather than mul. */
      /*
         n-1 n-2 n-3 n-4
        +---+---+---+---+
        | u1| u0| u low |
        +---+---+---+---+
          - | q1(2^96-1)|
            +-------+---+
            |q2(2^.)|
            +-------+

         We multiply by two low limbs of p, 2^96 - 1, so we could use
         shifts rather than mul.
      */
      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);
      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);
      t += (-q2) & 0xffffffff;
@@ -124,7 +135,10 @@ ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)                                                                                   
      u0 -= t;
      t = (u1 < cy);
      u1 -= cy;
      u1 += cnd_add_n (t, rp + n - 4, p->m, 3);

      cy = cnd_add_n (t, rp + n - 4, p->m, 2);
      u0 += cy;
      u1 += (u0 < cy);
      u1 -= (-t) & 0xffffffff;
    }
  rp[2] = u0;
@@ -211,7 +225,7 @@ ecc_256_modq (const struct ecc_modulo *q, mp_limb_t *rp)

      /* Conditional add of p */
      u1 += t;
      u2 += (t<<32) + (u0 < t);
      u2 += (t<<32) + (u1 < t);

      t = cnd_add_n (t, rp + n - 4, q->m, 2);
      u1 += t;
",https://git.lysator.liu.se/nettle/nettle/-/blob/549f95f88ad80e531569681cb64582c76eea6690/ecc-256.c,https://git.lysator.liu.se/nettle/nettle/-/blob/c71d2c9d20eeebb985e3872e4550137209e3ce4d/ecc-256.c,,
CVE-2015-8804,https://www.cvedetails.com/cve/CVE-2015-8804/,CWE-254,,,2016-02-23,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"x86_64/ecc-384-modp.asm in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-384 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors.",,lysator,https://git.lysator.liu.se/nettle/nettle/commit/fa269b6ad06dd13c901dbd84a12e52b918a09cd7,,,,,,,
CVE-2015-8803,https://www.cvedetails.com/cve/CVE-2015-8803/,CWE-254,,,2016-02-23,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The ecc_256_modp function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8805.",,lysator,https://git.lysator.liu.se/nettle/nettle/commit/c71d2c9d20eeebb985e3872e4550137209e3ce4d,,,,,,,
CVE-2015-8745,https://www.cvedetails.com/cve/CVE-2015-8745/,CWE-284,,,2016-12-29,2017-11-03,2.1,None,Local,Low,Not required,None,None,Partial,QEMU (aka Quick Emulator) built with a VMWARE VMXNET3 paravirtual NIC emulator support is vulnerable to crash issue. It could occur while reading Interrupt Mask Registers (IMR). A privileged (CAP_SYS_RAWIO) guest user could use this flaw to crash the QEMU process instance resulting in DoS.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=c6048f849c7e3f009786df76206e895,,,,,,,
CVE-2015-8744,https://www.cvedetails.com/cve/CVE-2015-8744/,CWE-20,,,2016-12-29,2017-11-03,2.1,None,Local,Low,Not required,None,None,Partial,QEMU (aka Quick Emulator) built with a VMWARE VMXNET3 paravirtual NIC emulator support is vulnerable to crash issue. It occurs when a guest sends a Layer-2 packet smaller than 22 bytes. A privileged (CAP_SYS_RAWIO) guest user could use this flaw to crash the QEMU process instance resulting in DoS.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a7278b36fcab9af469563bd7b,,,,,,,
CVE-2016-7393,https://www.cvedetails.com/cve/CVE-2016-7393/,CWE-125,,DoS Overflow,2017-02-15,2017-02-17,4.3,None,Remote,Medium,Not required,None,None,Partial,Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.,,libav,https://git.libav.org/?p=libav.git;a=commit;h=fb1473080223a634b8ac2cca48a632d037a0a69d,,,,,,,
CVE-2015-8558,https://www.cvedetails.com/cve/CVE-2015-8558/,CWE-20,,DoS,2016-05-23,2017-11-03,4.9,None,Local,Low,Not required,None,None,Complete,The ehci_process_itd function in hw/usb/hcd-ehci.c in QEMU allows local guest OS administrators to cause a denial of service (infinite loop and CPU consumption) via a circular isochronous transfer descriptor (iTD) list.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=156a2e4dbffa85997636a7a39ef12da6f1b40254,,,,,,,
CVE-2014-0224,https://www.cvedetails.com/cve/CVE-2014-0224/,CWE-310,,+Info,2014-06-05,2019-10-09,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the ""CCS Injection"" vulnerability.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441,,,,,,,
CVE-2014-0221,https://www.cvedetails.com/cve/CVE-2014-0221/,CWE-399,,DoS,2014-06-05,2019-04-22,4.3,None,Remote,Medium,Not required,None,None,Partial,"The dtls1_get_message_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (recursion and client crash) via a DTLS hello message in an invalid DTLS handshake.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d3152655d5319ce883c8e3ac4b99f8de4c59d846,,,,,,,
CVE-2014-0218,https://www.cvedetails.com/cve/CVE-2014-0218/,CWE-79,,XSS,2014-05-26,2015-07-24,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the URL downloader repository in repository/url/lib.php in Moodle through 2.3.11, 2.4.x before 2.4.10, 2.5.x before 2.5.6, and 2.6.x before 2.6.3 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45332,,,,,,,
CVE-2014-0217,https://www.cvedetails.com/cve/CVE-2014-0217/,CWE-200,,+Info,2014-05-26,2014-05-29,4.3,None,Remote,Medium,Not required,Partial,None,None,"enrol/index.php in Moodle 2.6.x before 2.6.3 does not check for the moodle/course:viewhiddencourses capability before listing hidden courses, which allows remote attackers to obtain sensitive name and summary information about these courses by leveraging the guest role and visiting a crafted URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-45126,,,,,,,
CVE-2014-0216,https://www.cvedetails.com/cve/CVE-2014-0216/,CWE-264,,+Info,2014-05-26,2014-05-29,5.0,None,Remote,Low,Not required,Partial,None,None,"The My Home implementation in the block_html_pluginfile function in blocks/html/lib.php in Moodle through 2.3.11, 2.4.x before 2.4.10, 2.5.x before 2.5.6, and 2.6.x before 2.6.3 does not properly restrict file access, which allows remote attackers to obtain sensitive information by visiting an HTML block.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43877,,,,,,,
CVE-2014-0215,https://www.cvedetails.com/cve/CVE-2014-0215/,CWE-200,,+Info,2014-05-26,2014-05-29,4.0,None,Remote,Low,Single system,Partial,None,None,"The blind-marking implementation in Moodle through 2.3.11, 2.4.x before 2.4.10, 2.5.x before 2.5.6, and 2.6.x before 2.6.3 allows remote authenticated users to de-anonymize student identities by (1) using a screen reader or (2) reading the HTML source.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-44750,,,,,,,
CVE-2014-0214,https://www.cvedetails.com/cve/CVE-2014-0214/,CWE-287,,,2014-05-26,2014-05-29,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"login/token.php in Moodle through 2.3.11, 2.4.x before 2.4.10, 2.5.x before 2.5.6, and 2.6.x before 2.6.3 creates a MoodleMobile web-service token with an infinite lifetime, which makes it easier for remote attackers to hijack sessions via a brute-force attack.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43119,,,,,,,
CVE-2014-0213,https://www.cvedetails.com/cve/CVE-2014-0213/,CWE-352,,CSRF,2014-05-26,2014-05-29,6.8,User,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in mod/assign/locallib.php in the Assignment subsystem in Moodle through 2.3.11, 2.4.x before 2.4.10, 2.5.x before 2.5.6, and 2.6.x before 2.6.3 allow remote attackers to hijack the authentication of teachers for quick-grading requests.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-44606,,,,,,,
CVE-2016-6832,https://www.cvedetails.com/cve/CVE-2016-6832/,CWE-119,,DoS Overflow,2017-02-15,2017-02-17,4.3,None,Remote,Medium,Not required,None,None,Partial,Heap-based buffer overflow in the ff_audio_resample function in resample.c in libav before 11.4 allows remote attackers to cause a denial of service (crash) via vectors related to buffer resizing.,,libav,https://git.libav.org/?p=libav.git;a=commit;h=0ac8ff618c5e6d878c547a8877e714ed728950ce,,,,,,,
CVE-2015-8325,https://www.cvedetails.com/cve/CVE-2015-8325/,CWE-264,,+Priv,2016-04-30,2018-06-29,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"The do_setup_env function in session.c in sshd in OpenSSH through 7.2p2, when the UseLogin feature is enabled and PAM is configured to read .pam_environment files in user home directories, allows local users to gain privileges by triggering a crafted environment for the /bin/login program, as demonstrated by an LD_PRELOAD environment variable.",,mindrot,https://anongit.mindrot.org/openssh.git/commit/?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,,,,,,,
CVE-2014-0195,https://www.cvedetails.com/cve/CVE-2014-0195/,CWE-119,,DoS Exec Code Overflow,2014-06-05,2019-04-22,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The dtls1_reassemble_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly validate fragment lengths in DTLS ClientHello messages, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) via a long non-initial fragment.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1632ef744872edc2aa2a53d487d3e79c965a4ad3,,,,,,,
CVE-2015-8312,https://www.cvedetails.com/cve/CVE-2015-8312/,CWE-189,,DoS,2016-05-13,2018-05-17,7.2,None,Local,Low,Not required,Complete,Complete,Complete,Off-by-one error in afs_pioctl.c in OpenAFS before 1.6.16 might allow local users to cause a denial of service (memory overwrite and system crash) via a pioctl with an input buffer size of 4096 bytes.,,openafs,http://git.openafs.org/?p=openafs.git;a=commitdiff;h=2ef863720da4d9f368aaca0461c672a3008195ca,,,,,,,
CVE-2014-0182,https://www.cvedetails.com/cve/CVE-2014-0182/,CWE-119,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the virtio_load function in hw/virtio/virtio.c in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via a crafted config length in a savevm image.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc,,,,,,,
CVE-2014-0129,https://www.cvedetails.com/cve/CVE-2014-0129/,CWE-264,,,2014-03-24,2014-03-24,4.0,None,Remote,Low,Single system,None,Partial,None,"badges/mybadges.php in Moodle 2.5.x before 2.5.5 and 2.6.x before 2.6.2 does not properly track the user to whom a badge was issued, which allows remote authenticated users to modify the visibility of an arbitrary badge via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-44140,,,,,,,
CVE-2014-0127,https://www.cvedetails.com/cve/CVE-2014-0127/,CWE-264,,Bypass,2014-03-24,2014-03-24,4.9,None,Remote,Medium,Single system,Partial,Partial,None,"The time-validation implementation in (1) mod/feedback/complete.php and (2) mod/feedback/complete_guest.php in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 allows remote authenticated users to bypass intended restrictions on starting a Feedback activity by choosing an unavailable time.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43656,,,,,,,
CVE-2014-0126,https://www.cvedetails.com/cve/CVE-2014-0126/,CWE-352,,CSRF,2014-03-24,2014-03-24,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Cross-site request forgery (CSRF) vulnerability in enrol/imsenterprise/importnow.php in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 allows remote attackers to hijack the authentication of administrators for requests that import an IMS Enterprise file.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43146,,,,,,,
CVE-2014-0125,https://www.cvedetails.com/cve/CVE-2014-0125/,CWE-264,,Bypass,2014-03-24,2014-03-24,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"repository/alfresco/lib.php in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 places a session key in a URL, which allows remote attackers to bypass intended Alfresco Repository file restrictions by impersonating a file's owner.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-29409,,,,,,,
CVE-2014-0124,https://www.cvedetails.com/cve/CVE-2014-0124/,CWE-264,,+Info,2014-03-24,2014-03-24,4.0,None,Remote,Low,Single system,Partial,None,None,"The identity-reporting implementations in mod/forum/renderer.php and mod/quiz/override_form.php in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 do not properly restrict the display of e-mail addresses, which allows remote authenticated users to obtain sensitive information by using the (1) Forum or (2) Quiz module.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43916,,,,,,,
CVE-2016-6489,https://www.cvedetails.com/cve/CVE-2016-6489/,CWE-310,,,2017-04-14,2017-06-30,5.0,None,Remote,Low,Not required,Partial,None,None,The RSA and DSA decryption code in Nettle makes it easier for attackers to discover private keys via a cache side channel attack.,,lysator,https://git.lysator.liu.se/nettle/nettle/commit/3fe1d6549765ecfb24f0b80b2ed086fdc818bff3,,,,,,,
CVE-2014-0123,https://www.cvedetails.com/cve/CVE-2014-0123/,CWE-264,,,2014-03-24,2014-03-24,4.9,None,Remote,Medium,Single system,Partial,Partial,None,"The wiki subsystem in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 does not properly restrict (1) view and (2) edit access, which allows remote authenticated users to perform wiki operations by leveraging the student role and using the Recent Activity block to reach the individual wiki of an arbitrary student.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39990,,,,,,,
CVE-2014-0122,https://www.cvedetails.com/cve/CVE-2014-0122/,CWE-264,,Bypass,2014-03-24,2014-03-24,4.9,None,Remote,Medium,Single system,Partial,Partial,None,"mod/chat/chat_ajax.php in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2 does not properly check for the mod/chat:chat capability during chat sessions, which allows remote authenticated users to bypass intended access restrictions in opportunistic circumstances by remaining in a chat session after an intra-session capability removal by an administrator.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-44082,,,,,,,
CVE-2015-7512,https://www.cvedetails.com/cve/CVE-2015-7512/,CWE-119,,DoS Exec Code Overflow,2016-01-08,2018-01-04,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Buffer overflow in the pcnet_receive function in hw/net/pcnet.c in QEMU, when a guest NIC has a larger MTU, allows remote attackers to cause a denial of service (guest OS crash) or execute arbitrary code via a large packet.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f,,,,,,,
CVE-2018-1130,https://www.cvedetails.com/cve/CVE-2018-1130/,CWE-476,,DoS,2018-05-10,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,Linux kernel before version 4.16-rc7 is vulnerable to a null pointer dereference in dccp_write_xmit() function in net/dccp/output.c in that allows a local user to cause a denial of service by a number of certain crafted system calls.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=67f93df79aeefc3add4e4b31a752600f834236e2,,,,,,,
CVE-2014-0076,https://www.cvedetails.com/cve/CVE-2014-0076/,CWE-310,,,2014-03-25,2017-12-15,1.9,None,Local,Medium,Not required,Partial,None,None,"The Montgomery ladder implementation in OpenSSL through 1.0.0l does not ensure that certain swap operations have a constant-time behavior, which makes it easier for local users to obtain ECDSA nonces via a FLUSH+RELOAD cache side-channel attack.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2198be3483259de374f91e57d247d0fc667aef29,,,,,,,
CVE-2018-1120,https://www.cvedetails.com/cve/CVE-2018-1120/,CWE-119,,DoS Overflow,2018-06-20,2019-10-09,3.5,None,Remote,Medium,Single system,None,None,Partial,"A flaw was found affecting the Linux kernel before version 4.17. By mmap()ing a FUSE-backed file onto a process's memory containing command line arguments (or environment strings), an attacker can cause utilities from psutils or procps (such as ps, w) or any other program which makes a read() call to the /proc/<pid>/cmdline (or /proc/<pid>/environ) files to block indefinitely (denial of service) or for some controlled time (as a synchronization primitive for other attacks).",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7f7ccc2ccc2e70c6054685f5e3522efa81556830,,,,,,,
CVE-2018-1116,https://www.cvedetails.com/cve/CVE-2018-1116/,CWE-200,,+Info,2018-07-10,2019-10-09,3.6,None,Local,Low,Not required,Partial,None,Partial,A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.,,polkit,https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364,,,,,,,
CVE-2018-1115,https://www.cvedetails.com/cve/CVE-2018-1115/,,,,2018-05-10,2019-10-09,6.4,None,Remote,Low,Not required,None,Partial,Partial,"postgresql before versions 10.4, 9.6.9 is vulnerable in the adminpack extension, the pg_catalog.pg_logfile_rotate() function doesn't follow the same ACLs than pg_rorate_logfile. If the adminpack is added to a database, an attacker able to connect to it could exploit this to force log rotation.",,postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=7b34740,,,,,,,
CVE-2018-1095,https://www.cvedetails.com/cve/CVE-2018-1095/,CWE-476,,DoS,2018-04-01,2018-10-31,7.1,None,Remote,Medium,Not required,None,None,Complete,"The ext4_xattr_check_entries function in fs/ext4/xattr.c in the Linux kernel through 4.15.15 does not properly validate xattr sizes, which causes misinterpretation of a size as an error code, and consequently allows attackers to cause a denial of service (get_acl NULL pointer dereference and system crash) via a crafted ext4 image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?id=ce3fd194fcc6fbdc00ce095a852f22df97baa401,,,,,,,
CVE-2018-1094,https://www.cvedetails.com/cve/CVE-2018-1094/,CWE-476,,DoS,2018-04-01,2018-10-31,7.1,None,Remote,Medium,Not required,None,None,Complete,"The ext4_fill_super function in fs/ext4/super.c in the Linux kernel through 4.15.15 does not always initialize the crc32c checksum driver, which allows attackers to cause a denial of service (ext4_xattr_inode_hash NULL pointer dereference and system crash) via a crafted ext4 image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?id=18db4b4e6fc31eda838dd1c1296d67dbcb3dc957,,,,,,,
CVE-2018-1094,https://www.cvedetails.com/cve/CVE-2018-1094/,CWE-476,,DoS,2018-04-01,2018-10-31,7.1,None,Remote,Medium,Not required,None,None,Complete,"The ext4_fill_super function in fs/ext4/super.c in the Linux kernel through 4.15.15 does not always initialize the crc32c checksum driver, which allows attackers to cause a denial of service (ext4_xattr_inode_hash NULL pointer dereference and system crash) via a crafted ext4 image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?id=a45403b51582a87872927a3e0fc0a389c26867f1,,,,,,,
CVE-2018-1093,https://www.cvedetails.com/cve/CVE-2018-1093/,CWE-125,,DoS,2018-04-01,2018-08-29,7.1,None,Remote,Medium,Not required,None,None,Complete,The ext4_valid_block_bitmap function in fs/ext4/balloc.c in the Linux kernel through 4.15.15 allows attackers to cause a denial of service (out-of-bounds read and system crash) via a crafted ext4 image because balloc.c and ialloc.c do not validate bitmap block numbers.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?id=7dac4a1726a9c64a517d595c40e95e2d0d135f6f,,,,,,,
CVE-2018-1092,https://www.cvedetails.com/cve/CVE-2018-1092/,CWE-476,,DoS,2018-04-01,2018-10-31,7.1,None,Remote,Medium,Not required,None,None,Complete,"The ext4_iget function in fs/ext4/inode.c in the Linux kernel through 4.15.15 mishandles the case of a root directory with a zero i_links_count, which allows attackers to cause a denial of service (ext4_process_freed_data NULL pointer dereference and OOPS) via a crafted ext4 image.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?id=8e4b5eae5decd9dfe5a4ee369c22028f90ab4c44,,,,,,,
CVE-2014-0010,https://www.cvedetails.com/cve/CVE-2014-0010/,CWE-352,,CSRF,2014-01-20,2016-04-06,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in user/profile/index.php in Moodle through 2.2.11, 2.3.x before 2.3.11, 2.4.x before 2.4.8, 2.5.x before 2.5.4, and 2.6.x before 2.6.1 allow remote attackers to hijack the authentication of administrators for requests that delete (1) categories or (2) fields.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-42883,,,,,,,
CVE-2018-1082,https://www.cvedetails.com/cve/CVE-2018-1082/,CWE-287,,,2018-04-04,2019-10-09,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"A flaw was found in Moodle 3.4 to 3.4.1, and 3.3 to 3.3.4. If a user account using OAuth2 authentication method was once confirmed but later suspended, the user could still login to the site.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-60101,,,,,,,
CVE-2014-0009,https://www.cvedetails.com/cve/CVE-2014-0009/,CWE-264,,,2014-01-20,2014-02-21,5.5,None,Remote,Low,Single system,Partial,Partial,None,"course/loginas.php in Moodle through 2.2.11, 2.3.x before 2.3.11, 2.4.x before 2.4.8, 2.5.x before 2.5.4, and 2.6.x before 2.6.1 does not enforce the moodle/site:accessallgroups capability requirement for outside-group users in a SEPARATEGROUPS configuration, which allows remote authenticated users to perform ""login as"" actions via a direct request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-42643,,,,,,,
CVE-2018-1081,https://www.cvedetails.com/cve/CVE-2018-1081/,CWE-388,,,2018-04-04,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,"A flaw was found in Moodle 3.4 to 3.4.1, 3.3 to 3.3.4, 3.2 to 3.2.7, 3.1 to 3.1.10 and earlier unsupported versions. Unauthenticated users can trigger custom messages to admin via paypal enrol script. Paypal IPN callback script should only send error emails to admin after request origin was verified, otherwise admin email can be spammed.",,moodle,https://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-61392,,,,,,,
CVE-2014-0008,https://www.cvedetails.com/cve/CVE-2014-0008/,CWE-255,,+Info,2014-01-20,2014-02-21,4.0,None,Remote,Low,Single system,Partial,None,None,"lib/adminlib.php in Moodle through 2.3.11, 2.4.x before 2.4.8, 2.5.x before 2.5.4, and 2.6.x before 2.6.1 logs cleartext passwords, which allows remote authenticated administrators to obtain sensitive information by reading the Config Changes Report.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-36721,,,,,,,
CVE-2018-1068,https://www.cvedetails.com/cve/CVE-2018-1068/,CWE-787,,,2018-03-16,2019-05-14,7.2,None,Local,Low,Not required,Complete,Complete,Complete,A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b71812168571fa55e44cdd0254471331b9c4c4c6,,,,,,,
CVE-2015-6527,https://www.cvedetails.com/cve/CVE-2015-6527/,CWE-17,,Exec Code,2016-01-19,2016-01-21,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,The php_str_replace_in_subject function in ext/standard/string.c in PHP 7.x before 7.0.0 allows remote attackers to execute arbitrary code via a crafted value in the third argument to the str_ireplace function.,,php,https://git.php.net/?p=php-src.git;a=commit;h=6aeee47b2cd47915ccfa3b41433a3f57aea24dd5,,,,,,,
CVE-2013-7341,https://www.cvedetails.com/cve/CVE-2013-7341/,CWE-79,,XSS,2014-03-24,2014-03-24,4.3,None,Remote,Medium,Not required,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in Flowplayer Flash before 3.2.17, as used in Moodle through 2.3.11, 2.4.x before 2.4.9, 2.5.x before 2.5.5, and 2.6.x before 2.6.2, allow remote attackers to inject arbitrary web script or HTML by (1) providing a crafted playerId or (2) referencing an external domain, a related issue to CVE-2013-7342.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-43344,,,,,,,
CVE-2013-7328,https://www.cvedetails.com/cve/CVE-2013-7328/,CWE-189,,DoS +Info,2014-02-18,2014-03-08,5.8,None,Remote,Medium,Not required,Partial,None,Partial,"Multiple integer signedness errors in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allow remote attackers to cause a denial of service (application crash) or obtain sensitive information via an imagecrop function call with a negative value for the (1) x or (2) y dimension, a different vulnerability than CVE-2013-7226.",,php,https://git.php.net/?p=php-src.git;a=commit;h=8f4a5373bb71590352fd934028d6dde5bc18530b,,,,,,,
CVE-2013-7327,https://www.cvedetails.com/cve/CVE-2013-7327/,CWE-20,,DoS,2014-02-18,2016-09-21,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 does not check return values, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via invalid imagecrop arguments that lead to use of a NULL pointer as a return value, a different vulnerability than CVE-2013-7226.",,php,https://git.php.net/?p=php-src.git;a=commit;h=8f4a5373bb71590352fd934028d6dde5bc18530b,,,,,,,
CVE-2015-5590,https://www.cvedetails.com/cve/CVE-2015-5590/,CWE-119,,DoS Overflow,2016-01-19,2017-11-03,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Stack-based buffer overflow in the phar_fix_filepath function in ext/phar/phar.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large length value, as demonstrated by mishandling of an e-mail attachment by the imap PHP extension.",,php,https://git.php.net/?p=php-src.git;a=commit;h=6dedeb40db13971af45276f80b5375030aa7e76f,,,,,,,
CVE-2015-5589,https://www.cvedetails.com/cve/CVE-2015-5589/,CWE-20,,DoS,2016-05-16,2017-11-03,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The phar_convert_to_other function in ext/phar/phar_object.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 does not validate a file pointer before a close operation, which allows remote attackers to cause a denial of service (segmentation fault) or possibly have unspecified other impact via a crafted TAR archive that is mishandled in a Phar::convertToData call.",,php,https://git.php.net/?p=php-src.git;a=commit;h=bf58162ddf970f63502837f366930e44d6a992cf,,,,,,,
CVE-2015-5479,https://www.cvedetails.com/cve/CVE-2015-5479/,CWE-189,,DoS,2016-04-19,2018-10-30,4.3,None,Remote,Medium,Not required,None,None,Partial,The ff_h263_decode_mba function in libavcodec/ituh263dec.c in Libav before 11.5 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a file with crafted dimensions.,,libav,https://git.libav.org/?p=libav.git;a=commitdiff;h=0a49a62f998747cfa564d98d36a459fe70d3299b,,,,,,,
CVE-2013-7296,https://www.cvedetails.com/cve/CVE-2013-7296/,CWE-119,,DoS Overflow,2014-01-25,2017-08-28,5.0,None,Remote,Low,Not required,None,None,Partial,"The JBIG2Stream::readSegments method in JBIG2Stream.cc in Poppler before 0.24.5 does not use the correct specifier within a format string, which allows context-dependent attackers to cause a denial of service (segmentation fault and application crash) via a crafted PDF file.",,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/?id=58e04a08afee39370283c494ee2e4e392fd3b684,,,,,,,
CVE-2015-5342,https://www.cvedetails.com/cve/CVE-2015-5342/,CWE-264,,Bypass,2016-02-22,2016-03-02,4.0,None,Remote,Low,Single system,None,Partial,None,"The choice module in Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 allows remote authenticated users to bypass intended access restrictions by visiting a URL to add or delete responses in the closed state.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51569,,,,,,,
CVE-2015-5341,https://www.cvedetails.com/cve/CVE-2015-5341/,CWE-264,,Bypass,2016-02-22,2016-03-02,4.0,None,Remote,Low,Single system,Partial,None,None,"mod_scorm in Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 mishandles availability dates, which allows remote authenticated users to bypass intended access restrictions and read SCORM contents via unspecified vectors.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50837,,,,,,,
CVE-2015-5340,https://www.cvedetails.com/cve/CVE-2015-5340/,CWE-264,,+Info,2016-02-22,2016-03-02,4.0,None,Remote,Low,Single system,Partial,None,None,"Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 does not consider the moodle/badges:viewbadges capability, which allows remote authenticated users to obtain sensitive badge information via a request involving (1) badges/overview.php or (2) badges/view.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51684,,,,,,,
CVE-2015-5339,https://www.cvedetails.com/cve/CVE-2015-5339/,CWE-264,,+Info,2016-02-22,2016-03-02,4.0,None,Remote,Low,Single system,Partial,None,None,"The core_enrol_get_enrolled_users web service in enrol/externallib.php in Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 does not properly implement group-based access restrictions, which allows remote authenticated users to obtain sensitive course-participant information via a web-service request.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51861,,,,,,,
CVE-2015-5338,https://www.cvedetails.com/cve/CVE-2015-5338/,CWE-352,,CSRF,2016-02-22,2016-03-02,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Multiple cross-site request forgery (CSRF) vulnerabilities in the lesson module in Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 allow remote attackers to hijack the authentication of arbitrary users for requests to (1) mod/lesson/mediafile.php or (2) mod/lesson/view.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48109,,,,,,,
CVE-2015-5337,https://www.cvedetails.com/cve/CVE-2015-5337/,CWE-79,,XSS,2016-02-22,2016-03-02,4.3,None,Remote,Medium,Not required,None,Partial,None,"Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 does not properly restrict the availability of Flowplayer, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted .swf file.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48085,,,,,,,
CVE-2015-5336,https://www.cvedetails.com/cve/CVE-2015-5336/,CWE-79,,XSS,2016-02-22,2016-03-02,3.5,None,Remote,Medium,Single system,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in the survey module in Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 allow remote authenticated users to inject arbitrary web script or HTML by leveraging the student role and entering a crafted survey answer.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-49940,,,,,,,
CVE-2015-5335,https://www.cvedetails.com/cve/CVE-2015-5335/,CWE-352,,CSRF,2016-02-22,2016-03-02,4.3,None,Remote,Medium,Not required,Partial,None,None,"Cross-site request forgery (CSRF) vulnerability in admin/registration/register.php in Moodle through 2.6.11, 2.7.x before 2.7.11, 2.8.x before 2.8.9, and 2.9.x before 2.9.3 allows remote attackers to hijack the authentication of administrators for requests that send statistics to an arbitrary hub URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51091,,,,,,,
CVE-2015-5332,https://www.cvedetails.com/cve/CVE-2015-5332/,CWE-399,,DoS,2016-02-22,2016-03-02,7.1,None,Remote,Medium,Not required,None,None,Complete,Atto in Moodle 2.8.x before 2.8.9 and 2.9.x before 2.9.3 allows remote attackers to cause a denial of service (disk consumption) by leveraging the guest role and entering drafts with the editor-autosave feature.,,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51000,,,,,,,
CVE-2015-5331,https://www.cvedetails.com/cve/CVE-2015-5331/,CWE-254,,Bypass,2016-02-22,2016-03-02,4.0,None,Remote,Low,Single system,None,Partial,None,"Moodle 2.9.x before 2.9.3 does not properly check the contact list before authorizing message transmission, which allows remote authenticated users to bypass intended access restrictions and conduct spam attacks via the messaging API.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50426,,,,,,,
CVE-2015-5272,https://www.cvedetails.com/cve/CVE-2015-5272/,CWE-264,,,2016-02-22,2017-09-16,4.0,None,Remote,Low,Single system,None,Partial,None,"The Forum module in Moodle 2.7.x before 2.7.10 allows remote authenticated users to post to arbitrary groups by leveraging the teacher role, as demonstrated by a post directed to ""all participants.""",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50576,,,,,,,
CVE-2015-5269,https://www.cvedetails.com/cve/CVE-2015-5269/,CWE-79,,XSS,2016-02-22,2017-09-16,3.5,None,Remote,Medium,Single system,None,Partial,None,"Cross-site scripting (XSS) vulnerability in group/overview.php in Moodle through 2.6.11, 2.7.x before 2.7.10, 2.8.x before 2.8.8, and 2.9.x before 2.9.2 allows remote authenticated users to inject arbitrary web script or HTML via a modified grouping description.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50709,,,,,,,
CVE-2015-5268,https://www.cvedetails.com/cve/CVE-2015-5268/,CWE-264,,+Info,2016-02-22,2017-09-16,4.0,None,Remote,Low,Single system,Partial,None,None,"The rating component in Moodle through 2.6.11, 2.7.x before 2.7.10, 2.8.x before 2.8.8, and 2.9.x before 2.9.2 mishandles group-based authorization checks, which allows remote authenticated users to obtain sensitive information by reading a rating value.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50173,,,,,,,
CVE-2015-5267,https://www.cvedetails.com/cve/CVE-2015-5267/,CWE-254,,,2016-02-22,2017-09-16,5.0,None,Remote,Low,Not required,Partial,None,None,"lib/moodlelib.php in Moodle through 2.6.11, 2.7.x before 2.7.10, 2.8.x before 2.8.8, and 2.9.x before 2.9.2 relies on the PHP mt_rand function to implement the random_string and complex_random_string functions, which makes it easier for remote attackers to predict password-recovery tokens via a brute-force approach.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50860,,,,,,,
CVE-2015-5266,https://www.cvedetails.com/cve/CVE-2015-5266/,CWE-264,,,2016-02-22,2017-09-16,4.9,None,Remote,Medium,Single system,Partial,Partial,None,"The enrol_meta_sync function in enrol/meta/locallib.php in Moodle through 2.6.11, 2.7.x before 2.7.10, 2.8.x before 2.8.8, and 2.9.x before 2.9.2 allows remote authenticated users to obtain manager privileges in opportunistic circumstances by leveraging incorrect role processing during a long-running sync script.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50744,,,,,,,
CVE-2015-5265,https://www.cvedetails.com/cve/CVE-2015-5265/,CWE-264,,,2016-02-22,2017-09-16,4.0,None,Remote,Low,Single system,None,Partial,None,"The wiki component in Moodle through 2.6.11, 2.7.x before 2.7.10, 2.8.x before 2.8.8, and 2.9.x before 2.9.2 does not consider the mod/wiki:managefiles capability before authorizing file management, which allows remote authenticated users to delete arbitrary files by using a manage-files button in a text editor.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-48371,,,,,,,
CVE-2015-5264,https://www.cvedetails.com/cve/CVE-2015-5264/,CWE-264,,Bypass,2016-02-22,2017-09-16,5.5,None,Remote,Low,Single system,Partial,Partial,None,"The lesson module in Moodle through 2.6.11, 2.7.x before 2.7.10, 2.8.x before 2.8.8, and 2.9.x before 2.9.2 allows remote authenticated users to bypass intended access restrictions and enter additional answer attempts by leveraging the student role.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50516,,,,,,,
CVE-2015-4644,https://www.cvedetails.com/cve/CVE-2015-4644/,,,DoS,2016-05-16,2019-04-22,5.0,None,Remote,Low,Not required,None,None,Partial,"The php_pgsql_meta_data function in pgsql.c in the PostgreSQL (aka pgsql) extension in PHP before 5.4.42, 5.5.x before 5.5.26, and 5.6.x before 5.6.10 does not validate token extraction for table names, which might allow remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted name.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1352.",,php,https://git.php.net/?p=php-src.git;a=commit;h=2cc4e69cc6d8dbc4b3568ad3dd583324a7c11d64,,,,,,,
CVE-2015-4643,https://www.cvedetails.com/cve/CVE-2015-4643/,CWE-119,,Exec Code Overflow,2016-05-16,2019-05-10,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.42, 5.5.x before 5.5.26, and 5.6.x before 5.6.10 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-4022.",,php,https://git.php.net/?p=php-src.git;a=commit;h=0765623d6991b62ffcd93ddb6be8a5203a2fa7e2,,,,,,,
CVE-2015-4642,https://www.cvedetails.com/cve/CVE-2015-4642/,CWE-78,,Exec Code,2016-05-16,2017-09-21,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The escapeshellarg function in ext/standard/exec.c in PHP before 5.4.42, 5.5.x before 5.5.26, and 5.6.x before 5.6.10 on Windows allows remote attackers to execute arbitrary OS commands via a crafted string to an application that accepts command-line arguments for a call to the PHP system function.",,php,https://git.php.net/?p=php-src.git;a=commit;h=d2ac264ffea5ca2e85640b6736e0c7cd4ee9a4a9,,,,,,,
CVE-2015-4605,https://www.cvedetails.com/cve/CVE-2015-4605/,CWE-20,,DoS Exec Code,2016-05-16,2019-04-22,5.0,None,Remote,Low,Not required,None,None,Partial,"The mcopy function in softmagic.c in file 5.x, as used in the Fileinfo component in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8, does not properly restrict a certain offset value, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string that is mishandled by a ""Python script text executable"" rule.",,php,https://git.php.net/?p=php-src.git;a=commit;h=f938112c495b0d26572435c0be73ac0bfe642ecd,,,,,,,
CVE-2015-4604,https://www.cvedetails.com/cve/CVE-2015-4604/,CWE-20,,DoS Exec Code,2016-05-16,2019-04-22,5.0,None,Remote,Low,Not required,None,None,Partial,"The mget function in softmagic.c in file 5.x, as used in the Fileinfo component in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8, does not properly maintain a certain pointer relationship, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string that is mishandled by a ""Python script text executable"" rule.",,php,https://git.php.net/?p=php-src.git;a=commit;h=f938112c495b0d26572435c0be73ac0bfe642ecd,,,,,,,
CVE-2015-4602,https://www.cvedetails.com/cve/CVE-2015-4602/,,,DoS Exec Code,2016-05-16,2019-04-22,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The __PHP_Incomplete_Class function in ext/standard/incomplete_class.c in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via an unexpected data type, related to a ""type confusion"" issue.",,php,https://git.php.net/?p=php-src.git;a=commit;h=fb83c76deec58f1fab17c350f04c9f042e5977d1,,,,,,,
CVE-2015-4601,https://www.cvedetails.com/cve/CVE-2015-4601/,,,DoS Exec Code,2016-05-16,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"PHP before 5.6.7 might allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via an unexpected data type, related to ""type confusion"" issues in (1) ext/soap/php_encoding.c, (2) ext/soap/php_http.c, and (3) ext/soap/soap.c, a different issue than CVE-2015-4600.",,php,https://git.php.net/?p=php-src.git;a=commit;h=0c136a2abd49298b66acb0cad504f0f972f5bfe8,,,,,,,
CVE-2015-4600,https://www.cvedetails.com/cve/CVE-2015-4600/,,,DoS Exec Code,2016-05-16,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The SoapClient implementation in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via an unexpected data type, related to ""type confusion"" issues in the (1) SoapClient::__getLastRequest, (2) SoapClient::__getLastResponse, (3) SoapClient::__getLastRequestHeaders, (4) SoapClient::__getLastResponseHeaders, (5) SoapClient::__getCookies, and (6) SoapClient::__setCookie methods.",,php,https://git.php.net/?p=php-src.git;a=commit;h=0c136a2abd49298b66acb0cad504f0f972f5bfe8,,,,,,,
CVE-2015-4599,https://www.cvedetails.com/cve/CVE-2015-4599/,,,DoS Exec Code +Info,2016-05-16,2018-01-04,10.0,None,Remote,Low,Not required,Complete,Complete,Complete,"The SoapFault::__toString method in ext/soap/soap.c in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 allows remote attackers to obtain sensitive information, cause a denial of service (application crash), or possibly execute arbitrary code via an unexpected data type, related to a ""type confusion"" issue.",,php,https://git.php.net/?p=php-src.git;a=commit;h=51856a76f87ecb24fe1385342be43610fb6c86e4,,,,,,,
CVE-2016-5011,https://www.cvedetails.com/cve/CVE-2016-5011/,CWE-399,,DoS,2017-04-11,2017-04-17,4.7,None,Local,Medium,Not required,None,None,Complete,The parse_dos_extended function in partitions/dos.c in the libblkid library in util-linux allows physically proximate attackers to cause a denial of service (memory consumption) via a crafted MSDOS partition table with an extended partition boot record at zero offset.,,linux kernel,https://git.kernel.org/pub/scm/utils/util-linux/util-linux.git/commit/?id=7164a1c3,,,,,,,
CVE-2015-4116,https://www.cvedetails.com/cve/CVE-2015-4116/,,,Exec Code,2016-05-16,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Use-after-free vulnerability in the spl_ptr_heap_insert function in ext/spl/spl_heap.c in PHP before 5.5.27 and 5.6.x before 5.6.11 allows remote attackers to execute arbitrary code by triggering a failed SplMinHeap::compare operation.,,php,https://git.php.net/?p=php-src.git;a=commit;h=1cbd25ca15383394ffa9ee8601c5de4c0f2f90e1,,,,,,,
CVE-2015-3418,https://www.cvedetails.com/cve/CVE-2015-3418/,CWE-369,,DoS,2016-12-13,2018-01-29,5.0,None,Remote,Low,Not required,None,None,Partial,The ProcPutImage function in dix/dispatch.c in X.Org Server (aka xserver and xorg-server) before 1.16.4 allows attackers to cause a denial of service (divide-by-zero and crash) via a zero-height PutImage request.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=dc777c346d5d452a53b13b917c45f6a1bad2f20b,,,,,,,
CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,,Bypass,2016-05-16,2019-04-22,5.0,None,Remote,Low,Not required,Partial,None,None,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",,php,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,,,,,,,
CVE-2015-3411,https://www.cvedetails.com/cve/CVE-2015-3411/,CWE-20,,Bypass,2016-05-16,2019-04-22,6.4,None,Remote,Low,Not required,Partial,Partial,None,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",,php,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,,,,,,,
CVE-2015-3275,https://www.cvedetails.com/cve/CVE-2015-3275/,CWE-79,,XSS,2016-02-22,2017-09-21,4.3,None,Remote,Medium,Not required,None,Partial,None,"Multiple cross-site scripting (XSS) vulnerabilities in the SCORM module in Moodle through 2.6.11, 2.7.x before 2.7.9, 2.8.x before 2.8.7, and 2.9.x before 2.9.1 allow remote attackers to inject arbitrary web script or HTML via a crafted organization name to (1) mod/scorm/player.php or (2) mod/scorm/prereqs.php.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50614,,,,,,,
CVE-2015-3274,https://www.cvedetails.com/cve/CVE-2015-3274/,CWE-79,,XSS,2016-02-22,2017-09-21,4.3,None,Remote,Medium,Not required,None,Partial,None,"Cross-site scripting (XSS) vulnerability in the user_get_user_details function in user/lib.php in Moodle through 2.6.11, 2.7.x before 2.7.9, 2.8.x before 2.8.7, and 2.9.x before 2.9.1 allows remote attackers to inject arbitrary web script or HTML by leveraging absence of an external_format_text call in a web service.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50130,,,,,,,
CVE-2015-3273,https://www.cvedetails.com/cve/CVE-2015-3273/,CWE-264,,Bypass,2016-02-22,2017-09-21,4.0,None,Remote,Low,Single system,None,Partial,None,"mod/forum/post.php in Moodle 2.9.x before 2.9.1 does not consider the mod/forum:canposttomygroups capability before authorizing ""Post a copy to all groups"" actions, which allows remote authenticated users to bypass intended access restrictions by leveraging per-group authorization.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50220,,,,,,,
CVE-2015-3272,https://www.cvedetails.com/cve/CVE-2015-3272/,,,,2016-02-22,2017-09-21,5.8,None,Remote,Medium,Not required,Partial,Partial,None,"Open redirect vulnerability in the clean_param function in lib/moodlelib.php in Moodle through 2.6.11, 2.7.x before 2.7.9, 2.8.x before 2.8.7, and 2.9.x before 2.9.1 allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via vectors involving an HTTP Referer header that has a substring match with a local URL.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-50688,,,,,,,
CVE-2015-3197,https://www.cvedetails.com/cve/CVE-2015-3197/,CWE-310,,,2016-02-14,2017-11-20,4.3,None,Remote,Medium,Not required,Partial,None,None,"ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=d81a1600588b726c2bdccda7efad3cc7a87d6245,,,,,,,
CVE-2015-3146,https://www.cvedetails.com/cve/CVE-2015-3146/,,,DoS,2016-04-13,2016-04-20,5.0,None,Remote,Low,Not required,None,None,Partial,"The (1) SSH_MSG_NEWKEYS and (2) SSH_MSG_KEXDH_REPLY packet handlers in package_cb.c in libssh before 0.6.5 do not properly validate state, which allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted SSH packet.",C,libssh,https://git.libssh.org/projects/libssh.git/commit/?h=libssh-0.6.5&id=94f6955fbaee6fda9385a23e505497efe21f5b4f,94f6955fbaee6fda9385a23e505497efe21f5b4f,d2a990a68ea555d7003edc94eb076356604facea,"@@ -94,7 +94,7 @@ SSH_PACKET_CALLBACK(ssh_packet_dh_reply){
   (void)type;
   (void)user;
   SSH_LOG(SSH_LOG_PROTOCOL,""Received SSH_KEXDH_REPLY"");
-  if(session->session_state!= SSH_SESSION_STATE_DH &&
+  if (session->session_state != SSH_SESSION_STATE_DH ||
 		session->dh_handshake_state != DH_STATE_INIT_SENT){
 	ssh_set_error(session,SSH_FATAL,""ssh_packet_dh_reply called in wrong state : %d:%d"",
 			session->session_state,session->dh_handshake_state);
@@ -135,12 +135,16 @@ SSH_PACKET_CALLBACK(ssh_packet_newkeys){
   (void)user;
   (void)type;
   SSH_LOG(SSH_LOG_PROTOCOL, ""Received SSH_MSG_NEWKEYS"");
-  if(session->session_state!= SSH_SESSION_STATE_DH &&
-		session->dh_handshake_state != DH_STATE_NEWKEYS_SENT){
-	ssh_set_error(session,SSH_FATAL,""ssh_packet_newkeys called in wrong state : %d:%d"",
-			session->session_state,session->dh_handshake_state);
-	goto error;
+
+  if (session->session_state != SSH_SESSION_STATE_DH ||
+      session->dh_handshake_state != DH_STATE_NEWKEYS_SENT) {
+      ssh_set_error(session,
+                    SSH_FATAL,
+                    ""ssh_packet_newkeys called in wrong state : %d:%d"",
+                    session->session_state,session->dh_handshake_state);
+      goto error;
   }
+
   if(session->server){
     /* server things are done in server.c */
     session->dh_handshake_state=DH_STATE_FINISHED;",https://git.libssh.org/projects/libssh.git/tree/src/packet_cb.c?h=libssh-0.6.5&id=d2a990a68ea555d7003edc94eb076356604facea,https://git.libssh.org/projects/libssh.git/tree/src/packet_cb.c?h=libssh-0.6.5&id=94f6955fbaee6fda9385a23e505497efe21f5b4f,,
CVE-2015-3146,https://www.cvedetails.com/cve/CVE-2015-3146/,,,DoS,2016-04-13,2016-04-20,5.0,None,Remote,Low,Not required,None,None,Partial,"The (1) SSH_MSG_NEWKEYS and (2) SSH_MSG_KEXDH_REPLY packet handlers in package_cb.c in libssh before 0.6.5 do not properly validate state, which allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted SSH packet.",C,libssh,https://git.libssh.org/projects/libssh.git/commit/?h=libssh-0.6.5&id=94f6955fbaee6fda9385a23e505497efe21f5b4f,94f6955fbaee6fda9385a23e505497efe21f5b4f,d2a990a68ea555d7003edc94eb076356604facea,"@@ -165,7 +165,7 @@ static int ssh_server_kexdh_init(ssh_session session, ssh_buffer packet){
 }
 
 SSH_PACKET_CALLBACK(ssh_packet_kexdh_init){
-  int rc;
+  int rc = SSH_ERROR;
   (void)type;
   (void)user;
 
@@ -193,9 +193,11 @@ SSH_PACKET_CALLBACK(ssh_packet_kexdh_init){
         ssh_set_error(session,SSH_FATAL,""Wrong kex type in ssh_packet_kexdh_init"");
         rc = SSH_ERROR;
   }
-  if (rc == SSH_ERROR)
+
+error:
+  if (rc == SSH_ERROR) {
       session->session_state = SSH_SESSION_STATE_ERROR;
-  error:
+  }
 
   return SSH_PACKET_USED;
 }",https://git.libssh.org/projects/libssh.git/tree/src/server.c?h=libssh-0.6.5&id=d2a990a68ea555d7003edc94eb076356604facea,https://git.libssh.org/projects/libssh.git/tree/src/server.c?h=libssh-0.6.5&id=94f6955fbaee6fda9385a23e505497efe21f5b4f,,
CVE-2018-0739,https://www.cvedetails.com/cve/CVE-2018-0739/,CWE-400,,DoS,2018-03-27,2019-04-23,4.3,None,Remote,Medium,Not required,None,None,Partial,Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=9310d45087ae546e27e61ddf8f6367f29848220d,,,,,,,
CVE-2018-0739,https://www.cvedetails.com/cve/CVE-2018-0739/,CWE-400,,DoS,2018-03-27,2019-04-23,4.3,None,Remote,Medium,Not required,None,None,Partial,Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2ac4c6f7b2b2af20c0e2b0ba05367e454cd11b33,,,,,,,
CVE-2018-0737,https://www.cvedetails.com/cve/CVE-2018-0737/,CWE-327,,,2018-04-16,2019-10-02,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=6939eab03a6e23d2bd2c3f5e34fe1d48e542e787,,,,,,,
CVE-2018-0737,https://www.cvedetails.com/cve/CVE-2018-0737/,CWE-327,,,2018-04-16,2019-10-02,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=349a41da1ad88ad87825414752a8ff5fdd6a6c3f,,,,,,,
CVE-2018-0735,https://www.cvedetails.com/cve/CVE-2018-0735/,CWE-320,,,2018-10-29,2019-07-23,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=56fb454d281a023b3f950d969693553d3f3ceea1,,,,,,,
CVE-2018-0735,https://www.cvedetails.com/cve/CVE-2018-0735/,CWE-320,,,2018-10-29,2019-07-23,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=b1d6d55ece1c26fa2829e2b819b038d7b6d692b4,,,,,,,
CVE-2018-0734,https://www.cvedetails.com/cve/CVE-2018-0734/,CWE-320,,,2018-10-30,2019-06-11,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=8abfe72e8c1de1b95f50aa0d9134803b4d00070f,,,,,,,
CVE-2018-0734,https://www.cvedetails.com/cve/CVE-2018-0734/,CWE-320,,,2018-10-30,2019-06-11,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=43e6a58d4991a451daf4891ff05a48735df871ac,,,,,,,
CVE-2018-0734,https://www.cvedetails.com/cve/CVE-2018-0734/,CWE-320,,,2018-10-30,2019-06-11,4.3,None,Remote,Medium,Not required,Partial,None,None,The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ef11e19d1365eea2b1851e6f540a0bf365d303e7,,,,,,,
CVE-2018-0733,https://www.cvedetails.com/cve/CVE-2018-0733/,CWE-20,,,2018-03-27,2019-04-23,4.3,None,Remote,Medium,Not required,None,Partial,None,"Because of an implementation bug the PA-RISC CRYPTO_memcmp function is effectively reduced to only comparing the least significant bit of each byte. This allows an attacker to forge messages that would be considered as authenticated in an amount of tries lower than that guaranteed by the security claims of the scheme. The module can only be compiled by the HP-UX assembler, so that only HP-UX PA-RISC targets are affected. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g).",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=56d5a4bfcaf37fa420aef2bb881aa55e61cf5f2f,,,,,,,
CVE-2018-0732,https://www.cvedetails.com/cve/CVE-2018-0732/,CWE-320,,DoS,2018-06-12,2019-05-30,5.0,None,Remote,Low,Not required,None,None,Partial,During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=3984ef0b72831da8b3ece4745cac4f8575b19098,,,,,,,
CVE-2018-0732,https://www.cvedetails.com/cve/CVE-2018-0732/,CWE-320,,DoS,2018-06-12,2019-05-30,5.0,None,Remote,Low,Not required,None,None,Partial,During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ea7abeeabf92b7aca160bdd0208636d4da69f4f4,,,,,,,
CVE-2013-6462,https://www.cvedetails.com/cve/CVE-2013-6462/,CWE-119,,DoS Exec Code Overflow,2014-01-09,2017-08-28,9.3,None,Remote,Medium,Not required,Complete,Complete,Complete,Stack-based buffer overflow in the bdfReadCharacters function in bitmap/bdfread.c in X.Org libXfont 1.1 through 1.4.6 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a long string in a character name in a BDF font file.,,libxfont,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=4d024ac10f964f6bd372ae0dd14f02772a6e5f63,,,,,,,
CVE-2013-6450,https://www.cvedetails.com/cve/CVE-2013-6450/,CWE-310,,DoS,2014-01-01,2018-10-09,5.8,None,Remote,Medium,Not required,None,Partial,Partial,"The DTLS retransmission implementation in OpenSSL 1.0.0 before 1.0.0l and 1.0.1 before 1.0.1f does not properly maintain data structures for digest and encryption contexts, which might allow man-in-the-middle attackers to trigger the use of a different context and cause a denial of service (application crash) by interfering with packet delivery, related to ssl/d1_both.c and ssl/t1_enc.c.",,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=34628967f1e65dc8f34e000f0f5518e21afbfc7b,,,,,,,
CVE-2013-6425,https://www.cvedetails.com/cve/CVE-2013-6425/,CWE-189,,DoS,2014-01-18,2014-03-05,5.0,None,Remote,Low,Not required,None,None,Partial,"Integer underflow in the pixman_trapezoid_valid macro in pixman.h in Pixman before 0.32.0, as used in X.Org server and cairo, allows context-dependent attackers to cause a denial of service (crash) via a negative bottom value.",,pixman,https://cgit.freedesktop.org/pixman/commit/?id=5e14da97f16e421d084a9e735be21b1025150f0c,,,,,,,
CVE-2013-6399,https://www.cvedetails.com/cve/CVE-2013-6399/,CWE-94,,Exec Code,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Array index error in the virtio_load function in hw/virtio/virtio.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted savevm image.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4b53c2c72cb5541cf394033b528a6fe2a86c0ac1,,,,,,,
CVE-2014-9771,https://www.cvedetails.com/cve/CVE-2014-9771/,,,DoS Overflow,2016-05-13,2016-11-30,5.0,None,Remote,Low,Not required,None,None,Partial,"Integer overflow in imlib2 before 1.4.7 allows remote attackers to cause a denial of service (memory consumption or application crash) via a crafted image, which triggers an invalid read operation.",,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?id=143f299,,,,,,,
CVE-2014-9766,https://www.cvedetails.com/cve/CVE-2014-9766/,CWE-189,,DoS Exec Code Overflow,2016-04-13,2016-12-02,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Integer overflow in the create_bits function in pixman-bits-image.c in Pixman before 0.32.6 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via large height and stride values.,,pixman,https://cgit.freedesktop.org/pixman/commit/?id=857e40f3d2bc2cfb714913e0cd7e6184cf69aca3,,,,,,,
CVE-2014-9764,https://www.cvedetails.com/cve/CVE-2014-9764/,CWE-20,,DoS,2016-05-13,2017-06-30,5.0,None,Remote,Low,Not required,None,None,Partial,imlib2 before 1.4.7 allows remote attackers to cause a denial of service (segmentation fault) via a crafted GIF file.,,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?h=v1.4.7&id=1f9b0b32728803a1578e658cd0955df773e34f49,,,,,,,
CVE-2014-9763,https://www.cvedetails.com/cve/CVE-2014-9763/,CWE-189,,DoS,2016-05-13,2017-06-30,5.0,None,Remote,Low,Not required,None,None,Partial,imlib2 before 1.4.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted PNM file.,,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?h=v1.4.7&id=c21beaf1780cf3ca291735ae7d58a3dde63277a2,,,,,,,
CVE-2014-9762,https://www.cvedetails.com/cve/CVE-2014-9762/,CWE-20,,DoS,2016-05-13,2017-06-30,5.0,None,Remote,Low,Not required,None,None,Partial,imlib2 before 1.4.7 allows remote attackers to cause a denial of service (segmentation fault) via a GIF image without a colormap.,,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?h=v1.4.7&id=39641e74a560982fbf93f29bf96b37d27803cb56,,,,,,,
CVE-2014-9746,https://www.cvedetails.com/cve/CVE-2014-9746/,CWE-20,,DoS,2016-06-07,2018-07-18,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The (1) t1_parse_font_matrix function in type1/t1load.c, (2) cid_parse_font_matrix function in cid/cidload.c, (3) t42_parse_font_matrix function in type42/t42parse.c, and (4) ps_parser_load_field function in psaux/psobjs.c in FreeType before 2.5.4 do not check return values, which allows remote attackers to cause a denial of service (uninitialized memory access and application crash) or possibly have unspecified other impact via a crafted font.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=8b281f83e8516535756f92dbf90940ac44bd45e1,,,,,,,
CVE-2014-0236,https://www.cvedetails.com/cve/CVE-2014-0236/,,,DoS,2016-05-16,2016-05-18,5.0,None,Remote,Low,Not required,None,None,Partial,"file before 5.18, as used in the Fileinfo component in PHP before 5.6.0, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a zero root_storage value in a CDF file, related to cdf.c and readcdf.c.",,php,https://git.php.net/?p=php-src.git;a=commit;h=f3f22ff5c697aef854ffc1918bce708b37481b0f,,,,,,,
CVE-2016-3734,https://www.cvedetails.com/cve/CVE-2016-3734/,CWE-352,,CSRF,2017-04-20,2017-04-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Cross-site request forgery (CSRF) vulnerability in markposts.php in Moodle 3.0 through 3.0.3, 2.9 through 2.9.5, 2.8 through 2.8.11, 2.7 through 2.7.13 and earlier allows remote attackers to hijack the authentication of users for requests that marks forum posts as read.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-53755,,,,,,,
CVE-2016-3733,https://www.cvedetails.com/cve/CVE-2016-3733/,CWE-284,,,2017-04-20,2017-04-28,4.0,None,Remote,Low,Single system,None,Partial,None,"The ""restore teacher"" feature in Moodle 3.0 through 3.0.3, 2.9 through 2.9.5, 2.8 through 2.8.11, 2.7 through 2.7.13, and earlier allows remote authenticated users to overwrite the course idnumber.",,moodle,http://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-51369,,,,,,,
CVE-2011-5326,https://www.cvedetails.com/cve/CVE-2011-5326/,CWE-189,,DoS,2016-05-13,2016-11-30,5.0,None,Remote,Low,Not required,None,None,Partial,imlib2 before 1.4.9 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) by drawing a 2x1 ellipse.,,enlight,https://git.enlightenment.org/legacy/imlib2.git/commit/?id=c94d83ccab15d5ef02f88d42dce38ed3f0892882,,,,,,,
CVE-2000-1254,https://www.cvedetails.com/cve/CVE-2000-1254/,CWE-310,,,2016-05-04,2017-02-01,5.0,None,Remote,Low,Not required,Partial,None,None,"crypto/rsa/rsa_gen.c in OpenSSL before 0.9.6 mishandles C bitwise-shift operations that exceed the size of an expression, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging improper RSA key generation on 64-bit HP-UX platforms.",,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=db82b8f9bd432a59aea8e1014694e15fc457c2bb,,,,,,,
CVE-2018-0496,https://www.cvedetails.com/cve/CVE-2018-0496/,CWE-22,,Dir. Trav.,2018-06-12,2018-08-07,5.0,None,Remote,Low,Not required,None,Partial,None,Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.,,savannah,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998,,,,,,,
CVE-2018-0495,https://www.cvedetails.com/cve/CVE-2018-0495/,CWE-200,,+Info,2018-06-13,2019-05-30,1.9,None,Local,Medium,Not required,Partial,None,None,"Libgcrypt before 1.7.10 and 1.8.x before 1.8.3 allows a memory-cache side-channel attack on ECDSA signatures that can be mitigated through the use of blinding during the signing process in the _gcry_ecc_ecdsa_sign function in cipher/ecc-ecdsa.c, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host.",,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=9010d1576e278a4274ad3f4aa15776c28f6ba965,,,,,,,
CVE-2018-0494,https://www.cvedetails.com/cve/CVE-2018-0494/,CWE-20,,,2018-05-06,2018-10-31,4.3,None,Remote,Medium,Not required,None,Partial,None,GNU Wget before 1.19.5 is prone to a cookie injection vulnerability in the resp_new function in http.c via a \r\n sequence in a continuation line.,,savannah,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=1fc9c95ec144499e69dc8ec76dbe07799d7d82cd,,,,,,,
CVE-2018-0493,https://www.cvedetails.com/cve/CVE-2018-0493/,CWE-416,,Exec Code Mem. Corr.,2018-04-03,2018-05-21,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"remctld in remctl before 3.14, when an attacker is authorized to execute a command that uses the sudo option, has a use-after-free that leads to a daemon crash, memory corruption, or arbitrary command execution.",Pm,eyrie,https://git.eyrie.org/?p=kerberos/remctl.git;a=commit;h=86c7e44090c988112a37589d2c7a94029eb5e641,86c7e44090c988112a37589d2c7a94029eb5e641,b3c8b2556b6a7bf912c0452830c5969f133df69c,"@@ -25,7 +25,7 @@ use DynaLoader;
 use vars qw($VERSION @EXPORT @ISA);
 
 BEGIN {
-    $VERSION = '3.13';
+    $VERSION = '3.14';
 }
 
 # use base qw(Exporter) requires Perl 5.8 and we still support Perl 5.6.",https://git.eyrie.org/?p=kerberos/remctl.git;a=blob;f=perl/lib/Net/Remctl.pm;h=38cd10c9b95232f7a4c4913ab05af0379135b867;hb=38cd10c9b95232f7a4c4913ab05af0379135b867,https://git.eyrie.org/?p=kerberos/remctl.git;a=blob;f=perl/lib/Net/Remctl.pm;h=c3a51975b92bdf61b0fc08292c1b8efc1904c691;hb=c3a51975b92bdf61b0fc08292c1b8efc1904c691,,
CVE-2018-0493,https://www.cvedetails.com/cve/CVE-2018-0493/,CWE-416,,Exec Code Mem. Corr.,2018-04-03,2018-05-21,6.5,None,Remote,Low,Single system,Partial,Partial,Partial,"remctld in remctl before 3.14, when an attacker is authorized to execute a command that uses the sudo option, has a use-after-free that leads to a daemon crash, memory corruption, or arbitrary command execution.",Pm,eyrie,https://git.eyrie.org/?p=kerberos/remctl.git;a=commit;h=86c7e44090c988112a37589d2c7a94029eb5e641,86c7e44090c988112a37589d2c7a94029eb5e641,b3c8b2556b6a7bf912c0452830c5969f133df69c,"@@ -48,7 +48,7 @@ our $VERSION;
 # This version matches the version of remctl with which this module was
 # released, but with at least two digits for the minor version.
 BEGIN {
-    $VERSION = '3.13';
+    $VERSION = '3.14';
 }
 
 # Constructor.  Takes all possible parameters as a hash.  See the POD",https://git.eyrie.org/?p=kerberos/remctl.git;a=blob;f=perl/lib/Net/Remctl/Backend.pm;h=3bcfdfc9578476d12beeb67a4cc2c5029d2f0ff9;hb=3bcfdfc9578476d12beeb67a4cc2c5029d2f0ff9,https://git.eyrie.org/?p=kerberos/remctl.git;a=blob;f=perl/lib/Net/Remctl/Backend.pm;h=7eff50ec0af65bbd978e2b66ed146c5818f69061;hb=7eff50ec0af65bbd978e2b66ed146c5818f69061,,
CVE-2016-2148,https://www.cvedetails.com/cve/CVE-2016-2148/,CWE-119,,Overflow,2017-02-09,2019-06-13,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Heap-based buffer overflow in the DHCP client (udhcpc) in BusyBox before 1.25.0 allows remote attackers to have unspecified impact via vectors involving OPTION_6RD parsing.,,busybox,https://git.busybox.net/busybox/commit/?id=352f79acbd759c14399e39baef21fc4ffe180ac2,,,,,,,
CVE-2016-2147,https://www.cvedetails.com/cve/CVE-2016-2147/,CWE-190,,DoS Overflow,2017-02-09,2019-06-13,5.0,None,Remote,Low,Not required,None,None,Partial,"Integer overflow in the DHCP client (udhcpc) in BusyBox before 1.25.0 allows remote attackers to cause a denial of service (crash) via a malformed RFC1035-encoded domain name, which triggers an out-of-bounds heap write.",,busybox,https://git.busybox.net/busybox/commit/?id=d474ffc68290e0a83651c4432eeabfa62cd51e87,,,,,,,
CVE-2016-2090,https://www.cvedetails.com/cve/CVE-2016-2090/,CWE-119,,Overflow,2017-01-13,2017-06-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.",,libbsd,https://cgit.freedesktop.org/libbsd/commit/?id=c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7,,,,,,,
CVE-2016-1908,https://www.cvedetails.com/cve/CVE-2016-1908/,CWE-254,,,2017-04-11,2018-09-11,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The client in OpenSSH before 7.2 mishandles failed cookie generation for untrusted X11 forwarding and relies on the local X11 server for access-control decisions, which allows remote X11 clients to trigger a fallback and obtain trusted X11 forwarding privileges by leveraging configuration issues on this X11 server, as demonstrated by lack of the SECURITY extension on this X11 server.",,mindrot,https://anongit.mindrot.org/openssh.git/commit/?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,,,,,,,
CVE-2013-4544,https://www.cvedetails.com/cve/CVE-2013-4544/,CWE-20,,DoS Exec Code,2014-05-08,2014-05-09,4.9,None,Local Network,Medium,Single system,Partial,Partial,Partial,"hw/net/vmxnet3.c in QEMU 2.0.0-rc0, 1.7.1, and earlier allows local guest users to cause a denial of service or possibly execute arbitrary code via vectors related to (1) RX or (2) TX queue numbers or (3) interrupt indices.  NOTE: some of these details are obtained from third party information.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484,,,,,,,
CVE-2013-4544,https://www.cvedetails.com/cve/CVE-2013-4544/,CWE-20,,DoS Exec Code,2014-05-08,2014-05-09,4.9,None,Local Network,Medium,Single system,Partial,Partial,Partial,"hw/net/vmxnet3.c in QEMU 2.0.0-rc0, 1.7.1, and earlier allows local guest users to cause a denial of service or possibly execute arbitrary code via vectors related to (1) RX or (2) TX queue numbers or (3) interrupt indices.  NOTE: some of these details are obtained from third party information.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=8c6c0478996e8f77374e69b6df68655b0b4ba689,,,,,,,
CVE-2013-4544,https://www.cvedetails.com/cve/CVE-2013-4544/,CWE-20,,DoS Exec Code,2014-05-08,2014-05-09,4.9,None,Local Network,Medium,Single system,Partial,Partial,Partial,"hw/net/vmxnet3.c in QEMU 2.0.0-rc0, 1.7.1, and earlier allows local guest users to cause a denial of service or possibly execute arbitrary code via vectors related to (1) RX or (2) TX queue numbers or (3) interrupt indices.  NOTE: some of these details are obtained from third party information.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=f12d048a523780dbda702027d4a91b62af1a08d7,,,,,,,
CVE-2013-4544,https://www.cvedetails.com/cve/CVE-2013-4544/,CWE-20,,DoS Exec Code,2014-05-08,2014-05-09,4.9,None,Local Network,Medium,Single system,Partial,Partial,Partial,"hw/net/vmxnet3.c in QEMU 2.0.0-rc0, 1.7.1, and earlier allows local guest users to cause a denial of service or possibly execute arbitrary code via vectors related to (1) RX or (2) TX queue numbers or (3) interrupt indices.  NOTE: some of these details are obtained from third party information.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=9878d173f574df74bde0ff50b2f81009fbee81bb,,,,,,,
CVE-2013-4542,https://www.cvedetails.com/cve/CVE-2013-4542/,CWE-119,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The virtio_scsi_load_request function in hw/scsi/scsi-bus.c in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via a crafted savevm image, which triggers an out-of-bounds array access.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3c3ce981423e0d6c18af82ee62f1850c2cda5976,,,,,,,
CVE-2013-4541,https://www.cvedetails.com/cve/CVE-2013-4541/,CWE-119,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The usb_device_post_load function in hw/usb/bus.c in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via a crafted savevm image, related to a negative setup_len or setup_index value.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f8e9895c504149d7048e9fc5eb5cbb34b16e49a,,,,,,,
CVE-2013-4540,https://www.cvedetails.com/cve/CVE-2013-4540/,CWE-119,,Exec Code Overflow,2014-11-04,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Buffer overflow in scoop_gpio_handler_update in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via a large (1) prev_level, (2) gpio_level, or (3) gpio_dir value in a savevm image.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=52f91c3723932f8340fe36c8ec8b18a757c37b2b,,,,,,,
CVE-2013-4539,https://www.cvedetails.com/cve/CVE-2013-4539/,CWE-119,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple buffer overflows in the tsc210x_load function in hw/input/tsc210x.c in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via a crafted (1) precision, (2) nextprecision, (3) function, or (4) nextfunction value in a savevm image.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f,,,,,,,
CVE-2013-4538,https://www.cvedetails.com/cve/CVE-2013-4538/,CWE-119,,DoS Exec Code Overflow Mem. Corr.,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Multiple buffer overflows in the ssd0323_load function in hw/display/ssd0323.c in QEMU before 1.7.2 allow remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via crafted (1) cmd_len, (2) row, or (3) col values; (4) row_start and row_end values; or (5) col_star and col_end values in a savevm image.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=ead7a57df37d2187813a121308213f41591bd811,,,,,,,
CVE-2013-4537,https://www.cvedetails.com/cve/CVE-2013-4537/,CWE-94,,Exec Code,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,The ssi_sd_transfer function in hw/sd/ssi-sd.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted arglen value in a savevm image.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=a9c380db3b8c6af19546a68145c8d1438a09c92b,,,,,,,
CVE-2013-4534,https://www.cvedetails.com/cve/CVE-2013-4534/,CWE-119,,DoS Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in hw/intc/openpic.c in QEMU before 1.7.2 allows remote attackers to cause a denial of service or possibly execute arbitrary code via vectors related to IRQDest elements.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=73d963c0a75cb99c6aaa3f6f25e427aa0b35a02e,,,,,,,
CVE-2013-4533,https://www.cvedetails.com/cve/CVE-2013-4533/,CWE-119,,DoS Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in the pxa2xx_ssp_load function in hw/arm/pxa2xx.c in QEMU before 1.7.2 allows remote attackers to cause a denial of service or possibly execute arbitrary code via a crafted s->rx_level value in a savevm image.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=caa881abe0e01f9931125a0977ec33c5343e4aa7,,,,,,,
CVE-2013-4531,https://www.cvedetails.com/cve/CVE-2013-4531/,CWE-119,,DoS Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in target-arm/machine.c in QEMU before 1.7.2 allows remote attackers to cause a denial of service and possibly execute arbitrary code via a negative value in cpreg_vmstate_array_len in a savevm image.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62,,,,,,,
CVE-2013-4530,https://www.cvedetails.com/cve/CVE-2013-4530/,CWE-119,,DoS Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in hw/ssi/pl022.c in QEMU before 1.7.2 allows remote attackers to cause a denial of service or possibly execute arbitrary code via crafted tx_fifo_head and rx_fifo_head values in a savevm image.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=d8d0a0bc7e194300e53a346d25fe5724fd588387,,,,,,,
CVE-2013-4527,https://www.cvedetails.com/cve/CVE-2013-4527/,CWE-119,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in hw/timer/hpet.c in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via vectors related to the number of timers.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3f1c49e2136fa08ab1ef3183fd55def308829584,,,,,,,
CVE-2013-4526,https://www.cvedetails.com/cve/CVE-2013-4526/,CWE-119,,DoS Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in hw/ide/ahci.c in QEMU before 1.7.2 allows remote attackers to cause a denial of service and possibly execute arbitrary code via vectors related to migrating ports.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5,,,,,,,
CVE-2013-4353,https://www.cvedetails.com/cve/CVE-2013-4353/,CWE-20,,DoS,2014-01-08,2017-01-06,4.3,None,Remote,Medium,Not required,None,None,Partial,The ssl3_take_mac function in ssl/s3_both.c in OpenSSL 1.0.1 before 1.0.1f allows remote TLS servers to cause a denial of service (NULL pointer dereference and application crash) via a crafted Next Protocol Negotiation record in a TLS handshake.,,openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=197e0ea817ad64820789d86711d55ff50d71f631,,,,,,,
CVE-2013-4159,https://www.cvedetails.com/cve/CVE-2013-4159/,CWE-264,,,2014-08-06,2018-10-30,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"ctdb before 2.3 in OpenSUSE 12.3 and 13.1 does not create temporary files securely, which has unspecified impact related to ""several temp file vulnerabilities"" in (1) tcp/tcp_connect.c, (2) server/eventscript.c, (3) tools/ctdb_diagnostics, (4) config/gdb_backtrace, and (5) include/ctdb_private.h.",,samba,https://git.samba.org/?p=ctdb.git;a=commitdiff;h=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,,,,,,,
CVE-2013-4151,https://www.cvedetails.com/cve/CVE-2013-4151/,CWE-94,,Exec Code,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The virtio_load function in virtio/virtio.c in QEMU 1.x before 1.7.2 allows remote attackers to execute arbitrary code via a crafted savevm image, which triggers an out-of-bounds write.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=cc45995294b92d95319b4782750a3580cabdbc0c,,,,,,,
CVE-2013-4150,https://www.cvedetails.com/cve/CVE-2013-4150/,CWE-119,,DoS Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"The virtio_net_load function in hw/net/virtio-net.c in QEMU 1.5.0 through 1.7.x before 1.7.2 allows remote attackers to cause a denial of service or possibly execute arbitrary code via vectors in which the value of curr_queues is greater than max_queues, which triggers an out-of-bounds write.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578,,,,,,,
CVE-2013-4149,https://www.cvedetails.com/cve/CVE-2013-4149/,CWE-119,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,Buffer overflow in virtio_net_load function in net/virtio-net.c in QEMU 1.3.0 through 1.7.x before 1.7.2 might allow remote attackers to execute arbitrary code via a large MAC table.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=98f93ddd84800f207889491e0b5d851386b459cf,,,,,,,
CVE-2013-4148,https://www.cvedetails.com/cve/CVE-2013-4148/,CWE-189,,Exec Code Overflow,2014-11-04,2014-11-05,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"Integer signedness error in the virtio_net_load function in hw/net/virtio-net.c in QEMU 1.x before 1.7.2 allows remote attackers to execute arbitrary code via a crafted savevm image, which triggers a buffer overflow.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=71f7fe48e10a8437c9d42d859389f37157f59980,,,,,,,
CVE-2015-8971,https://www.cvedetails.com/cve/CVE-2015-8971/,CWE-77,,Exec Code,2017-01-23,2017-01-26,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"Terminology 0.7.0 allows remote attackers to execute arbitrary commands via escape sequences that modify the window title and then are written to the terminal, a similar issue to CVE-2003-0063.",,enlight,https://git.enlightenment.org/apps/terminology.git/commit/?id=b80bedc7c21ecffe99d8d142930db696eebdd6a5,,,,,,,
CVE-2017-18595,https://www.cvedetails.com/cve/CVE-2017-18595/,CWE-415,,,2019-09-04,2019-10-10,7.2,None,Local,Low,Not required,Complete,Complete,Complete,An issue was discovered in the Linux kernel before 4.14.11. A double free may be caused by the function allocate_trace_buffer in the file kernel/trace/trace.c.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4397f04575c44e1440ec2e49b6302785c95fd2f8,,,,,,,
CVE-2017-18552,https://www.cvedetails.com/cve/CVE-2017-18552/,CWE-787,,,2019-08-18,2019-10-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,An issue was discovered in net/rds/af_rds.c in the Linux kernel before 4.11. There is an out of bounds write and read in the function rds_recv_track_latency.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=780e982905bef61d13496d9af5310bf4af3a64d3,,,,,,,
CVE-2017-18551,https://www.cvedetails.com/cve/CVE-2017-18551/,CWE-787,,,2019-08-18,2019-09-24,4.6,None,Local,Low,Not required,Partial,Partial,Partial,An issue was discovered in drivers/i2c/i2c-core-smbus.c in the Linux kernel before 4.14.15. There is an out of bounds write in the function i2c_smbus_xfer_emulated.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=89c6efa61f5709327ecfa24bff18e57a4e80c7fa,,,,,,,
CVE-2017-18550,https://www.cvedetails.com/cve/CVE-2017-18550/,CWE-200,,+Info,2019-08-18,2019-08-23,2.1,None,Local,Low,Not required,Partial,None,None,An issue was discovered in drivers/scsi/aacraid/commctrl.c in the Linux kernel before 4.13. There is potential exposure of kernel stack memory because aac_get_hba_info does not initialize the hbainfo structure.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=342ffc26693b528648bdc9377e51e4f2450b4860,,,,,,,
CVE-2017-18549,https://www.cvedetails.com/cve/CVE-2017-18549/,CWE-200,,+Info,2019-08-18,2019-08-23,2.1,None,Local,Low,Not required,Partial,None,None,An issue was discovered in drivers/scsi/aacraid/commctrl.c in the Linux kernel before 4.13. There is potential exposure of kernel stack memory because aac_send_raw_srb does not initialize the reply structure.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=342ffc26693b528648bdc9377e51e4f2450b4860,,,,,,,
CVE-2017-18266,https://www.cvedetails.com/cve/CVE-2017-18266/,CWE-74,,,2018-05-10,2018-06-14,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The open_envvar function in xdg-open in xdg-utils before 1.1.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL, as demonstrated by %s in this environment variable.",,xdg,https://cgit.freedesktop.org/xdg/xdg-utils/commit/?id=ce802d71c3466d1dbb24f2fe9b6db82a1f899bcb,,,,,,,
CVE-2017-18266,https://www.cvedetails.com/cve/CVE-2017-18266/,CWE-74,,,2018-05-10,2018-06-14,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"The open_envvar function in xdg-open in xdg-utils before 1.1.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL, as demonstrated by %s in this environment variable.",,xdg,https://cgit.freedesktop.org/xdg/xdg-utils/commit/?id=5647afb35e4bcba2060148e1a2a47bc43cc240f2,,,,,,,
CVE-2015-7549,https://www.cvedetails.com/cve/CVE-2015-7549/,CWE-476,,DoS,2017-10-30,2017-11-21,2.1,None,Local,Low,Not required,None,None,Partial,The MSI-X MMIO support in hw/pci/msix.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (NULL pointer dereference and QEMU process crash) by leveraging failure to define the .write method.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285,,,,,,,
CVE-2017-18238,https://www.cvedetails.com/cve/CVE-2017-18238/,CWE-835,,DoS,2018-03-15,2019-10-02,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in Exempi before 2.4.4. The TradQT_Manager::ParseCachedBoxes function in XMPFiles/source/FormatSupport/QuickTime_Support.cpp allows remote attackers to cause a denial of service (infinite loop) via crafted XMP data in a .qt file.,,exempi,https://cgit.freedesktop.org/exempi/commit/?id=886cd1d2314755adb1f4cdb99c16ff00830f0331,,,,,,,
CVE-2017-18237,https://www.cvedetails.com/cve/CVE-2017-18237/,CWE-476,,DoS,2018-03-15,2018-04-04,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in Exempi before 2.4.3. The PostScript_Support::ConvertToDate function in XMPFiles/source/FormatSupport/PostScript_Support.cpp allows remote attackers to cause a denial of service (invalid pointer dereference and application crash) via a crafted .ps file.,,exempi,https://cgit.freedesktop.org/exempi/commit/?id=f19d0107fbae1fb41836cd110d4425e407e64048,,,,,,,
CVE-2017-18236,https://www.cvedetails.com/cve/CVE-2017-18236/,CWE-835,,DoS,2018-03-15,2019-10-02,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in Exempi before 2.4.4. The ASF_Support::ReadHeaderObject function in XMPFiles/source/FormatSupport/ASF_Support.cpp allows remote attackers to cause a denial of service (infinite loop) via a crafted .asf file.,,exempi,https://cgit.freedesktop.org/exempi/commit/?id=fe59605d3520bf2ca4e0a963d194f10e9fee5806,,,,,,,
CVE-2017-18235,https://www.cvedetails.com/cve/CVE-2017-18235/,CWE-20,,DoS,2018-03-15,2018-04-04,4.3,None,Remote,Medium,Not required,None,None,Partial,"An issue was discovered in Exempi before 2.4.3. The VPXChunk class in XMPFiles/source/FormatSupport/WEBP_Support.cpp does not ensure nonzero widths and heights, which allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted .webp file.",,exempi,https://cgit.freedesktop.org/exempi/commit/?id=9e76a7782a54a242f18d609e7ba32bf1c430a5e4,,,,,,,
CVE-2017-18234,https://www.cvedetails.com/cve/CVE-2017-18234/,CWE-416,,DoS,2018-03-15,2019-08-06,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"An issue was discovered in Exempi before 2.4.3. It allows remote attackers to cause a denial of service (invalid memcpy with resultant use-after-free) or possibly have unspecified other impact via a .pdf file containing JPEG data, related to XMPFiles/source/FormatSupport/ReconcileTIFF.cpp, XMPFiles/source/FormatSupport/TIFF_MemoryReader.cpp, and XMPFiles/source/FormatSupport/TIFF_Support.hpp.",,exempi,https://cgit.freedesktop.org/exempi/commit/?id=c26d5beb60a5a85f76259f50ed3e08c8169b0a0c,,,,,,,
CVE-2017-18233,https://www.cvedetails.com/cve/CVE-2017-18233/,CWE-190,,DoS Overflow,2018-03-15,2019-10-02,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in Exempi before 2.4.4. Integer overflow in the Chunk class in XMPFiles/source/FormatSupport/RIFF.cpp allows remote attackers to cause a denial of service (infinite loop) via crafted XMP data in a .avi file.,,exempi,https://cgit.freedesktop.org/exempi/commit/?id=65a8492832b7335ffabd01f5f64d89dec757c260,,,,,,,
CVE-2017-18201,https://www.cvedetails.com/cve/CVE-2017-18201/,CWE-415,,,2018-02-26,2018-10-31,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,An issue was discovered in GNU libcdio before 2.0.0. There is a double free in get_cdtext_generic() in lib/driver/_cdio_generic.c.,,savannah,https://git.savannah.gnu.org/cgit/libcdio.git/commit/?id=f6f9c48fb40b8a1e8218799724b0b61a7161eb1d,,,,,,,
CVE-2015-5327,https://www.cvedetails.com/cve/CVE-2015-5327/,CWE-125,,,2017-09-25,2018-08-30,4.0,None,Remote,Low,Single system,Partial,None,None,Out-of-bounds memory read in the x509_decode_time function in x509_cert_parser.c in Linux kernels 4.3-rc1 and after.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cc25b994acfbc901429da682d0f73c190e960206,,,,,,,
CVE-2015-4035,https://www.cvedetails.com/cve/CVE-2015-4035/,CWE-20,,Exec Code,2017-07-25,2019-04-22,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"scripts/xzgrep.in in xzgrep 5.2.x before 5.2.0, before 5.0.0 does not properly process file names containing semicolons, which allows remote attackers to execute arbitrary code by having a user run xzgrep on a crafted file name.",in,tukaani,https://git.tukaani.org/?p=xz.git;a=commitdiff;h=f4b2b52624b802c786e4e2a8eb6895794dd93b24,f4b2b52624b802c786e4e2a8eb6895794dd93b24,cf38da00a140bd3bd65b192390ae5553380fd774,"@@ -154,7 +154,7 @@ for i; do
   # Fail if xz or grep (or sed) fails.
   xz_status=$(
     exec 5>&1
-    (eval ""$uncompress"" -- ""$i"" 5>&-; echo $? >&5) 3>&- |
+    ($uncompress -- ""$i"" 5>&-; echo $? >&5) 3>&- |
     if test $files_with_matches -eq 1; then
       eval ""$grep"" -q && { printf '%s\n' ""$i"" || exit 2; }
     elif test $files_without_matches -eq 1; then",https://git.tukaani.org/?p=xz.git;a=blob;f=src/scripts/xzgrep.in;h=9a9b393fcec2f980e17036b00df9d65ee7d8f221,https://git.tukaani.org/?p=xz.git;a=blob;f=src/scripts/xzgrep.in;h=bfa9fb536a4bb4c16266e7f4955df1a79689fe2c;hb=f4b2b52624b802c786e4e2a8eb6895794dd93b24,,
CVE-2012-0871,https://www.cvedetails.com/cve/CVE-2012-0871/,CWE-59,,,2014-04-18,2018-10-30,6.3,None,Local,Medium,Not required,None,Complete,Complete,"The session_link_x11_socket function in login/logind-session.c in systemd-logind in systemd, possibly 37 and earlier, allows local users to create or overwrite arbitrary files via a symlink attack on the X11 user directory in /run/user/.",,systemd,https://cgit.freedesktop.org/systemd/systemd/commit/?id=fc3c1c6e091ea16ad5600b145201ec535bbb5d7c,,,,,,,
CVE-2017-18043,https://www.cvedetails.com/cve/CVE-2017-18043/,CWE-190,,DoS Overflow,2018-01-31,2018-09-07,2.1,None,Local,Low,Not required,None,None,Partial,"Integer overflow in the macro ROUND_UP (n, d) in Quick Emulator (Qemu) allows a user to cause a denial of service (Qemu process crash).",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=2098b073f398cd628c09c5a78537a6854,,,,,,,
CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,,DoS Exec Code,2014-02-10,2014-02-10,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",,htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,,,,,,,
CVE-2017-18030,https://www.cvedetails.com/cve/CVE-2017-18030/,CWE-125,,DoS,2018-01-23,2018-09-07,2.1,None,Local,Low,Not required,None,None,Partial,The cirrus_invalidate_region function in hw/display/cirrus_vga.c in Qemu allows local OS guest privileged users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to negative pitch.,,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=f153b563f8cf121aebf5a2fff5f0110faf58ccb3,,,,,,,
CVE-2017-15652,https://www.cvedetails.com/cve/CVE-2017-15652/,CWE-200,,+Info,2019-05-23,2019-05-27,4.3,None,Remote,Medium,Not required,Partial,None,None,"Artifex Ghostscript 9.22 is affected by: Obtain Information. The impact is: obtain sensitive information. The component is: affected source code file, affected function, affected executable, affected libga (imagemagick used that). The attack vector is: Someone must open a postscript file though ghostscript. Because of imagemagick also use libga, so it was affected as well.",,ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=2fc463d0e,,,,,,,
CVE-2017-17858,https://www.cvedetails.com/cve/CVE-2017-17858/,CWE-119,,Exec Code Overflow,2018-01-22,2018-11-27,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,"Heap-based buffer overflow in the ensure_solid_xref function in pdf/pdf-xref.c in Artifex MuPDF 1.12.0 allows a remote attacker to potentially execute arbitrary code via a crafted PDF file, because xref subsection object numbers are unrestricted.",,ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=commit;h=55c3f68d638ac1263a386e0aaa004bb6e8bde731,,,,,,,
CVE-2010-5110,https://www.cvedetails.com/cve/CVE-2010-5110/,CWE-20,,DoS,2014-08-29,2014-09-02,4.3,None,Remote,Medium,Not required,None,None,Partial,DCTStream.cc in Poppler before 0.13.3 allows remote attackers to cause a denial of service (crash) via a crafted PDF file.,,poppler,https://cgit.freedesktop.org/poppler/poppler/commit/poppler/DCTStream.cc?id=fc071d800cb4329a3ccf898d7bf16b4db7323ad8,,,,,,,
CVE-2015-1395,https://www.cvedetails.com/cve/CVE-2015-1395/,CWE-22,,Dir. Trav.,2017-08-25,2017-08-29,7.8,None,Remote,Low,Not required,None,Complete,None,Directory traversal vulnerability in GNU patch versions which support Git-style patching before 2.7.3 allows remote attackers to write to arbitrary files with the permissions of the target user via a .. (dot dot) in a diff file name.,,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=17953b5893f7c9835f0dd2a704ba04e0371d2cbd,,,,,,,
CVE-2014-9645,https://www.cvedetails.com/cve/CVE-2014-9645/,CWE-20,,Bypass,2017-03-12,2019-04-03,2.1,None,Local,Low,Not required,None,Partial,None,"The add_probe function in modutils/modprobe.c in BusyBox before 1.23.0 allows local users to bypass intended restrictions on loading kernel modules via a / (slash) character in a module name, as demonstrated by an ""ifconfig /usbserial up"" command or a ""mount -t /snd_pcm none /"" command.",,busybox,https://git.busybox.net/busybox/commit/?id=4e314faa0aecb66717418e9a47a4451aec59262b,,,,,,,
CVE-2014-9637,https://www.cvedetails.com/cve/CVE-2014-9637/,CWE-399,,DoS,2017-08-25,2017-08-29,7.1,None,Remote,Medium,Not required,None,None,Complete,GNU patch 2.7.2 and earlier allows remote attackers to cause a denial of service (memory consumption and segmentation fault) via a crafted diff file.,,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=0c08d7a902c6fdd49b704623a12d8d672ef18944,,,,,,,
CVE-2016-10907,https://www.cvedetails.com/cve/CVE-2016-10907/,CWE-787,,,2019-08-18,2019-10-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,An issue was discovered in drivers/iio/dac/ad5755.c in the Linux kernel before 4.8.6. There is an out of bounds write in the function ad5755_parse_dt.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9d47964bfd471f0dd4c89f28556aec68bffa0020,,,,,,,
CVE-2016-10906,https://www.cvedetails.com/cve/CVE-2016-10906/,CWE-362,,,2019-08-18,2019-10-15,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,An issue was discovered in drivers/net/ethernet/arc/emac_main.c in the Linux kernel before 4.5. A use-after-free is caused by a race condition between the functions arc_emac_tx and arc_emac_tx_clean.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c278c253f3d992c6994d08aa0efb2b6806ca396f,,,,,,,
CVE-2016-10905,https://www.cvedetails.com/cve/CVE-2016-10905/,CWE-416,,,2019-08-18,2019-09-25,6.1,None,Local,Low,Not required,Partial,Partial,Complete,An issue was discovered in fs/gfs2/rgrp.c in the Linux kernel before 4.8. A use-after-free is caused by the functions gfs2_clear_rgrpd and read_rindex_entry.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=36e4ad0316c017d5b271378ed9a1c9a4b77fab5f,,,,,,,
CVE-2014-0146,https://www.cvedetails.com/cve/CVE-2014-0146/,CWE-476,,DoS,2017-08-10,2017-11-03,1.9,None,Local,Medium,Not required,None,None,Partial,"The qcow2_open function in the (block/qcow2.c) in QEMU before 1.7.2 and 2.x before 2.0.0 allows local users to cause a denial of service (NULL pointer dereference) via a crafted image which causes an error, related to the initialization of the snapshot_offset and nb_snapshots fields.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9,,,,,,,
CVE-2014-0145,https://www.cvedetails.com/cve/CVE-2014-0145/,CWE-119,,DoS Exec Code Overflow,2017-08-10,2017-11-03,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"Multiple buffer overflows in QEMU before 1.7.2 and 2.x before 2.0.0, allow local users to cause a denial of service (crash) or possibly execute arbitrary code via a large (1) L1 table in the qcow2_snapshot_load_tmp in the QCOW 2 block driver (block/qcow2-snapshot.c) or (2) uncompressed chunk, (3) chunk length, or (4) number of sectors in the DMG block driver (block/dmg.c).",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=c05e4667be91b46ab42b5a11babf8e84d476cc6b,,,,,,,
CVE-2014-0145,https://www.cvedetails.com/cve/CVE-2014-0145/,CWE-119,,DoS Exec Code Overflow,2017-08-10,2017-11-03,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"Multiple buffer overflows in QEMU before 1.7.2 and 2.x before 2.0.0, allow local users to cause a denial of service (crash) or possibly execute arbitrary code via a large (1) L1 table in the qcow2_snapshot_load_tmp in the QCOW 2 block driver (block/qcow2-snapshot.c) or (2) uncompressed chunk, (3) chunk length, or (4) number of sectors in the DMG block driver (block/dmg.c).",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=f0dce23475b5af5da6b17b97c1765271307734b6,,,,,,,
CVE-2014-0145,https://www.cvedetails.com/cve/CVE-2014-0145/,CWE-119,,DoS Exec Code Overflow,2017-08-10,2017-11-03,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"Multiple buffer overflows in QEMU before 1.7.2 and 2.x before 2.0.0, allow local users to cause a denial of service (crash) or possibly execute arbitrary code via a large (1) L1 table in the qcow2_snapshot_load_tmp in the QCOW 2 block driver (block/qcow2-snapshot.c) or (2) uncompressed chunk, (3) chunk length, or (4) number of sectors in the DMG block driver (block/dmg.c).",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=c165f7758009a4f793c1fc19ebb69cf55313450b,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=509a41bab5306181044b5fff02eadf96d9c8676a,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=e3737b820b45e54b059656dc3f914f895ac7a88b,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=cab60de930684c33f67d4e32c7509b567f8c445b,,,,,,,
CVE-2014-0143,https://www.cvedetails.com/cve/CVE-2014-0143/,CWE-190,,DoS Overflow Mem. Corr.,2017-08-10,2019-04-22,4.4,None,Local,Medium,Not required,Partial,Partial,Partial,"Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",,qemu,https://git.qemu.org/?p=qemu.git;a=commit;h=afbcc40bee4ef51731102d7d4b499ee12fc182e1,,,,,,,
CVE-2014-0142,https://www.cvedetails.com/cve/CVE-2014-0142/,CWE-369,,DoS,2017-08-10,2017-11-03,2.1,None,Local,Low,Not required,None,None,Partial,"QEMU, possibly before 2.0.0, allows local users to cause a denial of service (divide-by-zero error and crash) via a zero value in the (1) tracks field to the seek_to_sector function in block/parallels.c or (2) extent_size field in the bochs function in block/bochs.c.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9302e863aa8baa5d932fc078967050c055fa1a7f,,,,,,,
CVE-2014-0142,https://www.cvedetails.com/cve/CVE-2014-0142/,CWE-369,,DoS,2017-08-10,2017-11-03,2.1,None,Local,Low,Not required,None,None,Partial,"QEMU, possibly before 2.0.0, allows local users to cause a denial of service (divide-by-zero error and crash) via a zero value in the (1) tracks field to the seek_to_sector function in block/parallels.c or (2) extent_size field in the bochs function in block/bochs.c.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=8e53abbc20d08ae3ec30c2054e1161314ad9501d,,,,,,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -53,7 +53,6 @@
 #include ""qt/core/browser/oxide_qt_user_script.h""
 #include ""qt/core/glue/oxide_qt_web_context_proxy_client.h""
 #include ""shared/browser/media/oxide_media_capture_devices_context.h""
-#include ""shared/browser/oxide_browser_context.h""
 #include ""shared/browser/oxide_browser_context_delegate.h""
 #include ""shared/browser/oxide_browser_process_main.h""
 #include ""shared/browser/oxide_devtools_manager.h""
@@ -66,6 +65,7 @@
 namespace oxide {
 namespace qt {
 
+using oxide::BrowserContext;
 using oxide::DevToolsManager;
 using oxide::MediaCaptureDevicesContext;
 using oxide::UserAgentSettings;
@@ -456,7 +456,7 @@ WebContext::~WebContext() {
 }
 
 // static
-WebContext* WebContext::FromBrowserContext(oxide::BrowserContext* context) {
+WebContext* WebContext::FromBrowserContext(BrowserContext* context) {
   BrowserContextDelegate* delegate =
       static_cast<BrowserContextDelegate*>(context->GetDelegate());
   if (!delegate) {
@@ -466,21 +466,21 @@ WebContext* WebContext::FromBrowserContext(oxide::BrowserContext* context) {
   return delegate->context();
 }
 
-oxide::BrowserContext* WebContext::GetContext() {
+BrowserContext* WebContext::GetContext() {
   if (context_.get()) {
     return context_.get();
   }
 
   DCHECK(construct_props_);
 
-  oxide::BrowserContext::Params params(
+  BrowserContext::Params params(
       construct_props_->data_path,
       construct_props_->cache_path,
       construct_props_->max_cache_size_hint,
       construct_props_->session_cookie_mode);
   params.host_mapping_rules = construct_props_->host_mapping_rules;
 
-  context_ = oxide::BrowserContext::Create(params);
+  context_ = BrowserContext::Create(params);
 
   UserAgentSettings* ua_settings = UserAgentSettings::Get(context_.get());",https://git.launchpad.net/oxide/tree/qt/core/browser/oxide_qt_web_context.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/qt/core/browser/oxide_qt_web_context.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,H,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -33,6 +33,7 @@
 
 #include ""qt/core/glue/oxide_qt_web_context_proxy.h""
 #include ""shared/browser/media/oxide_media_capture_devices_context_client.h""
+#include ""shared/browser/oxide_browser_context.h""
 
 QT_BEGIN_NAMESPACE
 class QNetworkAccessManager;
@@ -43,9 +44,6 @@ class CookieStore;
 }
 
 namespace oxide {
-
-class BrowserContext;
-
 namespace qt {
 
 class SetCookiesContext;
@@ -152,7 +150,7 @@ class WebContext : public WebContextProxy,
 
   WebContextProxyClient* client_;
 
-  scoped_refptr<BrowserContext> context_;
+  BrowserContext::UniquePtr context_;
 
   struct ConstructProperties;
   std::unique_ptr<ConstructProperties> construct_props_;",https://git.launchpad.net/oxide/tree/qt/core/browser/oxide_qt_web_context.h?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/qt/core/browser/oxide_qt_web_context.h?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -2042,8 +2042,8 @@ If the application doesn't set this, then WebView will use the application
 default WebContext (Oxide::defaultWebContext).
 
 The application should ensure that the provided WebContext outlives this
-WebView. Although WebView will continue to function normally if its provided
-WebContext is deleted, it will mean that this property is null.
+WebView. Deleting the WebContext whilst the WebView is still alive may cause
+some features to stop working.
 
 If this WebView is created as a request to open a new window (via
 newViewRequested), then the WebContext will be inherited from the opening",https://git.launchpad.net/oxide/tree/qt/quick/api/oxideqquickwebview.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/qt/quick/api/oxideqquickwebview.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,exclude,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -1,2 +1,3 @@
+tst_bug1626099.qml
 tst_Incognito_cleanup.qml
 tst_Incognito_cookies.qml",https://git.launchpad.net/oxide/tree/qt/tests/qmltests/core/single-process.exclude?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/qt/tests/qmltests/core/single-process.exclude?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,gn,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -284,6 +284,8 @@ component(""shared"") {
     ""browser/input/oxide_input_method_context.h"",
     ""browser/input/oxide_input_method_context_observer.cc"",
     ""browser/input/oxide_input_method_context_observer.h"",
+    ""browser/in_process_renderer_observer.cc"",
+    ""browser/in_process_renderer_observer.h"",
     ""browser/media/oxide_media_capture_devices_context.cc"",
     ""browser/media/oxide_media_capture_devices_context.h"",
     ""browser/media/oxide_media_capture_devices_context_client.h"",",https://git.launchpad.net/oxide/tree/shared/BUILD.gn?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/BUILD.gn?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -558,24 +558,16 @@ class OTRBrowserContextImpl : public BrowserContext {
  public:
   OTRBrowserContextImpl(BrowserContextImpl* original,
                         BrowserContextIODataImpl* original_io_data);
-
-  base::WeakPtr<OTRBrowserContextImpl> GetWeakPtr() {
-    return weak_ptr_factory_.GetWeakPtr();
-  }
+  ~OTRBrowserContextImpl() override;
 
  private:
-  ~OTRBrowserContextImpl() override;
+  BrowserContext* GetOffTheRecordContext() override { return this; }
 
-  scoped_refptr<BrowserContext> GetOffTheRecordContext() override {
-    return make_scoped_refptr(this);
-  }
-  BrowserContext* GetOriginalContext() const override;
+  BrowserContext* GetOriginalContext() override;
 
   bool HasOffTheRecordContext() const override { return true; }
 
-  scoped_refptr<BrowserContextImpl> original_context_;
-
-  base::WeakPtrFactory<OTRBrowserContextImpl> weak_ptr_factory_;
+  BrowserContextImpl* original_context_;
 };
 
 class BrowserContextImpl : public BrowserContext {
@@ -583,50 +575,49 @@ class BrowserContextImpl : public BrowserContext {
   BrowserContextImpl(const BrowserContext::Params& params);
 
  private:
+  friend class BrowserContext;
+
   ~BrowserContextImpl() override;
 
-  scoped_refptr<BrowserContext> GetOffTheRecordContext() override;
+  BrowserContext* GetOffTheRecordContext() override;
 
-  BrowserContext* GetOriginalContext() const override {
-    return const_cast<BrowserContextImpl*>(this);
-  }
+  BrowserContext* GetOriginalContext() override { return this; }
 
   bool HasOffTheRecordContext() const override {
     return otr_context_ != nullptr;
   }
 
-  base::WeakPtr<OTRBrowserContextImpl> otr_context_;
+  std::unique_ptr<OTRBrowserContextImpl> otr_context_;
 };
 
-OTRBrowserContextImpl::~OTRBrowserContextImpl() {}
-
-BrowserContext* OTRBrowserContextImpl::GetOriginalContext() const {
-  return original_context_.get();
+BrowserContext* OTRBrowserContextImpl::GetOriginalContext() {
+  return original_context_;
 }
 
+OTRBrowserContextImpl::~OTRBrowserContextImpl() {}
+
 OTRBrowserContextImpl::OTRBrowserContextImpl(
     BrowserContextImpl* original,
     BrowserContextIODataImpl* original_io_data)
     : BrowserContext(new OTRBrowserContextIODataImpl(original_io_data)),
-      original_context_(original),
-      weak_ptr_factory_(this) {
+      original_context_(original) {
   BrowserContextDependencyManager::GetInstance()
       ->CreateBrowserContextServices(this);
 }
 
-BrowserContextImpl::~BrowserContextImpl() {
-  CHECK(!otr_context_);
-}
-
-scoped_refptr<BrowserContext> BrowserContextImpl::GetOffTheRecordContext() {
+BrowserContext* BrowserContextImpl::GetOffTheRecordContext() {
   if (!otr_context_) {
-    OTRBrowserContextImpl* context = new OTRBrowserContextImpl(
-        this,
-        static_cast<BrowserContextIODataImpl *>(io_data()));
-    otr_context_ = context->GetWeakPtr();
+    otr_context_ =
+        base::MakeUnique<OTRBrowserContextImpl>(
+            this,
+            static_cast<BrowserContextIODataImpl*>(io_data()));
   }
 
-  return make_scoped_refptr(otr_context_.get());
+  return otr_context_.get();
+}
+
+BrowserContextImpl::~BrowserContextImpl() {
+  CHECK(!otr_context_);
 }
 
 BrowserContextImpl::BrowserContextImpl(const BrowserContext::Params& params)
@@ -643,8 +634,9 @@ BrowserContextImpl::BrowserContextImpl(const BrowserContext::Params& params)
       ->CreateBrowserContextServices(this);
 }
 
-void BrowserContextTraits::Destruct(const BrowserContext* x) {
-  BrowserContextDestroyer::DestroyContext(const_cast<BrowserContext*>(x));
+void BrowserContext::Deleter::operator()(BrowserContext* context) {
+  CHECK(!context->IsOffTheRecord());
+  BrowserContextDestroyer::DestroyContext(base::WrapUnique(context));
 }
 
 std::unique_ptr<content::ZoomLevelDelegate>
@@ -744,8 +736,8 @@ void BrowserContext::RemoveObserver(BrowserContextObserver* observer) {
   observers_.RemoveObserver(observer);
 }
 
-BrowserContext::BrowserContext(BrowserContextIOData* io_data) :
-    io_data_(io_data) {
+BrowserContext::BrowserContext(BrowserContextIOData* io_data)
+    : io_data_(io_data) {
   CHECK(BrowserProcessMain::GetInstance()->IsRunning()) <<
       ""The main browser process components must be started before "" <<
       ""creating a context"";
@@ -786,9 +778,8 @@ BrowserContext::~BrowserContext() {
 }
 
 // static
-scoped_refptr<BrowserContext> BrowserContext::Create(const Params& params) {
-  scoped_refptr<BrowserContext> context = new BrowserContextImpl(params);
-  return context;
+BrowserContext::UniquePtr BrowserContext::Create(const Params& params) {
+  return BrowserContext::UniquePtr(new BrowserContextImpl(params));
 }
 
 // static
@@ -800,7 +791,10 @@ void BrowserContext::ForEach(const BrowserContextCallback& callback) {
 
 // static
 void BrowserContext::AssertNoContextsExist() {
-  CHECK_EQ(g_all_contexts.Get().size(), static_cast<size_t>(0));
+  CHECK_EQ(g_all_contexts.Get().size(), static_cast<size_t>(0))
+      << ""BrowserContexts still exist at shutdown! This is normally the result ""
+      << ""of an application leak, but it's possible that there might be an ""
+      << ""Oxide bug too"";
 }
 
 BrowserContextID BrowserContext::GetID() const {
@@ -820,6 +814,14 @@ void BrowserContext::SetDelegate(BrowserContextDelegate* delegate) {
   data.delegate = delegate;
 }
 
+// static
+void BrowserContext::DestroyOffTheRecordContextForContext(
+    BrowserContext* context) {
+  CHECK(!context->IsOffTheRecord() && context->HasOffTheRecordContext());
+  BrowserContextDestroyer::DestroyContext(
+      std::move(static_cast<BrowserContextImpl*>(context)->otr_context_));
+}
+
 bool BrowserContext::IsOffTheRecord() const {
   DCHECK(CalledOnValidThread());
   return io_data()->IsOffTheRecord();
@@ -829,7 +831,7 @@ bool BrowserContext::IsSameContext(BrowserContext* other) const {
   DCHECK(CalledOnValidThread());
   return other->GetOriginalContext() == this ||
          (other->HasOffTheRecordContext() &&
-          other->GetOffTheRecordContext().get() == this);
+          other->GetOffTheRecordContext() == this);
 }
 
 base::FilePath BrowserContext::GetPath() const {",https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,H,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -146,17 +146,10 @@ class BrowserContextIOData {
 
 class BrowserContext;
 
-struct OXIDE_SHARED_EXPORT BrowserContextTraits {
-  static void Destruct(const BrowserContext* x);
-};
-
 // This class holds the context needed for a browsing session. It lives on
-// and must only be accessed on the UI thread - note that it uses a thread-safe
-// refcount only so that we can override the delete behaviour
-class OXIDE_SHARED_EXPORT BrowserContext
-    : public content::BrowserContext,
-      public base::RefCountedThreadSafe<BrowserContext, BrowserContextTraits>,
-      public base::NonThreadSafe {
+// and must only be accessed on the UI thread
+class OXIDE_SHARED_EXPORT BrowserContext : public content::BrowserContext,
+                                           public base::NonThreadSafe {
  public:
 
   struct Params {
@@ -176,12 +169,24 @@ class OXIDE_SHARED_EXPORT BrowserContext
     std::vector<std::string> host_mapping_rules;
   };
 
+  virtual ~BrowserContext();
+
   static BrowserContext* FromContent(
       content::BrowserContext* context) {
     return static_cast<BrowserContext *>(context);
   }
 
-  static scoped_refptr<BrowserContext> Create(const Params& params);
+  struct Deleter {
+    void operator()(BrowserContext* context);
+  };
+
+  typedef std::unique_ptr<BrowserContext, Deleter> UniquePtr;
+
+  // Create a new BrowserContext. Callers should be aware that the returned
+  // std::unique_ptr is not guaranteed to delete the BrowserContext immediately
+  // when released - it schedules the BrowserContext to be deleted when it's no
+  // longer in use.
+  static UniquePtr Create(const Params& params);
 
   typedef base::Callback<void(BrowserContext*)> BrowserContextCallback;
   static void ForEach(const BrowserContextCallback& callback);
@@ -194,10 +199,22 @@ class OXIDE_SHARED_EXPORT BrowserContext
   BrowserContextDelegate* GetDelegate() const;
   void SetDelegate(BrowserContextDelegate* delegate);
 
-  virtual scoped_refptr<BrowserContext> GetOffTheRecordContext() = 0;
-  virtual BrowserContext* GetOriginalContext() const = 0;
+  // Returns an OTR BrowserContext, creating it if it needs to. Callers must
+  // never delete the returned BrowserContext directly, but must pass the
+  // BrowserContext returned by GetOriginalContext() to
+  // DestroyOffTheRecordContextForContext when it's no longer required.
+  virtual BrowserContext* GetOffTheRecordContext() = 0;
+
+  // Returns the main BrowserContext associated with |this|. Callers must never
+  // delete the returned BrowserContext.
+  // The returned BrowserContext is only guaranteed to be valid until |this| is
+  // released.
+  virtual BrowserContext* GetOriginalContext() = 0;
+
   virtual bool HasOffTheRecordContext() const = 0;
 
+  static void DestroyOffTheRecordContextForContext(BrowserContext* context);
+
   bool IsOffTheRecord() const override; // from content::BrowserContext
 
   bool IsSameContext(BrowserContext* other) const;
@@ -231,10 +248,7 @@ class OXIDE_SHARED_EXPORT BrowserContext
   BrowserContextIOData* GetIOData() const;
 
  protected:
-  friend class BrowserContextDestroyer; // for destructor
-
   BrowserContext(BrowserContextIOData* io_data);
-  virtual ~BrowserContext();
 
   BrowserContextIOData* io_data() const { return io_data_; }",https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context.h?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context.h?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -17,8 +17,11 @@
 
 #include ""oxide_browser_context_destroyer.h""
 
+#include <list>
+
+#include ""base/lazy_instance.h""
 #include ""base/logging.h""
-#include ""base/message_loop/message_loop.h""
+#include ""base/threading/thread_task_runner_handle.h""
 #include ""content/public/browser/browser_context.h""
 #include ""content/public/browser/render_process_host.h""
 
@@ -26,76 +29,229 @@
 
 namespace oxide {
 
+namespace {
+
+base::LazyInstance<std::list<BrowserContextDestroyer*>>
+    g_contexts_pending_deletion = LAZY_INSTANCE_INITIALIZER;
+
+std::set<content::RenderProcessHost*> 
+GetHostsForContext(BrowserContext* context) {
+  std::set<content::RenderProcessHost*> hosts;
+
+  for (auto it = content::RenderProcessHost::AllHostsIterator();
+       !it.IsAtEnd(); it.Advance()) {
+    content::RenderProcessHost* host = it.GetCurrentValue();
+    if (host->GetBrowserContext() != context) {
+      continue;
+    }
+
+    hosts.insert(host);
+  }
+
+  return std::move(hosts);
+}
+
+}
+
 BrowserContextDestroyer::BrowserContextDestroyer(
-    BrowserContext* context,
-    const std::set<content::RenderProcessHost*>& hosts)
-    : context_(context),
-      pending_hosts_(0) {
-  for (std::set<content::RenderProcessHost*>::iterator it = hosts.begin();
-       it != hosts.end(); ++it) {
-    (*it)->AddObserver(this);
-    ++pending_hosts_;
+    std::unique_ptr<BrowserContext> context,
+    const std::set<content::RenderProcessHost*>& hosts,
+    uint32_t otr_contexts_pending_deletion)
+    : context_(std::move(context)),
+      otr_contexts_pending_deletion_(otr_contexts_pending_deletion),
+      finish_destroy_scheduled_(false) {
+  DCHECK(hosts.size() > 0 ||
+         (!context->IsOffTheRecord() &&
+          (otr_contexts_pending_deletion > 0 ||
+               context->HasOffTheRecordContext())));
+
+  g_contexts_pending_deletion.Get().push_back(this);
+
+  for (auto* host : hosts) {
+    ObserveHost(host);
   }
 }
 
-BrowserContextDestroyer::~BrowserContextDestroyer() {}
+BrowserContextDestroyer::~BrowserContextDestroyer() = default;
+
+void BrowserContextDestroyer::ObserveHost(content::RenderProcessHost* host) {
+  DCHECK(pending_host_ids_.find(host->GetID()) == pending_host_ids_.end());
+
+  host->AddObserver(this);
+  pending_host_ids_.insert(host->GetID());
+}
+
+void BrowserContextDestroyer::MaybeScheduleFinishDestroyContext(
+    content::RenderProcessHost* host_being_destroyed) {
+  DCHECK(!finish_destroy_scheduled_);
+
+  if (pending_host_ids_.size() > 0) {
+    // We're monitoring RenderProcessHosts that are using this context, so it's
+    // not safe to delete yet
+    return;
+  }
+
+  if (!context_->IsOffTheRecord() &&
+      (otr_contexts_pending_deletion_ > 0 ||
+           context_->HasOffTheRecordContext())) {
+    // There are still live OTR BrowserContexts that depend on this context, so
+    // it can't be deleted yet
+    return;
+  }
+
+  finish_destroy_scheduled_ = true;
+
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE,
+      base::Bind(&BrowserContextDestroyer::FinishDestroyContext,
+                 // We have exclusive ownership of |this| - nobody else can
+                 // reference or delete it
+                 base::Unretained(this)));
+}
 
 void BrowserContextDestroyer::FinishDestroyContext() {
-  DCHECK_EQ(pending_hosts_, 0U);
+  DCHECK(finish_destroy_scheduled_);
+  CHECK_EQ(GetHostsForContext(context_.get()).size(), 0U)
+      << ""One or more RenderProcessHosts exist whilst its BrowserContext is ""
+      << ""being deleted!"";
 
-  delete context_;
-  context_ = nullptr;
+  g_contexts_pending_deletion.Get().remove(this);
+
+  if (context_->IsOffTheRecord()) {
+    // If this is an OTR context and its owner BrowserContext has been scheduled
+    // for deletion, update the owner's BrowserContextDestroyer
+    BrowserContextDestroyer* orig_destroyer =
+        GetForContext(context_->GetOriginalContext());
+    if (orig_destroyer) {
+      DCHECK_GT(orig_destroyer->otr_contexts_pending_deletion_, 0U);
+      DCHECK(!orig_destroyer->finish_destroy_scheduled_);
+      --orig_destroyer->otr_contexts_pending_deletion_;
+      orig_destroyer->MaybeScheduleFinishDestroyContext();
+    }
+  }
 
   delete this;
 }
 
+// static
+BrowserContextDestroyer* BrowserContextDestroyer::GetForContext(
+    content::BrowserContext* context) {
+  auto it = std::find_if(g_contexts_pending_deletion.Get().begin(),
+                         g_contexts_pending_deletion.Get().end(),
+                         [context](const BrowserContextDestroyer* d) {
+    return d->context_.get() == context;
+  });
+
+  if (it == g_contexts_pending_deletion.Get().end()) {
+    return nullptr;
+  }
+
+  return *it;
+}
+
 void BrowserContextDestroyer::RenderProcessHostDestroyed(
     content::RenderProcessHost* host) {
-  DCHECK_GT(pending_hosts_, 0U);
-  if (--pending_hosts_ != 0) {
-    return;
-  }
+  DCHECK_GT(pending_host_ids_.size(), 0U);
+
+  size_t erased = pending_host_ids_.erase(host->GetID());
+  DCHECK_GT(erased, 0U);
+
+  MaybeScheduleFinishDestroyContext(host);
+}
+
+// static
+void BrowserContextDestroyer::DestroyContext(
+    std::unique_ptr<BrowserContext> context) {
 
-  if (content::RenderProcessHost::run_renderer_in_process()) {
-    FinishDestroyContext();
+  bool has_live_otr_context = false;
+  uint32_t otr_contexts_pending_deletion = 0;
+
+  if (!context->IsOffTheRecord()) {
+    // If |context| is not an OTR BrowserContext, we need to keep track of how
+    // many OTR BrowserContexts that were owned by it are scheduled for deletion
+    // but still exist, as |context| must outlive these
+    for (auto* destroyer : g_contexts_pending_deletion.Get()) {
+      if (destroyer->context_->IsOffTheRecord() &&
+          destroyer->context_->GetOriginalContext() == context.get()) {
+        ++otr_contexts_pending_deletion;
+      }
+    }
+
+    // If |context| is not an OTR BrowserContext but currently owns a live OTR
+    // BrowserContext, then we have to outlive that
+    has_live_otr_context = context->HasOffTheRecordContext();
   } else {
-    base::MessageLoop::current()->PostTask(
-        FROM_HERE,
-        base::Bind(&BrowserContextDestroyer::FinishDestroyContext,
-                   // We have exclusive ownership of |this| - nobody else can
-                   // reference or delete it
-                   base::Unretained(this)));
+    // If |context| is an OTR BrowserContext and its owner has already been
+    // scheduled for deletion, then we need to prevent the owner from being
+    // deleted until after |context|
+    BrowserContextDestroyer* orig_destroyer =
+        GetForContext(context->GetOriginalContext());
+    if (orig_destroyer) {
+      CHECK(!orig_destroyer->finish_destroy_scheduled_);
+      ++orig_destroyer->otr_contexts_pending_deletion_;
+    }
+  }
+
+  // Get all of the live RenderProcessHosts that are using |context|
+  std::set<content::RenderProcessHost*> hosts =
+      GetHostsForContext(context.get());
+
+  content::BrowserContext::NotifyWillBeDestroyed(context.get());
+
+  // |hosts| might not be empty if the application released its BrowserContext
+  // too early, or if |context| is an OTR context or this application is single
+  // process
+
+  if (!hosts.empty() ||
+      otr_contexts_pending_deletion > 0 ||
+      has_live_otr_context) {
+    // |context| is not safe to delete yet
+    new BrowserContextDestroyer(std::move(context),
+                                hosts,
+                                otr_contexts_pending_deletion);
   }
 }
 
 // static
-void BrowserContextDestroyer::DestroyContext(BrowserContext* context) {
-  CHECK(context->IsOffTheRecord() || !context->HasOffTheRecordContext());
+void BrowserContextDestroyer::Shutdown() {
+  auto destroy_all_unused_contexts = []() {
+    auto it = g_contexts_pending_deletion.Get().begin();
+    while (it != g_contexts_pending_deletion.Get().end()) {
+      BrowserContextDestroyer* destroyer = *it;
+      ++it;
 
-  content::BrowserContext::NotifyWillBeDestroyed(context);
-
-  std::set<content::RenderProcessHost*> hosts;
+      if (!destroyer->finish_destroy_scheduled_) {
+        continue;
+      }
 
-  for (content::RenderProcessHost::iterator it =
-           content::RenderProcessHost::AllHostsIterator();
-       !it.IsAtEnd(); it.Advance()) {
-    content::RenderProcessHost* host = it.GetCurrentValue();
-    if (host->GetBrowserContext() != context) {
-      continue;
+      destroyer->FinishDestroyContext();
+      // |destroyer| is invalid now
     }
+  };
 
-    hosts.insert(host);
+  // We make 2 passes over the list because the first pass can destroy an
+  // incognito BrowserContext that subsequently schedules its owner context for
+  // deletion
+  destroy_all_unused_contexts();
+  destroy_all_unused_contexts();
+}
+
+// static
+void BrowserContextDestroyer::RenderProcessHostAssignedToSiteInstance(
+    content::RenderProcessHost* host) {
+  BrowserContextDestroyer* destroyer = GetForContext(host->GetBrowserContext());
+  if (!destroyer) {
+    return;
   }
 
-  // XXX: Given that we shutdown the service worker context and that there
-  // shouldn't be any live WebContents left, are there any circumstances
-  // other than in single-process mode where |hosts| isn't empty?
+  CHECK(!destroyer->finish_destroy_scheduled_);
 
-  if (hosts.empty()) {
-    delete context;
-  } else {
-    new BrowserContextDestroyer(context, hosts);
+  if (destroyer->pending_host_ids_.find(host->GetID()) !=
+      destroyer->pending_host_ids_.end()) {
+    return;
   }
+
+  destroyer->ObserveHost(host);
 }
 
 } // namespace oxide",https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context_destroyer.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context_destroyer.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,H,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -18,12 +18,14 @@
 #ifndef _OXIDE_SHARED_BROWSER_BROWSER_CONTEXT_DESTROYER_H_
 #define _OXIDE_SHARED_BROWSER_BROWSER_CONTEXT_DESTROYER_H_
 
+#include <memory>
 #include <set>
 
 #include ""base/macros.h""
 #include ""content/public/browser/render_process_host_observer.h""
 
 namespace content {
+class BrowserContext;
 class RenderProcessHost;
 }
 
@@ -31,23 +33,51 @@ namespace oxide {
 
 class BrowserContext;
 
+// A mechanism to manage BrowserContext destruction, ensuring it stays alive
+// until consumers inside Chromium no longer require it
 class BrowserContextDestroyer : public content::RenderProcessHostObserver {
  public:
-  static void DestroyContext(BrowserContext* context);
+  // Schedule |context| for deletion. If no RenderProcessHosts are using it then
+  // this will result in it being deleted immediately, else deletion will be
+  // happen after all RenderProcessHosts using it have gone away
+  static void DestroyContext(std::unique_ptr<BrowserContext> context);
+
+  // Delete all BrowserContexts that are pending deletion and safe to be deleted
+  static void Shutdown();
+
+  // Notify that |host| has been assigned to a SiteInstance. This is the first
+  // notification we get from content after a RenderProcessHost is created,
+  // although this doesn't mean it was actually just created.
+  // This ensures that |host| will be tracked if its BrowserContext has already
+  // been scheduled for deletion.
+  static void RenderProcessHostAssignedToSiteInstance(
+      content::RenderProcessHost* host);
 
  private:
-  BrowserContextDestroyer(BrowserContext* context,
-                          const std::set<content::RenderProcessHost*>& hosts);
+  BrowserContextDestroyer(std::unique_ptr<BrowserContext> context,
+                          const std::set<content::RenderProcessHost*>& hosts,
+                          uint32_t otr_contexts_pending_deletion);
   ~BrowserContextDestroyer() override;
 
+  void ObserveHost(content::RenderProcessHost* host);
+
+  void MaybeScheduleFinishDestroyContext(
+      content::RenderProcessHost* host_being_destroyed = nullptr);
   void FinishDestroyContext();
 
+  static BrowserContextDestroyer* GetForContext(
+      content::BrowserContext* context);
+
   // content::RenderProcessHostObserver implementation
   void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;
 
-  BrowserContext* context_;
+  std::unique_ptr<BrowserContext> context_;
+
+  std::set<int> pending_host_ids_;
+
+  uint32_t otr_contexts_pending_deletion_;
 
-  uint32_t pending_hosts_;
+  bool finish_destroy_scheduled_;
   
   DISALLOW_COPY_AND_ASSIGN(BrowserContextDestroyer);
 };",https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context_destroyer.h?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_context_destroyer.h?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -49,6 +49,7 @@
 #include ""shared/gpu/oxide_gl_context_dependent.h""
 
 #include ""oxide_browser_context.h""
+#include ""oxide_browser_context_destroyer.h""
 #include ""oxide_browser_platform_integration.h""
 #include ""oxide_browser_process_main.h""
 #include ""oxide_geolocation_delegate.h""
@@ -57,6 +58,7 @@
 #include ""oxide_lifecycle_observer.h""
 #include ""oxide_message_pump.h""
 #include ""oxide_render_process_initializer.h""
+#include ""oxide_web_contents_unloader.h""
 #include ""oxide_web_contents_view.h""
 #include ""screen.h""
 
@@ -341,15 +343,15 @@ bool BrowserMainParts::MainMessageLoopRun(int* result_code) {
 }
 
 void BrowserMainParts::PostMainMessageLoopRun() {
+  WebContentsUnloader::GetInstance()->Shutdown();
+
+  BrowserContextDestroyer::Shutdown();
+  BrowserContext::AssertNoContextsExist();
+
   CompositorUtils::GetInstance()->Shutdown();
 }
 
 void BrowserMainParts::PostDestroyThreads() {
-  if (BrowserProcessMain::GetInstance()->GetProcessModel() ==
-      PROCESS_MODEL_SINGLE_PROCESS) {
-    BrowserContext::AssertNoContextsExist();
-  }
-
   device_client_.reset();
 
   display::Screen::SetScreenInstance(nullptr);",https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_main_parts.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_main_parts.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -72,10 +72,8 @@
 #include ""shared/common/oxide_content_client.h""
 #include ""shared/common/oxide_form_factor.h""
 
-#include ""oxide_browser_context.h""
 #include ""oxide_form_factor_detection.h""
 #include ""oxide_message_pump.h""
-#include ""oxide_web_contents_unloader.h""
 
 namespace content {
 
@@ -581,14 +579,6 @@ void BrowserProcessMainImpl::Shutdown() {
 
   MessagePump::Get()->Stop();
 
-  WebContentsUnloader::GetInstance()->Shutdown();
-
-  if (process_model_ != PROCESS_MODEL_SINGLE_PROCESS) {
-    // In single process mode, we do this check after destroying
-    // threads, as we hold the single BrowserContext alive until then
-    BrowserContext::AssertNoContextsExist();
-  }
-
   browser_main_runner_->Shutdown();
   browser_main_runner_.reset();",https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_process_main.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_browser_process_main.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -46,7 +46,9 @@
 #include ""shared/common/oxide_content_client.h""
 
 #include ""display_form_factor.h""
+#include ""in_process_renderer_observer.h""
 #include ""oxide_browser_context.h""
+#include ""oxide_browser_context_destroyer.h""
 #include ""oxide_browser_main_parts.h""
 #include ""oxide_browser_platform_integration.h""
 #include ""oxide_browser_process_main.h""
@@ -92,12 +94,17 @@ content::BrowserMainParts* ContentBrowserClient::CreateBrowserMainParts(
 
 void ContentBrowserClient::RenderProcessWillLaunch(
     content::RenderProcessHost* host) {
+  if (content::RenderProcessHost::run_renderer_in_process()) {
+    host->AddObserver(new InProcessRendererObserver());
+  }
+
   host->AddFilter(new RenderMessageFilter(host));
 }
 
-std::string ContentBrowserClient::GetAcceptLangs(
-    content::BrowserContext* browser_context) {
-  return UserAgentSettings::Get(browser_context)->GetAcceptLangs();
+void ContentBrowserClient::SiteInstanceGotProcess(
+    content::SiteInstance* site_instance) {
+  BrowserContextDestroyer::RenderProcessHostAssignedToSiteInstance(
+      site_instance->GetProcess());
 }
 
 void ContentBrowserClient::AppendExtraCommandLineSwitches(
@@ -130,6 +137,16 @@ void ContentBrowserClient::AppendExtraCommandLineSwitches(
   }
 }
 
+std::string
+ContentBrowserClient::GetApplicationLocale() {
+  return application_locale_;
+}
+
+std::string ContentBrowserClient::GetAcceptLangs(
+    content::BrowserContext* browser_context) {
+  return UserAgentSettings::Get(browser_context)->GetAcceptLangs();
+}
+
 bool ContentBrowserClient::AllowGetCookie(const GURL& url,
                                           const GURL& first_party,
                                           const net::CookieList& cookie_list,
@@ -339,11 +356,6 @@ ContentBrowserClient::GetOsTypeOverrideForGpuDataManager(
 #endif
 }
 
-std::string
-ContentBrowserClient::GetApplicationLocale() {
-  return application_locale_;
-}
-
 ContentBrowserClient::ContentBrowserClient(
     const std::string& application_locale,
     BrowserPlatformIntegration* integration)",https://git.launchpad.net/oxide/tree/shared/browser/oxide_content_browser_client.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_content_browser_client.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,H,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -48,14 +48,15 @@ class ContentBrowserClient final : public content::ContentBrowserClient {
 
  private:
   // content::ContentBrowserClient implementation
-  std::string GetApplicationLocale() override;
   content::BrowserMainParts* CreateBrowserMainParts(
       const content::MainFunctionParams& parameters) override;
   void RenderProcessWillLaunch(content::RenderProcessHost* host) override;
-  std::string GetAcceptLangs(
-      content::BrowserContext* browser_context) override;
+  void SiteInstanceGotProcess(content::SiteInstance* site_instance) override;
   void AppendExtraCommandLineSwitches(base::CommandLine* command_line,
                                       int child_process_id) override;
+  std::string GetApplicationLocale() override;
+  std::string GetAcceptLangs(
+      content::BrowserContext* browser_context) override;
   bool AllowGetCookie(const GURL& url,
                       const GURL& first_party,
                       const net::CookieList& cookie_list,",https://git.launchpad.net/oxide/tree/shared/browser/oxide_content_browser_client.h?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_content_browser_client.h?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -24,8 +24,26 @@
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/browser/web_contents_observer.h""
 
+#include ""oxide_browser_context.h""
+#include ""oxide_web_view_contents_helper.h""
+
 namespace oxide {
 
+namespace {
+
+void MaybeDestroyOffTheRecordContext(BrowserContext* context) {
+  DCHECK(context->IsOffTheRecord());
+
+  if (WebViewContentsHelper::IsContextInUse(context)) {
+    return;
+  }
+
+  BrowserContext::DestroyOffTheRecordContextForContext(
+      context->GetOriginalContext());
+}
+
+}
+
 class WebContentsUnloaderObserver : public content::WebContentsObserver {
  public:
   explicit WebContentsUnloaderObserver(content::WebContents* contents)
@@ -46,10 +64,12 @@ class WebContentsUnloaderObserver : public content::WebContentsObserver {
 WebContentsUnloader::WebContentsUnloader() = default;
 
 void WebContentsUnloader::CloseContents(content::WebContents* contents) {
-  ScopedVector<content::WebContents>::iterator it =
-      std::find(contents_unloading_.begin(),
-                contents_unloading_.end(),
-                contents);
+  auto it = std::find_if(
+      contents_unloading_.begin(),
+      contents_unloading_.end(),
+      [contents](const std::unique_ptr<content::WebContents>& c) {
+    return contents == c.get();
+  });
   DCHECK(it != contents_unloading_.end());
 
   contents_unloading_.erase(it);
@@ -64,21 +84,28 @@ WebContentsUnloader* WebContentsUnloader::GetInstance() {
 
 void WebContentsUnloader::Unload(
     std::unique_ptr<content::WebContents> contents) {
-  if (!contents->NeedToFireBeforeUnload()) {
+  content::WebContents* c = contents.get();
+  contents_unloading_.push_back(std::move(contents));
+
+  content::BrowserContext* context = c->GetBrowserContext();
+  if (context->IsOffTheRecord()) {
+    MaybeDestroyOffTheRecordContext(BrowserContext::FromContent(context));
+  }
+
+  if (!c->NeedToFireBeforeUnload()) {
     // Despite the name, this checks if sudden termination is allowed. If so,
     // we shouldn't fire the unload handler particularly if this was script
     // closed, else we'll never get an ACK
+    CloseContents(c);
+    // |c| is invalid now
     return;
   }
 
   // To intercept render process crashes
-  new WebContentsUnloaderObserver(contents.get());
+  new WebContentsUnloaderObserver(c);
 
   // So we can intercept CloseContents
-  contents->SetDelegate(this);
-
-  content::WebContents* c = contents.get();
-  contents_unloading_.push_back(contents.release());
+  c->SetDelegate(this);
 
   c->ClosePage();
   // Note: |c| might be deleted at this point
@@ -88,4 +115,13 @@ void WebContentsUnloader::Shutdown() {
   contents_unloading_.clear();
 }
 
+bool WebContentsUnloader::IsUnloadInProgress(content::WebContents* contents) {
+  return std::find_if(
+      contents_unloading_.begin(),
+      contents_unloading_.end(),
+      [contents](const std::unique_ptr<content::WebContents>& c) {
+    return contents == c.get();
+  }) != contents_unloading_.end();
+}
+
 }",https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_contents_unloader.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_contents_unloader.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,H,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -19,9 +19,9 @@
 #define _OXIDE_SHARED_BROWSER_WEB_CONTENTS_UNLOADER_H_
 
 #include <memory>
+#include <vector>
 
 #include ""base/macros.h""
-#include ""base/memory/scoped_vector.h""
 #include ""content/public/browser/web_contents_delegate.h""
 
 namespace base {
@@ -48,9 +48,13 @@ class WebContentsUnloader : public content::WebContentsDelegate {
   // takes ownership of |contents| and deletes it when complete
   void Unload(std::unique_ptr<content::WebContents> contents);
 
-  // Delete all WebContents that are currently closing
+  // Delete all WebContents that are currently closing without waiting for
+  // unload handlers to complete
   void Shutdown();
 
+  // Determine whether |contents| is currently unloading
+  bool IsUnloadInProgress(content::WebContents* contents);
+
  private:
   friend class base::DefaultSingletonTraits<WebContentsUnloader>;
 
@@ -60,7 +64,7 @@ class WebContentsUnloader : public content::WebContentsDelegate {
   void CloseContents(content::WebContents* contents) override;
 
   // The WebContents for which we are waiting to unload
-  ScopedVector<content::WebContents> contents_unloading_;
+  std::vector<std::unique_ptr<content::WebContents>> contents_unloading_;
 
   DISALLOW_COPY_AND_ASSIGN(WebContentsUnloader);
 };",https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_contents_unloader.h?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_contents_unloader.h?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -994,11 +994,11 @@ WebView::WebView(const CommonParams& common_params,
     : WebView(common_params.client) {
   CHECK(create_params.context) << ""Didn't specify a BrowserContext"";
 
-  scoped_refptr<BrowserContext> context = create_params.incognito ?
+  BrowserContext* context = create_params.incognito ?
       create_params.context->GetOffTheRecordContext() :
       create_params.context->GetOriginalContext();
 
-  content::WebContents::CreateParams content_params(context.get());
+  content::WebContents::CreateParams content_params(context);
   content_params.initial_size =
       gfx::ToEnclosingRect(common_params.view_client->GetBounds()).size();
   content_params.initially_hidden = !common_params.view_client->IsVisible();
@@ -1013,7 +1013,7 @@ WebView::WebView(const CommonParams& common_params,
   if (create_params.restore_entries.size() > 0) {
     std::vector<std::unique_ptr<content::NavigationEntry>> entries =
         sessions::ContentSerializedNavigationBuilder::ToNavigationEntries(
-            create_params.restore_entries, context.get());
+            create_params.restore_entries, context);
     web_contents_->GetController().Restore(
         create_params.restore_index,
         create_params.restore_type,",https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_view.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_view.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,CPP,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -17,6 +17,9 @@
 
 #include ""oxide_web_view_contents_helper.h""
 
+#include <set>
+
+#include ""base/lazy_instance.h""
 #include ""base/logging.h""
 #include ""content/public/browser/render_view_host.h""
 #include ""content/public/browser/web_contents.h""
@@ -26,6 +29,7 @@
 #include ""shared/common/oxide_content_client.h""
 
 #include ""oxide_browser_context.h""
+#include ""oxide_web_contents_unloader.h""
 #include ""oxide_web_contents_view.h""
 #include ""oxide_web_preferences.h""
 #include ""oxide_web_view.h""
@@ -34,9 +38,14 @@ namespace oxide {
 
 namespace {
 const char kWebViewContentsHelperKey[] = ""oxide_web_view_contents_helper_data"";
+base::LazyInstance<std::set<WebViewContentsHelper*>> g_contents_helpers =
+    LAZY_INSTANCE_INITIALIZER;
 }
 
 WebViewContentsHelper::~WebViewContentsHelper() {
+  size_t erased = g_contents_helpers.Get().erase(this);
+  DCHECK_GT(erased, 0U);
+
   if (web_preferences() && owns_web_preferences_) {
     WebPreferences* prefs = web_preferences();
     WebPreferencesObserver::Observe(nullptr);
@@ -57,14 +66,10 @@ void WebViewContentsHelper::NotifyPopupBlockerEnabledChanged() {
   UpdateWebPreferences();
 }
 
-void WebViewContentsHelper::WebPreferencesValueChanged() {
-  UpdateWebPreferences();
-}
-
 void WebViewContentsHelper::NotifyDoNotTrackChanged() {
   content::RendererPreferences* renderer_prefs =
       web_contents_->GetMutableRendererPrefs();
-  renderer_prefs->enable_do_not_track = context_->GetDoNotTrack();
+  renderer_prefs->enable_do_not_track = GetBrowserContext()->GetDoNotTrack();
 
   // Send the new override string to the renderer.
   content::RenderViewHost* rvh = web_contents_->GetRenderViewHost();
@@ -88,20 +93,25 @@ void WebViewContentsHelper::OnShellModeChanged() {
   UpdateWebPreferences();
 }
 
+void WebViewContentsHelper::WebPreferencesValueChanged() {
+  UpdateWebPreferences();
+}
+
 WebViewContentsHelper::WebViewContentsHelper(content::WebContents* contents,
                                              content::WebContents* opener)
     : BrowserContextObserver(
           BrowserContext::FromContent(contents->GetBrowserContext())),
-      context_(BrowserContext::FromContent(contents->GetBrowserContext())),
       web_contents_(contents),
       owns_web_preferences_(false) {
   DCHECK(!FromWebContents(web_contents_));
 
+  g_contents_helpers.Get().insert(this);
+
   web_contents_->SetUserData(kWebViewContentsHelperKey, this);
 
   content::RendererPreferences* renderer_prefs =
       web_contents_->GetMutableRendererPrefs();
-  renderer_prefs->enable_do_not_track = context_->GetDoNotTrack();
+  renderer_prefs->enable_do_not_track = GetBrowserContext()->GetDoNotTrack();
 
   // Hardcoded selection colors to match the current Ambiance theme from the
   // Ubuntu UI Toolkit (https://bazaar.launchpad.net/~ubuntu-sdk-team/ubuntu-ui-toolkit/trunk/view/head:/src/Ubuntu/Components/Themes/Ambiance/1.3/Palette.qml)
@@ -135,7 +145,6 @@ WebViewContentsHelper* WebViewContentsHelper::FromWebContents(
       contents->GetUserData(kWebViewContentsHelperKey));
 }
 
-// static
 WebViewContentsHelper* WebViewContentsHelper::FromRenderViewHost(
     content::RenderViewHost* rvh) {
   content::WebContents* contents =
@@ -147,12 +156,25 @@ WebViewContentsHelper* WebViewContentsHelper::FromRenderViewHost(
   return FromWebContents(contents);
 }
 
+// static
+bool WebViewContentsHelper::IsContextInUse(BrowserContext* context) {
+  for (auto* helper : g_contents_helpers.Get()) {
+    if (helper->GetBrowserContext() == context &&
+        !WebContentsUnloader::GetInstance()->IsUnloadInProgress(
+            helper->GetWebContents())) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
 content::WebContents* WebViewContentsHelper::GetWebContents() const {
   return web_contents_;
 }
 
 BrowserContext* WebViewContentsHelper::GetBrowserContext() const {
-  return context_.get();
+  return BrowserContext::FromContent(web_contents_->GetBrowserContext());
 }
 
 WebPreferences* WebViewContentsHelper::GetWebPreferences() const {",https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_view_contents_helper.cc?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_view_contents_helper.cc?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2016-1586,https://www.cvedetails.com/cve/CVE-2016-1586/,CWE-20,,,2019-04-22,2019-10-09,5.0,None,Remote,Low,Not required,None,Partial,None,A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.,H,launchpad,https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,29014da83e5fc358d6bff0f574e9ed45e61a35ac,648e85080604e22bab00b48428b4e80c522cabea,"@@ -48,6 +48,8 @@ class WebViewContentsHelper final : private BrowserContextObserver,
   static WebViewContentsHelper* FromWebContents(content::WebContents* contents);
   static WebViewContentsHelper* FromRenderViewHost(content::RenderViewHost* rvh);
 
+  static bool IsContextInUse(BrowserContext* context);
+
   content::WebContents* GetWebContents() const;
   BrowserContext* GetBrowserContext() const;
 
@@ -72,7 +74,6 @@ class WebViewContentsHelper final : private BrowserContextObserver,
   // WebPreferencesObserver implementation
   void WebPreferencesValueChanged() final;
 
-  scoped_refptr<BrowserContext> context_;
   content::WebContents* web_contents_;
 
   bool owns_web_preferences_;",https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_view_contents_helper.h?id=648e85080604e22bab00b48428b4e80c522cabea,https://git.launchpad.net/oxide/tree/shared/browser/oxide_web_view_contents_helper.h?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac,,
CVE-2007-5199,https://www.cvedetails.com/cve/CVE-2007-5199/,CWE-119,,Overflow,2017-08-18,2017-08-23,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,A single byte overflow in catalogue.c in X.Org libXfont 1.3.1 allows remote attackers to have unspecified impact.,,libxfont,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=5bf703700ee4a5d6eae20da07cb7a29369667aef,,,,,,,
CVE-2015-9383,https://www.cvedetails.com/cve/CVE-2015-9383/,CWE-125,,,2019-09-03,2019-09-09,4.3,None,Remote,Medium,Not required,None,None,Partial,FreeType before 2.6.2 has a heap-based buffer over-read in tt_cmap14_validate in sfnt/ttcmap.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=57cbb8c148999ba8f14ed53435fc071ac9953afd,,,,,,,
CVE-2015-9382,https://www.cvedetails.com/cve/CVE-2015-9382/,CWE-125,,,2019-09-03,2019-09-09,4.3,None,Remote,Medium,Not required,None,None,Partial,FreeType before 2.6.1 has a buffer over-read in skip_comment in psaux/psobjs.c because ps_parser_skip_PS_token is mishandled in an FT_New_Memory_Face operation.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/src/psaux/psobjs.c?id=db5a4a9ae7b0048f033361744421da8569642f73,,,,,,,
CVE-2015-9381,https://www.cvedetails.com/cve/CVE-2015-9381/,CWE-125,,,2019-09-03,2019-09-09,6.8,None,Remote,Medium,Not required,Partial,Partial,Partial,FreeType before 2.6.1 has a heap-based buffer over-read in T1_Get_Private_Dict in type1/t1parse.c.,,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/src/type1/t1parse.c?id=7962a15d64c876870ca0ae435ea2467d9be268d9,,,,,,,
CVE-2015-9290,https://www.cvedetails.com/cve/CVE-2015-9290/,CWE-125,,,2019-07-30,2019-08-15,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,"In FreeType before 2.6.1, a buffer over-read occurs in type1/t1parse.c on function T1_Get_Private_Dict where there is no check that the new values of cur and limit are sensible before going to Again.",,savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/src/type1/t1parse.c?id=e3058617f384cb6709f3878f753fa17aca9e3a30,,,,,,,
CVE-2014-10375,https://www.cvedetails.com/cve/CVE-2014-10375/,CWE-189,,,2019-08-14,2019-08-27,5.0,None,Remote,Low,Not required,None,Partial,None,handle_messages in eXtl_tls.c in eXosip before 5.0.0 mishandles a negative value in a content-length header.,,savannah,http://git.savannah.nongnu.org/cgit/exosip.git/commit/?id=2549e421c14aff886629b8482c14af800f411070,,,,,,,
CVE-2017-15108,https://www.cvedetails.com/cve/CVE-2017-15108/,CWE-78,,Exec Code,2018-01-19,2019-10-02,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"spice-vdagent up to and including 0.17.0 does not properly escape save directory before passing to shell, allowing local attacker with access to the session the agent runs in to inject arbitrary commands to be executed.",,spice,https://cgit.freedesktop.org/spice/linux/vd_agent/commit/?id=8ba174816d245757e743e636df357910e1d5eb61,,,,,,,
CVE-2012-6711,https://www.cvedetails.com/cve/CVE-2012-6711/,CWE-119,,Exec Code Overflow,2019-06-18,2019-06-20,4.6,None,Local,Low,Not required,Partial,Partial,Partial,"A heap-based buffer overflow exists in GNU Bash before 4.3 when wide characters, not supported by the current locale set in the LC_CTYPE environment variable, are printed through the echo built-in function. A local attacker, who can provide data to print through the ""echo -e"" built-in function, may use this flaw to crash a script or execute code with the privileges of the bash process. This occurs because ansicstr() in lib/sh/strtrans.c mishandles u32cconv().",,savannah,https://git.savannah.gnu.org/cgit/bash.git/commit/?h=devel&id=863d31ae775d56b785dc5b0105b6d251515d81d5,,,,,,,
CVE-2017-13220,https://www.cvedetails.com/cve/CVE-2017-13220/,CWE-843,,,2018-01-12,2019-10-02,4.6,None,Local,Low,Not required,Partial,Partial,Partial,An elevation of privilege vulnerability in the Upstream kernel bluez. Product: Android. Versions: Android kernel. Android ID: A-63527053.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=51bda2bca53b265715ca1852528f38dc67429d9a,,,,,,,
CVE-2017-12187,https://www.cvedetails.com/cve/CVE-2017-12187/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=cad5a1050b7184d828aef9c1dd151c3ab649d37e,,,,,,,
CVE-2017-12186,https://www.cvedetails.com/cve/CVE-2017-12186/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in X-Resource extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=cad5a1050b7184d828aef9c1dd151c3ab649d37e,,,,,,,
CVE-2017-12185,https://www.cvedetails.com/cve/CVE-2017-12185/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in MIT-SCREEN-SAVER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=cad5a1050b7184d828aef9c1dd151c3ab649d37e,,,,,,,
CVE-2017-12184,https://www.cvedetails.com/cve/CVE-2017-12184/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in XINERAMA extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=cad5a1050b7184d828aef9c1dd151c3ab649d37e,,,,,,,
CVE-2017-12183,https://www.cvedetails.com/cve/CVE-2017-12183/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,,,,,,,
CVE-2017-12182,https://www.cvedetails.com/cve/CVE-2017-12182/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in XFree86 DRI extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=1b1d4c04695dced2463404174b50b3581dbd857b,,,,,,,
CVE-2017-12181,https://www.cvedetails.com/cve/CVE-2017-12181/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in XFree86 DGA extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=1b1d4c04695dced2463404174b50b3581dbd857b,,,,,,,
CVE-2017-12180,https://www.cvedetails.com/cve/CVE-2017-12180/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing length validation in XFree86 VidModeExtension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=1b1d4c04695dced2463404174b50b3581dbd857b,,,,,,,
CVE-2017-12179,https://www.cvedetails.com/cve/CVE-2017-12179/,CWE-190,,Exec Code Overflow,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was vulnerable to integer overflow in (S)ProcXIBarrierReleasePointer functions allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=d088e3c1286b548a58e62afdc70bb40981cdb9e8,,,,,,,
CVE-2017-12178,https://www.cvedetails.com/cve/CVE-2017-12178/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 had wrong extra length check in ProcXIChangeHierarchy function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=859b08d523307eebde7724fd1a0789c44813e821,,,,,,,
CVE-2017-12177,https://www.cvedetails.com/cve/CVE-2017-12177/,CWE-190,,Exec Code Overflow,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was vulnerable to integer overflow in ProcDbeGetVisualInfo function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=4ca68b878e851e2136c234f40a25008297d8d831,,,,,,,
CVE-2017-12176,https://www.cvedetails.com/cve/CVE-2017-12176/,CWE-20,,Exec Code,2018-01-24,2019-10-09,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,xorg-x11-server before 1.19.5 was missing extra length validation in ProcEstablishConnection function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,,xserver,https://cgit.freedesktop.org/xorg/xserver/commit/?id=b747da5e25be944337a9cd1415506fc06b70aa81,,,,,,,
CVE-2017-8316,https://www.cvedetails.com/cve/CVE-2017-8316/,CWE-611,,,2018-08-03,2018-10-23,7.8,None,Remote,Low,Not required,Complete,None,None,"IntelliJ IDEA XML parser was found vulnerable to XML External Entity attack, an attacker can exploit the vulnerability by implementing malicious code on both Androidmanifest.xml.",Java,jetbrains,http://git.jetbrains.org/?p=idea/adt-tools-base.git;a=commit;h=a778b2b88515513654e002cd51cbe8eb8226e96b,a778b2b88515513654e002cd51cbe8eb8226e96b,f917c16a93249fa0a177d2511f062b5821d27483,"@@ -152,7 +152,6 @@ public class PositionXmlParser {
             SAXParserFactory factory = SAXParserFactory.newInstance();
             XmlUtils.configureSaxFactory(factory, namespaceAware, false);
             SAXParser parser = XmlUtils.createSaxParser(factory, true);
-            parser.getXMLReader().setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
             DomBuilder handler = new DomBuilder(xml);
             XMLReader xmlReader = parser.getXMLReader();
             xmlReader.setProperty(""http://xml.org/sax/properties/lexical-handler"", handler);",http://git.jetbrains.org/?p=idea/adt-tools-base.git;a=blob;f=common/src/main/java/com/android/utils/PositionXmlParser.java;h=c739149cedca83c1f57220fa1b98114588f322f8;hb=c739149cedca83c1f57220fa1b98114588f322f8,http://git.jetbrains.org/?p=idea/adt-tools-base.git;a=blob;f=common/src/main/java/com/android/utils/PositionXmlParser.java;h=7db539a9183a4f700e228b27b7194af429408267;hb=7db539a9183a4f700e228b27b7194af429408267,,
CVE-2017-7539,https://www.cvedetails.com/cve/CVE-2017-7539/,CWE-20,,DoS,2018-07-26,2019-10-09,5.0,None,Remote,Low,Not required,None,None,Partial,"An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19,,,,,,,
CVE-2017-7539,https://www.cvedetails.com/cve/CVE-2017-7539/,CWE-20,,DoS,2018-07-26,2019-10-09,5.0,None,Remote,Low,Not required,None,None,Partial,"An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=2b0bbc4f8809c972bad134bc1a2570dbb01dea0b,,,,,,,
CVE-2017-7526,https://www.cvedetails.com/cve/CVE-2017-7526/,CWE-310,,,2018-07-26,2019-10-09,4.3,None,Remote,Medium,Not required,Partial,None,None,libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used.,,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=78130828e9a140a9de4dafadbc844dbb64cb709a,,,,,,,
CVE-2017-7526,https://www.cvedetails.com/cve/CVE-2017-7526/,CWE-310,,,2018-07-26,2019-10-09,4.3,None,Remote,Medium,Not required,Partial,None,None,libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used.,,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=8725c99ffa41778f382ca97233183bcd687bb0ce,,,,,,,
CVE-2017-7526,https://www.cvedetails.com/cve/CVE-2017-7526/,CWE-310,,,2018-07-26,2019-10-09,4.3,None,Remote,Medium,Not required,Partial,None,None,libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used.,,gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=e6a3dc9900433bbc8ad362a595a3837318c28fa9,,,,,,,
CVE-2017-7482,https://www.cvedetails.com/cve/CVE-2017-7482/,CWE-190,,Mem. Corr.,2018-07-30,2019-10-09,7.2,None,Local,Low,Not required,Complete,Complete,Complete,"In the Linux kernel before version 4.12, Kerberos 5 tickets decoded when using the RXRPC keys incorrectly assumes the size of a field. This could lead to the size-remaining variable wrapping and the data pointer going over the end of the buffer. This could possibly lead to memory corruption and possible privilege escalation.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5f2f97656ada8d811d3c1bef503ced266fcd53a0,,,,,,,
CVE-2017-7471,https://www.cvedetails.com/cve/CVE-2017-7471/,CWE-732,,,2018-07-09,2019-10-02,7.7,None,Local Network,Low,Single system,Complete,Complete,Complete,"Quick Emulator (Qemu) built with the VirtFS, host directory sharing via Plan 9 File System (9pfs) support, is vulnerable to an improper access control issue. It could occur while accessing files on a shared host directory. A privileged user inside guest could use this flaw to access host file system beyond the shared folder and potentially escalating their privileges on a host.",,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e,,,,,,,
CVE-2017-6888,https://www.cvedetails.com/cve/CVE-2017-6888/,CWE-772,,,2018-04-25,2019-10-02,4.3,None,Remote,Medium,Not required,None,None,Partial,"An error in the ""read_metadata_vorbiscomment_()"" function (src/libFLAC/stream_decoder.c) in FLAC version 1.3.2 can be exploited to cause a memory leak via a specially crafted FLAC file.",,xiph,https://git.xiph.org/?p=flac.git;a=commit;h=4f47b63e9c971e6391590caf00a0f2a5ed612e67,,,,,,,
CVE-2017-2634,https://www.cvedetails.com/cve/CVE-2017-2634/,CWE-119,,Overflow Mem. Corr.,2018-07-27,2019-10-09,7.8,None,Remote,Low,Not required,None,None,Complete,"It was found that the Linux kernel's Datagram Congestion Control Protocol (DCCP) implementation before 2.6.22.17 used the IPv4-only inet_sk_rebuild_header() function for both IPv4 and IPv6 DCCP connections, which could result in memory corruptions. A remote attacker could use this flaw to crash the system.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f53dc67c5e7babafe239b93a11678b0e05bead51,,,,,,,
CVE-2017-2633,https://www.cvedetails.com/cve/CVE-2017-2633/,CWE-125,,,2018-07-27,2019-10-09,4.0,None,Remote,Low,Single system,None,None,Partial,An out-of-bounds memory access issue was found in Quick Emulator (QEMU) before 1.7.2 in the VNC display driver. This flaw could occur while refreshing the VNC display surface area in the 'vnc_refresh_server_surface'. A user inside a guest could use this flaw to crash the QEMU process.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=bea60dd7679364493a0d7f5b54316c767cf894ef,,,,,,,
CVE-2017-2633,https://www.cvedetails.com/cve/CVE-2017-2633/,CWE-125,,,2018-07-27,2019-10-09,4.0,None,Remote,Low,Single system,None,None,Partial,An out-of-bounds memory access issue was found in Quick Emulator (QEMU) before 1.7.2 in the VNC display driver. This flaw could occur while refreshing the VNC display surface area in the 'vnc_refresh_server_surface'. A user inside a guest could use this flaw to crash the QEMU process.,,qemu,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7,,,,,,,
CVE-2017-2626,https://www.cvedetails.com/cve/CVE-2017-2626/,CWE-331,,,2018-07-27,2019-07-14,2.1,None,Local,Low,Not required,Partial,None,None,It was discovered that libICE before 1.0.9-8 used a weak entropy to generate keys. A local attacker could potentially use this flaw for session hijacking using the information available from the process list.,,libICE,https://cgit.freedesktop.org/xorg/lib/libICE/commit/?id=ff5e59f32255913bb1cdf51441b98c9107ae165b,,,,,,,
CVE-2017-2625,https://www.cvedetails.com/cve/CVE-2017-2625/,CWE-320,,,2018-07-27,2019-10-09,2.1,None,Local,Low,Not required,Partial,None,None,"It was discovered that libXdmcp before 1.1.2 including used weak entropy to generate session keys. On a multi-user system using xdmcp, a local attacker could potentially use information available from the process list to brute force the key, allowing them to hijack other users' sessions.",,libXdmcp,https://cgit.freedesktop.org/xorg/lib/libXdmcp/commit/?id=0554324ec6bbc2071f5d1f8ad211a1643e29eb1f,,,,,,,
CVE-2017-2618,https://www.cvedetails.com/cve/CVE-2017-2618/,CWE-682,,,2018-07-27,2019-10-09,4.9,None,Local,Low,Not required,None,None,Complete,A flaw was found in the Linux kernel's handling of clearing SELinux attributes on /proc/pid/attr files before 4.9.10. An empty (null) write to this file can crash the system by causing the system to attempt to access unmapped kernel memory.,,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0c461cb727d146c9ef2d3e86214f498b78b7d125,,,,,,,
CVE-2016-10713,https://www.cvedetails.com/cve/CVE-2016-10713/,CWE-119,,Overflow,2018-02-13,2018-04-17,4.3,None,Remote,Medium,Not required,None,None,Partial,An issue was discovered in GNU patch before 2.7.6. Out-of-bounds access within pch_write_line() in pch.c can possibly lead to DoS via a crafted input file.,,savannah,https://git.savannah.gnu.org/cgit/patch.git/commit/src/pch.c?id=a0d7fe4589651c64bd16ddaaa634030bb0455866,,,,,,,
CVE-2016-10712,https://www.cvedetails.com/cve/CVE-2016-10712/,CWE-20,,,2018-02-09,2019-05-22,5.0,None,Remote,Low,Not required,None,Partial,None,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",,php,https://git.php.net/?p=php-src.git;a=commit;h=6297a117d77fa3a0df2e21ca926a92c231819cd5,,,,,,,
CVE-2016-10708,https://www.cvedetails.com/cve/CVE-2016-10708/,CWE-476,,DoS,2018-01-21,2019-06-26,5.0,None,Remote,Low,Not required,None,None,Partial,"sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",,mindrot,https://anongit.mindrot.org/openssh.git/commit/?id=28652bca29046f62c7045e933e6b931de1d16737,,,,,,,
CVE-2016-9604,https://www.cvedetails.com/cve/CVE-2016-9604/,CWE-347,,Bypass,2018-07-11,2019-10-09,2.1,None,Local,Low,Not required,None,Partial,None,"It was discovered in the Linux kernel before 4.11-rc8 that root can gain direct access to an internal keyring, such as '.dns_resolver' in RHEL-7 or '.builtin_trusted_keys' upstream, by joining it as its session keyring. This allows root to bypass module signature verification by adding a new public key of its own devising to the keyring.",,linux kernel,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ee8f844e3c5a73b999edf733df1c529d6503ec2f,,,,,,,
CVE-2016-9601,https://www.cvedetails.com/cve/CVE-2016-9601/,CWE-119,,Overflow,2018-04-23,2019-10-09,4.3,None,Remote,Medium,Not required,None,None,Partial,"ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript.",,ghostscript,http://git.ghostscript.com/?p=jbig2dec.git;a=commit;h=e698d5c11d27212aa1098bc5b1673a3378563092,,,,,,,
CVE-2016-7056,https://www.cvedetails.com/cve/CVE-2016-7056/,CWE-320,,,2018-09-10,2019-10-09,2.1,None,Local,Low,Not required,Partial,None,None,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,,openssl,https://git.openssl.org/?p=openssl.git;a=commit;h=8aed2a7548362e88e84a7feb795a3a97e8395008,,,,,,,
CVE-2015-9262,https://www.cvedetails.com/cve/CVE-2015-9262/,CWE-119,,DoS Exec Code Overflow,2018-08-01,2019-04-16,7.5,None,Remote,Low,Not required,Partial,Partial,Partial,_XcursorThemeInherits in library.c in libXcursor before 1.1.15 allows remote attackers to cause denial of service or potentially code execution via a one-byte heap overflow.,,xcursor,https://cgit.freedesktop.org/xorg/lib/libXcursor/commit/?id=897213f36baf6926daf6d192c709cf627aa5fd05,,,,,,,
CVE-2015-9261,https://www.cvedetails.com/cve/CVE-2015-9261/,CWE-476,,,2018-07-26,2019-06-13,4.3,None,Remote,Medium,Not required,None,None,Partial,"huft_build in archival/libarchive/decompress_gunzip.c in BusyBox before 1.27.2 misuses a pointer, causing segfaults and an application crash during an unzip operation on a specially crafted ZIP file.",,busybox,https://git.busybox.net/busybox/commit/?id=1de25a6e87e0e627aa34298105a3d17c60a1f44e,,,,,,,
CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,,Dir. Trav.,2018-04-20,2019-10-03,5.0,None,Remote,Low,Not required,Partial,None,None,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,,wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=48739caa745f9f8002e87af574f03e5dc6ae3447,,,,,,,
CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,,Dir. Trav.,2018-04-20,2019-10-03,5.0,None,Remote,Low,Not required,Partial,None,None,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,,wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=8b10426dcc0246c1712a99460dd470dcb1cc4d9c,,,,,,,
CVE-2014-1846,https://www.cvedetails.com/cve/CVE-2014-1846/,CWE-264,,+Priv,2018-04-27,2018-06-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,Enlightenment before 0.17.6 might allow local users to gain privileges via vectors involving the gdb method.,,enlight,https://git.enlightenment.org/core/enlightenment.git/commit/?id=bb4a21e98656fe2c7d98ba2163e6defe9a630e2b,,,,,,,
CVE-2014-1845,https://www.cvedetails.com/cve/CVE-2014-1845/,CWE-264,,+Priv,2018-04-27,2018-06-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,An unspecified setuid root helper in Enlightenment before 0.17.6 allows local users to gain privileges by leveraging failure to properly sanitize the environment.,,enlight,https://git.enlightenment.org/core/enlightenment.git/commit/?id=bb4a21e98656fe2c7d98ba2163e6defe9a630e2b,,,,,,,
CVE-2014-1845,https://www.cvedetails.com/cve/CVE-2014-1845/,CWE-264,,+Priv,2018-04-27,2018-06-07,4.6,None,Local,Low,Not required,Partial,Partial,Partial,An unspecified setuid root helper in Enlightenment before 0.17.6 allows local users to gain privileges by leveraging failure to properly sanitize the environment.,,enlight,https://git.enlightenment.org/core/enlightenment.git/commit/?id=666df815cd86a50343859bce36c5cf968c5f38b0,,,,,,,
